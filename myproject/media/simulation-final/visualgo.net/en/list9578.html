<!DOCTYPE html>
<html lang="en">

<!-- Mirrored from visualgo.net/en/list?slide=2-3 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:17:58 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="description" content="Linked List is a data structure consisting of a group of vertices (nodes) which together represent a sequence. Under the simplest form, each vertex is composed of a data and a reference (link) to the next vertex in the sequence. Try clicking Search(77) for a sample animation on searching a value in a (Singly) Linked List.Linked List and its variations are used as underlying data structure to implement List, Stack, Queue, and Deque ADTs (read this Wikipedia article about ADT if you are not familiar with that term).In this visualization, we discuss (Singly) Linked List (LL) — with a single next pointer — and its two variants: Stack and Queue, and also Doubly Linked List (DLL) — with both next and previous pointers — and its variant: Deque.">
<meta name="keywords" content="Singly Doubly Double Linked List Stack Queue Deque">
 
<meta name="csrf-token" content="dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../img/png/list.png">
<title>Linked List (Single, Doubly), Stack, Queue, Deque - VisuAlgo</title>
<link rel="icon" href="../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../img/favicon.png">
<link rel="stylesheet" href="../css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../css/common-1.0.2.css">
<link rel="stylesheet" href="../css/viz-1.0.4.css">
<link rel="stylesheet" href="../css/visual.css">
<link rel="stylesheet" href="../css/drawgraph-1.0.2.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
        z-index: 8001;
      }
      #e-lecture-timeline {
        top: 80px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }
      .e-lecture-timeline-slide {
        height: 5px;
        width: 2px;
        background: black;
        float: left;
      }
      .e-lecture-timeline-checkpoint {
        height: 20px;
        width: 3px;
        margin-left: 2px;
        margin-top: -7.5px;
        background: black;
        float: left;
      }

      #e-lecture-f1map {
        top: 102.5px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }

      .e-lecture-f1map-sector {
        flex-grow: 1;
        background: black;
        float: left;
        height: 5px;
        margin-right: 1px;
      }

      .e-lecture-f1map-sector:last-child {
        margin-right: 0px;
      }

      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }

      .electure-read-status {
        position: absolute;
        bottom: 4px;
        right: 4px;
        font-size: 14px;
        cursor: default;
        color: #00FF7F;
        display: none;
      }

      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
      .electure-print, .electure-end {
        position: fixed;
        top: 45px;
        height: 20px;
        width: 17px;
        right: 80px;
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
        text-align: center;
      }
      .electure-end {
        right: 45px; /* beside the X */
      }

      #change-lang-popup {
        position: fixed;
        background: green;
        left: 40px;
        top: 50px;
        width: 250px;
        height: 125px;
        border: transparent;
        border-radius: 10px;
        padding: 10px 20px;
        z-index: 9000;
      }

      #change-lang-popup p {
        font-size: medium;
        color: white;
        line-height: 2;
        font-family: "PT Sans", sans-serif;
      }

      #change-lang-popup-btn {
        text-decoration: underline;
        margin-left: 50px;
      }

      #change-lang-popup-btn:hover {
        cursor: pointer;
      }

      #rotateDeviceOverlay {
        z-index: 10000;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        background-color: white;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        overflow: hidden;
      }

      #mobile-playback-overlay {
        z-index: 9600;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        gap: 100px;
        background-color: black;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        opacity: 0.3;
        overflow: hidden;
      }
      .mobile-playback-item {
        min-width: 2.5%;
        max-width: 35px;
      }
      .mobile-playback-item img {
        width: 100%
      }
      .mobile-playback-label {
        opacity: 0;
        color: white;
        font-size: 25px;
        font-weight: bold;
        min-width: 1.5%;
        max-width: 25px;
        transition: opacity 0.25s ease-out;
        -webkit-backface-visibility: hidden;
      }
      #mobile-playback-rewind-label {
        margin-right: -70px;
      }
      #mobile-playback-forward-label {
        margin-left: -70px;
      }
      #viz-speed-value {
          font-size: 15px;
          width: 10%;
      }

      #scale {
        position: fixed;
        left: 5px;
      }
    </style>
<style>
/* copied here from common.css (perhaps need to use version numbering) until caches worldwide settles */
#reload-mobile-popup, #message-popup { /* #gdpr-popup, */
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  min-width: 320px;
  bottom: 62px;
  height: 300px;
  background-color: #0275d8;
  border-radius: 15px;
  padding: 30px 40px;
  z-index: 9500;
}
#reload-mobile-popup {
  background-color: green;
  height: 200px;
}
#message-popup {
  z-index: 9000;
  width: 40%;
  height: 130px;
  background-color: #d9534f;
}

#reload-mobile-popup p, #message-popup p { /* #gdpr-popup p, */
  font-size: large;
  color: white;
  line-height: 2;
  font-family: "PT Sans", sans-serif;
}

#reload-mobile-popup .inner-button, #message-popup .inner-button { /* #gdpr-popup .gdpr-button, */
  border: white solid 2px;
  border-radius: 4px;
  font-weight: bold;
  font-size: x-large;
  padding: 2px 8px;
  color: white;
  width: 90px;
  text-align: center;
  position: absolute;
  letter-spacing: 1px;
  text-decoration: none;
  cursor: pointer;
}

#gdpr-accept, #reload-mobile-button, #dismiss-message-btn {
  bottom: 30px;
  right: 40px;
}

#gdpr-reject, #cancel-reload-mobile-button {
  bottom: 30px;
  right: 170px;
}
    </style>
</head>
<body>
<div id="body-container" style="display: flex; flex-direction: column; min-height: 100vh;">
<style>
  #topbar {
    background-color: rgb(0,0,0);
    font-family: "PT Sans", sans-serif;
    font-size: 13px;
    height: 40px;

    padding-left: 40px;
    padding-right: 40px;

    display: flex;
    flex-wrap: wrap;
    align-items: center;
    position: relative;
    justify-content: flex-start;
  }

  #topbar a:hover {
    text-decoration: none;
  }

  #account-dropdown-btn {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;
    height: 24px;
    line-height: 1.5;
  }

  #account-dropdown-btn:hover {
    color: #0a58ca!important;
    border-color: #198754;
    text-decoration: none;
  }

  #login-button {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;

    height: 24px;
    line-height: 1.5;
  }

  #login-button a:hover {
    color: #0a58ca!important;
    text-decoration: none;
  }

  #account-dropdown-menu {
    display: none;
    position: absolute;
    background-color: white;
    z-index: 1000;
    min-width: 10rem;
    padding: 0.5rem 0;
    margin: 0;
    font-size: 1rem;
    color: rgb(0,0,0);
    text-align: left;
    list-style: none;
    background-clip: padding-box;
    border: 1px solid rgba(0,0,0,.15);
    border-radius: 0.25rem;
    top: 45px;
    right: 40px;
    line-height: 1.5;
  }

  .account-dropdown-item {
    display: block;
    width: auto;
    padding: 0.25rem 1rem;
    clear: both;
    font-weight: 400;
    color: rgb(0,0,0);
    text-align: inherit;
    text-decoration: none;
    white-space: nowrap;
    background-color: transparent;
    border: 0;
    height: 24px;
    font-family: SilkscreenNormal, sans-serif;
  }

  .account-dropdown-item:hover {
    background-color: #e9ecef;
    color: #0a58ca;
    text-decoration: none;
  }
</style>
<nav id="topbar">
<span style="margin-right: 0.25rem">
<a href="https://www.comp.nus.edu.sg/~stevenha" style="text-decoration: none; color: white">
<span class="colour" style="border: 1px solid; border-color: #198754!important; border-radius: .25rem!important">7</span>
</a>
<a href="https://visualgo.net/" style="font-family: SilkscreenNormal,sans-serif; font-size: 20px; margin-left: 4px;">
<span style="color: white">Visu</span><span class="colour">Algo</span><span style="font-size: 40%; color: white">.net</span>
</a>
<span style="color: white">/</span>
<select id="Language" class="select2-dropdown" onchange="changeURL()">
<option value="en" selected>en</option>
<option value="zh">zh</option>
<option value="id">id</option>
</select>
<span style="color: white; font-family: monospace">/list</span>
</span>
<span style="max-height: 30px">
<span id="title">
<a id="title-LL" class="selected-viz">LL</a>
<a id="title-Stack">Stack</a>
<a id="title-Queue">Queue</a>
<a id="title-DLL">DLL</a>
<a id="title-Deque">Deque</a>
</span>
</span>
<span style="max-height: 30px; background-color:rgb(0,0,0)!important; color: white; margin-left: auto">
<div id="mode-menu">
<div id="mode-button" style="background-color: rgb(0,0,0)!important;" title="exploration">Exploration Mode &#9663;</div>
<div id="other-modes" style="background-color: rgb(0,0,0)!important; padding-top: 11px">
<a title="e-Lecture" style="background-color: rgb(0,0,0)!important;">e-Lecture Mode</a>
</div>
</div>
</span>
<span id="login-button" style="font-family: SilkscreenNormal,sans-serif">
<a href="https://visualgo.net/login">Login</a>
</span>
</nav>
<ul id="account-dropdown-menu">
<li><a class="account-dropdown-item" href="https://visualgo.net/profile">Profile</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/training">Training</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/tests">Tests</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/logout">Log Out</a></li>
</ul>
<script>
  function changeURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    URL[3] = document.getElementById("Language").value;
    window.location.assign(URL.join('https://visualgo.net/'));
  }

  function changeDefaultLanguageAndURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    let val = document.getElementById("Language").value;
    URL[3] = val;

    let data = {
      '_token': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
      'lang'  : val
    }
    $.post('https://visualgo.net/changeLanguage', data, function (res, status) {
      if(res['status'] === 'success') {
        window.location.assign(URL.join('https://visualgo.net/'));
      } else if (res['status'] === 'failed') {
        alert(res['message']);
      } else {
        alert('An unknown error occurred');
      }
    })
  }
</script>
<div id="dark-overlay"></div>
<div id="main-content-container" style="flex: 1">

<div id="mobile-playback-overlay" class="playing" style="display: none;">
<span id="mobile-playback-rewind-label" class="mobile-playback-label">-7</span>
<span id="mobile-playback-rewind" class="mobile-playback-item" onclick="mobilePlaybackRewind()"><img src="../img/prevFrame.png" alt="rewind 7 frames"></span>
<span id="mobile-playback-pause" class="mobile-playback-item" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/pause.png" alt="pause"></span>
<span id="mobile-playback-play" class="mobile-playback-item" style="display: none;" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/play.png" alt="play"></span>
<span id="mobile-playback-forward" class="mobile-playback-item" onclick="mobilePlaybackForward()"><img src="../img/nextFrame.png" alt="forward 7 frames"></span>
<span id="mobile-playback-forward-label" class="mobile-playback-label">+7</span>
</div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id="speed-control"><div id="speed-input"></div><div id="viz-speed-value">1x</div></div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick="goToBeginning()"><img src="../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick="stepBackward()"><img src="../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick="pause()"><img src="../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick="play()"><img src="../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick="stepForward()"><img src="../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick="goToEnd()"><img src="../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id="viz">
<p id="info" "></p>
</div>
<div id="current-action" class="panel"></div>
<div id="e-lecture" class="panel"></div> 
<div id="e-lecture-timeline"></div>
<div id="e-lecture-f1map">
<div class="e-lecture-f1map-sector" sectorNo="1"></div>
<div class="e-lecture-f1map-sector" sectorNo="2"></div>
<div class="e-lecture-f1map-sector" sectorNo="3"></div>
</div>
<div id="overlay" hidden onclick="end_eLecture()"> 
<div id="electure-dropdown">
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. LL, Stack, Queue, DLL, Deque</option>
<option value="1-1">&nbsp;&nbsp;&nbsp;1-1. Five Modes</option>
<option value="2">2. Motivation</option>
<option value="2-1">&nbsp;&nbsp;&nbsp;2-1. List ADT</option>
<option value="2-2">&nbsp;&nbsp;&nbsp;2-2. The Answer</option>
<option value="2-3">&nbsp;&nbsp;&nbsp;2-3. Array Implementation - Part 1</option>
<option value="2-4">&nbsp;&nbsp;&nbsp;2-4. Array Implementation - Part 2</option>
<option value="2-5">&nbsp;&nbsp;&nbsp;2-5. Time Complexity Summary</option>
<option value="2-6">&nbsp;&nbsp;&nbsp;2-6. Fixed Space Issue</option>
<option value="2-7">&nbsp;&nbsp;&nbsp;2-7. Variable Space</option>
<option value="2-8">&nbsp;&nbsp;&nbsp;2-8. Observations</option>
<option value="3">3. Linked List (LL)</option>
<option value="3-1">&nbsp;&nbsp;&nbsp;3-1. Linked List Vertex C++ Implementation</option>
<option value="3-2">&nbsp;&nbsp;&nbsp;3-2. The Answer</option>
<option value="3-3">&nbsp;&nbsp;&nbsp;3-3. Linked List, Additional Data</option>
<option value="3-4">&nbsp;&nbsp;&nbsp;3-4. Variations</option>
<option value="3-5">&nbsp;&nbsp;&nbsp;3-5. Get(i) - Much Slower than Array</option>
<option value="3-6">&nbsp;&nbsp;&nbsp;3-6. Search(v) - Not Better than Array</option>
<option value="3-7">&nbsp;&nbsp;&nbsp;3-7. Insertion - Four Cases</option>
<option value="3-8">&nbsp;&nbsp;&nbsp;3-8. Insert(i, v) - Insert at Head (i = 0)</option>
<option value="3-9">&nbsp;&nbsp;&nbsp;3-9. The Answer</option>
<option value="3-10">&nbsp;&nbsp;&nbsp;3-10. Insert(i, v) - Insert into an Empty List</option>
<option value="3-11">&nbsp;&nbsp;&nbsp;3-11. Insert(i, v) - In Between, i &in; [1..N-1]</option>
<option value="3-12">&nbsp;&nbsp;&nbsp;3-12. Insert(i, v) - Beyond the Tail, i = N</option>
<option value="3-13">&nbsp;&nbsp;&nbsp;3-13. The Answer</option>
<option value="3-14">&nbsp;&nbsp;&nbsp;3-14. Removal - Three Cases</option>
<option value="3-15">&nbsp;&nbsp;&nbsp;3-15. Remove(i) - At Head (i = 0)</option>
<option value="3-16">&nbsp;&nbsp;&nbsp;3-16. The Answer</option>
<option value="3-17">&nbsp;&nbsp;&nbsp;3-17. Remove(i) - In Between, i &in; [1..N-2]</option>
<option value="3-18">&nbsp;&nbsp;&nbsp;3-18. Remove(i) - At Tail (i = N-1) - Part 1</option>
<option value="3-19">&nbsp;&nbsp;&nbsp;3-19. Remove(i) - At Tail (i = N-1) - Part 2</option>
<option value="3-20">&nbsp;&nbsp;&nbsp;3-20. The Answer</option>
<option value="3-21">&nbsp;&nbsp;&nbsp;3-21. Time Complexity Summary</option>
<option value="3-22">&nbsp;&nbsp;&nbsp;3-22. Linked List Applications</option>
<option value="4">4. Stack</option>
<option value="4-1">&nbsp;&nbsp;&nbsp;4-1. The Design Choice</option>
<option value="4-2">&nbsp;&nbsp;&nbsp;4-2. The Answer</option>
<option value="4-3">&nbsp;&nbsp;&nbsp;4-3. Stack Applications</option>
<option value="4-4">&nbsp;&nbsp;&nbsp;4-4. Bracket Matching Problem</option>
<option value="4-5">&nbsp;&nbsp;&nbsp;4-5. O(N) Solution with Stack</option>
<option value="4-6">&nbsp;&nbsp;&nbsp;4-6. Calculating Postfix Expression</option>
<option value="4-7">&nbsp;&nbsp;&nbsp;4-7. O(N) Solution with Stack</option>
<option value="5">5. Queue</option>
<option value="5-1">&nbsp;&nbsp;&nbsp;5-1. Array Implementation Issues - Part 1</option>
<option value="5-2">&nbsp;&nbsp;&nbsp;5-2. Array Implementation Issues - Part 2</option>
<option value="5-3">&nbsp;&nbsp;&nbsp;5-3. Array Implementation Issues - Part 3</option>
<option value="5-4">&nbsp;&nbsp;&nbsp;5-4. Array Implementation Issues - Part 4</option>
<option value="5-5">&nbsp;&nbsp;&nbsp;5-5. Efficient Queue with Two Stacks</option>
<option value="5-6">&nbsp;&nbsp;&nbsp;5-6. Linked List to the Rescue</option>
<option value="5-7">&nbsp;&nbsp;&nbsp;5-7. Queue Application</option>
<option value="6">6. Doubly Linked List (DLL)</option>
<option value="6-1">&nbsp;&nbsp;&nbsp;6-1. Remove(i) - At Tail (i = N-1), Revisited</option>
<option value="6-2">&nbsp;&nbsp;&nbsp;6-2. Constant Factor Extra Step(s) Elsewhere</option>
<option value="7">7. Double-Ended Queue (Deque)</option>
<option value="7-1">&nbsp;&nbsp;&nbsp;7-1. Deque Applications</option>
<option value="8">8. Summary</option>
<option value="9">9. Extras</option>
<option value="9-1">&nbsp;&nbsp;&nbsp;9-1. Potential Discussion Topics</option>
<option value="9-2">&nbsp;&nbsp;&nbsp;9-2. Our Current Answers</option>
<option value="9-3">&nbsp;&nbsp;&nbsp;9-3. C++ STL and Java API Implementations</option>
<option value="9-4">&nbsp;&nbsp;&nbsp;9-4. Python and OCaml Standard Library</option>
<option value="9-5">&nbsp;&nbsp;&nbsp;9-5. Online Quiz</option>
<option value="9-6">&nbsp;&nbsp;&nbsp;9-6. Online Judge Exercises</option>
</select>
</div>
<div class="electure-print" title="Print the e-Lecture note" style="z-index=8001;">&#9997;</div>
<div class="electure-end" title="Close the e-Lecture mode" style="z-index=8001;">&#10008;</div>
</div>
<div id="dropdown-temp-holder" hidden></div>

<div id="electure-1" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Linked List is a data structure consisting of a group of vertices (nodes) which together represent a sequence. Under the simplest form, each vertex is composed of a data and a reference (link) to the next vertex in the sequence. Try clicking <span class="slide-actions" onclick="doButtonAction96()">Search(77)</span> for a sample animation on searching a value in a (Singly) Linked List.</p><br><p>Linked List and its variations are used as underlying data structure to implement List, Stack, Queue, and Deque ADTs (read this <a href="https://en.wikipedia.org/wiki/Abstract_data_type" target="_blank"><u>Wikipedia article about ADT</u></a> if you are not familiar with that term).</p><br><p>In this visualization, we discuss (Singly) Linked List (LL) — with a single next pointer — and its two variants: Stack and Queue, and also Doubly Linked List (DLL) — with both next and previous pointers — and its variant: Deque.</p>
<div class="electure-addition">
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
If you are an NUS student and a repeat visitor, please <a href="https://visualgo.net/login"><u>login</u></a>.</p>
</div>
<div class="electure-next" data-nextid="1-1" title="Go to the next slide 1-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-1-1" class="electure-dialog" style="top:70px;left:200px;width:500px;">
<p>We decide to group five related modes involving Linked List (LL, Stack, Queue, DLL, Deque) in one single visualization page. To facilitate more diversity, we randomize the selected mode upon loading this direct URL: https://visualgo.net/en/list.</p><br><p>However, you can use the following URL shortcuts to access individual mode directly (only works for logged-in users who have cleared reading all 3 sectors of these lecture notes):</p><ol><li><a href="list81f0.html"><u>https://visualgo.net/en/ll</u></a>,</li><li><a href="listf308.html"><u>https://visualgo.net/en/stack</u></a>,</li><li><a href="listc97b.html"><u>https://visualgo.net/en/queue</u></a>,</li><li><a href="list058a.html"><u>https://visualgo.net/en/dll</u></a>,</li><li><a href="list3a3f.html"><u>https://visualgo.net/en/deque</u></a>.</li></ol>
<div class="electure-addition">
<hr>
<p>Pro-tip 1: Since you are not <a href="https://visualgo.net/login"><u>logged-in</u></a>, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b>/<b>[PageUp]</b> to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use <b>[&rarr; or &darr;/&larr; or &uarr;]</b> to do the same),and <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
</div>
<div class="electure-prev" data-nextid="1" title="Go to the previous slide 1">&larr;</div>
<div class="electure-next" data-nextid="2" title="Go to the next slide 2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Linked List data structure is commonly taught in Computer Science (CS) undergraduate courses for a few reasons:</p><ol><li>It is a simple linear data structure,</li><li>It has a range of potential applications as a list ADT e.g., student list, event list, appointment list, etc (albeit there are other more advanced data structures that can do the same (and more) applications better) or as stack/queue/deque ADTs,</li><li>It has interesting corner/special cases to illustrate the need for a good implementation of a data structure,</li><li>It has various customization options and thus usually this Linked List data structure is taught using Object-Oriented Programming (OOP) way.</li></ol>
<div class="electure-addition">
<hr>
<p>Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
</div>
<div class="electure-prev" data-nextid="1-1" title="Go to the previous slide 1-1">&larr;</div>
<div class="electure-next" data-nextid="2-1" title="Go to the next slide 2-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>List is a sequence of items/data where positional order matter {a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>N-2</sub>, a<sub>N-1</sub>}.<br>Common List ADT operations are:</p><ol start="0"><li><samp>get(i)</samp> — maybe a trivial operation, return <samp>a<sub>i</sub></samp> (0-based indexing),</li><li><samp>search(v)</samp> — decide if item/data <b>v</b> exists (and report its position/index)<br>or not exist (and usually report a non existing index -1) in the list,</li><li><samp>insert(i, v)</samp> — insert item/data <b>v</b> specifically at position/index <b>i</b> in the list, potentially shifting the items from previous positions: [<b>i</b>..<b>N</b>-1] by one position to their right to make a space,</li><li><samp>remove(i)</samp> — remove item that is specifically at position/index <b>i</b> in the list, potentially shifting the items from previous positions: [<b>i+1</b>..<b>N</b>-1] by one position to their left to close the gap.</li></ol><p>Discussion 1: What if we want to remove item with specific value <b>v</b> in the list?</p><p>Discussion 2: Can a List ADT contains duplicate items, i.e., a<sub>i</sub> = a<sub>j</sub> where i &ne; j?</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode): <b>Spacebar</b> to play/pause/replay the animation, <b>&larr;</b>/<b>&rarr;</b> to step the animation backwards/forwards, respectively, and <b>-</b>/<b>+</b> to decrease/increase the animation speed, respectively.</p>
</div>
<div class="electure-prev" data-nextid="2" title="Go to the previous slide 2">&larr;</div>
<div class="electure-next" data-nextid="2-2" title="Go to the next slide 2-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-2" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-1" title="Go to the previous slide 2-1">&larr;</div>
<div class="electure-next" data-nextid="2-3" title="Go to the next slide 2-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-3" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>(Compact) Array is a good candidate for implementing the List ADT as it is a simple construct to handle a collection of items.</p><br><p>When we say compact array, we mean an array that has <b>no gap</b>, i.e., if there are <b>N</b> items in the array (that has size <b>M</b>, where <b>M &ge; N</b>), then only index [0..<b>N</b>-1] are occupied and other indices [<b>N</b>..<b>M</b>-1] should remain <b>empty</b>.</p><br><img src="../img/compactarray_illustration.png" width="100%" alt="Compact Array Illustration">
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-2" title="Go to the previous slide 2-2">&larr;</div>
<div class="electure-next" data-nextid="2-4" title="Go to the next slide 2-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-4" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Let the <b>compact</b> array name be <samp>A</samp> with index [0..<b>N</b>-1] occupied with the items of the list.</p><br><p><samp>get(i)</samp>, just return <samp>A[i]</samp>.<br>This simple operation will be unnecessarily complicated if the array is <b>not</b> compact.</p><br><p><samp>search(v)</samp>, we check each index <samp>i</samp> ∈ [0..<b>N</b>-1] one by one to see if <samp>A[i] == v</samp>.<br>This is because <samp>v</samp> (if it exists) can be anywhere in index [0..<b>N</b>-1].<br>Since this visualization only accept distinct items, <samp>v</samp> can only be found at most once.<br>In a general List ADT, we may want to have <samp>search(v)</samp> returns a list of indices.</p><br><p><samp>insert(i, v)</samp>, we shift items ∈ [<b>i</b>..<b>N</b>-1] to [<b>i</b>+1..<b>N</b>] (<i>from backwards</i>) and set <samp>A[i] = v</samp>.<br>This is so that <samp>v</samp> is inserted correctly at index <samp>i</samp> and maintain compactness.</p><br><p><samp>remove(i)</samp>, we shift items ∈ [<b>i+1</b>..<b>N</b>-1] to [<b>i</b>..<b>N</b>-2], overwriting the old <samp>A[i]</samp>.<br>This is to maintain compactness.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-3" title="Go to the previous slide 2-3">&larr;</div>
<div class="electure-next" data-nextid="2-5" title="Go to the next slide 2-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-5" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p><samp>get(i)</samp> is very fast: Just one access, O(<b>1</b>).<br>Another CS module: &#39;Computer Organisation&#39; discusses the details on this O(<b>1</b>)<br>performance of this array indexing operation.</p><br><p><samp>search(v)</samp><br>In the best case, <b>v</b> is found at the first position, O(<b>1</b>).<br>In the worst case, <b>v</b> is not found in the list and we require O(<b>N</b>) scan to determine that.</p><br><p><samp>insert(i, v)</samp><br>In the best case, insert at <b>i = N</b>, there is no shifting of element, O(<b>1</b>).<br>In the worst case, insert at <b>i = 0</b>, we shift all <b>N</b> elements, O(<b>N</b>).</p><br><p><samp>remove(i)</samp><br>In the best case, remove at <b>i = N-1</b>, there is no shifting of element, O(<b>1</b>).<br>In the worst case, remove at <b>i = 0</b>, we shift all <b>N</b> elements, O(<b>N</b>).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-4" title="Go to the previous slide 2-4">&larr;</div>
<div class="electure-next" data-nextid="2-6" title="Go to the next slide 2-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-6" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>The size of the compact array <b>M</b> is not infinite, but a finite number. This poses a problem as the maximum size may not be known in advance in many applications.</p><br><p>If <b>M</b> is too big, then the unused spaces are wasted.<br>If <b>M</b> is too small, then we will run out of space easily.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-5" title="Go to the previous slide 2-5">&larr;</div>
<div class="electure-next" data-nextid="2-7" title="Go to the next slide 2-7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-7" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Solution: Make <b>M</b> a variable. So when the array is full, we create a larger array (usually two times larger) and move the elements from the old array to the new array. Thus, there is no more limits on size other than the (usually large) physical computer memory size.</p><br><p><a href="https://en.cppreference.com/w/cpp/container/vector" target="_blank"><u>C++ STL std::vector</u></a>, <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" target="_blank"><u>Python list</u></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html" target="_blank"><u>Java Vector</u></a>, or <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html" target="_blank"><u>Java ArrayList</u></a> all implement this variable-size array. Note that Python <i>list</i> and Java Array<i>List</i> are <b>not</b> Linked Lists, but are actually variable-size arrays.</p> <br><p>However, the classic array-based issues of space wastage and copying/shifting items overhead are still problematic.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-6" title="Go to the previous slide 2-6">&larr;</div>
<div class="electure-next" data-nextid="2-8" title="Go to the next slide 2-8">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-8" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>For fixed-size collections with known max limit of number of items that will ever be needed, i.e., the max size of <b>M</b>, then array is already a reasonably good data structure for List ADT implementation.</p><br><p>For variable-size collections with unknown size <b>M</b> and where dynamic operations such as insert/remove are common, a simple array is actually a poor choice of data structure.</p><br><p>For such applications, there are better data structures. Let&#39;s read on...</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-7" title="Go to the previous slide 2-7">&larr;</div>
<div class="electure-next" data-nextid="3" title="Go to the next slide 3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>We now introduce the Linked List data structure. It uses pointers/references to allow items/data to be <b>non-contiguous</b> in memory (that is the main difference with a <a href="listec4c.html?slide=2-2"><u>simple array</u></a>). The items are ordered from index 0 to index <b>N</b>-1 by associating item <b>i</b> with its neighbour item <b>i+1</b> through a pointer.</p><br><img src="../img/ll_illustration.png" width="100%" alt="Linked List Illustration">
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-8" title="Go to the previous slide 2-8">&larr;</div>
<div class="electure-next" data-nextid="3-1" title="Go to the next slide 3-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-1" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>In its basic form, a single vertex (node) in the Linked List has this rough structure:</p><pre>struct Vertex { // we can use either C struct or C++/Python/Java class<br>  int item; // the data is stored here, an integer in this example<br>  Vertex* next; // this pointer tells us where is the next vertex<br>};</pre><p>Using the default example Linked List [22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)] for illustration, we have:<br><b>a<sub>0</sub></b> with its <b>item</b> = 22 and its <b>next</b> = <b>a<sub>1</sub></b>,<br><b>a<sub>1</sub></b> with its <b>item</b> = 2 and its <b>next</b> = <b>a<sub>2</sub></b>,<br>...<br><b>a<sub>6</sub></b> with its <b>item</b> = 89 and its <b>next</b> = <b>null</b>.</p><br><p>Discussion: Which one is better for a C++ implementation of Linked List? struct or class? How about Python or Java implementation?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3" title="Go to the previous slide 3">&larr;</div>
<div class="electure-next" data-nextid="3-2" title="Go to the next slide 3-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-2" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-1" title="Go to the previous slide 3-1">&larr;</div>
<div class="electure-next" data-nextid="3-3" title="Go to the next slide 3-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-3" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>We also have a few additional data that we remember in this Linked List data structure. We use the default example Linked List [22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)] for illustration.</p><ol><li>The <b>head</b> pointer points to <b>a<sub>0</sub></b> — it is 22, nothing points to the head item,</li><li>The current number of elements <b>N</b> in the Linked List — <b>N = 7 </b>elements.</li><li>The <b>tail</b> pointer points to <b>a<sub>N-1</sub></b> — it is <b>a<sub>6</sub></b> = 89, nothing is after the tail item.</li></ol><p>That&#39;s it, we only add three more extra variables in data structure.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-2" title="Go to the previous slide 3-2">&larr;</div>
<div class="electure-next" data-nextid="3-4" title="Go to the next slide 3-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-4" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Note that there are various subtle differences found in many Computer Science textbooks on how to implement a (Singly) Linked List e.g., use tail pointer or not, circular or not, use dummy head item or not, allow duplicate items or not &mdash; see <a href="listf3ec.html?slide=9-1"><u>this slide</u></a>.</p><br><p>Our version in this visualization (with tail pointer, not circular, without dummy head, disallow duplicate) may not be 100% the same compared to what you learn in your class but the basic ideas should remain the same.</p><br><p>In this visualization, each vertex has Integer item, but this can easily be changed to any other data type as needed.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-3" title="Go to the previous slide 3-3">&larr;</div>
<div class="electure-next" data-nextid="3-5" title="Go to the next slide 3-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-5" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Since we only keep the head and tail pointers, list traversal subroutine is needed to reach positions other than the head (index 0) and the tail (index <b>N</b>-1).</p><br><p>As this sub-routine is so frequently used, we will abstract it out as a function. The code below is written in C++.</p><pre>Vertex* Get(int i) { // returns the vertex<br>  Vertex* ptr = head; // we have to start from head<br>  for (int k = 0; k &lt; i; ++k) // advance forward i time(s)<br>    ptr = ptr-&gt;next; // the pointers are pointing to the higher index<br>  return ptr;<br>}</pre><p>It runs in O(<b>N</b>) as <b>i</b> can be as big as index <b>N</b>-2.<br>Compare this with <a href="listad01.html?slide=2-4"><u>array</u></a> where we can access index <b>i</b> in O(<b>1</b>) time.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-4" title="Go to the previous slide 3-4">&larr;</div>
<div class="electure-next" data-nextid="3-6" title="Go to the next slide 3-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-6" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>As we only have direct reference to the first head item and the last tail item, plus the pointers are pointing to the <b>right</b> (higher position/index), we can only access the rest by starting from the head item and hopping through the next pointers. On the default [22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)], we have:</p><p><br></p><p><span class="slide-actions" onclick="doButtonAction96()">Search(77)</span> — found in the example above at position/index 2 (0-based indexing).</p><br><p><span class="slide-actions" onclick="doButtonAction97()">Search(7)</span> — not found in the example above, and this is only known after all <b>N</b> items are examined, so <samp>Search(v)</samp> has O(<b>N</b>) worst case time complexity.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-5" title="Go to the previous slide 3-5">&larr;</div>
<div class="electure-next" data-nextid="3-7" title="Go to the next slide 3-7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-7" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>There are more cases than <a href="listad01.html?slide=2-4"><u>array</u></a> version due to the nature of Linked List.</p><br><p>Most CS students who learn Linked List for the first time usually are not aware of all cases until they figure it out themselves when their Linked List code fail.</p><br><p>In this e-Lecture, we directly elaborate all cases.</p><br><p>For <samp>insert(i, v)</samp>, there are four (legal) possibilities, i.e., item <b>v</b> is added to:</p><ol><li>The head (before the current first item) of the linked list, <b>i = 0</b>,</li><li>An empty linked list (which fortunately similar to the previous case),</li><li>The position beyond the last (the current tail) item of the linked list, <b>i = N</b>,</li><li>The other positions of the linked list, <b>i = [1..N-1]</b>.</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-6" title="Go to the previous slide 3-6">&larr;</div>
<div class="electure-next" data-nextid="3-8" title="Go to the next slide 3-8">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-8" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>The (C++) code for insertion at head is simple and efficient, in O(<b>1</b>):</p><pre>Vertex* vtx = new Vertex(); // create new vertex vtx from item v<br>vtx-&gt;item = v;<br>vtx-&gt;next = head; // link this new vertex to the (old) head vertex<br>head = vtx; // the new vertex becomes the new head</pre><p>Try <span class="slide-actions" onclick="doButtonAction100()">InsertHead(50)</span>, which is <samp>insert(0, 50)</samp>, on the example Linked List&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)].</p><br><p>Discussion: What happen if we use <a href="listd82e.html?slide=2-5"><u>array</u></a> implementation for insertion at head of the list?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-7" title="Go to the previous slide 3-7">&larr;</div>
<div class="electure-next" data-nextid="3-9" title="Go to the next slide 3-9">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-9" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-8" title="Go to the previous slide 3-8">&larr;</div>
<div class="electure-next" data-nextid="3-10" title="Go to the next slide 3-10">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-10" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Empty data structure is a common corner/special case that can often cause unexpected crash if not properly tested. It is legal to insert a new item into a currently empty list, i.e., at index <b>i = 0</b>. Fortunately, the same pseudo-code for insertion at head also works for an empty list so we can just use the same code as in <a href="list1a24.html?slide=3-8"><u>this slide</u></a>&nbsp;(with one minor change, we also need to set tail = head).</p><br><p>Try <span class="slide-actions" onclick="doButtonAction103()">InsertHead(50)</span>, which is <samp>insert(0, 50)</samp>, but on the empty Linked List [].</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-9" title="Go to the previous slide 3-9">&larr;</div>
<div class="electure-next" data-nextid="3-11" title="Go to the next slide 3-11">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-11" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>With the Linked List traversal <samp>Get(i)</samp> sub-routine, we can now implement insertion in the middle of the Linked List as follows (in C++):</p><pre>Vertex* pre = Get(i-1); // traverse to (i-1)-th vertex, O(N)<br>aft = pre-&gt;next; // aft cannot be null, think about it<br>Vertex* vtx = new Vertex(); // create new vertex<br>vtx-&gt;item = v;<br>vtx-&gt;next = aft; // link this<br>pre-&gt;next = vtx; // and this</pre><p>Try <span class="slide-actions" onclick="doButtonAction102()">Insert(3, 44)</span> on the example Linked List&nbsp;&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)].</p><br><p>Also try <span class="slide-actions" onclick="doButtonAction104()">Insert(6, 55)</span> on the same example Linked List. This is a corner case: Insert at the position of tail item, shifting the tail to one position to its right.</p><br><p>This operation is slow, O(<b>N</b>), due to the need for traversing the list (e.g. if <b>i</b> close to <b>N</b>-1).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-10" title="Go to the previous slide 3-10">&larr;</div>
<div class="electure-next" data-nextid="3-12" title="Go to the next slide 3-12">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-12" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>If we also remember the tail pointer as with the implementation <a href="liste0b3.html?slide=3-3"><u>in this e-Lecture</u></a> (which is advisable as it is just one additional pointer variable), we can perform insertion beyond the tail item (at <b>i = N</b>) efficiently, in O(<b>1</b>):</p><pre>Vertex* vtx = new Vertex(); // this is also a C++ code<br>vtx-&gt;item = v; // create new vertex vtx from item v<br>tail-&gt;next = vtx; // just link this, as tail is the i = (N-1)-th item<br>tail = vtx; // now update the tail pointer</pre><p>Try <span class="slide-actions" onclick="doButtonAction101()">InsertTail(10)</span>, which is <samp>insert(7, 10)</samp>, on the example Linked List&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)]&nbsp;. A common misconception is to say that this is insertion at tail. Insertion at tail element is <samp>insert(N-1, v)</samp>. Insertion <b>beyond</b> the tail is <samp>insert(N, v)</samp>.</p><br><p>Discussion: What happen if we use <a href="listd82e.html?slide=2-5"><u>array</u></a> implementation for insertion beyond the tail of the list?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-11" title="Go to the previous slide 3-11">&larr;</div>
<div class="electure-next" data-nextid="3-13" title="Go to the next slide 3-13">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-13" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-12" title="Go to the previous slide 3-12">&larr;</div>
<div class="electure-next" data-nextid="3-14" title="Go to the next slide 3-14">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-14" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>For <samp>remove(i)</samp>, there are three (legal) possibilities, i.e., index <b>i</b> is:</p><ol><li>The head (the current first item) of the linked list, <b>i = 0</b>, it affects the head pointer</li><li>The tail of the linked list, <b>i = N-1</b>, it affects the tail pointer</li><li>The other positions of the linked list, <b>i = [1..N-2]</b>.</li></ol><p>Discussion: Compare this slide with <a href="list7ebc.html?slide=3-7"><u>Insertion Cases slide</u></a> to realize the subtle differences. Is removing anything from an already empty Linked List considered &#39;legal&#39;?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-13" title="Go to the previous slide 3-13">&larr;</div>
<div class="electure-next" data-nextid="3-15" title="Go to the next slide 3-15">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-15" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>This case is straightforward (written in C++):</p><pre>if (head == NULL) return; // avoid crashing when SLL is empty<br>Vertex* tmp = head; // so we can delete it later<br>head = head-&gt;next; // book keeping, update the head pointer<br>delete tmp; // which is the old head</pre><p>Try <span class="slide-actions" onclick="doButtonAction105()">RemoveHead()</span> repeatedly on the (shorter) example Linked List&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6 (tail)]. It will continuously working correctly up until the Linked List contains one item where the head = the tail item. We prevent execution if the LL is already empty as it is an illegal case.</p><br><p>Discussion: What happen if we use <a href="listd82e.html?slide=2-5"><u>array</u></a> implementation for removal of head of the list?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-14" title="Go to the previous slide 3-14">&larr;</div>
<div class="electure-next" data-nextid="3-16" title="Go to the next slide 3-16">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-16" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-15" title="Go to the previous slide 3-15">&larr;</div>
<div class="electure-next" data-nextid="3-17" title="Go to the next slide 3-17">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-17" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>With the Linked List traversal <samp>Get(i)</samp> sub-routine (<a href="liste090.html?slide=3-5"><u>discussed earlier</u></a>), we can now implement removal of the middle item of the Linked List as follows (in C++):</p><pre>Vertex* pre = Get(i-1); // traverse to (i-1)-th vertex, O(N)<br>Vertex* del = pre-&gt;next, aft = del-&gt;next;<br>pre-&gt;next = aft; // bypass del<br>delete del;</pre><p>Try <span class="slide-actions" onclick="doButtonAction107()">Remove(5)</span>, the element at index <b>N-2</b> (as <b>N = 7</b> in the example&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)]&nbsp;.<br>This is the worst O(<b>N</b>) case on the example above.</p><br><p>Note that <b>Remove(N-1)</b> is removal at tail that requires us to update the tail pointer, see the next case.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-16" title="Go to the previous slide 3-16">&larr;</div>
<div class="electure-next" data-nextid="3-18" title="Go to the next slide 3-18">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-18" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>We can implement the removal of the tail of the Linked List as follows, assuming that the Linked List has more than 1 item (in C++):</p><pre>Vertex* pre = head;<br>tmp = head-&gt;next;<br>while (tmp-&gt;next != null) // while my neighbor is not the tail<br>  pre = pre-&gt;next, tmp = tmp-&gt;next;<br>pre-&gt;next = null;<br>delete tmp; // tmp = (old) tail<br>tail = pre; // update tail pointer</pre><p>Try <span class="slide-actions" onclick="doButtonAction106()">RemoveTail()</span> repeatedly on the (shorter) example Linked List&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6 (tail)]. It will continuously working correctly up until the Linked List contains one item where the head = the tail item and we switch to <a href="list05ba.html?slide=3-15"><u>removal at head</u></a> case. We prevent execution if the LL is already empty as it is an illegal case.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-17" title="Go to the previous slide 3-17">&larr;</div>
<div class="electure-next" data-nextid="3-19" title="Go to the next slide 3-19">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-19" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Actually, if we also maintain the size of the Linked List <b>N</b> (compare with <a href="liste0b3.html?slide=3-3"><u>this slide</u></a>), we can use the Linked List traversal sub-routine <samp>Get(i)</samp> to implement the removal of the tail of the Linked List this way (in C++):</p><pre>Vertex* pre = Get(N-2); // go to one index just before tail, O(N)<br>pre-&gt;next = null;<br>delete tail;<br>tail = pre; // we have access to old tail</pre><p>Notice that this operation is slow, O(<b>N</b>), just because of the need to update the tail pointer from item <b>N</b>-1 backwards by one unit to item <b>N</b>-2 so that future insertion after tail remains correct... This deficiency will be <a href="list105d.html?slide=6-1"><u>later addressed</u></a> in Doubly Linked List variant.</p><br><p>Discussion: What happen if we use <a href="listd82e.html?slide=2-5"><u>array</u></a> implementation for removal of tail of the list?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-18" title="Go to the previous slide 3-18">&larr;</div>
<div class="electure-next" data-nextid="3-20" title="Go to the next slide 3-20">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-20" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-19" title="Go to the previous slide 3-19">&larr;</div>
<div class="electure-next" data-nextid="3-21" title="Go to the next slide 3-21">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-21" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p><samp>get(i)</samp> is slow: O(<b>N</b>).<br>In Linked List, we need to perform sequential access from head element.</p><br><p><samp>search(v)</samp><br>In the best case, <b>v</b> is found at the first position, O(<b>1</b>).<br>In the worst case, <b>v</b> is not found in the list and we require O(<b>N</b>) scan to determine that.</p><br><p><samp>insert(i, v)</samp><br>In the best case, insert at <b>i = 0</b> or at <b>i = N</b>, head and tail pointers help, O(<b>1</b>).<br>In the worst case, insert at <b>i = N-1</b>, we need to find the item <b>N</b>-2</b> just before the tail, O(<b>N</b>).</p><br><p><samp>remove(i)</samp><br>In the best case, remove at <b>i = 0</b>, head pointer helps, O(<b>1</b>).<br>In the worst case, remove at <b>i = N-1</b>, due to the need to update the tail pointer, O(<b>N</b>).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-20" title="Go to the previous slide 3-20">&larr;</div>
<div class="electure-next" data-nextid="3-22" title="Go to the next slide 3-22">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-22" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Pure (Singly) Linked List applications are surprisingly rare as the simpler resizeable compact array (vector) can do the job better, compare the <a href="list78af.html?slide=3-21"><u>Linked List version</u></a> with the <a href="listd82e.html?slide=2-5"><u>compact array version</u></a>.</p><br><p>However, the basic concept of Linked List that allows the vertices to be non-contiguous in memory makes it an excellent resize-able data structure for the next two other Abstract Data Types: <a href="list1438.html?slide=4"><u>Stack</u></a> and <a href="list3254.html?slide=5"><u>Queue</u></a>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-21" title="Go to the previous slide 3-21">&larr;</div>
<div class="electure-next" data-nextid="4" title="Go to the next slide 4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4" class="electure-dialog" style="top:150px;right:60px;width:500px;">
<p>Stack is a particular kind of Abstract Data Type in which the main operations on the collection are the addition of an item to the collection, known as push, only to the top of the stack and removal of an item, known as pop, only from the top of the stack.</p><br><p>It is known as Last-In-First-Out (LIFO) data structure, e.g., the stack of book below.</p><br><img src="../img/stack_illustration.png" width="100%" alt="Stack Illustration">
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-22" title="Go to the previous slide 3-22">&larr;</div>
<div class="electure-next" data-nextid="4-1" title="Go to the next slide 4-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-1" class="electure-dialog" style="top:150px;right:60px;width:500px;">
<p>In most implementations and also in this visualization, Stack is basically a <b>protected</b> (Singly) Linked List where we can only peek at the head item, push a new item only to the head (<a href="list2c9d.html?slide=3-9"><u>insert at head</u></a>), e.g., try <span class="slide-actions" onclick="doButtonAction99()">InsertHead(6)</span>, and pop existing item only from the head (<a href="listde91.html?slide=3-14"><u>remove from head</u></a>), e.g., try <span class="slide-actions" onclick="doButtonAction105()">RemoveHead()</span>. All operations are O(1).</p><br><p>In this visualization, we orientate the (Single) Linked List top down, with the head/tail item at the top/bottom, respectively. In the example, we have [2 (top/head)-&gt;7-&gt;5-&gt;3-&gt;1-&gt;9 (bottom/tail)]. Due to vertical screen size limit (in landscape mode), we only allow a Stack of at most 7 items in this visualization.</p><br><p>Discussion: Can we use vector, a resizeable array, to implement Stack ADT efficiently?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4" title="Go to the previous slide 4">&larr;</div>
<div class="electure-next" data-nextid="4-2" title="Go to the next slide 4-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-2" class="electure-dialog" style="top:150px;right:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-1" title="Go to the previous slide 4-1">&larr;</div>
<div class="electure-next" data-nextid="4-3" title="Go to the next slide 4-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-3" class="electure-dialog" style="top:150px;right:60px;width:500px;">
<p>Stack has a few popular textbook applications. Some examples:</p><ol><li>Bracket Matching,</li><li>Postfix Calculator,</li><li>A few other interesting applications that are not shown for pedagogical purposes.</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-2" title="Go to the previous slide 4-2">&larr;</div>
<div class="electure-next" data-nextid="4-4" title="Go to the next slide 4-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-4" class="electure-dialog" style="top:150px;right:60px;width:500px;">
<p>Mathematical expression can get quite convoluted, e.g., <samp>{[x+2]^(2+5)-2}*(y+5)</samp>.</p><br><p>Bracket Matching problem is a problem of checking whether all brackets in the given input are matched correctly, i.e., ( with ), [ with ] and { with }, and so on.</p><br><p>Bracket Matching is equally useful for checking the legality of a source code.</p><br><p>Discussion: It turns out that we can use Stack&#39;s LIFO behavior to solve this problem.<br>The question is how?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-3" title="Go to the previous slide 4-3">&larr;</div>
<div class="electure-next" data-nextid="4-5" title="Go to the next slide 4-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-5" class="electure-dialog" style="top:150px;right:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-4" title="Go to the previous slide 4-4">&larr;</div>
<div class="electure-next" data-nextid="4-6" title="Go to the next slide 4-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-6" class="electure-dialog" style="top:150px;right:60px;width:500px;">
<p>Postfix expression is a mathematical expression in: <samp>operand1 operand2 operator</samp> format which is different from what human is most comfortable at, the Infix expression: <samp>operand1 operator operand2</samp>.</p><br><p>For example, expression <samp>2 3 + 4 *</samp> is the Postfix version of <samp>(2+3)*4</samp>.</p><br><p>In Postfix expression, we do not need brackets.</p><br><p>Discussion: It turns out that we can also use Stack to solve this problem efficiently.<br>The question is how?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-5" title="Go to the previous slide 4-5">&larr;</div>
<div class="electure-next" data-nextid="4-7" title="Go to the next slide 4-7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-7" class="electure-dialog" style="top:150px;right:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-6" title="Go to the previous slide 4-6">&larr;</div>
<div class="electure-next" data-nextid="5" title="Go to the next slide 5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Queue is another Abstract Data Type in which the items in the collection are kept <b>in order</b> and the main operations on the collection are the addition of items to the back position (enqueue) and removal of items from the front position (dequeue).</p><br><p>It is known as <b>First-In-First-Out (FIFO)</b> data structure as the first item to be enqueued will eventually be the first item to be dequeued, as in real life queues (see below).</p><br><img src="../img/queue_illustration.png" width="100%" alt="Queue Illustration">
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-7" title="Go to the previous slide 4-7">&larr;</div>
<div class="electure-next" data-nextid="5-1" title="Go to the next slide 5-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-1" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>If we simply use the <a href="list9578.html?slide=2-3"><u>compact array</u></a> implementation for this Queue ADT with <samp>a<sub>0</sub></samp> is the front of the queue and <samp>a<sub>N-1</sub></samp> is the back of the queue, we will encounter major performance issue with the <b>dequeue</b> operation.</p><br><p>This is because insertion at the back of a compact array is fast, O(<b>1</b>), but removal at the front of a compact array is slow due to the need to shift items, please review <a href="listd82e.html?slide=2-5"><u>this slide</u></a>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5" title="Go to the previous slide 5">&larr;</div>
<div class="electure-next" data-nextid="5-2" title="Go to the next slide 5-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-2" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Another possible array implementation is to avoid that shifting of items during dequeue operation by having <b>two</b> indices: <b>front</b> (the index of the queue front-most item, increased after a dequeue operation) and <b>back</b> (the index of the queue back-most item, also increased after an enqueue operation).</p><br><p>Suppose we use an array of size <b>M = 8</b> items and the content of our queue is as follows: <samp>[<span style="color: green">(<u>2</u>,4,1,<i>7</i>)</span>,-,-,-,-]</samp> with <u><b>front = 0</b> (underlined)</u> and <i><b>back = 3</b> (italic)</i>. The current active queue elements are highlighted with <span style="color: green">(green color)</span>.</p><br><p>If we call dequeue(), we have <samp>[-,<span style="color: green">(<u>4</u>,1,<i>7</i>)</span>,-,-,-,-]</samp>, <u><b>front = 0+1 = 1</b></u>, and <i><b>back = 3</b></i>.</p><br><p>If we call enqueue(5), we have <samp>[-,<span style="color: green">(<u>4</u>,1,7,<i>5</i>)</span>,-,-,-]</samp>, <u><b>front = 1</b></u>, and <i><b>back = 3+1 = 4</b></i>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-1" title="Go to the previous slide 5-1">&larr;</div>
<div class="electure-next" data-nextid="5-3" title="Go to the next slide 5-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-3" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>However, many dequeue and enqueue operations later, we may have <samp>[-,-,-,-,-,<span style="color: green"><u>6</u>,2,<i>3</i></span>]</samp>, <u><b>front = 5</b></u>, and <i><b>back = 7</b></i>. By now, we cannot enqueue anything else albeit we have many empty spaces at the front of the array.</p><br><p>If we allow both <b>front</b> and <b>back</b> indices to "wrap back" to index 0 when they have reached index <b>M</b>-1, we effectively make the array "circular" and we can use the empty spaces.</p><br><p>For example, if we call enqueue(8) next, we have <samp>[<span style="color: green"><i>8</i>)</span>,-,-,-,-,<span style="color: green">(<u>6</u>,2,3</span>]</samp>, <u><b>front = 5</b></u>, and <i><b>back = (7+1)%8 = 0</b></i>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-2" title="Go to the previous slide 5-2">&larr;</div>
<div class="electure-next" data-nextid="5-4" title="Go to the next slide 5-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-4" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Yet, this does not solve the main problem of fixed-size array implementation. A few more enqueue operations later, we may have <samp>[<span style="color: green">8,10,11,12,<i>13</i>),(<u>6</u>,2,3</span>]</samp>, <u><b>front = 5</b></u>, and <i><b>back = 4</b></i>. At this point (<b>front = (back+1) % M)</b>), we cannot enqueue anything else.</p><br><p>Do note that if we know that our queue size will never exceed the fixed array size <b>M</b>, then the circular array idea is actually already a good way to implement Queue ADT.</p><br><p>However, if we do not know the upper bound of queue size, we can enlarge (double) the size of the array, e.g., make <b>M = 2*8 = 16</b> (two-times larger), but that will entail re-copying the items from index <u><b>front</b></u> to <i><b>back</b></i> in a <b>slow</b> (but rare) O(<b>N</b>) process to have <samp>[<span style="color: green">(<u>6</u>,2,3,8,10,11,12,<i>13</i>)</span>,-,-,-,-,-,-,-,-,]</samp>, <u><b>front = 0</b></u>, and <i><b>back = 7</b></i>.</p><br><p>PS1: If you understand amortized analysis, this heavy O(<b>N</b>) cost when the circular array is full can actually be spread out so that each enqueue remains O(<b>1</b>) in amortized sense.</p><br><p>PS2: There is an alternative way to implement an efficient Queue using two Stacks. How?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-3" title="Go to the previous slide 5-3">&larr;</div>
<div class="electure-next" data-nextid="5-5" title="Go to the next slide 5-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-5" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-4" title="Go to the previous slide 5-4">&larr;</div>
<div class="electure-next" data-nextid="5-6" title="Go to the next slide 5-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-6" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>If we do not really know the the upper bound of queue size, then Singly Linked List (SLL) can be a good data structure to implement Queue ADT.</p><br><p>Recall that in a Queue, we only need the two extreme ends of the List, one for insertion (enqueue) only and one for removal (dequeue) only.</p><br><p>If we review <a href="list78af.html?slide=3-21"><u>this slide</u></a>, we see that insertion <b>after tail</b> and removal <b>from head</b> in a Singly Linked List are fast, i.e., O(<b>1</b>). Thus, we designate the head/tail of the Singly Linked List as the front/back of the queue, respectively. Then, as the items in a Linked List are <b>not</b> stored contiguously in computer memory, our Linked List can grow and shrink as needed.</p><br><p>In our visualization, Queue is basically a <b>protected</b> Singly Linked List where we can only peek at the head item, enqueue a new item to one position after the current tail, e.g., try <span class="slide-actions" onclick="doButtonAction108()">Enqueue(random-integer)</span>, and dequeue existing item from the head, e.g., try <span class="slide-actions" onclick="doButtonAction105()">RemoveHead()</span> (which is essentially a dequeue operation). All operations are O(<b>1</b>).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-5" title="Go to the previous slide 5-5">&larr;</div>
<div class="electure-next" data-nextid="5-7" title="Go to the next slide 5-7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-7" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Queue ADT is usually used to simulate real queues.</p><br><p>One super important application of Queue ADT is inside the <a href="sssp.html"><u>Breadth-First Search</u></a> graph traversal algorithm.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-6" title="Go to the previous slide 5-6">&larr;</div>
<div class="electure-next" data-nextid="6" title="Go to the next slide 6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Doubly Linked List (DLL) is 99% the same as its Singly Linked List version. The main difference is that now each vertex contains <b>two</b> pointers. The <b>next</b> pointer is the same as in Singly Linked List version in which it links item <b>a<sub>i</sub></b> with the next item <b>a<sub>i+1</sub></b>, if exists. The additional <b>prev</b> pointer also links item <b>a<sub>i</sub></b> with the previous item <b>a<sub>i-1</sub></b>, if exists.</p><br><p>The usage of <b>prev</b> pointers makes it possible to move/iterate <b>backwards</b> at the expense of two-times memory usage requirement as now each vertex records one additional pointer. The positive side effect of this ability to move backwards is now we can address the weak <a href="listc679.html?slide=3-18"><u>removal at tail case</u></a> of the Singly Linked List.</p><br><p>In this visualization, notice that the edges in Doubly Linked List (and later Deque) are undirected (bidirectional) edges.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-7" title="Go to the previous slide 5-7">&larr;</div>
<div class="electure-next" data-nextid="6-1" title="Go to the next slide 6-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6-1" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>The main problem of removal of the tail element in the Singly Linked List, even if we have direct access to the tail item via the tail pointer, is that we then have to update the tail pointer to point to one item just before the tail after such removal.</p><br><p>With Doubly Linked List ability to move <b>backwards</b>, we can find this item before the tail via <samp>tail-&gt;prev</samp>... Thus, we can implement removal of tail this way (in C++):</p><pre>Vertex* tmp = tail; // remember tail item<br>tail = tail-&gt;prev; // the key step to achieve O(1) performance :O<br>tail-&gt;next = null; // remove this dangling reference<br>delete tmp; // remove the old tail</pre><p>Now this operation is O(<b>1</b>). Try <span class="slide-actions" onclick="doButtonAction106()">RemoveTail()</span> on example DLL [22 (head)&lt;-&gt;2&lt;-&gt;77&lt;-&gt;6&lt;-&gt;43&lt;-&gt;76&lt;-&gt;89 (tail)].</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6" title="Go to the previous slide 6">&larr;</div>
<div class="electure-next" data-nextid="6-2" title="Go to the next slide 6-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6-2" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>As we have one more pointer <b>prev</b> for each vertex, their values need to be updated too during each insertion or removal. Try all these operations on example DLL [22 (head)&lt;-&gt;2&lt;-&gt;77&lt;-&gt;6&lt;-&gt;43&lt;-&gt;76&lt;-&gt;89 (tail)].</p><br><p>Try <span class="slide-actions" onclick="doButtonAction100()">InsertHead(50)</span> — additional step: 22&#39;s <b>prev</b> pointer points to new head 50.</p><br><p>Try <span class="slide-actions" onclick="doButtonAction101()">InsertTail(10)</span> — additional step: 10&#39;s <b>prev</b> pointer points to old tail 89.</p><br><p>Try <span class="slide-actions" onclick="doButtonAction102()">Insert(3, 44)</span> — additional step: 6&#39;s/44&#39;s <b>prev</b> pointers point to 44/77, respectively.</p><br><p>Try <span class="slide-actions" onclick="doButtonAction105()">RemoveHead()</span> — set new head 2&#39;s <b>prev</b> pointer to null.</p><br><p>Try <span class="slide-actions" onclick="doButtonAction107()">Remove(5)</span> — set 89&#39;s <b>prev</b> pointer to 43.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6-1" title="Go to the previous slide 6-1">&larr;</div>
<div class="electure-next" data-nextid="7" title="Go to the next slide 7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Double-ended queue (often abbreviated to deque, pronounced deck) is an Abstract Data Type that generalizes a Queue, for which elements can be added to or removed only from <b>either</b> the front (head) or back (tail).</p><br><p>In our visualization, Deque is basically a protected Doubly Linked List where we can only:<br>search the head/tail item (peek front/back),<br>insert a new item to the head/tail (try <span class="slide-actions" onclick="doButtonAction100()">InsertHead(50)</span> or <span class="slide-actions" onclick="doButtonAction101()">InsertTail(10)</span>), and <br>remove an existing item from the head/tail (try <span class="slide-actions" onclick="doButtonAction105()">RemoveHead()</span> or <span class="slide-actions" onclick="doButtonAction106()">RemoveTail()</span>).</p><br><p>All operations are O(<b>1</b>).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6-2" title="Go to the previous slide 6-2">&larr;</div>
<div class="electure-next" data-nextid="7-1" title="Go to the next slide 7-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-1" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Deque are used a few advanced applications, like finding the shortest paths 0/1-weighted graph using modified BFS, on some sliding window techniques, etc.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7" title="Go to the previous slide 7">&larr;</div>
<div class="electure-next" data-nextid="8" title="Go to the next slide 8">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8" class="electure-dialog" style="bottom:200px;left:60px;width:500px;">
<p>Create operation is the same for all five modes.</p><br><p>However there are minor differences for the search/insert/remove operations among the five modes.</p><br><p>For Stack, you can only peek/restricted-search, push/restricted-insert, and pop/restricted-remove from the top/head.</p><br><p>For Queue, you can only peek/restricted-search from the front (or sometimes, the back), push/restricted-insert from the back, and pop/restricted-remove from the front.</p><br><p>For Deque, you can peek/restricted-search, enqueue/restricted-insert, dequeue/restricted-remove from both front/back, but not from the middle.</p><br><p>Single (Singly) and Doubly Linked List do not have such restrictions.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-1" title="Go to the previous slide 7-1">&larr;</div>
<div class="electure-next" data-nextid="9" title="Go to the next slide 9">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-9" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>We have reached the end of this e-Lecture.</p><br><p>But read ahead for a few extra challenges.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="8" title="Go to the previous slide 8">&larr;</div>
<div class="electure-next" data-nextid="9-1" title="Go to the next slide 9-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-9-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>The following are the more advanced insights about Linked List:</p><ol><li>What happen if we don&#39;t store the tail pointer too?</li><li>What if we use dummy head?</li><li>What if the last tail item points back to the head item?</li><li>What need to be changed to allow duplicate items (a more general List ADT)?</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="9" title="Go to the previous slide 9">&larr;</div>
<div class="electure-next" data-nextid="9-2" title="Go to the next slide 9-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-9-2" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="9-1" title="Go to the previous slide 9-1">&larr;</div>
<div class="electure-next" data-nextid="9-3" title="Go to the next slide 9-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-9-3" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>C++ STL:<br><a href="http://en.cppreference.com/w/cpp/container/forward_list" target="_blank"><u>forward_list</u></a> (a Singly Linked List)<br><a href="http://en.cppreference.com/w/cpp/container/stack" target="_blank"><u>stack</u></a><br><a href="http://en.cppreference.com/w/cpp/container/queue" target="_blank"><u>queue</u></a><br><a href="http://en.cppreference.com/w/cpp/container/list" target="_blank"><u>list</u></a> (a Doubly Linked List)<br><a href="http://en.cppreference.com/w/cpp/container/deque" target="_blank"><u>deque</u></a> (actually not using Doubly Linked List but another technique, see cppreference)</p><br><p>Java API:<br><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html" target="_blank"><u>LinkedList</u></a> (already a Doubly Linked List)<br><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Stack.html" target="_blank"><u>Stack</u></a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html" target="_blank"><u>Queue</u></a> (actually an interface, usually implemented using LinkedList class)<br><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html" target="_blank"><u>Deque</u></a> (actually an interface, usually implemented using LinkedList class)</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="9-2" title="Go to the previous slide 9-2">&larr;</div>
<div class="electure-next" data-nextid="9-4" title="Go to the next slide 9-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-9-4" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Python:<br><a href="https://docs.python.org/3/tutorial/datastructures.html" target="_blank"><u>list</u></a> for List/Stack/Queue<br><a href="https://docs.python.org/3/library/collections.html#collections.deque" target="_blank"><u>deque</u></a></p><br><p>OCaml:<br><a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html" target="_blank"><u>List</u></a><br><a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Stack.html" target="_blank"><u>Stack</u></a><br><a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Queue.html" target="_blank"><u>Queue</u></a><br>No built-in support for Deque</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="9-3" title="Go to the previous slide 9-3">&larr;</div>
<div class="electure-next" data-nextid="9-5" title="Go to the next slide 9-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-9-5" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>For a few more interesting questions about this data structure, please practice on <a href="https://visualgo.net/training?diff=Medium&amp;n=7&amp;tl=0&amp;module=list"><u>Linked List</u></a> training module.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="9-4" title="Go to the previous slide 9-4">&larr;</div>
<div class="electure-next" data-nextid="9-6" title="Go to the next slide 9-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-9-6" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>We also have a few programming problems that somewhat requires the usage of this Linked List, Stack, Queue, or Deque data structure:<br><a href="https://uva.onlinejudge.org/external/119/11988.pdf" title target="_blank"><u>UVa 11988 - Broken Keyboard (a.k.a. Beiju Text)</u></a>,<br><a href="https://open.kattis.com/problems/backspace" title target="_blank"><u>Kattis - backspace</u></a>, and<br><a href="https://open.kattis.com/problems/integerlists" title target="_blank"><u>Kattis - integerlists</u></a>.</p><br><p>Try them to consolidate and improve your understanding about this data structure. You are allowed to use C++ STL, Python standard library, or Java API if that simplifies your implementation.</p>
<div class="electure-addition">
<hr>
<p>You have reached the last slide. Return to 'Exploration Mode' to start exploring!</p>
<p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
</div>
<div class="electure-prev" data-nextid="9-5" title="Go to the previous slide 9-5">&larr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>Close</u></span>
</div>
<div id="rotateDeviceOverlay" style="display: none;">
<div id="rotateDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please rotate your device to landscape mode for a better user experience</div>
<div id="widenDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please make the window wider for a better user experience</div>
</div>

<style>
        .create {
            bottom: 146px
        }
    </style>
<style>
        .search {
            bottom: 119px
        }
    </style>
<style>
        .insert {
            bottom: 92px
        }
    </style>
<style>
        .remove {
            bottom: 65px
        }
    </style>
<div id="actions" class="panel">
<p id="create">Create(A)</p>
<p class="execAction" id="search" onClick="searchGeneric()">Search</p>
<p id="insert">Insert</p>
<p id="remove">Remove</p>
</div>
<div id="actions-hide" class="panel-hide"><span style="color:white; font-size: x-large; display: inline-block;">&gt;</span></div>
<div id="actions-extras">
<div class="create action-menu-pullout">
<div id="create-empty" class="execAction new-menu-option coloured-menu-option" onClick="empty()">
<p>Empty</p>
</div>
<div id="create-from-arr" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;create&#039;, &#039;create-from-arr&#039;)">
<p>User Defined List</p>
<div id="create-from-arr-third-tier" class="create-from-arr-third-tier new-menu-option" style="display: none;">
<div id="create-from-arr-input" style="float: left;">
A = <input id="v-create-arr" type="text" style="width: 80px;" title="Enter an Integer or comma-separated array of Integers" autocomplete="off" value="2,3,5,7"> </div>
<div id="create-from-arr-go" class="execAction coloured-menu-option" style="float: right;" onClick="nonRandom()">
<p>Go</p>
</div>
</div>
</div>
<div id="create-random-input" class="new-menu-option">
N = <input id="v-create-size" type="number" title="Enter the size of the linked list (N)" autocomplete="off" min="1" max="15" value="7"> </div>
<div id="create-random" class="execAction new-menu-option coloured-menu-option" onClick="random()">
<p>Random</p>
</div>
<div id="create-random-sorted" class="execAction new-menu-option coloured-menu-option" onClick="randomSorted()">
<p>Random Sorted</p>
</div>
<div id="create-err" class="err" style="float: left;"></div>
</div>
<div class="search action-menu-pullout">
<div id="search-peek-front" class="execAction new-menu-option coloured-menu-option" onClick="peekQueueDeque(&#039;front&#039;)" style="display: none;">
<p>Front</p>
</div>
<div id="search-peek-back" class="execAction new-menu-option coloured-menu-option" onClick="peekQueueDeque(&#039;back&#039;)" style="display: none;">
<p>Back</p>
</div>
<div id="search-input" class="new-menu-option">
v = <input id="v-search" type="number" title="Enter an Integer" autocomplete="off" min="1" max="99" value="7"> </div>
<div id="search-go" class="execAction new-menu-option coloured-menu-option" onClick="searchVertex()">
<p>Go</p>
</div>
<div id="search-err" class="err" style="float: left;"></div>
</div>
<div class="insert action-menu-pullout">
<div id="pushtop-input" class="new-menu-option" style="display: none;">
v = <input id="v-push-top-value" type="text" title="Enter an Integer or comma-separated array of Integers" autocomplete="off" value="1,53" style="width: 200px"> </div>
<div id="pushtop-go" class="execAction new-menu-option coloured-menu-option" onClick="pushTop()" style="display: none;">
<p>Go</p>
</div>
<div id="enqueueback-input" class="new-menu-option" style="display: none;">
v = <input id="v-enqueue-back-value" type="text" title="Enter an Integer or comma-separated array of Integers" autocomplete="off" value="1,57" style="width: 200px"> </div>
<div id="enqueueback-go" class="execAction new-menu-option coloured-menu-option" onClick="enqueueBack()" style="display: none;">
<p>Go</p>
</div>
<div id="insert-deque-input" class="new-menu-option" style="display: none;">
v = <input id="v-insert-deque-value" type="text" title="Enter an Integer or comma-separated array of Integers" autocomplete="off" value="1,57" style="width: 200px"> </div>
<div id="insert-deque-front" class="execAction new-menu-option coloured-menu-option" onClick="insertDeque(&#039;front&#039;)" style="display: none;">
<p>Front</p>
</div>
<div id="insert-deque-back" class="execAction new-menu-option coloured-menu-option" onClick="insertDeque(&#039;back&#039;)" style="display: none;">
<p>Back</p>
</div>
<div id="insert-head" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;insert&#039;, &#039;insert-head&#039;)">
<p>i = 0 (Head), specify v =</p>
<div id="insert-head-third-tier" class="insert-head-third-tier new-menu-option" style="display: none;">
<div id="inserthead-input" style="float: left;">
v = <input id="v-insert-head-value" type="number" title="Enter an Integer" autocomplete="off" min="1" max="99" value="85"> </div>
<div id="inserthead-go" class="execAction coloured-menu-option" style="float: right;" onClick="insertHead()">
<p>Go</p>
</div>
</div>
</div>
<div id="insert-tail" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;insert&#039;, &#039;insert-tail&#039;)">
<p>i = N (After Tail), specify v =</p>
<div id="insert-tail-third-tier" class="insert-tail-third-tier new-menu-option" style="display: none;">
<div id="inserttail-input" style="float: left;">
v = <input id="v-insert-tail-value" type="number" title="Enter an Integer" autocomplete="off" min="1" max="99" value="80"> </div>
<div id="inserttail-go" class="execAction coloured-menu-option" style="float: right;" onClick="insertTail()">
<p>Go</p>
</div>
</div>
</div>
<div id="insert-kth" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;insert&#039;, &#039;insert-kth&#039;)">
<p>specify both i in [1..N-1] and v =</p>
<div id="insert-kth-third-tier" class="insert-kth-third-tier new-menu-option" style="display: none;">
<div id="insertkth-input-index" style="float: left;">
i = <input id="v-insert-kth" type="number" title="Enter an Integer" autocomplete="off" min="0" max="14" value="2"> </div>
<div id="insertkth-input-value" style="float: left;">
v = <input id="v-insert-kth-value" type="number" title="Enter an Integer" autocomplete="off" min="1" max="99" value="80"> </div>
<div id="insertkth-go" class="execAction coloured-menu-option" style="float: right;" onClick="insertKth()">
<p>Go</p>
</div>
</div>
</div>
<div id="insert-err" class="err" style="float: left;"></div>
</div>
<div class="remove action-menu-pullout">
<div id="remove-deque-input" class="new-menu-option" style="display: none;">
K = <input id="K-remove-deque" type="number" title="Enter an Integer" autocomplete="off" min="1" max="15" value="1"> </div>
<div id="remove-deque-front" class="execAction new-menu-option coloured-menu-option" onClick="removeDeque(&#039;front&#039;)" style="display: none;">
<p>Front</p>
</div>
<div id="remove-deque-back" class="execAction new-menu-option coloured-menu-option" onClick="removeDeque(&#039;back&#039;)" style="display: none;">
<p>Back</p>
</div>
<div id="remove-queue-once" class="execAction new-menu-option coloured-menu-option" onClick="removeHead(true)" style="display: none;">
<p>1x (Dequeue)</p>
</div>
<div id="remove-queue-input" class="new-menu-option" style="display: none;">
K = <input id="K-remove-queue" type="number" title="Enter an Integer" autocomplete="off" min="2" max="15" value="2"> </div>
<div id="remove-queue-ktimes" class="execAction new-menu-option coloured-menu-option" onClick="popKTimes()" style="display: none">
<p>Kx (Dequeue)</p>
</div>
<div id="remove-head" class="execAction new-menu-option coloured-menu-option" onClick="removeHead(true)">
<p>Remove i = 0 (Head)</p>
</div>
<div id="remove-tail" class="execAction new-menu-option coloured-menu-option" onClick="removeTail()">
<p>Remove i = N-1 (Tail)</p>
</div>
<div id="remove-kth" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;remove&#039;, &#039;remove-kth&#039;)">
<p>specify i in [1..N-2]</p>
<div id="remove-kth-third-tier" class="remove-kth-third-tier new-menu-option" style="display: none;">
<div id="removekth-input" style="float: left;">
i = <input id="v-remove-kth" type="number" title="Enter an Integer" autocomplete="off" min="0" max="14" value="2"> </div>
<div id="removekth-go" class="execAction coloured-menu-option" style="float: right;" onClick="removeKth()">
<p>Go</p>
</div>
</div>
</div>
<div id="pop-once" class="execAction new-menu-option coloured-menu-option" onClick="removeHead(true)" style="display: none;">
<p>1x (Pop)</p>
</div>
<div id="pop-ktimes-input" class="new-menu-option" style="display: none;">
K = <input id="K-remove-stack" type="number" title="Enter an Integer" autocomplete="off" min="2" max="15" value="2"> </div>
<div id="pop-ktimes" class="execAction new-menu-option coloured-menu-option" onClick="popKTimes()" style="display: none;">
<p>Kx (Pop)</p>
</div>
<div id="remove-err" class="err" style="float: left;"></div>
</div>
</div>

</div>

<div id="bottom-bar">
<a id="scale" style="display: none;">1.0x</a>
<a id="trigger-about">About</a>
<a id="trigger-team">Team</a>
<a id="trigger-terms">Terms of use</a>
<a id="trigger-privacy">Privacy Policy</a>
</div>
<div id="about" class="overlays">
<h4>About</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.</p><p>Featuring numerous advanced algorithms discussed in Dr. Steven Halim&#39;s book, &#39;Competitive Programming&#39; — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.</p><p>While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.</p><p>Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.</p><p>VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.</p><p>Equipped with a built-in question generator and answer verifier, VisuAlgo&#39;s "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students&#39; answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students&#39; mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.</p><p>VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:</p>
<a href="https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689" target="_blank"><u>id</u></a>,
<a href="http://blog.naver.com/visualgo_nus" target="_blank"><u>kr</u></a>,
<a href="https://www.facebook.com/groups/163215593699283/permalink/824003417620494/" target="_blank"><u>vn</u></a>,
<a href="http://pantip.com/topic/32736343" target="_blank"><u>th</u></a>.
</div>
</div>
<div id="team" class="overlays">
<h4>Team</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>
<strong><span style="line-height: 150%;">Project Leader &amp; Advisor (Jul 2011-present)</span></strong><br>
<a href="https://www.comp.nus.edu.sg/~stevenha/" target="_blank">Associate Professor Steven Halim</a>, School of Computing (SoC), National University of Singapore (NUS)<br>
<a href="https://www.linkedin.com/in/felixhalim/" target="_blank">Dr Felix Halim</a>, Senior Software Engineer, Google (Mountain View)
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 1</span></strong><br>
<b>CDTL TEG 1: Jul 2011-Apr 2012</b>: Koh Zi Chun, Victor Loh Bo Huai
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 1</span></strong><br>
<b>Jul 2012-Dec 2013</b>: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang Duy<br>
<b>Jun 2013-Apr 2014</b> <a href="https://www.rosemarietan.com/" target="_blank">Rose Marie Tan Zhao Yun</a>, Ivan Reinaldo
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 2</span></strong><br>
<b>CDTL TEG 2: May 2014-Jul 2014</b>: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 2</span></strong><br>
<b>Jun 2014-Apr 2015</b>: Erin Teo Yi Ling, Wang Zi<br>
<b>Jun 2016-Dec 2017</b>: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin Mudzakir<br>
<b>Aug 2021-Apr 2023</b>: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius<br>
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 3</span></strong><br>
<b>Optiver: Aug 2023-Oct 2023</b>: Bui Hong Duc, Oleh Naver, Tay Ngan Lin<br>
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 3</span></strong><br>
<b>Aug 2023-Apr 2024</b>: Xiong Jingya, Radian Krisno, Ng Wee Han<br>
</p>
<p>
List of translators who have contributed &ge; 100 translations can be found at <a href="https://visualgo.net/statistics">statistics</a> page.
</p>
<p>
<strong><span style="line-height: 150%;">Acknowledgements</span></strong><br>
NUS <a href="https://nus.edu.sg/cdtl" target="_blank"><u>CDTL</u></a> gave Teaching Enhancement Grant to kickstart this project.<div>For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.</div>
</p>
</div>
</div>
<div id="termsofuse" class="overlays">
<h4>Terms of use</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that you <b>spread the word about its existence to fellow Computer Science students and instructors</b>. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.</p><p>Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (<a href="https://visualgo.net/">https://visualgo.net</a>) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo&#39;s client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.</p><p>Please note that VisuAlgo&#39;s online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the &#39;training mode.&#39; The &#39;test mode&#39; offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.</p><p><strong><span style="line-height: 200%;">List of Publications</span></strong></p> <p>This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can click <a href="https://ioinformatics.org/journal/INFOL099.pdf" target="_blank">this link</a> to read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) and <a href="https://ioinformatics.org/journal/v9_2015_243_245.pdf" target="_blank">this link</a> for the short update in 2015 (to link VisuAlgo name with the previous project).</p><p><strong><span style="line-height: 200%;">Bug Reports or Request for New Features</span></strong></p> <p>VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.</p>
</div>
</div>
<div id="privacy-policy" class="overlays">
<h4>Privacy Policy</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p><b>Version 1.2 (Updated Fri, 18 Aug 2023).</b></p><p>Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.</p><p>Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).</p><p>Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.</p><p>For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.<br></p><p>For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.</p>
</div>
</div>
</div>


<script src="../../code.jquery.com/jquery-3.7.0.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
<script src="../../cdn.jsdelivr.net/npm/bootstrap%405.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<script src="../../unpkg.com/d3-force-boundary%400.0.1/dist/d3-force-boundary.min.js"></script>
<script>
  $(function () {
    // overlays stuffs
    $('#trigger-about').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#about').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-team').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#team').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-terms').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#termsofuse').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-privacy').click(function () {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#privacy-policy').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    })

    $('.close-overlay').click(function() {
      $('.overlays').fadeOut(function() {
        $('#dark-overlay').fadeOut();
      });
    });

    $('#dark-overlay').click(function() {
      $('.overlays').fadeOut();
      $('#dark-overlay').fadeOut();
      if (typeof GeometryWidget !== 'undefined') {
        GeometryWidget.stopLoop();
      }
    });
  })
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-1566631-4"></script>
<script>
      $.ajaxSetup({
        headers: {
          'X-CSRF-TOKEN': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H"
        }
      });

      // handles account dropdown menu
      $(function () {
        $('#language-dropdown-btn').click(function (e) {
          $('#language-dropdown-menu').css('display', 'block');
          $('#account-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function () {
          $('#language-dropdown-menu').css('display', 'none')
        })
      })

      $(function () {
        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        })
      })

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        if (retval) {
          $('#current-action').show();
          $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
          $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
          triggerRightPanels();
          isPlaying = true;
        }
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; ++i) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      const MOBILE_WIDTH = 1000;
      const matchMediaMobile = window.matchMedia(`only screen and (max-width: ${MOBILE_WIDTH}px)`);
      const matchMediaNarrow = window.matchMedia(`only screen and (max-width: 500px)`);
      function isMobile() {
        return matchMediaMobile.matches;
      }
      //To fix the issue of a narrow desktop window being asked to rotate, I am now checking for it based on the navigator.userAgent to see if its mobile or not.
      //This may change in the future if browsers decide to change the naming of userAgent for mobile browsers so may need to keep an eye on this.
      function isMobileOS() {
        return /Mobi/i.test(navigator.userAgent) && !/ipad/i.test(navigator.userAgent);
      }
      let portraitMatcher = window.matchMedia("(orientation:portrait)");
      function isPortrait() {
        return portraitMatcher.matches;
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.colour').css("color", surpriseColour);
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
        });
      });

/*
      // GA dropped 26 Jun 2023 and then made official on 18 Aug 2023
/*
      // the sunset-ed GA, commented on 26 Jun 2023, and Prof Halim doesn't bother to use anymore
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
*/

      // function setCookie(cname, cvalue, exdays) {
      //   const d = new Date();
      //   d.setTime(d.getTime() + (exdays*24*60*60*1000));
      //   let expires = "expires="+ d.toUTCString();
      //   document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
      // }

//       //         $(function() {
//           $('#gdpr-accept').click(function () {
// /*
//             // added on 26 Jun 2023
//             window.dataLayer = window.dataLayer || [];
//             function gtag(){dataLayer.push(arguments);}
//             gtag('js', new Date());

//             gtag('config', 'UA-1566631-4');
// */
// //            ga('create', 'UA-1566631-4', 'auto');
// //            ga('send', 'pageview');
//             setCookie('use_google_analytics', 'true', 365)
//             $('#gdpr-popup').hide()
//           });
//           $('#gdpr-reject').click(function () {
//             setCookie('use_google_analytics', 'false', 365)
//             $('#gdpr-popup').hide()
//           });
//         });
//       
      $('#gdpr-privacy-policy').click(function () {
        if ($(window).width() > 600) {
          $('#dark-overlay').fadeIn(function() {
            $('#privacy-policy').fadeIn();
          });
        }
        else
          alert('Sorry, this dialog is too big. Please load it on bigger screen');
      })
    </script>

<script src="../js/jquery-ui.min.js"></script>

<script src="../js/d3.min.js"></script>
<script src="../js/viz-1.0.10.js"></script>

<script src="../js/graph_library/constant.js"></script>
<script src="../js/graph_library/drawgraph.js"></script>
<script src="../js/graph_library/GraphEdgeWidget.js"></script>
<script src="../js/graph_library/GraphPolygonWidget.js"></script>
<script src="../js/graph_library/GraphVertexWidget.js"></script>
<script src="../js/graph_library/GraphWidget.js"></script>
<script src="../js/graph_library/helperObjects89db.js?refresh22aug9pm"></script> 
<script src="../js/graph_library/misc.js"></script>
<script src="../js/graph_library/properties.js"></script>
<script src="../js/graph_library/Widget.js"></script>
<script src="../js/graph_library/force_directed_library.js"></script>

<script>
      $(function () {
        let defaultPlaybackSpeed = 1;
                createPlaybackSpeedSlider(defaultPlaybackSpeed);


        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        });
        //Mobile Design Related DOM Manipulations
        if (isMobile()) {
          $("#status").css({
            "bottom": "10%",
            "height": "12%",
            "max-height": "54px"
          });
          $("#current-action").css("bottom", "22%");
          $('#status-hide').remove();
          $('#left-bar').remove();
          $('#right-bar').remove();
          $("#mode-menu").remove();
          $("#codetrace").css("z-index", 1);
          $("#bottom-bar a").hide();
          $("#bottom-bar").css("height", $("#topbar").css("height"));
          $(".speed-dropup-btn").show();
          $("#go-to-beginning").remove();
          $("#go-to-end").remove();
          $("#pause").remove();
          $("#play").remove();
          $("#previous").remove();
          $("#next").remove();

          //make progress bar longer
          $("#progress-bar").css({
            left: "30%",
            width: "60%",
            'margin-left': 0
          })
        }
      })

      let mobilePlaybackOverlayTimeout;
      $(function() {
        $("#viz").on("click", () => {
          if (isMobile()) {
            if ($("#mobile-playback-overlay").is(":hidden") && isPlaying) {
              $("#mobile-playback-overlay").fadeIn();
              hideMobilePlaybackOverlay(6000);
            } else {
              $("#mobile-playback-overlay").fadeOut();
            }
          }
        });
        $("#mobile-playback-overlay").on("click", (event) => {
          if (event.target === event.currentTarget) //to ensure clicks on the controls dont fade the overlay
            $("#mobile-playback-overlay").fadeOut();
          else
            hideMobilePlaybackOverlay(5000);
        })
      });
      function hideMobilePlaybackOverlay(timeOut) {
        if (mobilePlaybackOverlayTimeout)
          clearTimeout(mobilePlaybackOverlayTimeout);
        mobilePlaybackOverlayTimeout = setTimeout(() => {
            $("#mobile-playback-overlay").fadeOut();
        }, timeOut);
      }
      function mobilePlaybackPauseOrPlay() {
        if ($("#mobile-playback-overlay").hasClass("playing")) {
          pause();
          hideMobilePlaybackOverlay(5000);
        } else {
          play();
          hideMobilePlaybackOverlay(3000);
        }
      }
      let rewindLabelTimeout, forwardLabelTimeout;
      function mobilePlaybackRewind() {
        $("#mobile-playback-rewind-label").css("opacity", 1);
        if (rewindLabelTimeout)
          clearTimeout(rewindLabelTimeout);
        rewindLabelTimeout = setTimeout(() => {
          $("#mobile-playback-rewind-label").css("opacity", 0);
        }, 800);
        stepBackward(7);
      }
      function mobilePlaybackForward() {
        $("#mobile-playback-forward-label").css("opacity", 1);
        if (forwardLabelTimeout)
          clearTimeout(forwardLabelTimeout);
        forwardLabelTimeout = setTimeout(() => {
          $("#mobile-playback-forward-label").css("opacity", 0);
        }, 800);
        stepForward(7);
      }

      //let eLectureSessionHistory = {};
      const sectorColors = ['#05a4d0', '#f1c706', '#fa0202'];
      function setSlideTimelineColor(slideNo) {
        const sectionNo = slideNo.split('-')[0];
        $(`[slideNo="${slideNo}"]`).css('background', sectorColors[(parseInt(sectionNo) % 3)]);
      }

      let currSlideTimer = null; //global so that we can clear the timeout when required

      const lectureIds = [{"id":82,"category":"list","order":1,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-02-19 10:44:10","updated_at":"2023-06-06 06:07:05","section":-1,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":-1,"value":"1","text":"<p>Linked List is a data structure consisting of a group of vertices (nodes) which together represent a sequence. Under the simplest form, each vertex is composed of a data and a reference (link) to the next vertex in the sequence. Try clicking <span class=\"slide-actions\" onclick=\"doButtonAction96()\">Search(77)<\/span> for a sample animation on searching a value in a (Singly) Linked List.<\/p><br><p>Linked List and its variations are used as underlying data structure to implement List, Stack, Queue, and Deque ADTs (read this <a href=\"https:\/\/en.wikipedia.org\/wiki\/Abstract_data_type\" target=\"_blank\"><u>Wikipedia article about ADT<\/u><\/a> if you are not familiar with that term).<\/p><br><p>In this visualization, we discuss (Singly) Linked List (LL) \u2014 with a single next pointer \u2014 and its two variants: Stack and Queue, and also Doubly Linked List (DLL) \u2014 with both next and previous pointers \u2014 and its variant: Deque.<\/p>","title":"LL, Stack, Queue, DLL, Deque"},{"id":625,"category":"list","order":1,"top":"70px","right":"","bottom":"","left":"200px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-14 03:15:44","updated_at":"2023-04-24 07:57:38","section":82,"code":"","section_order":1,"value":"1-1","text":"<p>We decide to group five related modes involving Linked List (LL, Stack, Queue, DLL, Deque) in one single visualization page. To facilitate more diversity, we randomize the selected mode upon loading this direct URL: https:\/\/visualgo.net\/en\/list.<\/p><br><p>However, you can use the following URL shortcuts to access individual mode directly (only works for logged-in users who have cleared reading all 3 sectors of these lecture notes):<\/p><ol><li><a href=\"https:\/\/visualgo.net\/en\/ll\"><u>https:\/\/visualgo.net\/en\/ll<\/u><\/a>,<\/li><li><a href=\"https:\/\/visualgo.net\/en\/stack\"><u>https:\/\/visualgo.net\/en\/stack<\/u><\/a>,<\/li><li><a href=\"https:\/\/visualgo.net\/en\/queue\"><u>https:\/\/visualgo.net\/en\/queue<\/u><\/a>,<\/li><li><a href=\"https:\/\/visualgo.net\/en\/dll\"><u>https:\/\/visualgo.net\/en\/dll<\/u><\/a>,<\/li><li><a href=\"https:\/\/visualgo.net\/en\/deque\"><u>https:\/\/visualgo.net\/en\/deque<\/u><\/a>.<\/li><\/ol>","title":"Five Modes"},{"id":584,"category":"list","order":2,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-06 05:56:30","updated_at":"2023-04-24 07:57:56","section":-1,"code":"","section_order":-1,"value":"2","text":"<p>Linked List data structure is commonly taught in Computer Science (CS) undergraduate courses for a few reasons:<\/p><ol><li>It is a simple linear data structure,<\/li><li>It has a range of potential applications as a list ADT e.g., student list, event list, appointment list, etc (albeit there are other more advanced data structures that can do the same (and more) applications better) or as stack\/queue\/deque ADTs,<\/li><li>It has interesting corner\/special cases to illustrate the need for a good implementation of a data structure,<\/li><li>It has various customization options and thus usually this Linked List data structure is taught using Object-Oriented Programming (OOP) way.<\/li><\/ol>","title":"Motivation"},{"id":585,"category":"list","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-06 05:58:17","updated_at":"2023-04-24 07:59:29","section":584,"code":"","section_order":2,"value":"2-1","text":"<p>List is a sequence of items\/data where positional order matter {a<sub>0<\/sub>, a<sub>1<\/sub>, ..., a<sub>N-2<\/sub>, a<sub>N-1<\/sub>}.<br>Common List ADT operations are:<\/p><ol start=\"0\"><li><samp>get(i)<\/samp> \u2014 maybe a trivial operation, return <samp>a<sub>i<\/sub><\/samp> (0-based indexing),<\/li><li><samp>search(v)<\/samp> \u2014 decide if item\/data <b>v<\/b> exists (and report its position\/index)<br>or not exist (and usually report a non existing index -1) in the list,<\/li><li><samp>insert(i, v)<\/samp> \u2014 insert item\/data <b>v<\/b> specifically at position\/index <b>i<\/b> in the list, potentially shifting the items from previous positions: [<b>i<\/b>..<b>N<\/b>-1] by one position to their right to make a space,<\/li><li><samp>remove(i)<\/samp> \u2014 remove item that is specifically at position\/index <b>i<\/b> in the list, potentially shifting the items from previous positions: [<b>i+1<\/b>..<b>N<\/b>-1] by one position to their left to close the gap.<\/li><\/ol><p>Discussion 1: What if we want to remove item with specific value <b>v<\/b> in the list?<\/p><p>Discussion 2: Can a List ADT contains duplicate items, i.e., a<sub>i<\/sub> = a<sub>j<\/sub> where i &ne; j?<\/p>","title":"List ADT"},{"id":626,"category":"list","order":2,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-06-14 03:25:01","updated_at":"2023-06-06 06:06:00","section":584,"code":"","section_order":2,"value":"2-2","text":"<p>To remove a specific value <b>v<\/b>, assuming it exists, we can use the following code:<\/p><pre>i = search(v);<br>if (i != -1) remove(i);<\/pre><p>PS: There are additional possible helper operations like <samp>isEmpty()<\/samp> (check if <b>N == 0<\/b>?), <samp>getLength()<\/samp> (return the current value of <b>N<\/b>), <samp>sortList()<\/samp>, <samp>printList()<\/samp>, etc.<\/p><hr><p>List ADT can contains duplicate. However, as of today, this visualization has a limitation that it can only accept distinct items only.<\/p>","title":"The Answer"},{"id":586,"category":"list","order":3,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-06 05:58:23","updated_at":"2023-04-24 08:00:45","section":584,"code":"","section_order":2,"value":"2-3","text":"<p>(Compact) Array is a good candidate for implementing the List ADT as it is a simple construct to handle a collection of items.<\/p><br><p>When we say compact array, we mean an array that has <b>no gap<\/b>, i.e., if there are <b>N<\/b> items in the array (that has size <b>M<\/b>, where <b>M &ge; N<\/b>), then only index [0..<b>N<\/b>-1] are occupied and other indices [<b>N<\/b>..<b>M<\/b>-1] should remain <b>empty<\/b>.<\/p><br><img src=\"https:\/\/visualgo.net\/img\/compactarray_illustration.png\" width=\"100%\" alt=\"Compact Array Illustration\">","title":"Array Implementation - Part 1"},{"id":627,"category":"list","order":4,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-14 03:28:19","updated_at":"2023-04-24 08:03:27","section":584,"code":"","section_order":2,"value":"2-4","text":"<p>Let the <b>compact<\/b> array name be <samp>A<\/samp> with index [0..<b>N<\/b>-1] occupied with the items of the list.<\/p><br><p><samp>get(i)<\/samp>, just return <samp>A[i]<\/samp>.<br>This simple operation will be unnecessarily complicated if the array is <b>not<\/b> compact.<\/p><br><p><samp>search(v)<\/samp>, we check each index <samp>i<\/samp> \u2208 [0..<b>N<\/b>-1] one by one to see if <samp>A[i] == v<\/samp>.<br>This is because <samp>v<\/samp> (if it exists) can be anywhere in index [0..<b>N<\/b>-1].<br>Since this visualization only accept distinct items, <samp>v<\/samp> can only be found at most once.<br>In a general List ADT, we may want to have <samp>search(v)<\/samp> returns a list of indices.<\/p><br><p><samp>insert(i, v)<\/samp>, we shift items \u2208 [<b>i<\/b>..<b>N<\/b>-1] to [<b>i<\/b>+1..<b>N<\/b>] (<i>from backwards<\/i>) and set <samp>A[i] = v<\/samp>.<br>This is so that <samp>v<\/samp> is inserted correctly at index <samp>i<\/samp> and maintain compactness.<\/p><br><p><samp>remove(i)<\/samp>, we shift items \u2208 [<b>i+1<\/b>..<b>N<\/b>-1] to [<b>i<\/b>..<b>N<\/b>-2], overwriting the old <samp>A[i]<\/samp>.<br>This is to maintain compactness.<\/p>","title":"Array Implementation - Part 2"},{"id":587,"category":"list","order":5,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-06 06:02:45","updated_at":"2023-04-24 08:01:05","section":584,"code":"","section_order":2,"value":"2-5","text":"<p><samp>get(i)<\/samp> is very fast: Just one access, O(<b>1<\/b>).<br>Another CS module: &#39;Computer Organisation&#39; discusses the details on this O(<b>1<\/b>)<br>performance of this array indexing operation.<\/p><br><p><samp>search(v)<\/samp><br>In the best case, <b>v<\/b> is found at the first position, O(<b>1<\/b>).<br>In the worst case, <b>v<\/b> is not found in the list and we require O(<b>N<\/b>) scan to determine that.<\/p><br><p><samp>insert(i, v)<\/samp><br>In the best case, insert at <b>i = N<\/b>, there is no shifting of element, O(<b>1<\/b>).<br>In the worst case, insert at <b>i = 0<\/b>, we shift all <b>N<\/b> elements, O(<b>N<\/b>).<\/p><br><p><samp>remove(i)<\/samp><br>In the best case, remove at <b>i = N-1<\/b>, there is no shifting of element, O(<b>1<\/b>).<br>In the worst case, remove at <b>i = 0<\/b>, we shift all <b>N<\/b> elements, O(<b>N<\/b>).<\/p>","title":"Time Complexity Summary"},{"id":589,"category":"list","order":6,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-06 06:07:18","updated_at":"2023-04-24 08:01:10","section":584,"code":"","section_order":2,"value":"2-6","text":"<p>The size of the compact array <b>M<\/b> is not infinite, but a finite number. This poses a problem as the maximum size may not be known in advance in many applications.<\/p><br><p>If <b>M<\/b> is too big, then the unused spaces are wasted.<br>If <b>M<\/b> is too small, then we will run out of space easily.<\/p>","title":"Fixed Space Issue"},{"id":639,"category":"list","order":7,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-09-08 02:56:06","updated_at":"2023-04-24 08:05:08","section":584,"code":"","section_order":2,"value":"2-7","text":"<p>Solution: Make <b>M<\/b> a variable. So when the array is full, we create a larger array (usually two times larger) and move the elements from the old array to the new array. Thus, there is no more limits on size other than the (usually large) physical computer memory size.<\/p><br><p><a href=\"https:\/\/en.cppreference.com\/w\/cpp\/container\/vector\" target=\"_blank\"><u>C++ STL std::vector<\/u><\/a>, <a href=\"https:\/\/docs.python.org\/3\/tutorial\/datastructures.html#more-on-lists\" target=\"_blank\"><u>Python list<\/u><\/a>, <a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/util\/Vector.html\" target=\"_blank\"><u>Java Vector<\/u><\/a>, or <a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/util\/ArrayList.html\" target=\"_blank\"><u>Java ArrayList<\/u><\/a> all implement this variable-size array. Note that Python <i>list<\/i> and Java Array<i>List<\/i> are <b>not<\/b> Linked Lists, but are actually variable-size arrays.<\/p> <br><p>However, the classic array-based issues of space wastage and copying\/shifting items overhead are still problematic.<\/p>","title":"Variable Space"},{"id":588,"category":"list","order":8,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-06 06:07:00","updated_at":"2023-04-24 08:01:16","section":584,"code":"","section_order":2,"value":"2-8","text":"<p>For fixed-size collections with known max limit of number of items that will ever be needed, i.e., the max size of <b>M<\/b>, then array is already a reasonably good data structure for List ADT implementation.<\/p><br><p>For variable-size collections with unknown size <b>M<\/b> and where dynamic operations such as insert\/remove are common, a simple array is actually a poor choice of data structure.<\/p><br><p>For such applications, there are better data structures. Let&#39;s read on...<\/p>","title":"Observations"},{"id":590,"category":"list","order":3,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-06 06:09:09","updated_at":"2023-04-24 08:07:02","section":-1,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":-1,"value":"3","text":"<p>We now introduce the Linked List data structure. It uses pointers\/references to allow items\/data to be <b>non-contiguous<\/b> in memory (that is the main difference with a <a href=\"?slide=2-2\"><u>simple array<\/u><\/a>). The items are ordered from index 0 to index <b>N<\/b>-1 by associating item <b>i<\/b> with its neighbour item <b>i+1<\/b> through a pointer.<\/p><br><img src=\"https:\/\/visualgo.net\/img\/ll_illustration.png\" width=\"100%\" alt=\"Linked List Illustration\">","title":"Linked List (LL)"},{"id":601,"category":"list","order":1,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-09 06:47:57","updated_at":"2023-04-24 08:05:38","section":590,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":3,"value":"3-1","text":"<p>In its basic form, a single vertex (node) in the Linked List has this rough structure:<\/p><pre>struct Vertex { \/\/ we can use either C struct or C++\/Python\/Java class<br>  int item; \/\/ the data is stored here, an integer in this example<br>  Vertex* next; \/\/ this pointer tells us where is the next vertex<br>};<\/pre><p>Using the default example Linked List [22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)] for illustration, we have:<br><b>a<sub>0<\/sub><\/b> with its <b>item<\/b> = 22 and its <b>next<\/b> = <b>a<sub>1<\/sub><\/b>,<br><b>a<sub>1<\/sub><\/b> with its <b>item<\/b> = 2 and its <b>next<\/b> = <b>a<sub>2<\/sub><\/b>,<br>...<br><b>a<sub>6<\/sub><\/b> with its <b>item<\/b> = 89 and its <b>next<\/b> = <b>null<\/b>.<\/p><br><p>Discussion: Which one is better for a C++ implementation of Linked List? struct or class? How about Python or Java implementation?<\/p>","title":"Linked List Vertex C++ Implementation"},{"id":640,"category":"list","order":2,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-09-08 03:03:27","updated_at":"2023-04-24 08:05:41","section":590,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":3,"value":"3-2","text":"<p>No clear right or wrong answer.<\/p><br><p>Performance wise, both are approximately equal.<\/p><br><p>C struct is slightly easier to code while C++\/Python\/Java class has a few more small details.<\/p><br><p>All members of struct are public whereas we can control visibility of class members.<\/p><br><p>Python\/Java users do not have a choice though and have to use class.<\/p>","title":"The Answer"},{"id":602,"category":"list","order":3,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-09 06:51:46","updated_at":"2023-04-24 08:05:43","section":590,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":3,"value":"3-3","text":"<p>We also have a few additional data that we remember in this Linked List data structure. We use the default example Linked List [22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)] for illustration.<\/p><ol><li>The <b>head<\/b> pointer points to <b>a<sub>0<\/sub><\/b> \u2014 it is 22, nothing points to the head item,<\/li><li>The current number of elements <b>N<\/b> in the Linked List \u2014 <b>N = 7 <\/b>elements.<\/li><li>The <b>tail<\/b> pointer points to <b>a<sub>N-1<\/sub><\/b> \u2014 it is <b>a<sub>6<\/sub><\/b> = 89, nothing is after the tail item.<\/li><\/ol><p>That&#39;s it, we only add three more extra variables in data structure.<\/p>","title":"Linked List, Additional Data"},{"id":628,"category":"list","order":4,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-14 05:48:12","updated_at":"2023-04-24 08:09:33","section":590,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":3,"value":"3-4","text":"<p>Note that there are various subtle differences found in many Computer Science textbooks on how to implement a (Singly) Linked List e.g., use tail pointer or not, circular or not, use dummy head item or not, allow duplicate items or not &mdash; see <a href=\"?slide=9-1\"><u>this slide<\/u><\/a>.<\/p><br><p>Our version in this visualization (with tail pointer, not circular, without dummy head, disallow duplicate) may not be 100% the same compared to what you learn in your class but the basic ideas should remain the same.<\/p><br><p>In this visualization, each vertex has Integer item, but this can easily be changed to any other data type as needed.<\/p>","title":"Variations"},{"id":593,"category":"list","order":5,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-06 06:14:22","updated_at":"2023-04-24 08:05:49","section":590,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":3,"value":"3-5","text":"<p>Since we only keep the head and tail pointers, list traversal subroutine is needed to reach positions other than the head (index 0) and the tail (index <b>N<\/b>-1).<\/p><br><p>As this sub-routine is so frequently used, we will abstract it out as a function. The code below is written in C++.<\/p><pre>Vertex* Get(int i) { \/\/ returns the vertex<br>  Vertex* ptr = head; \/\/ we have to start from head<br>  for (int k = 0; k &lt; i; ++k) \/\/ advance forward i time(s)<br>    ptr = ptr-&gt;next; \/\/ the pointers are pointing to the higher index<br>  return ptr;<br>}<\/pre><p>It runs in O(<b>N<\/b>) as <b>i<\/b> can be as big as index <b>N<\/b>-2.<br>Compare this with <a href=\"?slide=2-4\"><u>array<\/u><\/a> where we can access index <b>i<\/b> in O(<b>1<\/b>) time.<\/p>","title":"Get(i) - Much Slower than Array"},{"id":604,"category":"list","order":6,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-12 13:03:17","updated_at":"2023-04-24 08:05:51","section":590,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":3,"value":"3-6","text":"<p>As we only have direct reference to the first head item and the last tail item, plus the pointers are pointing to the <b>right<\/b> (higher position\/index), we can only access the rest by starting from the head item and hopping through the next pointers. On the default [22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)], we have:<\/p><p><br><\/p><p><span class=\"slide-actions\" onclick=\"doButtonAction96()\">Search(77)<\/span> \u2014 found in the example above at position\/index 2 (0-based indexing).<\/p><br><p><span class=\"slide-actions\" onclick=\"doButtonAction97()\">Search(7)<\/span> \u2014 not found in the example above, and this is only known after all <b>N<\/b> items are examined, so <samp>Search(v)<\/samp> has O(<b>N<\/b>) worst case time complexity.<\/p>","title":"Search(v) - Not Better than Array"},{"id":591,"category":"list","order":7,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-06 06:11:02","updated_at":"2023-04-24 08:05:54","section":590,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":3,"value":"3-7","text":"<p>There are more cases than <a href=\"?slide=2-4\"><u>array<\/u><\/a> version due to the nature of Linked List.<\/p><br><p>Most CS students who learn Linked List for the first time usually are not aware of all cases until they figure it out themselves when their Linked List code fail.<\/p><br><p>In this e-Lecture, we directly elaborate all cases.<\/p><br><p>For <samp>insert(i, v)<\/samp>, there are four (legal) possibilities, i.e., item <b>v<\/b> is added to:<\/p><ol><li>The head (before the current first item) of the linked list, <b>i = 0<\/b>,<\/li><li>An empty linked list (which fortunately similar to the previous case),<\/li><li>The position beyond the last (the current tail) item of the linked list, <b>i = N<\/b>,<\/li><li>The other positions of the linked list, <b>i = [1..N-1]<\/b>.<\/li><\/ol>","title":"Insertion - Four Cases"},{"id":592,"category":"list","order":8,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-06 06:12:53","updated_at":"2023-04-24 08:05:59","section":590,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":3,"value":"3-8","text":"<p>The (C++) code for insertion at head is simple and efficient, in O(<b>1<\/b>):<\/p><pre>Vertex* vtx = new Vertex(); \/\/ create new vertex vtx from item v<br>vtx-&gt;item = v;<br>vtx-&gt;next = head; \/\/ link this new vertex to the (old) head vertex<br>head = vtx; \/\/ the new vertex becomes the new head<\/pre><p>Try <span class=\"slide-actions\" onclick=\"doButtonAction100()\">InsertHead(50)<\/span>, which is <samp>insert(0, 50)<\/samp>, on the example Linked List&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)].<\/p><br><p>Discussion: What happen if we use <a href=\"?slide=2-5\"><u>array<\/u><\/a> implementation for insertion at head of the list?<\/p>","title":"Insert(i, v) - Insert at Head (i = 0)"},{"id":605,"category":"list","order":9,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-06-12 13:14:36","updated_at":"2023-04-24 08:06:03","section":590,"code":"$(\"#title-LL\").click();","section_order":3,"value":"3-9","text":"<p>This is one area where Linked List is much better than array.<\/p><br><p>As the items can be non-contiguous in the memory, we do not need to shift items from old index [0..<b>N<\/b>-1] to [1..<b>N<\/b>] in order to make room for a new item at index 0.<\/p><br><p>This efficient O(<b>1<\/b>) insertion at head of the list is useful for <a href=\"?slide=4\"><u>Stack ADT<\/u><\/a> later on.<\/p>","title":"The Answer"},{"id":600,"category":"list","order":10,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-07 07:30:34","updated_at":"2023-04-24 08:06:05","section":590,"code":"$(\"#title-LL\").click();\nempty();","section_order":3,"value":"3-10","text":"<p>Empty data structure is a common corner\/special case that can often cause unexpected crash if not properly tested. It is legal to insert a new item into a currently empty list, i.e., at index <b>i = 0<\/b>. Fortunately, the same pseudo-code for insertion at head also works for an empty list so we can just use the same code as in <a href=\"?slide=3-8\"><u>this slide<\/u><\/a>&nbsp;(with one minor change, we also need to set tail = head).<\/p><br><p>Try <span class=\"slide-actions\" onclick=\"doButtonAction103()\">InsertHead(50)<\/span>, which is <samp>insert(0, 50)<\/samp>, but on the empty Linked List [].<\/p>","title":"Insert(i, v) - Insert into an Empty List"},{"id":594,"category":"list","order":11,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-06 06:28:29","updated_at":"2023-04-24 08:06:11","section":590,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":3,"value":"3-11","text":"<p>With the Linked List traversal <samp>Get(i)<\/samp> sub-routine, we can now implement insertion in the middle of the Linked List as follows (in C++):<\/p><pre>Vertex* pre = Get(i-1); \/\/ traverse to (i-1)-th vertex, O(N)<br>aft = pre-&gt;next; \/\/ aft cannot be null, think about it<br>Vertex* vtx = new Vertex(); \/\/ create new vertex<br>vtx-&gt;item = v;<br>vtx-&gt;next = aft; \/\/ link this<br>pre-&gt;next = vtx; \/\/ and this<\/pre><p>Try <span class=\"slide-actions\" onclick=\"doButtonAction102()\">Insert(3, 44)<\/span> on the example Linked List&nbsp;&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)].<\/p><br><p>Also try <span class=\"slide-actions\" onclick=\"doButtonAction104()\">Insert(6, 55)<\/span> on the same example Linked List. This is a corner case: Insert at the position of tail item, shifting the tail to one position to its right.<\/p><br><p>This operation is slow, O(<b>N<\/b>), due to the need for traversing the list (e.g. if <b>i<\/b> close to <b>N<\/b>-1).<\/p>","title":"Insert(i, v) - In Between, i &in; [1..N-1]"},{"id":599,"category":"list","order":12,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-07 04:32:10","updated_at":"2023-04-24 08:06:13","section":590,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":3,"value":"3-12","text":"<p>If we also remember the tail pointer as with the implementation <a href=\"?slide=3-3\"><u>in this e-Lecture<\/u><\/a> (which is advisable as it is just one additional pointer variable), we can perform insertion beyond the tail item (at <b>i = N<\/b>) efficiently, in O(<b>1<\/b>):<\/p><pre>Vertex* vtx = new Vertex(); \/\/ this is also a C++ code<br>vtx-&gt;item = v; \/\/ create new vertex vtx from item v<br>tail-&gt;next = vtx; \/\/ just link this, as tail is the i = (N-1)-th item<br>tail = vtx; \/\/ now update the tail pointer<\/pre><p>Try <span class=\"slide-actions\" onclick=\"doButtonAction101()\">InsertTail(10)<\/span>, which is <samp>insert(7, 10)<\/samp>, on the example Linked List&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)]&nbsp;. A common misconception is to say that this is insertion at tail. Insertion at tail element is <samp>insert(N-1, v)<\/samp>. Insertion <b>beyond<\/b> the tail is <samp>insert(N, v)<\/samp>.<\/p><br><p>Discussion: What happen if we use <a href=\"?slide=2-5\"><u>array<\/u><\/a> implementation for insertion beyond the tail of the list?<\/p>","title":"Insert(i, v) - Beyond the Tail, i = N"},{"id":606,"category":"list","order":13,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-06-12 13:25:00","updated_at":"2023-04-24 08:06:16","section":590,"code":"$(\"#title-LL\").click();","section_order":3,"value":"3-13","text":"<p>Both (compact) array and Linked List performs equally well &mdash; O(<b>1<\/b>) &mdash; for this scenario.<\/p><br><p>As insertion to the back of the list (after the tail item) can be made efficient O(<b>1<\/b>) due to the memorizing the position of the tail item, Linked List can be very useful for <a href=\"?slide=5\"><u>Queue ADT<\/u><\/a> later on.<\/p>","title":"The Answer"},{"id":595,"category":"list","order":14,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-06 06:30:01","updated_at":"2023-04-24 08:06:20","section":590,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":3,"value":"3-14","text":"<p>For <samp>remove(i)<\/samp>, there are three (legal) possibilities, i.e., index <b>i<\/b> is:<\/p><ol><li>The head (the current first item) of the linked list, <b>i = 0<\/b>, it affects the head pointer<\/li><li>The tail of the linked list, <b>i = N-1<\/b>, it affects the tail pointer<\/li><li>The other positions of the linked list, <b>i = [1..N-2]<\/b>.<\/li><\/ol><p>Discussion: Compare this slide with <a href=\"?slide=3-7\"><u>Insertion Cases slide<\/u><\/a> to realize the subtle differences. Is removing anything from an already empty Linked List considered &#39;legal&#39;?<\/p>","title":"Removal - Three Cases"},{"id":596,"category":"list","order":15,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-06 06:30:27","updated_at":"2023-04-24 08:06:26","section":590,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6\");\nnonRandom();","section_order":3,"value":"3-15","text":"<p>This case is straightforward (written in C++):<\/p><pre>if (head == NULL) return; \/\/ avoid crashing when SLL is empty<br>Vertex* tmp = head; \/\/ so we can delete it later<br>head = head-&gt;next; \/\/ book keeping, update the head pointer<br>delete tmp; \/\/ which is the old head<\/pre><p>Try <span class=\"slide-actions\" onclick=\"doButtonAction105()\">RemoveHead()<\/span> repeatedly on the (shorter) example Linked List&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6 (tail)]. It will continuously working correctly up until the Linked List contains one item where the head = the tail item. We prevent execution if the LL is already empty as it is an illegal case.<\/p><br><p>Discussion: What happen if we use <a href=\"?slide=2-5\"><u>array<\/u><\/a> implementation for removal of head of the list?<\/p>","title":"Remove(i) - At Head (i = 0)"},{"id":607,"category":"list","order":16,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-06-12 13:28:25","updated_at":"2023-04-24 08:06:29","section":590,"code":"$(\"#title-LL\").click();","section_order":3,"value":"3-16","text":"<p>This is another area where Linked List is much better than array.<\/p><br><p>Again, as the items can be non-contiguous in the memory, we do not need to shift items from old index [1..<b>N<\/b>-1] to [0..<b>N<\/b>-2] in order to close the gap after deletion of (old) item at index 0.<\/p><br><p>This efficient O(<b>1<\/b>) removal of head of the list is useful for <a href=\"?slide=4\"><u>Stack ADT<\/u><\/a> and also <a href=\"?slide=5\"><u>Queue ADT<\/u><\/a>.<\/p>","title":"The Answer"},{"id":597,"category":"list","order":17,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-06 06:30:50","updated_at":"2023-04-24 08:06:32","section":590,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":3,"value":"3-17","text":"<p>With the Linked List traversal <samp>Get(i)<\/samp> sub-routine (<a href=\"?slide=3-5\"><u>discussed earlier<\/u><\/a>), we can now implement removal of the middle item of the Linked List as follows (in C++):<\/p><pre>Vertex* pre = Get(i-1); \/\/ traverse to (i-1)-th vertex, O(N)<br>Vertex* del = pre-&gt;next, aft = del-&gt;next;<br>pre-&gt;next = aft; \/\/ bypass del<br>delete del;<\/pre><p>Try <span class=\"slide-actions\" onclick=\"doButtonAction107()\">Remove(5)<\/span>, the element at index <b>N-2<\/b> (as <b>N = 7<\/b> in the example&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)]&nbsp;.<br>This is the worst O(<b>N<\/b>) case on the example above.<\/p><br><p>Note that <b>Remove(N-1)<\/b> is removal at tail that requires us to update the tail pointer, see the next case.<\/p>","title":"Remove(i) - In Between, i &in; [1..N-2]"},{"id":603,"category":"list","order":18,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-09 08:47:50","updated_at":"2023-04-24 08:06:35","section":590,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6\");\nnonRandom();","section_order":3,"value":"3-18","text":"<p>We can implement the removal of the tail of the Linked List as follows, assuming that the Linked List has more than 1 item (in C++):<\/p><pre>Vertex* pre = head;<br>tmp = head-&gt;next;<br>while (tmp-&gt;next != null) \/\/ while my neighbor is not the tail<br>  pre = pre-&gt;next, tmp = tmp-&gt;next;<br>pre-&gt;next = null;<br>delete tmp; \/\/ tmp = (old) tail<br>tail = pre; \/\/ update tail pointer<\/pre><p>Try <span class=\"slide-actions\" onclick=\"doButtonAction106()\">RemoveTail()<\/span> repeatedly on the (shorter) example Linked List&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6 (tail)]. It will continuously working correctly up until the Linked List contains one item where the head = the tail item and we switch to <a href=\"?slide=3-15\"><u>removal at head<\/u><\/a> case. We prevent execution if the LL is already empty as it is an illegal case.<\/p>","title":"Remove(i) - At Tail (i = N-1) - Part 1"},{"id":608,"category":"list","order":19,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-12 15:07:33","updated_at":"2023-04-24 08:06:38","section":590,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6\");\nnonRandom();","section_order":3,"value":"3-19","text":"<p>Actually, if we also maintain the size of the Linked List <b>N<\/b> (compare with <a href=\"?slide=3-3\"><u>this slide<\/u><\/a>), we can use the Linked List traversal sub-routine <samp>Get(i)<\/samp> to implement the removal of the tail of the Linked List this way (in C++):<\/p><pre>Vertex* pre = Get(N-2); \/\/ go to one index just before tail, O(N)<br>pre-&gt;next = null;<br>delete tail;<br>tail = pre; \/\/ we have access to old tail<\/pre><p>Notice that this operation is slow, O(<b>N<\/b>), just because of the need to update the tail pointer from item <b>N<\/b>-1 backwards by one unit to item <b>N<\/b>-2 so that future insertion after tail remains correct... This deficiency will be <a href=\"?slide=6-1\"><u>later addressed<\/u><\/a> in Doubly Linked List variant.<\/p><br><p>Discussion: What happen if we use <a href=\"?slide=2-5\"><u>array<\/u><\/a> implementation for removal of tail of the list?<\/p>","title":"Remove(i) - At Tail (i = N-1) - Part 2"},{"id":609,"category":"list","order":20,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-06-12 15:59:31","updated_at":"2023-04-24 08:06:41","section":590,"code":"$(\"#title-LL\").click();","section_order":3,"value":"3-20","text":"<p>Until we use Doubly Linked List later, removal of the tail item of a (Singly) Linked List is inefficient, O(<b>N<\/b>).<\/p><br><p>However, even a simple <a href=\"?slide=2-5\"><u>compact array<\/u><\/a> can be used to do removal of the tail item in O(<b>1<\/b>).<\/p>","title":"The Answer"},{"id":598,"category":"list","order":21,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-06 06:32:16","updated_at":"2023-04-24 08:06:44","section":590,"code":"$(\"#title-LL\").click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":3,"value":"3-21","text":"<p><samp>get(i)<\/samp> is slow: O(<b>N<\/b>).<br>In Linked List, we need to perform sequential access from head element.<\/p><br><p><samp>search(v)<\/samp><br>In the best case, <b>v<\/b> is found at the first position, O(<b>1<\/b>).<br>In the worst case, <b>v<\/b> is not found in the list and we require O(<b>N<\/b>) scan to determine that.<\/p><br><p><samp>insert(i, v)<\/samp><br>In the best case, insert at <b>i = 0<\/b> or at <b>i = N<\/b>, head and tail pointers help, O(<b>1<\/b>).<br>In the worst case, insert at <b>i = N-1<\/b>, we need to find the item <b>N<\/b>-2<\/b> just before the tail, O(<b>N<\/b>).<\/p><br><p><samp>remove(i)<\/samp><br>In the best case, remove at <b>i = 0<\/b>, head pointer helps, O(<b>1<\/b>).<br>In the worst case, remove at <b>i = N-1<\/b>, due to the need to update the tail pointer, O(<b>N<\/b>).<\/p>","title":"Time Complexity Summary"},{"id":617,"category":"list","order":22,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-13 06:09:52","updated_at":"2023-04-24 08:06:46","section":590,"code":"$(\"#title-LL\").click();","section_order":3,"value":"3-22","text":"<p>Pure (Singly) Linked List applications are surprisingly rare as the simpler resizeable compact array (vector) can do the job better, compare the <a href=\"?slide=3-21\"><u>Linked List version<\/u><\/a> with the <a href=\"?slide=2-5\"><u>compact array version<\/u><\/a>.<\/p><br><p>However, the basic concept of Linked List that allows the vertices to be non-contiguous in memory makes it an excellent resize-able data structure for the next two other Abstract Data Types: <a href=\"?slide=4\"><u>Stack<\/u><\/a> and <a href=\"?slide=5\"><u>Queue<\/u><\/a>.<\/p>","title":"Linked List Applications"},{"id":84,"category":"list","order":4,"top":"150px","right":"60px","bottom":"","left":"","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-02-19 10:46:47","updated_at":"2023-04-24 08:15:32","section":-1,"code":"$('#title-Stack').click();\n$(\"#v-create-arr\").val(\"2,7,5,3,1,9\");\nnonRandom();","section_order":-1,"value":"4","text":"<p>Stack is a particular kind of Abstract Data Type in which the main operations on the collection are the addition of an item to the collection, known as push, only to the top of the stack and removal of an item, known as pop, only from the top of the stack.<\/p><br><p>It is known as Last-In-First-Out (LIFO) data structure, e.g., the stack of book below.<\/p><br><img src=\"https:\/\/visualgo.net\/img\/stack_illustration.png\" width=\"100%\" alt=\"Stack Illustration\">","title":"Stack"},{"id":610,"category":"list","order":1,"top":"150px","right":"60px","bottom":"","left":"","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-12 16:23:50","updated_at":"2023-04-24 08:16:59","section":84,"code":"$('#title-Stack').click();\n$(\"#v-create-arr\").val(\"2,7,5,3,1,9\");\nnonRandom();","section_order":4,"value":"4-1","text":"<p>In most implementations and also in this visualization, Stack is basically a <b>protected<\/b> (Singly) Linked List where we can only peek at the head item, push a new item only to the head (<a href=\"?slide=3-9\"><u>insert at head<\/u><\/a>), e.g., try <span class=\"slide-actions\" onclick=\"doButtonAction99()\">InsertHead(6)<\/span>, and pop existing item only from the head (<a href=\"?slide=3-14\"><u>remove from head<\/u><\/a>), e.g., try <span class=\"slide-actions\" onclick=\"doButtonAction105()\">RemoveHead()<\/span>. All operations are O(1).<\/p><br><p>In this visualization, we orientate the (Single) Linked List top down, with the head\/tail item at the top\/bottom, respectively. In the example, we have [2 (top\/head)-&gt;7-&gt;5-&gt;3-&gt;1-&gt;9 (bottom\/tail)]. Due to vertical screen size limit (in landscape mode), we only allow a Stack of at most 7 items in this visualization.<\/p><br><p>Discussion: Can we use vector, a resizeable array, to implement Stack ADT efficiently?<\/p>","title":"The Design Choice"},{"id":623,"category":"list","order":2,"top":"150px","right":"60px","bottom":"","left":"","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-06-13 07:08:53","updated_at":"2023-04-24 08:15:21","section":84,"code":"$('#title-Stack').click();","section_order":4,"value":"4-2","text":"<p>Yes, but this time we need to use the back side of the vector as the top of the stack as insertion and removal from an <a href=\"?slide=2-5\"><u>array<\/u><\/a> (this time, resizeable vector) is O(<b>1<\/b>).<\/p>","title":"The Answer"},{"id":611,"category":"list","order":3,"top":"150px","right":"60px","bottom":"","left":"","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-12 16:29:48","updated_at":"2023-04-24 08:15:17","section":84,"code":"$('#title-Stack').click();","section_order":4,"value":"4-3","text":"<p>Stack has a few popular textbook applications. Some examples:<\/p><ol><li>Bracket Matching,<\/li><li>Postfix Calculator,<\/li><li>A few other interesting applications that are not shown for pedagogical purposes.<\/li><\/ol>","title":"Stack Applications"},{"id":619,"category":"list","order":4,"top":"150px","right":"60px","bottom":"","left":"","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-13 06:44:08","updated_at":"2023-04-24 08:15:12","section":84,"code":"$('#title-Stack').click();","section_order":4,"value":"4-4","text":"<p>Mathematical expression can get quite convoluted, e.g., <samp>{[x+2]^(2+5)-2}*(y+5)<\/samp>.<\/p><br><p>Bracket Matching problem is a problem of checking whether all brackets in the given input are matched correctly, i.e., ( with ), [ with ] and { with }, and so on.<\/p><br><p>Bracket Matching is equally useful for checking the legality of a source code.<\/p><br><p>Discussion: It turns out that we can use Stack&#39;s LIFO behavior to solve this problem.<br>The question is how?<\/p>","title":"Bracket Matching Problem"},{"id":620,"category":"list","order":5,"top":"150px","right":"60px","bottom":"","left":"","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-06-13 06:46:47","updated_at":"2023-04-24 08:15:05","section":84,"code":"$('#title-Stack').click();","section_order":4,"value":"4-5","text":"<p>We go through the input string character-by-character in O(<b>N<\/b>), ignoring all non-brackets.<\/p><br><p>If we encounter any open bracket character, e.g., {, [, or (, we push it into a stack.<\/p><br><p>If we encounter any close bracket character, e.g., }, ], or ), we compare the current topmost item of the stack with this close bracket character. We report &#39;mismatch&#39; if the stack is empty (there is no open bracket to match this close bracket with). We also report &#39;mismatch&#39; if the compared characters mismatch (the last encountered open bracket does not match this current close bracket) \u2014 the LIFO behavior. Otherwise, we pop the topmost open bracket character from the stack and continue.<\/p><br><p>Finally, the stack must returns back to empty state after we read through the whole string, otherwise there is\/are unmatched open bracket(s) left which implies that the input string is wrong.<\/p>","title":"O(N) Solution with Stack"},{"id":621,"category":"list","order":6,"top":"150px","right":"60px","bottom":"","left":"","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-13 06:57:38","updated_at":"2023-04-24 08:15:01","section":84,"code":"$('#title-Stack').click();","section_order":4,"value":"4-6","text":"<p>Postfix expression is a mathematical expression in: <samp>operand1 operand2 operator<\/samp> format which is different from what human is most comfortable at, the Infix expression: <samp>operand1 operator operand2<\/samp>.<\/p><br><p>For example, expression <samp>2 3 + 4 *<\/samp> is the Postfix version of <samp>(2+3)*4<\/samp>.<\/p><br><p>In Postfix expression, we do not need brackets.<\/p><br><p>Discussion: It turns out that we can also use Stack to solve this problem efficiently.<br>The question is how?<\/p>","title":"Calculating Postfix Expression"},{"id":622,"category":"list","order":7,"top":"150px","right":"60px","bottom":"","left":"","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-06-13 07:02:15","updated_at":"2023-04-24 08:14:47","section":84,"code":"$('#title-Stack').click();","section_order":4,"value":"4-7","text":"<p>First, we create an empty stack and then we evaluate each item in the postfix expression once by one, hence O(<b>N<\/b>):<\/p><ol><li>If the item is an operand, we push it on the stack,<\/li><li>If it is an operator, we pop the last two operands from the top two elements of the stack, perform the requested operation, and push the result onto the stack again.<\/li><\/ol>","title":"O(N) Solution with Stack"},{"id":85,"category":"list","order":5,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-02-19 10:58:35","updated_at":"2023-04-24 08:17:28","section":-1,"code":"$('#title-Queue').click();","section_order":-1,"value":"5","text":"<p>Queue is another Abstract Data Type in which the items in the collection are kept <b>in order<\/b> and the main operations on the collection are the addition of items to the back position (enqueue) and removal of items from the front position (dequeue).<\/p><br><p>It is known as <b>First-In-First-Out (FIFO)<\/b> data structure as the first item to be enqueued will eventually be the first item to be dequeued, as in real life queues (see below).<\/p><br><img src=\"https:\/\/visualgo.net\/img\/queue_illustration.png\" width=\"100%\" alt=\"Queue Illustration\">","title":"Queue"},{"id":630,"category":"list","order":1,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-14 08:48:10","updated_at":"2023-04-24 08:17:31","section":85,"code":"$('#title-Queue').click();","section_order":5,"value":"5-1","text":"<p>If we simply use the <a href=\"?slide=2-3\"><u>compact array<\/u><\/a> implementation for this Queue ADT with <samp>a<sub>0<\/sub><\/samp> is the front of the queue and <samp>a<sub>N-1<\/sub><\/samp> is the back of the queue, we will encounter major performance issue with the <b>dequeue<\/b> operation.<\/p><br><p>This is because insertion at the back of a compact array is fast, O(<b>1<\/b>), but removal at the front of a compact array is slow due to the need to shift items, please review <a href=\"?slide=2-5\"><u>this slide<\/u><\/a>.<\/p>","title":"Array Implementation Issues - Part 1"},{"id":631,"category":"list","order":2,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-14 08:53:16","updated_at":"2023-09-07 10:54:29","section":85,"code":"$('#title-Queue').click();","section_order":5,"value":"5-2","text":"<p>Another possible array implementation is to avoid that shifting of items during dequeue operation by having <b>two<\/b> indices: <b>front<\/b> (the index of the queue front-most item, increased after a dequeue operation) and <b>back<\/b> (the index of the queue back-most item, also increased after an enqueue operation).<\/p><br><p>Suppose we use an array of size <b>M = 8<\/b> items and the content of our queue is as follows: <samp>[<span style=\"color: green\">(<u>2<\/u>,4,1,<i>7<\/i>)<\/span>,-,-,-,-]<\/samp> with <u><b>front = 0<\/b> (underlined)<\/u>  and <i><b>back = 3<\/b> (italic)<\/i>. The current active queue elements are highlighted with <span style=\"color: green\">(green color)<\/span>.<\/p><br><p>If we call dequeue(), we have <samp>[-,<span style=\"color: green\">(<u>4<\/u>,1,<i>7<\/i>)<\/span>,-,-,-,-]<\/samp>, <u><b>front = 0+1 = 1<\/b><\/u>, and <i><b>back = 3<\/b><\/i>.<\/p><br><p>If we call enqueue(5), we have <samp>[-,<span style=\"color: green\">(<u>4<\/u>,1,7,<i>5<\/i>)<\/span>,-,-,-]<\/samp>, <u><b>front = 1<\/b><\/u>, and <i><b>back = 3+1 = 4<\/b><\/i>.<\/p>","title":"Array Implementation Issues - Part 2"},{"id":632,"category":"list","order":3,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-14 09:01:24","updated_at":"2023-09-07 10:55:03","section":85,"code":"$('#title-Queue').click();","section_order":5,"value":"5-3","text":"<p>However, many dequeue and enqueue operations later, we may have <samp>[-,-,-,-,-,<span style=\"color: green\"><u>6<\/u>,2,<i>3<\/i><\/span>]<\/samp>, <u><b>front = 5<\/b><\/u>, and <i><b>back = 7<\/b><\/i>. By now, we cannot enqueue anything else albeit we have many empty spaces at the front of the array.<\/p><br><p>If we allow both <b>front<\/b> and <b>back<\/b> indices to \"wrap back\" to index 0 when they have reached index <b>M<\/b>-1, we effectively make the array \"circular\" and we can use the empty spaces.<\/p><br><p>For example, if we call enqueue(8) next, we have <samp>[<span style=\"color: green\"><i>8<\/i>)<\/span>,-,-,-,-,<span style=\"color: green\">(<u>6<\/u>,2,3<\/span>]<\/samp>, <u><b>front = 5<\/b><\/u>, and <i><b>back = (7+1)%8 = 0<\/b><\/i>.<\/p>","title":"Array Implementation Issues - Part 3"},{"id":633,"category":"list","order":4,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-14 09:15:40","updated_at":"2023-09-07 11:01:23","section":85,"code":"$('#title-Queue').click();","section_order":5,"value":"5-4","text":"<p>Yet, this does not solve the main problem of fixed-size array implementation. A few more enqueue operations later, we may have <samp>[<span style=\"color: green\">8,10,11,12,<i>13<\/i>),(<u>6<\/u>,2,3<\/span>]<\/samp>, <u><b>front = 5<\/b><\/u>, and <i><b>back = 4<\/b><\/i>. At this point (<b>front = (back+1) % M)<\/b>), we cannot enqueue anything else.<\/p><br><p>Do note that if we know that our queue size will never exceed the fixed array size <b>M<\/b>, then the circular array idea is actually already a good way to implement Queue ADT.<\/p><br><p>However, if we do not know the upper bound of queue size, we can enlarge (double) the size of the array, e.g., make <b>M = 2*8 = 16<\/b> (two-times larger), but that will entail re-copying the items from index <u><b>front<\/b><\/u> to <i><b>back<\/b><\/i> in a <b>slow<\/b> (but rare) O(<b>N<\/b>) process to have <samp>[<span style=\"color: green\">(<u>6<\/u>,2,3,8,10,11,12,<i>13<\/i>)<\/span>,-,-,-,-,-,-,-,-,]<\/samp>, <u><b>front = 0<\/b><\/u>, and <i><b>back = 7<\/b><\/i>.<\/p><br><p>PS1: If you understand amortized analysis, this heavy O(<b>N<\/b>) cost when the circular array is full can actually be spread out so that each enqueue remains O(<b>1<\/b>) in amortized sense.<\/p><br><p>PS2: There is an alternative way to implement an efficient Queue using two Stacks. How?<\/p>","title":"Array Implementation Issues - Part 4"},{"id":863,"category":"list","order":5,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2023-09-07 11:01:28","updated_at":"2023-09-07 11:05:17","section":85,"code":"$('#title-Queue').click();","section_order":5,"value":"5-5","text":"<p>We can use two stacks, in-stack and out-stack.<\/p><br><p>For <b>enqueue(v)<\/b>, push <b>v<\/b> into in-stack.<\/p><br><p>For <b>dequeue()<\/b>, we do a preliminary check first: If the out-stack is empty, refill the out-stack by popping each element from the in-stack and pushing it to the out-stack. This can be a heavy (but rare) <b>O(N)<\/b> operation. Then, we pop and return the top element from out-stack.<\/p><br><p>Using this idea, each element will be in each stack exactly once. In other words, each element will be pushed twice and popped twice, giving amortized constant time operations.<\/p>","title":"Efficient Queue with Two Stacks"},{"id":612,"category":"list","order":6,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-12 16:47:26","updated_at":"2023-09-07 11:06:56","section":85,"code":"$('#title-Queue').click();","section_order":5,"value":"5-6","text":"<p>If we do not really know the the upper bound of queue size, then Singly Linked List (SLL) can be a good data structure to implement Queue ADT.<\/p><br><p>Recall that in a Queue, we only need the two extreme ends of the List, one for insertion (enqueue) only and one for removal (dequeue) only.<\/p><br><p>If we review <a href=\"?slide=3-21\"><u>this slide<\/u><\/a>, we see that insertion <b>after tail<\/b> and removal <b>from head<\/b> in a Singly Linked List are fast, i.e., O(<b>1<\/b>). Thus, we designate the head\/tail of the Singly Linked List as the front\/back of the queue, respectively. Then, as the items in a Linked List are <b>not<\/b> stored contiguously in computer memory, our Linked List can grow and shrink as needed.<\/p><br><p>In our visualization, Queue is basically a <b>protected<\/b> Singly Linked List where we can only peek at the head item, enqueue a new item to one position after the current tail, e.g., try <span class=\"slide-actions\" onclick=\"doButtonAction108()\">Enqueue(random-integer)<\/span>, and dequeue existing item from the head, e.g., try <span class=\"slide-actions\" onclick=\"doButtonAction105()\">RemoveHead()<\/span> (which is essentially a dequeue operation). All operations are O(<b>1<\/b>).<\/p>","title":"Linked List to the Rescue"},{"id":613,"category":"list","order":7,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-12 16:47:51","updated_at":"2023-09-07 11:01:33","section":85,"code":"$('#title-Queue').click();","section_order":5,"value":"5-7","text":"<p>Queue ADT is usually used to simulate real queues.<\/p><br><p>One super important application of Queue ADT is inside the <a href=\".\/sssp\"><u>Breadth-First Search<\/u><\/a> graph traversal algorithm.<\/p>","title":"Queue Application"},{"id":86,"category":"list","order":6,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-02-19 10:59:48","updated_at":"2023-04-24 08:18:21","section":-1,"code":"$('#title-DLL').click();","section_order":-1,"value":"6","text":"<p>Doubly Linked List (DLL) is 99% the same as its Singly Linked List version. The main difference is that now each vertex contains <b>two<\/b> pointers. The <b>next<\/b> pointer is the same as in Singly Linked List version in which it links item <b>a<sub>i<\/sub><\/b> with the next item <b>a<sub>i+1<\/sub><\/b>, if exists. The additional <b>prev<\/b> pointer also links item <b>a<sub>i<\/sub><\/b> with the previous item <b>a<sub>i-1<\/sub><\/b>, if exists.<\/p><br><p>The usage of <b>prev<\/b> pointers makes it possible to move\/iterate <b>backwards<\/b> at the expense of two-times memory usage requirement as now each vertex records one additional pointer. The positive side effect of this ability to move backwards is now we can address the weak <a href=\"?slide=3-18\"><u>removal at tail case<\/u><\/a> of the Singly Linked List.<\/p><br><p>In this visualization, notice that the edges in Doubly Linked List (and later Deque) are undirected (bidirectional) edges.<\/p>","title":"Doubly Linked List (DLL)"},{"id":634,"category":"list","order":1,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-14 10:03:37","updated_at":"2023-04-24 08:18:24","section":86,"code":"$('#title-DLL').click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":6,"value":"6-1","text":"<p>The main problem of removal of the tail element in the Singly Linked List, even if we have direct access to the tail item via the tail pointer, is that we then have to update the tail pointer to point to one item just before the tail after such removal.<\/p><br><p>With Doubly Linked List ability to move <b>backwards<\/b>, we can find this item before the tail via <samp>tail-&gt;prev<\/samp>... Thus, we can implement removal of tail this way (in C++):<\/p><pre>Vertex* tmp = tail; \/\/ remember tail item<br>tail = tail-&gt;prev; \/\/ the key step to achieve O(1) performance :O<br>tail-&gt;next = null; \/\/ remove this dangling reference<br>delete tmp; \/\/ remove the old tail<\/pre><p>Now this operation is O(<b>1<\/b>). Try <span class=\"slide-actions\" onclick=\"doButtonAction106()\">RemoveTail()<\/span> on example DLL [22 (head)&lt;-&gt;2&lt;-&gt;77&lt;-&gt;6&lt;-&gt;43&lt;-&gt;76&lt;-&gt;89 (tail)].<\/p>","title":"Remove(i) - At Tail (i = N-1), Revisited"},{"id":637,"category":"list","order":2,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-15 04:11:45","updated_at":"2023-04-24 08:18:27","section":86,"code":"$('#title-DLL').click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":6,"value":"6-2","text":"<p>As we have one more pointer <b>prev<\/b> for each vertex, their values need to be updated too during each insertion or removal. Try all these operations on example DLL [22 (head)&lt;-&gt;2&lt;-&gt;77&lt;-&gt;6&lt;-&gt;43&lt;-&gt;76&lt;-&gt;89 (tail)].<\/p><br><p>Try <span class=\"slide-actions\" onclick=\"doButtonAction100()\">InsertHead(50)<\/span> \u2014 additional step: 22&#39;s <b>prev<\/b> pointer points to new head 50.<\/p><br><p>Try <span class=\"slide-actions\" onclick=\"doButtonAction101()\">InsertTail(10)<\/span> \u2014 additional step: 10&#39;s <b>prev<\/b> pointer points to old tail 89.<\/p><br><p>Try <span class=\"slide-actions\" onclick=\"doButtonAction102()\">Insert(3, 44)<\/span> \u2014 additional step: 6&#39;s\/44&#39;s <b>prev<\/b> pointers point to 44\/77, respectively.<\/p><br><p>Try <span class=\"slide-actions\" onclick=\"doButtonAction105()\">RemoveHead()<\/span> \u2014 set new head 2&#39;s <b>prev<\/b> pointer to null.<\/p><br><p>Try <span class=\"slide-actions\" onclick=\"doButtonAction107()\">Remove(5)<\/span> \u2014 set 89&#39;s <b>prev<\/b> pointer to 43.<\/p>","title":"Constant Factor Extra Step(s) Elsewhere"},{"id":87,"category":"list","order":7,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-02-19 11:01:11","updated_at":"2023-04-24 08:18:30","section":-1,"code":"$('#title-Deque').click();\n$(\"#v-create-arr\").val(\"22,2,77,6,43,76,89\");\nnonRandom();","section_order":-1,"value":"7","text":"<p>Double-ended queue (often abbreviated to deque, pronounced deck) is an Abstract Data Type that generalizes a Queue, for which elements can be added to or removed only from <b>either<\/b> the front (head) or back (tail).<\/p><br><p>In our visualization, Deque is basically a protected Doubly Linked List where we can only:<br>search the head\/tail item (peek front\/back),<br>insert a new item to the head\/tail (try <span class=\"slide-actions\" onclick=\"doButtonAction100()\">InsertHead(50)<\/span> or <span class=\"slide-actions\" onclick=\"doButtonAction101()\">InsertTail(10)<\/span>), and <br>remove an existing item from the head\/tail (try <span class=\"slide-actions\" onclick=\"doButtonAction105()\">RemoveHead()<\/span> or <span class=\"slide-actions\" onclick=\"doButtonAction106()\">RemoveTail()<\/span>).<\/p><br><p>All operations are O(<b>1<\/b>).<\/p>","title":"Double-Ended Queue (Deque)"},{"id":614,"category":"list","order":1,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-12 16:50:43","updated_at":"2023-04-24 08:18:34","section":87,"code":"$('#title-Deque').click();","section_order":7,"value":"7-1","text":"<p>Deque are used a few advanced applications, like finding the shortest paths 0\/1-weighted graph using modified BFS, on some sliding window techniques, etc.<\/p>","title":"Deque Applications"},{"id":89,"category":"list","order":8,"top":"","right":"","bottom":"200px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-02-19 11:03:46","updated_at":"2023-09-08 09:52:42","section":-1,"code":"","section_order":-1,"value":"8","text":"<p>Create operation is the same for all five modes.<\/p><br><p>However there are minor differences for the search\/insert\/remove operations among the five modes.<\/p><br><p>For Stack, you can only peek\/restricted-search, push\/restricted-insert, and pop\/restricted-remove from the top\/head.<\/p><br><p>For Queue, you can only peek\/restricted-search from the front (or sometimes, the back), push\/restricted-insert from the back, and pop\/restricted-remove from the front.<\/p><br><p>For Deque, you can peek\/restricted-search, enqueue\/restricted-insert, dequeue\/restricted-remove from both front\/back, but not from the middle.<\/p><br><p>Single (Singly) and Doubly Linked List do not have such restrictions.<\/p>","title":"Summary"},{"id":615,"category":"list","order":9,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-13 03:35:14","updated_at":"2023-04-24 08:10:21","section":-1,"code":"","section_order":-1,"value":"9","text":"<p>We have reached the end of this e-Lecture.<\/p><br><p>But read ahead for a few extra challenges.<\/p>","title":"Extras"},{"id":629,"category":"list","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-14 08:31:33","updated_at":"2023-04-24 08:21:32","section":615,"code":"","section_order":9,"value":"9-1","text":"<p>The following are the more advanced insights about Linked List:<\/p><ol><li>What happen if we don&#39;t store the tail pointer too?<\/li><li>What if we use dummy head?<\/li><li>What if the last tail item points back to the head item?<\/li><li>What need to be changed to allow duplicate items (a more general List ADT)?<\/li><\/ol>","title":"Potential Discussion Topics"},{"id":641,"category":"list","order":2,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-09-11 08:19:37","updated_at":"2023-04-24 08:11:38","section":615,"code":"","section_order":9,"value":"9-2","text":"<ol><li>Worse performance for InsertAfterTail (and RemoveAtTail for Doubly Linked List) if we do not sacrifice just ~4 bytes of one more additional tail pointer.<\/li><li>It will simplify the code a bit but this part is not compulsory.<\/li><li>We can then save just ~4 bytes of not recording the head pointer and just remember tail pointer as head is just tail.next in a circular Linked List. We reckon that this is not compulsory too.<\/li><li>We may want to upgrade the implementation of this Linked List visualization to allow duplicates too. A few things need to be changed, e.g., <samp>search(v)<\/samp> may now return more than one index if <samp>v<\/samp> appears more than once in the list.<\/li><\/ol>","title":"Our Current Answers"},{"id":616,"category":"list","order":3,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-13 03:35:25","updated_at":"2023-04-24 08:11:44","section":615,"code":"","section_order":9,"value":"9-3","text":"<p>C++ STL:<br><a href=\"http:\/\/en.cppreference.com\/w\/cpp\/container\/forward_list\" target=\"_blank\"><u>forward_list<\/u><\/a> (a Singly Linked List)<br><a href=\"http:\/\/en.cppreference.com\/w\/cpp\/container\/stack\" target=\"_blank\"><u>stack<\/u><\/a><br><a href=\"http:\/\/en.cppreference.com\/w\/cpp\/container\/queue\" target=\"_blank\"><u>queue<\/u><\/a><br><a href=\"http:\/\/en.cppreference.com\/w\/cpp\/container\/list\" target=\"_blank\"><u>list<\/u><\/a> (a Doubly Linked List)<br><a href=\"http:\/\/en.cppreference.com\/w\/cpp\/container\/deque\" target=\"_blank\"><u>deque<\/u><\/a> (actually not using Doubly Linked List but another technique, see cppreference)<\/p><br><p>Java API:<br><a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/util\/LinkedList.html\" target=\"_blank\"><u>LinkedList<\/u><\/a> (already a Doubly Linked List)<br><a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/util\/Stack.html\" target=\"_blank\"><u>Stack<\/u><\/a><br><a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/util\/Queue.html\" target=\"_blank\"><u>Queue<\/u><\/a> (actually an interface, usually implemented using LinkedList class)<br><a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/util\/Deque.html\" target=\"_blank\"><u>Deque<\/u><\/a> (actually an interface, usually implemented using LinkedList class)<\/p>","title":"C++ STL and Java API Implementations"},{"id":727,"category":"list","order":4,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2020-07-17 11:49:11","updated_at":"2023-04-24 08:11:48","section":615,"code":"","section_order":9,"value":"9-4","text":"<p>Python:<br><a href=\"https:\/\/docs.python.org\/3\/tutorial\/datastructures.html\" target=\"_blank\"><u>list<\/u><\/a> for List\/Stack\/Queue<br><a href=\"https:\/\/docs.python.org\/3\/library\/collections.html#collections.deque\" target=\"_blank\"><u>deque<\/u><\/a><\/p><br><p>OCaml:<br><a href=\"https:\/\/caml.inria.fr\/pub\/docs\/manual-ocaml\/libref\/List.html\" target=\"_blank\"><u>List<\/u><\/a><br><a href=\"https:\/\/caml.inria.fr\/pub\/docs\/manual-ocaml\/libref\/Stack.html\" target=\"_blank\"><u>Stack<\/u><\/a><br><a href=\"https:\/\/caml.inria.fr\/pub\/docs\/manual-ocaml\/libref\/Queue.html\" target=\"_blank\"><u>Queue<\/u><\/a><br>No built-in support for Deque<\/p>","title":"Python and OCaml Standard Library"},{"id":636,"category":"list","order":5,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-14 10:12:38","updated_at":"2023-04-24 08:11:50","section":615,"code":"","section_order":9,"value":"9-5","text":"<p>For a few more interesting questions about this data structure, please practice on <a href=\"https:\/\/visualgo.net\/training?diff=Medium&amp;n=7&amp;tl=0&amp;module=list\"><u>Linked List<\/u><\/a> training module.<\/p>","title":"Online Quiz"},{"id":635,"category":"list","order":6,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-06-14 10:12:25","updated_at":"2023-04-24 08:11:54","section":615,"code":"","section_order":9,"value":"9-6","text":"<p>We also have a few programming problems that somewhat requires the usage of this Linked List, Stack, Queue, or Deque data structure:<br><a href=\"https:\/\/uva.onlinejudge.org\/external\/119\/11988.pdf\" title=\"\" target=\"_blank\"><u>UVa 11988 - Broken Keyboard (a.k.a. Beiju Text)<\/u><\/a>,<br><a href=\"https:\/\/open.kattis.com\/problems\/backspace\" title=\"\" target=\"_blank\"><u>Kattis - backspace<\/u><\/a>, and<br><a href=\"https:\/\/open.kattis.com\/problems\/integerlists\" title=\"\" target=\"_blank\"><u>Kattis - integerlists<\/u><\/a>.<\/p><br><p>Try them to consolidate and improve your understanding about this data structure. You are allowed to use C++ STL, Python standard library, or Java API if that simplifies your implementation.<\/p>","title":"Online Judge Exercises"}];
      const numSlides = lectureIds.length;
      var sectorJunction12Section = 0, sectorJunction12Slide = 0;
      var sectorJunction23Section = 0, sectorJunction23Slide = 0;
      var sector1Count = 0, sector2Count = 0, sector3Count = 0;
      const sectorLength = Math.floor(numSlides / 3);
      function createELectureTimelineDisplay() {
        for (let j = 0; j < numSlides; ++j) {
          const currLecture = lectureIds[j].value;
          if (currLecture.includes('-')) {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-slide" slideNo=${lectureIds[j].value}></div>`)
            );
          } else {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-checkpoint" slideNo=${lectureIds[j].value}></div>`)
            );
          }
        }
      }

      function setSectorJunctionInfo() {
          //setting the sector junction slide numbers
          const j12 = sectorLength !== 0 ? (sectorLength - 1): 0;
          const j23 = sectorLength !== 0 ? (2 * sectorLength - 1) : 0;

          const sectorJunction12 = lectureIds[j12].value.split('-');
          sectorJunction12Section = parseInt(sectorJunction12[0]);
          sectorJunction12Slide = sectorJunction12.length > 1 ? parseInt(sectorJunction12[1]) : sectorJunction12Slide;

          const sectorJunction23 = lectureIds[j23].value.split('-');
          sectorJunction23Section = parseInt(sectorJunction23[0]);
          sectorJunction23Slide = sectorJunction23.length > 1 ? parseInt(sectorJunction23[1]) : sectorJunction23Slide;
      }

      function runSlide(slide) { // Steven's patch on 28 Jan 2022: Properly remove slide 99, 99-1, 99-2, 99-3, integrate with the earlier slides
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 1 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '1-1') {
          $("#e-lecture").html("slide " + slide + " (" + 3 + "%)");
          
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 4 + "%)");
          
        }
        if (slide == '2-1') {
          $("#e-lecture").html("slide " + slide + " (" + 6 + "%)");
          
        }
        if (slide == '2-2') {
          $("#e-lecture").html("slide " + slide + " (" + 7 + "%)");
          
        }
        if (slide == '2-3') {
          $("#e-lecture").html("slide " + slide + " (" + 9 + "%)");
          
        }
        if (slide == '2-4') {
          $("#e-lecture").html("slide " + slide + " (" + 11 + "%)");
          
        }
        if (slide == '2-5') {
          $("#e-lecture").html("slide " + slide + " (" + 12 + "%)");
          
        }
        if (slide == '2-6') {
          $("#e-lecture").html("slide " + slide + " (" + 14 + "%)");
          
        }
        if (slide == '2-7') {
          $("#e-lecture").html("slide " + slide + " (" + 15 + "%)");
          
        }
        if (slide == '2-8') {
          $("#e-lecture").html("slide " + slide + " (" + 17 + "%)");
          
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 19 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '3-1') {
          $("#e-lecture").html("slide " + slide + " (" + 20 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '3-2') {
          $("#e-lecture").html("slide " + slide + " (" + 22 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '3-3') {
          $("#e-lecture").html("slide " + slide + " (" + 23 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '3-4') {
          $("#e-lecture").html("slide " + slide + " (" + 25 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '3-5') {
          $("#e-lecture").html("slide " + slide + " (" + 26 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '3-6') {
          $("#e-lecture").html("slide " + slide + " (" + 28 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '3-7') {
          $("#e-lecture").html("slide " + slide + " (" + 30 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '3-8') {
          $("#e-lecture").html("slide " + slide + " (" + 31 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '3-9') {
          $("#e-lecture").html("slide " + slide + " (" + 33 + "%)");
          $("#title-LL").click();
        }
        if (slide == '3-10') {
          $("#e-lecture").html("slide " + slide + " (" + 34 + "%)");
          $("#title-LL").click();
empty();
        }
        if (slide == '3-11') {
          $("#e-lecture").html("slide " + slide + " (" + 36 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '3-12') {
          $("#e-lecture").html("slide " + slide + " (" + 38 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '3-13') {
          $("#e-lecture").html("slide " + slide + " (" + 39 + "%)");
          $("#title-LL").click();
        }
        if (slide == '3-14') {
          $("#e-lecture").html("slide " + slide + " (" + 41 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '3-15') {
          $("#e-lecture").html("slide " + slide + " (" + 42 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6");
nonRandom();
        }
        if (slide == '3-16') {
          $("#e-lecture").html("slide " + slide + " (" + 44 + "%)");
          $("#title-LL").click();
        }
        if (slide == '3-17') {
          $("#e-lecture").html("slide " + slide + " (" + 46 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '3-18') {
          $("#e-lecture").html("slide " + slide + " (" + 47 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6");
nonRandom();
        }
        if (slide == '3-19') {
          $("#e-lecture").html("slide " + slide + " (" + 49 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6");
nonRandom();
        }
        if (slide == '3-20') {
          $("#e-lecture").html("slide " + slide + " (" + 50 + "%)");
          $("#title-LL").click();
        }
        if (slide == '3-21') {
          $("#e-lecture").html("slide " + slide + " (" + 52 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '3-22') {
          $("#e-lecture").html("slide " + slide + " (" + 53 + "%)");
          $("#title-LL").click();
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 55 + "%)");
          $('#title-Stack').click();
$("#v-create-arr").val("2,7,5,3,1,9");
nonRandom();
        }
        if (slide == '4-1') {
          $("#e-lecture").html("slide " + slide + " (" + 57 + "%)");
          $('#title-Stack').click();
$("#v-create-arr").val("2,7,5,3,1,9");
nonRandom();
        }
        if (slide == '4-2') {
          $("#e-lecture").html("slide " + slide + " (" + 58 + "%)");
          $('#title-Stack').click();
        }
        if (slide == '4-3') {
          $("#e-lecture").html("slide " + slide + " (" + 60 + "%)");
          $('#title-Stack').click();
        }
        if (slide == '4-4') {
          $("#e-lecture").html("slide " + slide + " (" + 61 + "%)");
          $('#title-Stack').click();
        }
        if (slide == '4-5') {
          $("#e-lecture").html("slide " + slide + " (" + 63 + "%)");
          $('#title-Stack').click();
        }
        if (slide == '4-6') {
          $("#e-lecture").html("slide " + slide + " (" + 65 + "%)");
          $('#title-Stack').click();
        }
        if (slide == '4-7') {
          $("#e-lecture").html("slide " + slide + " (" + 66 + "%)");
          $('#title-Stack').click();
        }
        if (slide == '5') {
          $("#e-lecture").html("slide " + slide + " (" + 68 + "%)");
          $('#title-Queue').click();
        }
        if (slide == '5-1') {
          $("#e-lecture").html("slide " + slide + " (" + 69 + "%)");
          $('#title-Queue').click();
        }
        if (slide == '5-2') {
          $("#e-lecture").html("slide " + slide + " (" + 71 + "%)");
          $('#title-Queue').click();
        }
        if (slide == '5-3') {
          $("#e-lecture").html("slide " + slide + " (" + 73 + "%)");
          $('#title-Queue').click();
        }
        if (slide == '5-4') {
          $("#e-lecture").html("slide " + slide + " (" + 74 + "%)");
          $('#title-Queue').click();
        }
        if (slide == '5-5') {
          $("#e-lecture").html("slide " + slide + " (" + 76 + "%)");
          $('#title-Queue').click();
        }
        if (slide == '5-6') {
          $("#e-lecture").html("slide " + slide + " (" + 77 + "%)");
          $('#title-Queue').click();
        }
        if (slide == '5-7') {
          $("#e-lecture").html("slide " + slide + " (" + 79 + "%)");
          $('#title-Queue').click();
        }
        if (slide == '6') {
          $("#e-lecture").html("slide " + slide + " (" + 80 + "%)");
          $('#title-DLL').click();
        }
        if (slide == '6-1') {
          $("#e-lecture").html("slide " + slide + " (" + 82 + "%)");
          $('#title-DLL').click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '6-2') {
          $("#e-lecture").html("slide " + slide + " (" + 84 + "%)");
          $('#title-DLL').click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '7') {
          $("#e-lecture").html("slide " + slide + " (" + 85 + "%)");
          $('#title-Deque').click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
        }
        if (slide == '7-1') {
          $("#e-lecture").html("slide " + slide + " (" + 87 + "%)");
          $('#title-Deque').click();
        }
        if (slide == '8') {
          $("#e-lecture").html("slide " + slide + " (" + 88 + "%)");
          
        }
        if (slide == '9') {
          $("#e-lecture").html("slide " + slide + " (" + 90 + "%)");
          
        }
        if (slide == '9-1') {
          $("#e-lecture").html("slide " + slide + " (" + 92 + "%)");
          
        }
        if (slide == '9-2') {
          $("#e-lecture").html("slide " + slide + " (" + 93 + "%)");
          
        }
        if (slide == '9-3') {
          $("#e-lecture").html("slide " + slide + " (" + 95 + "%)");
          
        }
        if (slide == '9-4') {
          $("#e-lecture").html("slide " + slide + " (" + 96 + "%)");
          
        }
        if (slide == '9-5') {
          $("#e-lecture").html("slide " + slide + " (" + 98 + "%)");
          
        }
        if (slide == '9-6') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
        }
        clearTimeout(currSlideTimer);
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };
      var slideTimeline = {};

      //reads all visited slides in the slideTimeline and gives them their sector color
      function setVisitedSlideTimelineColors() {
        for(const [sectionNo, visitedSlides] of Object.entries(slideTimeline)) {
          const visitedSlides = slideTimeline[sectionNo];
          for(const visitedSlideNo of visitedSlides) {
            setSlideTimelineColor(visitedSlideNo);
          }
        }
      }

      //only called on load if there is nothing in session
      function setTimelineForCompletedSector(sectorNum) {
        let len = sectorLength;
        switch (sectorNum) {
          case 1 : len = sectorLength; break;
          case 2 : len = 2 * sectorLength; break;
          default: len = numSlides;
        }
        let i = 0;
        switch (sectorNum) {
          case 1 : i = 0; break;
          case 2 : i = sectorLength; break;
          default: i = 2 * sectorLength;
        }
        for (; i < len; i++) {
          saveELectureTimeline(lectureIds[i].value, true);
        }
      }

      function getUserSectorHistory(callback) {
        $.ajax({
          type: 'GET',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            topic: "/list".substring(1)
          }
        }
        ).done(function (data) {
            if (data.data[0] === 1) {
              setF1SectorColor(1);
              setTimelineForCompletedSector(1);
            }
            if (data.data[1] === 1) {
              setF1SectorColor(2);
              setTimelineForCompletedSector(2);
            }
            if (data.data[2] === 1) {
              setF1SectorColor(3);
              setTimelineForCompletedSector(3);
            }
            callback();
        }).fail(function (data) {
            console.log('get user sector history failed!');
        });
      }

      function getELectureTimelineFromSession() {
        const page = "/list".substring(1);
        const timelineKey = page + '-slide-timeline';
        const storedTimeline = window.sessionStorage.getItem(timelineKey);
        if (storedTimeline) {
          slideTimeline = JSON.parse(storedTimeline);
        } else {
          return false;
        }
        let slideInfo = [];
        for (const [sectionNum, slides] of Object.entries(slideTimeline)) {
          for (const slide of slides) {
            indicateSlideCompletedUI(slide);
            slideInfo = slide.split('-');
            incrementSectorVisits(parseInt(sectionNum), slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0);
          }
        }
        return true;
      }

      async function initializeELectureTimeline() {
        setSectorJunctionInfo();
        if (!getELectureTimelineFromSession())
          getUserSectorHistory(sectorBasedModeSelection);
        else
          sectorBasedModeSelection();

        createELectureTimelineDisplay();
        setVisitedSlideTimelineColors();
      }

      function setF1SectorColor(sectorNum) {
        $(`[sectorNo="${sectorNum}"]`).css('background', sectorColors[(parseInt(sectorNum) % 3)]);
      }

      function updateSectorInDB(sectorNum) {
        $.ajax({
          type: 'POST',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            section: (sectorNum - 1),
            topic: "/list".substring(1)
          }
        }
        ).done(function (data) {
            //console.log("Saved the sector " + sectorNum + " as done " + JSON.stringify(data));
        }).fail(function (data) {
            console.log("Setting sector done failed new attempt! "+ JSON.stringify(data));
        });
      }

      //If 87.5% or more of the slides in sector are done
      function setF1SectorCompleted(sectorNum, isInitializationCall) {
        setF1SectorColor(sectorNum);
        //avoid api call on initialization
        if (!isInitializationCall) {
          updateSectorInDB(sectorNum);
          $(`[sectorNo="${sectorNum}"]`).css("animation", "green-pulse 2s 4");
          setTimeout(() => {
            $(`[sectorNo="${sectorNum}"]`).css("animation", "");
          }, 8000);
        }
      }

      function incrementSectorVisits(sectionNum, slideNumWithinSection, isInitializationCall) {
        //updating sector count
        if (sectionNum < sectorJunction12Section
          || (sectionNum === sectorJunction12Section && slideNumWithinSection <= sectorJunction12Slide)) {
          ++sector1Count;
          if (sector1Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(1, isInitializationCall);
        } else if (sectionNum < sectorJunction23Section
          || (sectionNum === sectorJunction23Section && slideNumWithinSection <= sectorJunction23Slide)) {
          ++sector2Count;
          if (sector2Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(2, isInitializationCall);
        } else {
          ++sector3Count;
          if (sector3Count >= Math.ceil(0.875 * (numSlides - 2 * sectorLength)))
            setF1SectorCompleted(3, isInitializationCall);
        }
      }

      function saveELectureTimeline(slideNo, isInitialization) {
        const slideInfo = slideNo.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        if (slideTimeline[sectionNo]) {
          if (!slideTimeline[sectionNo].includes(slideNo)) {
            slideTimeline[sectionNo].push(slideNo);
            const sectionNum = parseInt(sectionNo);
            incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
          }
        } else {
          slideTimeline[sectionNo] = [];
          slideTimeline[sectionNo].push(slideNo);
          const sectionNum = parseInt(sectionNo);
          incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
        }
        setSlideTimelineColor(slideNo);
        indicateSlideCompletedUI(slideNo);
      }

      function saveELectureTimelineToSession() {
        const page = "/list".substring(1);
        const timelineKey = page + '-slide-timeline';
        window.sessionStorage.setItem(timelineKey, JSON.stringify(slideTimeline));
      }

      function handleTimelineOnRunSlide(slideValue) {
        const slideInfo = slideValue.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        //start timer only if the slide isnt already done
        if (!slideTimeline[sectionNo] || !slideTimeline[sectionNo].includes(slideValue)) {
          const slideTextLength = $('#electure-'+slideValue + " p").text().length + $('#electure-'+slideValue + " li").text().length;
          const CHARS_READ_PER_MS = 0.05; //when fast, 50 characters a second
          //setting max reading time as 10 seconds for around 500 character slide
          const minSlideReadingTime = Math.min(Math.max(2000, (slideTextLength / CHARS_READ_PER_MS) +  + (2000 * $('#electure-'+slideValue + " img").length)), 10000);
          currSlideTimer = setTimeout(() => {
            saveELectureTimeline(slideValue);
          }, minSlideReadingTime);
        }
      }

      function indicateSlideCompletedUI(slide) {
        $('#electure-'+slide).css("box-shadow", "3px 3px 8px green"); //set green shadow for completed slides
        $('#electure-'+slide + ' .electure-read-status').html("&#10004;");
        $('#electure-'+slide + ' .electure-read-status').attr("title", "Slide Completed!");
        $('#electure-'+slide + ' .electure-read-status').css("font-size", "17px");
      }

      function pushState(slideValue) {
        var url = '/en/list';
        if (typeof slideValue != 'undefined' && slideValue != null) {
          url += '?slide=' + slideValue;
                  }
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5);
        $('#overlay').show();

        $("#e-lecture-timeline").show();
        $("#e-lecture-f1map").show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
        $("#e-lecture-timeline").hide();
        $("#e-lecture-f1map").hide();
        clearTimeout(currSlideTimer);
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      function sectorBasedModeSelection() {
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        //check params are empty and then that all sectors are completed or not
        if (!Object.keys(params).length
          && sector1Count === sectorLength && sector2Count === sectorLength && sector3Count === (numSlides - 2 * sectorLength)) {
            hideOverlay();
        }
        else
          $('#mode-menu a').click();
      }

      $(function() {
        if (isMobileOS() && portraitMatcher.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').show();
          $('#widenDeviceText').hide();
          $('#topbar').css("z-index", 10001);
        } else if (matchMediaNarrow.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').hide();
          $('#widenDeviceText').show();
          $('#topbar').css("z-index", 10001);
        } else {
          $('#rotateDeviceOverlay').hide();
          $('#topbar').css("z-index", "");
        }

        matchMediaNarrow.addEventListener('change', e => {
          //screws up for square device! NEED RESIZE EVENT
          if (e.matches) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').hide();
              $('#widenDeviceText').show();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        portraitMatcher.addEventListener('change', e => {
          if (e.matches && isMobileOS()) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').show();
              $('#widenDeviceText').hide();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        let slide = getUrlParameter('slide');
        if (typeof slide !== undefined && slide != null) {
          cur_slide = slide;
        }
        //do all timeline and slide stuff only if specific params not provided
        if (!Object.keys(params).length || params["slide"]) {
          if (!isMobile()) {
                            $('#mode-menu a').click();
                      }
        }
        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
        $('#electure-1-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-1-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
        $('#electure-2-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2-2');
          pushState('2-2');
        });
        $('#electure-2-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-2-2 .electure-next').click(function() {
          hidePopup();
          runSlide('2-3');
          pushState('2-3');
        });
        $('#electure-2-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
        $('#electure-2-3 .electure-next').click(function() {
          hidePopup();
          runSlide('2-4');
          pushState('2-4');
        });
        $('#electure-2-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-2');
          pushState('2-2');
        });
        $('#electure-2-4 .electure-next').click(function() {
          hidePopup();
          runSlide('2-5');
          pushState('2-5');
        });
        $('#electure-2-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-3');
          pushState('2-3');
        });
        $('#electure-2-5 .electure-next').click(function() {
          hidePopup();
          runSlide('2-6');
          pushState('2-6');
        });
        $('#electure-2-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-4');
          pushState('2-4');
        });
        $('#electure-2-6 .electure-next').click(function() {
          hidePopup();
          runSlide('2-7');
          pushState('2-7');
        });
        $('#electure-2-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-5');
          pushState('2-5');
        });
        $('#electure-2-7 .electure-next').click(function() {
          hidePopup();
          runSlide('2-8');
          pushState('2-8');
        });
        $('#electure-2-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-6');
          pushState('2-6');
        });
        $('#electure-2-8 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-7');
          pushState('2-7');
        });
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-8');
          pushState('2-8');
        });
        $('#electure-3-1 .electure-next').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
        $('#electure-3-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-3-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
        $('#electure-3-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
        $('#electure-3-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
        $('#electure-3-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
        $('#electure-3-4 .electure-next').click(function() {
          hidePopup();
          runSlide('3-5');
          pushState('3-5');
        });
        $('#electure-3-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
        $('#electure-3-5 .electure-next').click(function() {
          hidePopup();
          runSlide('3-6');
          pushState('3-6');
        });
        $('#electure-3-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
        $('#electure-3-6 .electure-next').click(function() {
          hidePopup();
          runSlide('3-7');
          pushState('3-7');
        });
        $('#electure-3-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-5');
          pushState('3-5');
        });
        $('#electure-3-7 .electure-next').click(function() {
          hidePopup();
          runSlide('3-8');
          pushState('3-8');
        });
        $('#electure-3-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-6');
          pushState('3-6');
        });
        $('#electure-3-8 .electure-next').click(function() {
          hidePopup();
          runSlide('3-9');
          pushState('3-9');
        });
        $('#electure-3-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-7');
          pushState('3-7');
        });
        $('#electure-3-9 .electure-next').click(function() {
          hidePopup();
          runSlide('3-10');
          pushState('3-10');
        });
        $('#electure-3-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-8');
          pushState('3-8');
        });
        $('#electure-3-10 .electure-next').click(function() {
          hidePopup();
          runSlide('3-11');
          pushState('3-11');
        });
        $('#electure-3-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-9');
          pushState('3-9');
        });
        $('#electure-3-11 .electure-next').click(function() {
          hidePopup();
          runSlide('3-12');
          pushState('3-12');
        });
        $('#electure-3-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-10');
          pushState('3-10');
        });
        $('#electure-3-12 .electure-next').click(function() {
          hidePopup();
          runSlide('3-13');
          pushState('3-13');
        });
        $('#electure-3-12 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-11');
          pushState('3-11');
        });
        $('#electure-3-13 .electure-next').click(function() {
          hidePopup();
          runSlide('3-14');
          pushState('3-14');
        });
        $('#electure-3-13 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-12');
          pushState('3-12');
        });
        $('#electure-3-14 .electure-next').click(function() {
          hidePopup();
          runSlide('3-15');
          pushState('3-15');
        });
        $('#electure-3-14 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-13');
          pushState('3-13');
        });
        $('#electure-3-15 .electure-next').click(function() {
          hidePopup();
          runSlide('3-16');
          pushState('3-16');
        });
        $('#electure-3-15 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-14');
          pushState('3-14');
        });
        $('#electure-3-16 .electure-next').click(function() {
          hidePopup();
          runSlide('3-17');
          pushState('3-17');
        });
        $('#electure-3-16 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-15');
          pushState('3-15');
        });
        $('#electure-3-17 .electure-next').click(function() {
          hidePopup();
          runSlide('3-18');
          pushState('3-18');
        });
        $('#electure-3-17 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-16');
          pushState('3-16');
        });
        $('#electure-3-18 .electure-next').click(function() {
          hidePopup();
          runSlide('3-19');
          pushState('3-19');
        });
        $('#electure-3-18 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-17');
          pushState('3-17');
        });
        $('#electure-3-19 .electure-next').click(function() {
          hidePopup();
          runSlide('3-20');
          pushState('3-20');
        });
        $('#electure-3-19 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-18');
          pushState('3-18');
        });
        $('#electure-3-20 .electure-next').click(function() {
          hidePopup();
          runSlide('3-21');
          pushState('3-21');
        });
        $('#electure-3-20 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-19');
          pushState('3-19');
        });
        $('#electure-3-21 .electure-next').click(function() {
          hidePopup();
          runSlide('3-22');
          pushState('3-22');
        });
        $('#electure-3-21 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-20');
          pushState('3-20');
        });
        $('#electure-3-22 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3-22 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-21');
          pushState('3-21');
        });
        $('#electure-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-22');
          pushState('3-22');
        });
        $('#electure-4-1 .electure-next').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-4-2 .electure-next').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
        $('#electure-4-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
        $('#electure-4-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
        $('#electure-4-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
        $('#electure-4-5 .electure-next').click(function() {
          hidePopup();
          runSlide('4-6');
          pushState('4-6');
        });
        $('#electure-4-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
        $('#electure-4-6 .electure-next').click(function() {
          hidePopup();
          runSlide('4-7');
          pushState('4-7');
        });
        $('#electure-4-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
        $('#electure-4-7 .electure-next').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-4-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-6');
          pushState('4-6');
        });
        $('#electure-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
        $('#electure-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-7');
          pushState('4-7');
        });
        $('#electure-5-1 .electure-next').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
        $('#electure-5-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-5-2 .electure-next').click(function() {
          hidePopup();
          runSlide('5-3');
          pushState('5-3');
        });
        $('#electure-5-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
        $('#electure-5-3 .electure-next').click(function() {
          hidePopup();
          runSlide('5-4');
          pushState('5-4');
        });
        $('#electure-5-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
        $('#electure-5-4 .electure-next').click(function() {
          hidePopup();
          runSlide('5-5');
          pushState('5-5');
        });
        $('#electure-5-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-3');
          pushState('5-3');
        });
        $('#electure-5-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-6');
          pushState('5-6');
        });
        $('#electure-5-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-4');
          pushState('5-4');
        });
        $('#electure-5-6 .electure-next').click(function() {
          hidePopup();
          runSlide('5-7');
          pushState('5-7');
        });
        $('#electure-5-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-5');
          pushState('5-5');
        });
        $('#electure-5-7 .electure-next').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-5-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-6');
          pushState('5-6');
        });
        $('#electure-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-7');
          pushState('5-7');
        });
        $('#electure-6-1 .electure-next').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-6-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-6-2 .electure-next').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-6-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-7 .electure-next').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-7-1 .electure-next').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
        $('#electure-7-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-8 .electure-next').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
        $('#electure-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-9 .electure-next').click(function() {
          hidePopup();
          runSlide('9-1');
          pushState('9-1');
        });
        $('#electure-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
        $('#electure-9-1 .electure-next').click(function() {
          hidePopup();
          runSlide('9-2');
          pushState('9-2');
        });
        $('#electure-9-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
        $('#electure-9-2 .electure-next').click(function() {
          hidePopup();
          runSlide('9-3');
          pushState('9-3');
        });
        $('#electure-9-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-1');
          pushState('9-1');
        });
        $('#electure-9-3 .electure-next').click(function() {
          hidePopup();
          runSlide('9-4');
          pushState('9-4');
        });
        $('#electure-9-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-2');
          pushState('9-2');
        });
        $('#electure-9-4 .electure-next').click(function() {
          hidePopup();
          runSlide('9-5');
          pushState('9-5');
        });
        $('#electure-9-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-3');
          pushState('9-3');
        });
        $('#electure-9-5 .electure-next').click(function() {
          hidePopup();
          runSlide('9-6');
          pushState('9-6');
        });
        $('#electure-9-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-4');
          pushState('9-4');
        });
        $('#electure-9-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-5');
          pushState('9-5');
        });
      });

      function doButtonAction96() {
        CUSTOM_ACTION('search','77');
      }
      function doButtonAction97() {
        CUSTOM_ACTION('search','7');
      }
      function doButtonAction98() {
        CUSTOM_ACTION('peek');
      }
      function doButtonAction99() {
        CUSTOM_ACTION('push','6');
      }
      function doButtonAction100() {
        $("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
CUSTOM_ACTION('insert_head','50');
      }
      function doButtonAction101() {
        $("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
CUSTOM_ACTION('insert_tail','10');
      }
      function doButtonAction102() {
        $("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
CUSTOM_ACTION('insert_kth','3,44');
      }
      function doButtonAction103() {
        empty();
CUSTOM_ACTION('insert_head','50');
      }
      function doButtonAction104() {
        $("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
CUSTOM_ACTION('insert_kth','6,55');
      }
      function doButtonAction105() {
        CUSTOM_ACTION('remove_head');
      }
      function doButtonAction106() {
        CUSTOM_ACTION('remove_tail');
      }
      function doButtonAction107() {
        $("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
CUSTOM_ACTION('remove_kth','5');
      }
      function doButtonAction108() {
        CUSTOM_ACTION('enqueue');
      }

      $('.electure-print').click(() => {
        window.open(`/en/list/print`);
      });
      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url.html) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}

      // This function will be called everytime 1.0x is changed to 0.5x or vice versa
      function redraw() {}

      $(document).ready(function () {
        setTimeout(function () {
          $('#change-lang-popup').fadeOut('slow')
        }, 5000)
      })
    </script>
<script type="text/javascript">
    var extraCSS = {"remove":"65px","insert":"92px","search":"119px","create":"146px"};
    var actionsIds = {"create":{"p":"Create(A)","parents":["create-from-arr"]},"search":{"p":"Search","onClick":"searchGeneric()"},"insert":{"p":"Insert","parents":["insert-head","insert-tail","insert-kth"]},"remove":{"p":"Remove","parents":["remove-kth"]}};
    var isOpens = {};
    var len = 4;
    var keys = ["create","search","insert","remove"]; 
    for (i = 0; i < len; i++) {
        var actionDetails = keys[i];
        isOpens[actionDetails] = false;
    }
    function openAction(id) {
        hideThirdTiers(id);
        $("." + id).css("bottom", extraCSS[id]);
        if (!isOpens[id]) {
            $('.' + id).fadeIn('fast');
            isOpens[id] = true;
        }
    }
    function closeAction(id) {
        hideThirdTiers(id);
        if (isOpens[id]) {
            $('.' + id).fadeOut('fast');
            $('#' + id + '-err').html("");
            isOpens[id] = false;
        }
    }

    function hideEntireActionsPanel() {
        //hideAllThirdTiers();
                    closeAction('create');
                    closeAction('search');
                    closeAction('insert');
                    closeAction('remove');
                hideActionsPanel();
    }

    function hideThirdTiers(tier1Action) {
        if ("parents" in actionsIds[tier1Action]) {
            for (const secondTierAction of actionsIds[tier1Action]["parents"]) {
                $('#' + secondTierAction + '-third-tier').fadeOut('fast');
            }
        }
    }

    function hideAllThirdTiers() {
        for (const tier1Action in actionsIds) {
            hideThirdTiers(tier1Action);
        }
    }

    function toggleChildExtras(tier1, selectedParentTier2) {
        hideThirdTiers(tier1);
        //this actionId must have childExtras
        var style = extraCSS[tier1];
        $("." + tier1).css("bottom", (parseInt(style.substring(0, style.length - 2)) - 27));
        //fade ins and outs are done on the ID whereas css class is set on the class
        //fade in the third tier of the selected 2nd tier parent
        $('#' + selectedParentTier2 + '-third-tier').fadeIn('fast');

        // //fade out all other third tiers of that 'action'
        // for (const parent of actions[tier1]["parents"]) {
        //     console.log("parent is " + parent + " for " + selectedParentTier2);
        //     if (parent != selectedParentTier2) {
        //         $('#' + parent + '-third-tier').fadeOut('fast');
        //     }
        // }
    }

    function setActionHeightOriginal(tier1Action) {
        $("." + tier1Action).css("bottom", extraCSS[tier1Action]);
    }

            $('#' + 'create').click(function() {
            openAction('create');
                                                                            closeAction('search');
                                                                closeAction('insert');
                                                                closeAction('remove');
                                    });
            $('#' + 'search').click(function() {
            openAction('search');
                                                closeAction('create');
                                                                                            closeAction('insert');
                                                                closeAction('remove');
                                    });
            $('#' + 'insert').click(function() {
            openAction('insert');
                                                closeAction('create');
                                                                closeAction('search');
                                                                                            closeAction('remove');
                                    });
            $('#' + 'remove').click(function() {
            openAction('remove');
                                                closeAction('create');
                                                                closeAction('search');
                                                                closeAction('insert');
                                                                });
    
    //important to have all the input fields in actions menu take an id containing '-input'
    $("[id*='-input']").on("keypress keydown keyup", (event) => {
        event.stopPropagation();
    });
</script>
<script type="text/javascript">

// List Widget
// original author: Steven Kester Yuwono, then cleaned and maintained by Steven Halim

var BACK_EDGE_CONST = 5000;
var scale = false;
var List = function(isMediumScale = false) {
  var self = this;
  var graphWidget = new GraphWidget(isMediumScale);
  var activeStatus = "list";
  var maxSize = 15;
  var maxStackSize = 7; // 18 Apr 23, 7 now

  var valueRange = [1, 99]; // Range of valid values of List vertexes allowed
  var maxHeightAllowed = 10;

  var initialArray = [15, 6, 23, 4, 7, 71, 5, 50];
  var initialStackArray = [15, 6, 50, 4];

  var curArray = [];
  var stateList = [];

  /*
   * iL: Internal representation of List in this object
   * The keys are the text of the vertices, and the value is the attributes of the corresponding vertex encapsulated in a JS object, which are:
   * - "prev": text of the prev vertex. If the vertex is root Vertex, the value is null
   * - "next": text of the right child. No child -> null
   * - "cx": X-coordinate of center of the vertex
   * - "cy": Y-coordinate of center of the vertex
   * - "height": height of the Vertex. Height of root is 0
   * - "vtxIdx": Vertex class number of the corresponding Vertex
   *
   * In addition, there is a key called "head" in iL, containing the text of the root Vertex.
   * If List is empty, root is null.
   */

  var iL = {};
  var amountVertex = 0;
  var vertexClassNumberCounter = 9;
  iL["head"] = null;

  curArray = generateRandomArray(Math.floor((Math.random()*4 + 4))); // [4..7]
  init(curArray);

  this.setActiveStatus = function(newActiveStatus) {
    if (activeStatus != newActiveStatus) {
      activeStatus = newActiveStatus;
      curArray = generateRandomArray(Math.floor((Math.random()*4 + 4))); // [4..7]
      init(curArray);
    }
  }

  this.getActiveStatus = function() { return activeStatus; }

  this.widgetRecalculatePosition = function() { recalculatePosition(); }

  this.getGraphWidget = function() { return graphWidget; }

  /* FIRST MENU: Create */

  this.generate = function(initArr) {
    curArray = initArr;
    init(curArr);
  }

  function generateRandomArray(vertexAmt) {
    var initArr = new Array();
    while (initArr.length < vertexAmt) {
      var random = Math.floor(1 + Math.random()*98);
      if ($.inArray(random, initArr) < 0)
        initArr.push(random);
    }
    return initArr;
  }

  this.generateRandomFixedSize = function(val, isSorted) {
    if (activeStatus == "stack") {
      if (val > maxStackSize) {
        $('#create-err').html('Sorry, the maximum number of vertex allowed is {maxSize}'.replace("{maxSize}", maxStackSize));
        return false;
      }
    }
    else {
      if (val > maxSize) {
        $('#create-err').html('Sorry, the maximum number of vertex allowed is {maxSize}'.replace("{maxSize}", maxSize));
        return false;
      }
    }
    curArr = generateRandomArray(val);
    if (isSorted) curArr.sort(function(a, b) { return a-b; }); // sort it first
    init(curArr);
    return true;
  }

  this.generateUserDefined = function(vertexTextArr) {
    var vertexAmt = vertexTextArr.length;
    if (activeStatus == "stack") {
      if (vertexAmt > maxStackSize) {
        $('#create-err').html('Sorry, the maximum number of vertex allowed is {maxSize}'.replace("{maxSize}", maxStackSize));
        return false;
      }
    }
    else {
      if (vertexAmt > maxSize) {
        $('#create-err').html('Sorry, the maximum number of vertex allowed is {maxSize}'.replace("{maxSize}", maxSize));
        return false;
      }
    }

    if (vertexTextArr == '') { // prevent creation of empty list
      $('#create-err').html('Sorry, the minimum number of vertex is at least 1.');
      return false;
    }

    curArr = new Array();
    for (i = 0; i < vertexTextArr.length; ++i) {
      var vt = parseInt(vertexTextArr[i]);
      if (!isNaN(vt) && $.inArray(vt, curArr) < 0) // remove duplicates
        curArr.push(vt);
    }
    init(curArr);
    return true;
  }

  this.getA = function() {
    var theArr = [], currentVertex = iL["head"];
    while (currentVertex != null) {
      theArr.push(currentVertex);
      currentVertex = iL[currentVertex]["next"];
    }
    return theArr;
  }

  /* SECOND MENU: Search (LL, DLL) or Peek (Stack, Queue+Deque -- additional Peek back) */

  this.search = function(val, callback) {
    stateList = [];
    var vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = createState(iL), curVtxIdx, key, index = 0;

    if (currentVertex == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The current Linked List is empty, we return NOT_FOUND.
      cs["status"] = 'The current Linked List is empty, we return NOT_FOUND.';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      // temp = head, index = 0
      cs = createState(iL, vertexTraversed, edgeTraversed);
      curVtxIdx = iL[currentVertex]["vtxIdx"];
      cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][curVtxIdx]["extratext"] = (index == 0 ? "h/" : (iL[currentVertex]["next"] == null ? "t/" : "")) + "tmp/" + index;
      // This is the current Linked List.
      // We want to search for value v = {val} starting from the head (index 0).
      cs["status"] = 'This is the current Linked List.<br>We want to search for value v = {val} starting from the head (index 0).'.replace("{val}", val);
      cs["lineNo"] = 2;
      stateList.push(cs);

      // while (temp.data != input)
      while (parseInt(currentVertex) != parseInt(val)) {
        vertexTraversed[currentVertex] = true;
        cs = createState(iL, vertexTraversed, edgeTraversed);
        // Comparing {currentVertex} with {val} (index = {index}).
        // {currentVertex} is not equal to {val} so we have to continue.
        cs["status"] = 'Comparing {currentVertex} (index = {index}) with v = {val}.<br>{currentVertex} is not equal to {val} so we have to continue.'.replace("{currentVertex}", currentVertex).replace("{val}", val).replace("{index}", index).replace("{currentVertex}", currentVertex).replace("{val}", val);
        cs["vl"][curVtxIdx]["extratext"] = (index == 0 ? "h/" : (iL[currentVertex]["next"] == null ? "t/" : "")) + "tmp/" + index;
        cs["lineNo"] = 3;
        stateList.push(cs);

        currentVertex = iL[currentVertex]["next"];
        ++index;

        // case when vertex is not found
        if (currentVertex == null) {
          // temp = temp.next, index++
          cs = createState(iL, vertexTraversed, edgeTraversed);
          // We try advancing temp to the next vertex.
          // But...
          cs["status"] = 'We try advancing tmp to the next vertex.<br>But...';
          cs["lineNo"] = 4;
          stateList.push(cs);

          // if temp == null
          //   return -1
          cs = createState(iL, vertexTraversed, edgeTraversed);
          // temp is null (we have gone past the tail after O(N) step(s)).
          // We conclude that value {val} is NOT_FOUND in the Linked List.
          cs["status"] = 'tmp is null (we have gone past the tail after O(N) step(s)).<br>We conclude that value v = {val} is NOT_FOUND in the Linked List.'.replace("{val}", val);
          cs["lineNo"] = [5, 6];
          stateList.push(cs);

          break;
        }

        // temp = temp.next, index++
        // if temp == null
        curVtx = iL[currentVertex]["prev"];
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        var edgeHighlighted = iL[curVtx]["vtxIdx"];
        edgeTraversed[edgeHighlighted] = true;
        // update on 19 Oct, don't highlight the back edge
        // if ((activeStatus == "doublylist") || (activeStatus == "deque"))
        //  edgeTraversed[edgeHighlighted + BACK_EDGE_CONST] = true;
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = (index == 0 ? "h/" : (iL[currentVertex]["next"] == null ? "t/" : "")) + "tmp/" + index;
        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
        // So temp advances to the next vertex.
        // temp is not null, continue searching.
        cs["status"] = 'So tmp advances to the next vertex.<br>tmp is not null, continue searching.';
        cs["lineNo"] = [4, 5];
        stateList.push(cs);
      }

      // case when vertex is found
      if (currentVertex != null) {
        // return index
        cs = createState(iL, vertexTraversed, edgeTraversed);
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = (index == 0 ? "h/" : (iL[currentVertex]["next"] == null ? "t/" : "")) + "tmp/" + index;
        // Found value v = {val} at this highlighted vertex so we return index {index}.
        // The whole operation is O(N).
        cs["status"] = 'Found value v = {val} at this highlighted vertex so we return index {index}.<br>The whole operation is O(N).'.replace("{val}", val).replace("{index}", index);
        cs["lineNo"] = 7;
        stateList.push(cs);
      }
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(4);
    return true;
  };

  this.peek = function(isHead, callback) {
    stateList = [];
    var vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = createState(iL), curVtxIdx, key, index = 0;

    if (currentVertex == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The current Linked List is empty, we return NOT_FOUND.
      cs["status"] = 'The current Linked List is empty, we return NOT_FOUND.';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      if (!isHead) {
        while (true) { // go to tail
          if (iL[currentVertex]["next"] != null) currentVertex = iL[currentVertex]["next"];
          else break;
        }
      }

      cs = createState(iL, vertexTraversed, edgeTraversed);
      curVtxIdx = iL[currentVertex]["vtxIdx"];
      cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      // Return the value stored at the head: {currentVertex}.
      cs["status"] = (isHead ? 'Return the value stored at the head: {currentVertex}.' : 'Return the value stored at the tail: {currentVertex}.').replace("{currentVertex}", currentVertex);
      cs["lineNo"] = 2;
      stateList.push(cs);
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(isHead ? 3 : 9);
    return true;
  }

  /* THIRD MENU: Insert (LL, DLL, minor differences only)/Push (Stack)/Enqueue (Queue, Deque) */

  this.insertHead = function(v, callback) {
    var tempinternalList = deepCopy(iL);

    // 0. Check whether input is array
    if (Object.prototype.toString.call(v) != '[object Array]') {
      $('#insert-err').html('Please fill in a number or comma-separated array of numbers!');  // TODO: Add the error into varlist
      return false;
    }

    for (i = 0; i < v.length; ++i) {
      var val = parseInt(v[i]);

      // 1. Check whether value is number
      if (isNaN(val)) {
        // Please fill in an Integer.
        $('#insert-err').html('Please fill in an Integer.');
        return false;
      }

      // 2. No duplicates allowed. Also works if more than one similar value are inserted
      if (tempinternalList[val] != null) {
        // No duplicate vertex allowed!
        $('#insert-err').html('No duplicate vertex allowed!');
        if (typeof callback == 'function') callback();
        return false;
      }

      // 3. Check range
      if (val < valueRange[0] || val > valueRange[1]) {
        // Sorry, only values between {range0} and {range1} can be inserted.
        $('#insert-err').html('Sorry, only values between {range0} and {range1} can be inserted.'.replace("{range0}", valueRange[0]).replace("{range1}", valueRange[1]));
        return false;
      }
    }

    // 4. check size
    if (activeStatus == "stack") {
      var limit = (scale ? 2 : 1) * maxStackSize;
      if (v.length + amountVertex > limit) {
        // Sorry, the maximum size is {maxSize}.
        $('#insert-err').html('Sorry, the maximum size is {maxSize}.'.replace("{maxSize}", limit));
        return false;
      }
    }
    else {
      if (amountVertex >= maxSize) {
        // Sorry, the maximum size is {maxSize}.
        $('#insert-err').html('Sorry, the maximum size is {maxSize}.'.replace("{maxSize}", maxSize));
        return false;
      }
    }

    stateList = [];
    var vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;
    if (amountVertex >= 1) cs = createState(iL);
    else                   cs = {};

    for (i = 0; i < v.length; ++i) {
      var val = parseInt(v[i]);

      // Begin insertion, first, update internal representation
      iL[parseInt(val)] = {
        "next": null,
        "vtxIdx": vertexClassNumberCounter++
      };

      // modified this part for linked list insertion
      var newVtx = parseInt(val);
      var oldHeadIdx;

      if (activeStatus == "stack") {
        iL[newVtx]["cx"] = 350; // stack vertices are all here
        iL[newVtx]["cy"] = 400 - ((amountVertex+1)*50);
      }
      else {
        iL[newVtx]["cx"] = 200;
        if (amountVertex >= 1)
          iL[newVtx]["cx"] = iL[iL["head"]]["cx"]-50; // 50 less
        iL[newVtx]["cy"] = 100;
      }

      // Vertex vtx = new Vertex(v)
      var newVtxIdx = iL[parseInt(val)]["vtxIdx"];
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][newVtxIdx]["extratext"] = "vtx";
      // cs["vl"][oldHeadIdx]["extratext"] = "head";
      //cs["el"][newVtxIdx]["state"] = OBJ_HIDDEN;
      //if ((activeStatus == "doublylist") || (activeStatus == "deque"))
      //  cs["el"][newVtxIdx + BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
      // Create new vertex to store value {val}.
      cs["status"] = 'Create new vertex to store value {val}.'.replace("{val}", val);
      cs["lineNo"] = 1;
      stateList.push(cs);

      if (amountVertex+1 > 1) {
        var tempChild = iL["head"];
        oldHeadIdx = iL[tempChild]["vtxIdx"];
        iL[newVtx]["next"] = tempChild;
        iL[tempChild]["prev"] = newVtx;
      }
      iL["head"] = newVtx;

      // Then, draw edge
      if (amountVertex+1 > 1) {
        // vtx.next = head
        cs = createState(iL, vertexTraversed, edgeTraversed);
        var edgeHighlighted = iL[newVtx]["vtxIdx"];
        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_HIGHLIGHTED;
        cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][newVtxIdx]["extratext"] = "vtx";
        cs["vl"][oldHeadIdx]["extratext"] = "head/0";
        if ((activeStatus == "doublylist") || (activeStatus == "deque"))
          cs["el"][newVtxIdx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
        // Now, temp.next points to the current head.
        cs["status"] = 'vtx.next points to the current head.';
        cs["lineNo"] = 2;
        stateList.push(cs);

        if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
          // if (head != null) head.prev = vtx
          cs = createState(iL, vertexTraversed, edgeTraversed);
          cs["vl"][oldHeadIdx]["extratext"] = "head/0";
          cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
          cs["vl"][newVtxIdx]["extratext"] = "vtx";
          cs["el"][newVtxIdx+BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
          cs["el"][newVtxIdx+BACK_EDGE_CONST]["animateHighlighted"] = true;
          // (Old) head.prev points to vtx.
          cs["status"] = 'Current head.prev points to vtx.';
          cs["lineNo"] = 3;
          stateList.push(cs);
        }
      }
      else {
        // Vertex vtx = new Vertex(v)
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][newVtxIdx]["extratext"] = "vtx";
        // Create new vertex to store value {val}.
        // But as head is currently null, temp.next remains null.
        cs["status"] = 'Create new vertex to store value {val}.'.replace("{val}", val) + '<br>Head is currently null.';
        cs["lineNo"] = [1, 2];
        stateList.push(cs);
      }

      // head = vtx
      ++amountVertex;
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][newVtxIdx]["extratext"] = "head/0";
      // Now, head points to vtx.
      cs["status"] = 'head points to vtx.';
      if ((activeStatus == "doublylist") || (activeStatus == "deque"))
        cs["lineNo"] = 4;
      else
        cs["lineNo"] = 3;
      stateList.push(cs);

      if (amountVertex == 1) {
        // tail = head
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
        cs["vl"][newVtxIdx]["extratext"] = "head/tail/0";
        // iL["head"] = newVtxIdx; // is this correct?
        // Tail points to head.
        cs["status"] = 'Tail points to head.';
        cs["lineNo"] = 3;
        stateList.push(cs);
      }

      if (iL[iL["head"]]["cx"] < 70) { // only do this when we are about to go off-screen
        recalculatePosition();
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
        cs["vl"][newVtxIdx]["extratext"] = "head" + (amountVertex == 1 ? "/tail" : "") + "/0";
        // Re-layout the Linked List for visualization.
        // The whole process is O({N}).
        cs["status"] = 'Re-layout the Linked List for visualization (not in the actual Linked List).<br>The whole process is still O({N}).'.replace("{N}", "1");
        cs["lineNo"] = 0;
        stateList.push(cs);
      }
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(1);
    return true;
  }

  this.insertTail = function(v, callback) {
    var tempinternalList = deepCopy(iL); // Use this to simulate internal insertion

    // 0. Check whether input is array
    if (Object.prototype.toString.call(v) != '[object Array]') {
      $('#insert-err').html('Please fill in a number or comma-separated array of numbers!');  // TODO: Add the error into varlist
      return false;
    }

    for (i = 0; i < v.length; ++i) {
      var val = parseInt(v[i]);

      // 1. Check whether value is number
      if (isNaN(val)) {
        // Please fill in an Integer.
        $('#insert-err').html('Please fill in an Integer.');
        if (typeof callback == 'function') callback();
        return false;
      }

      // 2. No duplicates allowed. Also works if more than one similar value are inserted
      if (tempinternalList[val] != null) {
        // No duplicate vertex allowed!
        $('#insert-err').html('No duplicate vertex allowed!');
        if (typeof callback == 'function') callback();
        return false;
      }

      // 3. Check range
      if (val < valueRange[0] || val > valueRange[1]) {
        // Sorry, only values between {range0} and {range1} can be inserted.
        $('#insert-err').html('Sorry, only values between {range0} and {range1} can be inserted.'.replace("{range0}", valueRange[0]).replace("{range1}", valueRange[1]));
        if (typeof callback == 'function') callback();
        return false;
      }
    }

    // 4. check size
    if (v.length + amountVertex >= maxSize) {
      // Sorry, the maximum size is {maxSize}.
      $('#insert-err').html('Sorry, the maximum size is {maxSize}.'.replace("{maxSize}", maxSize));
      if (typeof callback == 'function') callback();
      return false;
    }

    stateList = [];
    var vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;
    if (amountVertex >= 1) cs = createState(iL);
    else                   cs = {};

    for (i = 0; i < v.length; ++i) {
      var val = parseInt(v[i]);

      // Find prev
      while (currentVertex != null && currentVertex != val) {
        var nextVertex;
        nextVertex = iL[currentVertex]["next"];
        if (nextVertex == null) break;
        else                    currentVertex = nextVertex;
      }

      // Begin insertion, first, update internal representation
      var newVtx = parseInt(val);
      // var oldTailIdx = iL[currentVertex]["vtxIdx"];
      var oldTailIdx;
      if (currentVertex != null) {
        oldTailIdx = iL[currentVertex]["vtxIdx"];
      }

      iL[parseInt(val)] = {
        "next": null,
        "vtxIdx": vertexClassNumberCounter++
      };

      // turn on a bit for recalculatePosition
      if (currentVertex != null) {
        iL[parseInt(val)]["prev"] = currentVertex;
        iL[currentVertex]["next"] = parseInt(val);
      }
      else {
        iL[parseInt(val)]["prev"] = null;
      }

      ++amountVertex;
      iL[parseInt(val)]["cx"] = 200;
      if (currentVertex != null) {
        iL[parseInt(val)]["cx"] = iL[currentVertex]["cx"]+50;
      }
      iL[parseInt(val)]["cy"] = 100;
      if (iL[parseInt(val)]["cx"] > 930)
        recalculatePosition();

      // turn off temporarily
      if (currentVertex != null) {
        iL[parseInt(val)]["prev"] = null;
        iL[currentVertex]["next"] = null;
      }
      else {
        iL[parseInt(val)]["prev"] = null;
      }

      var newVtxIdx = iL[parseInt(val)]["vtxIdx"];

      // Vertex vtx = new vertex(v)
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][newVtxIdx]["extratext"] = "vtx";
      if (oldTailIdx !== undefined) {
        cs["vl"][oldTailIdx]["extratext"] = "tail/" + (amountVertex-2);
      }
      // turn off on 21 Oct
      // cs["el"][curVtxIdx]["state"] = OBJ_HIDDEN;
      // if ((activeStatus == "doublylist") || (activeStatus == "deque"))
      //   cs["el"][curVtxIdx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
      // Create new vertex to store value {val}.
      cs["status"] = 'Create new vertex to store value {val}.'.replace("{val}", val);
      cs["lineNo"] = 1;
      stateList.push(cs);

      // update properly
      if (currentVertex != null) {
        iL[parseInt(val)]["prev"] = currentVertex;
        iL[currentVertex]["next"] = parseInt(val);
      }
      else {
        iL[parseInt(val)]["prev"] = null;
        iL["head"] = parseInt(val);
      }

      // tail.next = vtx
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][newVtxIdx]["extratext"] = "vtx/" + (amountVertex-1);
      
      if (currentVertex != null) {
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
        cs["vl"][oldTailIdx]["extratext"] = "tail/" + (amountVertex-2);
        cs["el"][curVtxIdx]["state"] = EDGE_TRAVERSED;
        cs["el"][curVtxIdx]["animateHighlighted"] = true;
      }
      //if ((activeStatus == "doublylist") || (activeStatus == "deque"))
      //  cs["el"][curVtxIdx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
      // Now vtx.next points to new vertex.
      cs["status"] = 'Current tail.next points to vtx.';
      cs["lineNo"] = 2;
      // stateList.push(cs); // don't push now

      if ((currentVertex != null) && ((activeStatus == "doublylist") || (activeStatus == "deque"))) {
        // cs = createState(iL, vertexTraversed, edgeTraversed);
        // cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
        // cs["vl"][curVtxIdx]["extratext"] = "tail";
        // cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        // cs["vl"][newVtxIdx]["extratext"] = "vtx";
        cs["el"][curVtxIdx+BACK_EDGE_CONST]["state"] = EDGE_TRAVERSED; // EDGE_HIGHLIGHTED;
        //cs["el"][curVtxIdx+BACK_EDGE_CONST]["animateHighlighted"] = true;
        // Update prev pointer of the new vertex to point back to the (old) tail.
        cs["status"] = cs["status"] + '<br>vtx.prev points back to the current tail.';
        // cs["lineNo"] = 2;
      }
      stateList.push(cs);

      // tail = vtx
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][newVtxIdx]["extratext"] = "tail/" + (amountVertex-1);
      
      if (currentVertex == null) {
        cs["vl"][newVtxIdx]["extratext"] = "head/tail/" + (amountVertex-1);
      }

      // Now, tail points to the new vertex too.
      // The whole operation is O(1) if we maintain the tail pointer.
      cs["status"] = 'tail points to vtx.<br>The whole operation is O(1) if we maintain the tail pointer.';
      cs["lineNo"] = 3;
      stateList.push(cs);

      currentVertex = newVtx;
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(2);
    return true;
  }

  this.insertKth = function(index, v, callback) {
    // index checking start
    if (isNaN(index)) {
      // Please fill in an Integer.
      $('#insert-err').html('Please fill in an Integer.');
      return false;
    }
    if ((index < 1) || (index > amountVertex)) {
      // Please enter a valid index between [1..{limit}].
      $('#insert-err').html('Please enter a valid index between [1..{limit}].'.replace("{limit}", Math.max(1, amountVertex-1)));
      return false;
    }

    // check if it is insertion at index 0/N i.e. insert head/tail, respectively (will no longer be used?)
    if (index == 0)            return this.insertHead([v]);
    if (index == amountVertex) return this.insertTail([v]);

    var val = parseInt(v);
    var tempinternalList = deepCopy(iL); // Use this to simulate internal insertion

    // 1. Check whether value is number
    if (isNaN(val)) {
      // Please fill in an Integer.
      $('#insert-err').html('Please fill in an Integer.');
      return false;
    }
    // 2. No duplicates allowed. Also works if more than one similar value are inserted
    if (tempinternalList[val] != null) {
      // No duplicate vertex allowed!
      $('#insert-err').html('No duplicate vertex allowed!');
      return false;
    }
    // 3. Check range
    if (parseInt(val) < valueRange[0] || parseInt(val) > valueRange[1]) {
      // Sorry, only values between {range0} and {range1} can be inserted.
      $('#insert-err').html('Sorry, only values between {range0} and {range1} can be inserted.'.replace("{range0}", valueRange[0]).replace("{range1}", valueRange[1]));
      return false;
    }
    // 4. check size
    if (amountVertex >= maxSize) {
      // Sorry, the maximum size is {maxSize}.
      $('#insert-err').html('Sorry, the maximum size is {maxSize}.'.replace("{maxSize}", maxSize));
      return false;
    }

    stateList = [];
    var vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {};
    var temp1Idx, temp2Idx, newVtxIdx;

    // Vertex prev = head
    cs = createState(iL, vertexTraversed, edgeTraversed);
    temp1Idx = iL[currentVertex]["vtxIdx"];
    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][temp1Idx]["extratext"] = "h/p/0";
    vertexTraversed[currentVertex] = true;
    // Set prev to head.
    cs["status"] = 'Set tmp1 to head.';
    cs["lineNo"] = 1;
    stateList.push(cs);

    // Find prev
    // for (k = 0; k < i; ++k)
    var i = 0;
    for (var k = 0; k < index-1; ++k) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      temp1Idx = iL[currentVertex]["vtxIdx"];
      cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][temp1Idx]["extratext"] = (i == 0 ? "h/" : (iL[currentVertex]["next"] == null ? "t/" : "")) + "p/" + i;
      vertexTraversed[currentVertex] = true;
      // Increment k, index specified has not been reached.
      // k is now: {k}.
      cs["status"] = 'Decrement k, index specified has not been reached.<br>k is now: {k}.'.replace("{k}", k);
      cs["lineNo"] = 2;
      stateList.push(cs);

      var nextVertex;
      nextVertex = iL[currentVertex]["next"];

      if (nextVertex == null) break;
      else                    currentVertex = nextVertex;

      // pre = pre.next
      curVtx = iL[currentVertex]["prev"];
      cs = createState(iL, vertexTraversed, edgeTraversed);
      var edgeHighlighted = iL[curVtx]["vtxIdx"];
      edgeTraversed[edgeHighlighted] = true;
      cs["vl"][temp1Idx]["extratext"] = (i == 0 ? "h/" : (iL[currentVertex]["next"] == null ? "t/" : "")) + "p/" + i;
      cs["el"][edgeHighlighted]["animateHighlighted"] = true;
      cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
      // We set prev to the next vertex.
      cs["status"] = 'We set prev to the next vertex.';
      cs["lineNo"] = 3;
      stateList.push(cs);

      ++i;
    }

    if (currentVertex != null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      temp1Idx = iL[currentVertex]["vtxIdx"];
      cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][temp1Idx]["extratext"] = (i == 0 ? "h/" : (iL[currentVertex]["next"] == null ? "t/" : "")) + "p/" + i;
      vertexTraversed[currentVertex] = true;
      // We have found the insertion point.
      // We continue the next insertion step.
      cs["status"] = 'We have found the insertion point.<br>We continue the next insertion step.';
      cs["lineNo"] = 2;
      stateList.push(cs);
    }

    // Begin insertion, first, update internal representation
    // Vertex aft = pre.next
    var temp2Vertex = iL[currentVertex]["next"];
    temp2Idx = iL[temp2Vertex]["vtxIdx"];
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][temp1Idx]["extratext"] = (i == 0 ? "h/" : (iL[currentVertex]["next"] == null ? "t/" : "")) + "p/" + i;
    cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
    cs["vl"][temp2Idx]["extratext"] = (i+1 == 0 ? "h/" : (iL[temp2Vertex]["next"] == null ? "t/" : "")) + "a/" + (i+1);
    cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
    cs["el"][temp1Idx]["animateHighlighted"] = true;
    edgeTraversed[temp1Idx] = true;
    // The specified index is found.
    // pre is before the insertion point and aft is the insertion point.
    cs["status"] = 'The index before insertion point is found.<br>pre is before the insertion point and aft is the insertion point.';
    cs["lineNo"] = 4;
    stateList.push(cs);

    // if inserting at position k clashes with the previous vertex with the same cx and cy, relayout first
    if (iL[currentVertex]["cy"] == iL[temp2Vertex]["cy"]+50) { // collission going to happen
      recalculatePosition();
      cs = createState(iL, {}, {});
      // Re-layout the Linked List for visualization.
      // The whole process is O({N}).
      cs["status"] = 'Re-layout the Linked List for visualization (not in the actual Linked List).<br>The whole process is still O({N}).'.replace("{N}", "N");
      cs["lineNo"] = 0;
      stateList.push(cs);
    }

    iL[parseInt(val)] = {
      "next": null,
      "vtxIdx": vertexClassNumberCounter++
    };
    //modified this part for linked list insertion
    var newVtx = parseInt(val);
    newVtxIdx = iL[parseInt(val)]["vtxIdx"];
    var tempChild;

    iL[newVtx]["cx"] = iL[temp2Vertex]["cx"];
    iL[newVtx]["cy"] = iL[temp2Vertex]["cy"]+50; // below

    // vertex vtx = new Vertex(v)
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][temp1Idx]["extratext"] = (i == 0 ? "h/" : (iL[currentVertex]["next"] == null ? "t/" : "")) + "p/" + i;
    cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
    cs["vl"][temp2Idx]["extratext"] = (i+1 == 0 ? "h/" : (iL[temp2Vertex]["next"] == null ? "t/" : "")) + "a/" + (i+1);
    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["extratext"] = "vtx";
    // Create new vertex to store value {val}.
    cs["status"] = 'Create new vertex to store value {val}.'.replace("{val}", val);
    cs["lineNo"] = 5;
    stateList.push(cs);
    edgeTraversed[newVtxIdx] = true;

    // RELINK THE POINTERs
    iL[newVtx]["next"] = temp2Vertex;
    iL[temp2Vertex]["prev"] = newVtx;

    // vtx.next = aft
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][temp1Idx]["extratext"] = (i == 0 ? "h/" : (iL[currentVertex]["next"] == null ? "t/" : "")) + "p/" + i;
    cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
    cs["vl"][temp2Idx]["extratext"] = (i+1 == 0 ? "h/" : (iL[temp2Vertex]["next"] == null ? "t/" : "")) + "a/" + (i+1);
    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["extratext"] = "vtx";
    cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
    cs["el"][newVtxIdx]["state"] = EDGE_GREEN;
    cs["el"][newVtxIdx]["animateHighlighted"] = true;
    // 20 Oct, turn these two lines off
    // if ((activeStatus == "doublylist") || (activeStatus == "deque"))
      // cs["el"][newVtxIdx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
    // v.next points to aft.
    cs["status"] = 'vtx.next points to aft.';
    cs["lineNo"] = 6;
    stateList.push(cs);

    // aft.prev = vtx (for DLL and deque)
    if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][temp1Idx]["extratext"] = (i == 0 ? "h/" : (iL[currentVertex]["next"] == null ? "t/" : "")) + "p/" + i;
      cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
      cs["vl"][temp2Idx]["extratext"] = (i+1 == 0 ? "h/" : (iL[temp2Vertex]["next"] == null ? "t/" : "")) + "a/" + (i+1);
      cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][newVtxIdx]["extratext"] = "vtx";
      cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
      cs["el"][newVtxIdx]["state"] = EDGE_GREEN;
      // 20 Oct, turn these two lines off
      // cs["el"][newVtxIdx+BACK_EDGE_CONST]["state"] = EDGE_GREEN;
      // cs["el"][temp1Idx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
      // aft.prev points to vtx.
      cs["status"] = 'aft.prev points to vtx.';
      cs["lineNo"] = 6;
      stateList.push(cs);
    }

    // pre.next = vtx
    iL[currentVertex]["next"] = newVtx;
    iL[newVtx]["prev"] = currentVertex;
    ++amountVertex;

    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][temp1Idx]["extratext"] = (i == 0 ? "h/" : (iL[currentVertex]["next"] == null ? "t/" : "")) + "p/" + i;
    cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
    cs["vl"][temp2Idx]["extratext"] = (i+1 == 0 ? "h/" : (iL[temp2Vertex]["next"] == null ? "t/" : "")) + "a/" + (i+2);
    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["extratext"] = "vtx/" + (i+1);
    cs["el"][newVtxIdx]["state"] = EDGE_GREEN;
    cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
    // if ((activeStatus == "doublylist") || (activeStatus == "deque"))
    //  cs["el"][temp1Idx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
    // pre.next points to vtx.
    cs["status"] = 'pre.next points to vtx.';
    cs["lineNo"] = 7;
    stateList.push(cs);

    // vtx.prev = pre
    if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][temp1Idx]["extratext"] = (i == 0 ? "h/" : (iL[currentVertex]["next"] == null ? "t/" : "")) + "p/" + i;
      cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
      cs["vl"][temp2Idx]["extratext"] = (i+1 == 0 ? "h/" : (iL[temp2Vertex]["next"] == null ? "t/" : "")) + "a/" + (i+2);
      cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][newVtxIdx]["extratext"] = "vtx/" + (i+1);
      //cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
      //cs["el"][temp1Idx+BACK_EDGE_CONST]["state"] = EDGE_TRAVERSED;
      // vtx.prev points to pre.
      cs["status"] = 'vtx.prev points to pre.';
      cs["lineNo"] = 7;
      stateList.push(cs);
    }

    if (iL[newVtx]["cy"] > 150) {
      recalculatePosition();
      cs = createState(iL, {}, {});
      cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][newVtxIdx]["extratext"] = "vtx/" + (i+1);
      // Re-layout the Linked List for visualization.
      // The whole process is O({N}).
      cs["status"] = 'Re-layout the Linked List for visualization (not in the actual Linked List).<br>The whole process is still O({N}).'.replace("{N}", "N");
      cs["lineNo"] = 0;
      stateList.push(cs);
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(0);
    return true;
  }

  /* FOURTH MENU: Remove */

  this.removeHead = function(startAnimationDirectly, callback) {
    var vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;

    if (startAnimationDirectly) {
      stateList = [];
      populatePseudocode(5);
    }

    if (currentVertex == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The Linked List is already empty.
      // No action is performed.
      cs["status"] = 'The Linked List is already empty.<br>No action is performed.';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      if (iL[currentVertex]["next"] == null) { // head has no next vertex
        // temp = head
        cs = createState(iL, vertexTraversed, edgeTraversed);
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        // The head is the only vertex in this List.
        cs["status"] = 'The head is the only vertex in this List.';
        cs["lineNo"] = 2;
        stateList.push(cs);

        // head = head.next
        cs = createState(iL, vertexTraversed, edgeTraversed);
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        // Head points to next (which is null).
        cs["status"] = 'Head points to next (which is null).';
        cs["lineNo"] = 3;
        stateList.push(cs);

        curVtxIdx = iL[currentVertex]["vtxIdx"];

        // delete temp
        iL["head"] = null;
        delete iL[currentVertex];
        delete vertexTraversed[currentVertex];
        delete edgeTraversed[curVtxIdx];
        --amountVertex;

        cs = createState(iL, vertexTraversed, edgeTraversed);
        // Remove head vertex.
        // We now have an empty List.
        cs["status"] = 'Remove head vertex.<br>We now have an empty List.';
        cs["lineNo"] = 4;
        stateList.push(cs);
      }
      else { // head has next vertex
        // temp = head
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = "h/t/0";
        // The head has a next vertex.
        cs["status"] = 'The head has a next vertex.';
        cs["lineNo"] = 2;
        stateList.push(cs);

        var rightChildVertex = iL[currentVertex]["next"];
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        nextVtxIdx = iL[rightChildVertex]["vtxIdx"];

        // head = head.next
        --amountVertex;
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = "temp";
        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
        cs["vl"][nextVtxIdx]["extratext"] = "head/0";
        cs["el"][curVtxIdx]["state"] = EDGE_GREEN;
        cs["el"][curVtxIdx]["animateHighlighted"] = true;
        // head points to the next vertex.
        cs["status"] = 'head points to the next vertex.';
        cs["lineNo"] = 3;
        stateList.push(cs);

        iL["head"] = rightChildVertex;
        iL[rightChildVertex]["prev"] = null;

        // delete temp
        delete iL[currentVertex];
        delete vertexTraversed[currentVertex];
        delete edgeTraversed[curVtxIdx];
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
        if (amountVertex == 1) cs["vl"][nextVtxIdx]["extratext"] = "head/tail/0";
        // Delete temp = (previous) head.
        cs["status"] = 'Delete tmp, which was the (previous) head.';
        cs["lineNo"] = 4;
        stateList.push(cs);

        if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
          // head.prev = null
          cs = createState(iL, vertexTraversed, edgeTraversed);
          cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
          if (amountVertex == 1) cs["vl"][nextVtxIdx]["extratext"] = "head/tail/0";
          // Set head.prev to null for consistency purpose.
          cs["status"] = 'Set head.prev to null for consistency purpose.';
          cs["lineNo"] = 5;
          stateList.push(cs);
        }

        // relayout
        if (iL[iL["head"]]["cx"] > 400) {
          recalculatePosition(); // this line triggers some D3.js errors although OK? find the root cause?
          cs = createState(iL, vertexTraversed, edgeTraversed);
          cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
          // Re-layout the Linked List for visualization.
          // The whole process is O({N}).
          cs["status"] = 'Re-layout the Linked List for visualization (not in the actual Linked List).<br>The whole process is still O({N}).'.replace("{N}", "1");
          stateList.push(cs);
        }
      }
    }

    if (startAnimationDirectly) graphWidget.startAnimation(stateList, callback);
    return true;
  }

  this.popKTimes = function(k, callback) {
    if (k > amountVertex) {
      $('#remove-err').html("K must be &le; N");
      if (typeof callback == 'function') callback();
      return false;
    }

    populatePseudocode(10);
    stateList = [];
    var vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;

    for (var i = 0; i < k; ++i) {
      this.removeHead(false);
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["lineNo"] = 1;
      stateList.push(cs);
    }

    graphWidget.startAnimation(stateList, callback);
    return true;
  }

  this.removeTail = function(callback) {
    if (amountVertex == 1) return this.removeHead(true, callback); // special case

    stateList = [];
    var vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;

    if (currentVertex == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The Linked List is already empty.
      // No action is performed.
      cs["status"] = 'The Linked List is already empty.<br>No action is performed.';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      var nextVertex = iL[currentVertex]["next"], nextVtxIdx;

      // Vertex pre = head
      cs = createState(iL, vertexTraversed, edgeTraversed);
      curVtxIdx = iL[currentVertex]["vtxIdx"];
      cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][curVtxIdx]["extratext"] = "h/p";
      // Set up pre pointer.
      // pre will eventually point to the last vertex before tail.
      cs["status"] = 'Set up pre pointer.<br>pre will eventually point to the last vertex before tail.';
      cs["lineNo"] = 2;
      stateList.push(cs);

      // temp = head.next
      cs = createState(iL, vertexTraversed, edgeTraversed);
      curVtxIdx = iL[currentVertex]["vtxIdx"];
      cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][curVtxIdx]["extratext"] = "h/p";
      nextVtxIdx = iL[nextVertex]["vtxIdx"];
      cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][nextVtxIdx]["extratext"] = (iL[nextVertex]["next"] == null ? "t/" : "") + "tmp";
      cs["el"][curVtxIdx]["animateHighlighted"] = true;
      cs["el"][curVtxIdx]["state"] = EDGE_TRAVERSED;
      // Set up temp pointer.
      // temp will eventually point to the current tail.
      cs["status"] = 'Set up tmp pointer.<br>tmp will eventually point to the current tail.';
      cs["lineNo"] = 3;
      stateList.push(cs);

      // Find vertex
      var i = 0;
      while (true) {
        cs = createState(iL, vertexTraversed, edgeTraversed);
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = (i == 0 ? "h/" : "") + "p";
        nextVtxIdx = iL[nextVertex]["vtxIdx"];
        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
        cs["vl"][nextVtxIdx]["extratext"] = (iL[nextVertex]["next"] == null ? "t/" : "") + "tmp";
        vertexTraversed[currentVertex] = true;
        // Check if temp.next is null.
        cs["status"] = 'Check if tmp.next is null.';
        cs["lineNo"] = 4;
        stateList.push(cs);

        if (iL[nextVertex]["next"] != null) {
          nextVertex = iL[nextVertex]["next"];
          currentVertex = iL[currentVertex]["next"];
          i++;
        }
        else
          break;

        // pre = pre.next, temp = temp.next
        cs = createState(iL, vertexTraversed, edgeTraversed);
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = (i == 0 ? "h/" : "") + "p";
        nextVtxIdx = iL[nextVertex]["vtxIdx"];
        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
        cs["vl"][nextVtxIdx]["extratext"] = (iL[nextVertex]["next"] == null ? "t/" : "") + "tmp";
        vertexTraversed[currentVertex] = true;
        curVtx = iL[currentVertex]["prev"];
        var edgeHighlighted = iL[curVtx]["vtxIdx"];
        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
        edgeTraversed[edgeHighlighted] = true;
        var edgeHighlighted2 = iL[currentVertex]["vtxIdx"];
        cs["el"][edgeHighlighted2]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted2]["state"] = EDGE_GREEN;
        // It is not null.
        // So both pre and temp pointers advance to their next vertex.
        cs["status"] = 'It is not null.<br>So both pre and tmp pointers advance to their next vertex.';
        cs["lineNo"] = 5;
        stateList.push(cs);
      }

      // pre.next = null
      var curVtx = iL[nextVertex]["prev"];
      if (curVtx != null) iL[curVtx]["next"] = null;
      else                iL["head"] = null;

      cs = createState(iL, vertexTraversed, edgeTraversed);
      curVtxIdx = iL[currentVertex]["vtxIdx"];
      nextVtxIdx = iL[nextVertex]["vtxIdx"];
      // cs["el"][curVtxIdx]["state"] = OBJ_HIDDEN;
      cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][curVtxIdx]["extratext"] = (i == 0 ? "h/" : "") + "p";
      nextVtxIdx = iL[nextVertex]["vtxIdx"];
      cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][nextVtxIdx]["extratext"] = "t/tmp";
      vertexTraversed[currentVertex] = true;
      // It is null.
      // So set the next of pre (the new tail) to null.
      cs["status"] = 'It is null.<br>So set the next of pre (the new tail) to null.';
      cs["lineNo"] = 6;
      stateList.push(cs);

      // delete temp, tail = pre
      delete iL[nextVertex];
      delete vertexTraversed[nextVertex];
      delete edgeTraversed[nextVtxIdx];

      --amountVertex;

      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
      if (amountVertex == 1) cs["vl"][curVtxIdx]["extratext"] = "head/tail";
      // Delete temp (the previous tail) then update the tail pointer to prev (the current tail). The whole process is O(N) just to find the pre pointer.
      cs["status"] = 'Delete tmp (the previous tail) then update the tail pointer to pre (the current tail). The whole process is O(N) just to find the pre pointer.';
      cs["lineNo"] = 7;
      stateList.push(cs);
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(6);
    return true;
  }

  this.removeTailDLL = function(startAnimationDirectly, callback) {
    if (amountVertex == 1) return this.removeHead(startAnimationDirectly, callback);

    if (startAnimationDirectly) {
      stateList = [];
      populatePseudocode(8);
    }

    var vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {};

    if (currentVertex == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The Linked List is already empty.
      // No action is performed.
      cs["status"] = 'The Linked List is already empty.<br>No action is performed.';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      var nextVertex = iL[currentVertex]["next"];
      var curVtxIdx, nextVtxIdx;

      while (iL[nextVertex]["next"] != null) {
        nextVertex = iL[nextVertex]["next"];
        currentVertex = iL[currentVertex]["next"];
      }

      curVtxIdx = iL[currentVertex]["vtxIdx"];
      nextVtxIdx = iL[nextVertex]["vtxIdx"];

      // temp = tail
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][nextVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][nextVtxIdx]["extratext"] = "tail/temp";
      // Set temp to (old) tail.
      cs["status"] = 'Set tmp to (old) tail.';
      cs["lineNo"] = 2;
      stateList.push(cs);

      // tail = tail.prev
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][nextVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][nextVtxIdx]["extratext"] = "tmp";
      cs["el"][curVtxIdx + BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
      cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][curVtxIdx]["extratext"] = "tail";
      // Set tail to tail.prev
      cs["status"] = 'Set tail to tail.prev';
      cs["lineNo"] = 3;
      stateList.push(cs);

      // tail.next = null
      // 18 Apr, combine these two frames into one
/*
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][curVtxIdx]["extratext"] = "tail";
      cs["vl"][nextVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][nextVtxIdx]["extratext"] = "temp";
      cs["el"][curVtxIdx]["state"] = OBJ_HIDDEN;
      vertexTraversed[currentVertex] = true;
      // Set the next of (new) tail to null.
      cs["status"] = 'Set the next of (new) tail to null.';
      cs["lineNo"] = 4;
      stateList.push(cs);
*/
      var curVtx = iL[nextVertex]["prev"];
      if (curVtx != null) iL[curVtx]["next"] = null;
      else                iL["head"] = null;

      delete iL[nextVertex];
      delete vertexTraversed[nextVertex];
      delete edgeTraversed[nextVtxIdx];

      --amountVertex;

      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
      if (amountVertex == 1) cs["vl"][curVtxIdx]["extratext"] = "head/tail";
      // Delete temp.
      // The whole operations is just O(1) as we can access (old) tail.prev.
      cs["status"] = 'Set the next of (new) tail to null.' + '; ' + 'Delete tmp.<br>The whole operations is just O(1) as we can access (old) tail.prev.';
      cs["lineNo"] = [4, 5];
      stateList.push(cs);
    }

    if (startAnimationDirectly) graphWidget.startAnimation(stateList, callback);
    return true;
  }

  this.removeKTailDLL = function(k, callback) {
    if (k > amountVertex) {
      $('#remove-err').html("K must be &le; N");
      if (typeof callback == 'function') callback();
      return false;
    }

    stateList = [];
    var vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;

    populatePseudocode(8);
    for (var i = 0; i < k; ++i) {
      this.removeTailDLL(false);
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["lineNo"] = 1;
      stateList.push(cs);
    }

    graphWidget.startAnimation(stateList, callback);
    return true;
  }


  this.removeKth = function(v, callback) {
    var index = parseInt(v);

    // Check whether value is number
    if (isNaN(index)) {
      $('#remove-err').html('Please fill in an Integer.');
      return false;
    }
    if (amountVertex < 3) {
      // This operation only works for N bigger than 2.
      $('#remove-err').html('This operation only works for N bigger than 2.');
      return false;
    }
    if ((index < 1) || (index >= amountVertex-1)) {
      // Please enter a valid index between [1..{limit}].
      $('#remove-err').html('Please enter a valid index between [1..{limit}].'.replace("{limit}", Math.max(1, amountVertex-2)));
      return false;
    }

    if (index == 0) return this.removeHead(true); // not going to be executable
    if (index == amountVertex-1) {
      if (this.getActiveStatus() == "doublylist") return this.removeTailDLL(true);
      else                                        return this.removeTail();
    }

    stateList = [];
    var vertexTraversed = {}, edgeTraversed = {}, prevVtx = iL["head"], delVtx, afterVtx, cs = {};
    var prevIdx, delIdx, afterIdx;

    if (prevVtx == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The Linked List is already empty.
      // No action is performed.
      cs["status"] = 'The Linked List is already empty.<br>No action is performed.';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      // Vertex pre = head
      prevIdx = iL[prevVtx]["vtxIdx"];
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][prevIdx]["extratext"] = "h/p/0";
      // Set prev to head.
      // Pointer prev will stop at one vertex before the deleted vertex.
      cs["status"] = 'Set prev to head.<br>Pointer prev will stop at one vertex before the deleted vertex.';
      cs["lineNo"] = 2;
      stateList.push(cs);

      // Find vertex
      for (i = 0; i < index-1; ++i) {
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][prevIdx]["extratext"] = (i == 0 ? "h/" : "") + "p/" + i;
        vertexTraversed[prevVtx] = true;
        // Index specified has not been reached.
        // k = {k}.
        cs["status"] = 'Index specified has not been reached.<br>k = {i}.'.replace("{k}", i);
        cs["lineNo"] = 3;
        stateList.push(cs);

        // important assignment
        var edgeHighlighted = iL[prevVtx]["vtxIdx"]; // before moving
        prevVtx = iL[prevVtx]["next"];
        prevIdx = iL[prevVtx]["vtxIdx"];

        // pre = pre.next
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][prevIdx]["extratext"] = "p/" + (i+1);
        edgeTraversed[edgeHighlighted] = true;
        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
        // Pointer prev advances to the next vertex.
        cs["status"] = 'Pointer prev advances to the next vertex.';
        cs["lineNo"] = 4;
        stateList.push(cs);
      }

      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][prevIdx]["extratext"] = "p/" + i;
      vertexTraversed[prevVtx] = true;
      // k is 0, prev now points to one vertex behind the vertex to-be-deleted.
      // We stop searching and continue with the removal.
      cs["status"] = 'k is 0, prev now points to one vertex behind the vertex to-be-deleted.<br>We stop searching and continue with the removal.';
      cs["lineNo"] = 3;
      stateList.push(cs);

      var delVertex = iL[prevVtx]["next"];
      delIdx = iL[delVertex]["vtxIdx"];
      var afterVertex = iL[delVertex]["next"];
      afterIdx = iL[afterVertex]["vtxIdx"];

      // Vertex del = prev.next
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][prevIdx]["extratext"] = "p/" + i;
      cs["vl"][delIdx]["state"] = VERTEX_RED_FILL;
      cs["vl"][delIdx]["extratext"] = "del/" + (i+1);
      cs["vl"][afterIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][afterIdx]["extratext"] = "a/" + (i+2);
      edgeTraversed[prevIdx] = edgeTraversed[delIdx] = true;
      cs["el"][prevIdx]["animateHighlighted"] = cs["el"][delIdx]["animateHighlighted"] = true;
      cs["el"][prevIdx]["state"] = EDGE_HIGHLIGHTED;
      cs["el"][delIdx]["state"] = EDGE_HIGHLIGHTED;
      if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
        cs["el"][prevIdx+BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
        cs["el"][delIdx+BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED; // RED;
      }
      vertexTraversed[prevVtx] = true;
      // We store reference to the vertex to-be-deleted.
      // We also store reference to the vertex after the to-be-deleted vertex.
      cs["status"] = 'We store reference to the vertex to-be-deleted.<br>We also store reference to the vertex after the to-be-deleted vertex.';
      cs["lineNo"] = 5;
      stateList.push(cs);

      // prev.next = after, after.prev = prev (for DLL and deque)
      iL[delVertex]["cy"] = 50; // iL[delVertex]["cy"]-50; // make this go up
      iL[prevVtx]["next"] = afterVertex;
      iL[afterVertex]["prev"] = prevVtx;
      --amountVertex;

      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][prevIdx]["extratext"] = "p/" + i;
      cs["vl"][delIdx]["state"] = VERTEX_RED_FILL;
      cs["vl"][delIdx]["extratext"] = "del";
      cs["vl"][afterIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][afterIdx]["extratext"] = "a/" + (i+1);
      cs["el"][prevIdx]["animateHighlighted"] = true;
      cs["el"][prevIdx]["state"] = EDGE_HIGHLIGHTED;
      if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
        cs["el"][prevIdx+BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
        cs["el"][prevIdx+BACK_EDGE_CONST]["animateHighlighted"] = true;
        cs["el"][delIdx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
      }
      // We connect the vertex behind the vertex to-be-deleted (pointer prev) with the next vertex after the vertex to-be-deleted (pointer after).
      cs["status"] = 'We connect the vertex behind the vertex to-be-deleted (pointer prev) with the next vertex after the vertex to-be-deleted (pointer after).';
      cs["lineNo"] = 6;
      stateList.push(cs);

      // delete temp
      delete iL[delVertex];
      delete vertexTraversed[delVertex];
      delete edgeTraversed[delIdx];
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][afterIdx]["state"] = VERTEX_GREEN_FILL;
      // Now we delete this vertex.
      cs["status"] = 'Now we delete this vertex.';
      cs["lineNo"] = 7;
      stateList.push(cs);

      // relayout list
      // recalculatePosition();
      cs = createState(iL, {}, {});
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][afterIdx]["state"] = VERTEX_GREEN_FILL;
      if (amountVertex == 1) cs["vl"][afterIdx]["extratext"] = "head/tail";
      // Re-layout the Linked List for visualization.
      // The whole process is O({N}).
      cs["status"] = 'Re-layout the Linked List for visualization (not in the actual Linked List).<br>The whole process is still O({N}).'.replace("{N}", "N");
      stateList.push(cs);
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(7);
    return true;
  }

  function init(initArr) {
    clearScreen();
    amountVertex = 0;

    for (var i = 0; i < initArr.length; ++i) {
      var curVtx = iL["head"];
      var newVtx = parseInt(initArr[i]);

      if (curVtx == null) {
        iL["head"] = parseInt(newVtx);
        iL[newVtx] = {
          "prev": null,
          "next": null,
          "vtxIdx": amountVertex
        };
      }
      else {
        while (true) { // go to tail
          if (iL[curVtx]["next"] == null) break;
          curVtx = iL[curVtx]["next"];
        }
        iL[curVtx]["next"] = newVtx;
        iL[newVtx] = {
          "prev": curVtx,
          "next": null,
          "vtxIdx": amountVertex
        }
      }

      ++amountVertex;
    }

    recalculatePosition();

    for (key in iL) {
      if (key == "head") continue;
      graphWidget.addVertex(iL[key]["cx"], iL[key]["cy"], key, iL[key]["vtxIdx"], true, (iL["head"] == key ? "head" : (iL[key]["next"] == null ? "tail" : ""))); // iL[key]["vtxIdx"] + 
    }

    for (key in iL) {
      if (key == "head") continue;
      if (key == iL["head"]) continue;
      var curVtx = iL[key]["prev"];

      if ((activeStatus == "doublylist") || (activeStatus == "deque"))
        graphWidget.addEdge(iL[key]["vtxIdx"], iL[curVtx]["vtxIdx"], iL[curVtx]["vtxIdx"]+BACK_EDGE_CONST, EDGE_TYPE_DE, 1, true);
      graphWidget.addEdge(iL[curVtx]["vtxIdx"], iL[key]["vtxIdx"], iL[curVtx]["vtxIdx"], EDGE_TYPE_DE, 1, true);
    }

    if (amountVertex > 15)
      setMediumScale();
    else
      setDefaultScale();

    var newState = createState(iL, {}, {});
    graphWidget.updateGraph(newState, 500); // do this so that bidirectional edges are drawn as bidirectional...
  }

  function clearScreen() {
    var key;

    for (key in iL) {
      if (key == "head") continue;
      graphWidget.removeEdge(iL[key]["vtxIdx"]+BACK_EDGE_CONST);
      graphWidget.removeEdge(iL[key]["vtxIdx"]);
    }

    for (key in iL) {
      if (key == "head") continue;
      graphWidget.removeVertex(iL[key]["vtxIdx"]);
    }

    iL = {};
    iL["head"] = null;
    amountVertex = 0;
  }

/*
  this.redraw = function() {
    curArr = this.getA();
    init(curArr);
  }
*/

  this.getN = function() {
    return amountVertex;
  }

  /*
   * iLObject: a JS object with the same structure of iL. This means the List doen't have to be the List stored in this class
   * vertexTraversed: JS object with the vertexes of the List which are to be marked as traversed as the key
   * edgeTraversed: JS object with the edges of the List which are to be marked as traversed as the key
   */

  function createState(iLObject, vertexTraversed, edgeTraversed) {
    if (vertexTraversed == null || vertexTraversed == undefined || !(vertexTraversed instanceof Object))
      vertexTraversed = {};
    if (edgeTraversed == null || edgeTraversed == undefined || !(edgeTraversed instanceof Object))
      edgeTraversed = {};

    var state = {
      "vl": {},
      "el": {}
    };
    var key;

    for (key in iLObject) {
      if (key == "head") continue;

      idx = iLObject[key]["vtxIdx"];

      state["vl"][idx] = {};
      state["vl"][idx]["cx"] = iLObject[key]["cx"];
      state["vl"][idx]["cy"] = iLObject[key]["cy"];
      state["vl"][idx]["text"] = key;
      state["vl"][idx]["state"] = VERTEX_DEFAULT;

      if (iLObject[key]["next"] == null) continue;

      parentChildEdgeId = iLObject[key]["vtxIdx"];

      state["el"][parentChildEdgeId] = {};

      state["el"][parentChildEdgeId]["vertexA"] = iLObject[key]["vtxIdx"];
      state["el"][parentChildEdgeId]["vertexB"] = iLObject[iLObject[key]["next"]]["vtxIdx"];
      state["el"][parentChildEdgeId]["type"] = EDGE_TYPE_DE;
      state["el"][parentChildEdgeId]["weight"] = 1;
      state["el"][parentChildEdgeId]["state"] = EDGE_DEFAULT;
      state["el"][parentChildEdgeId]["animateHighlighted"] = false;

      // add an edge for doubly linked list
      if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
        parentChildEdgeId = iLObject[key]["vtxIdx"]+BACK_EDGE_CONST;
        state["el"][parentChildEdgeId] = {};

        state["el"][parentChildEdgeId]["vertexA"] = iLObject[iLObject[key]["next"]]["vtxIdx"]; // where is 'prev'?
        state["el"][parentChildEdgeId]["vertexB"] = iLObject[key]["vtxIdx"];
        //if (iLObject[key]["prev"] == null) continue;
        //state["el"][parentChildEdgeId]["vertexA"] = iLObject[key]["vtxIdx"]; // iLObject[iLObject[key]["next"]]["vtxIdx"]; // where is 'prev'?
        //state["el"][parentChildEdgeId]["vertexB"] = iLObject[iLObject[key]["prev"]]["vtxIdx"];
        state["el"][parentChildEdgeId]["type"] = EDGE_TYPE_DE;
        state["el"][parentChildEdgeId]["weight"] = 1;
        state["el"][parentChildEdgeId]["state"] = EDGE_DEFAULT;
        state["el"][parentChildEdgeId]["animateHighlighted"] = false;
      }
    }

    var cur = iLObject["head"], idx = 0;
    while (cur != null) {
      curIdx = iLObject[cur]["vtxIdx"];
      // state["vl"][curIdx]["extratext"] = idx;
           if (idx == 0)                      state["vl"][curIdx]["extratext"] = "head/0";
      else if (iLObject[cur]["next"] == null) state["vl"][curIdx]["extratext"] = "tail/" + (amountVertex-1);
      cur = iLObject[cur]["next"];
      idx++;
    }

    for (key in vertexTraversed) {
      idx = iLObject[key]["vtxIdx"];
      state["vl"][idx]["state"] = VERTEX_TRAVERSED;
    }

    for (key in edgeTraversed) {
      state["el"][key]["state"] = EDGE_TRAVERSED;
      //if (state["el"][key+BACK_EDGE_CONST] != null) state["el"][key+BACK_EDGE_CONST] = EDGE_TRAVERSED;
    }

    return state;
  }

  function recalculatePosition() {
    updatePosition(iL["head"]);

    function updatePosition(currentVertex) {
      if (currentVertex == null) return;

      if (activeStatus == "stack") { // relayout vertical
        if (currentVertex == iL["head"])
          iL[currentVertex]["cy"] = 400 - (amountVertex*50);
        else {
          var curVtx = iL[currentVertex]["prev"]
          iL[currentVertex]["cy"] = iL[curVtx]["cy"]+50; // standard for now
        }
        iL[currentVertex]["cx"] = 350;
      }
      else { // relayout horizontal, for everything else
        if (currentVertex == iL["head"])
          iL[currentVertex]["cx"] = 200; // 24 Apr: give room so that 50, 100, 150 can be used for 3 more InsertHeads before relayout
        else {
          var curVtx = iL[currentVertex]["prev"];
          iL[currentVertex]["cx"] = iL[curVtx]["cx"]+50; // sideway to right
        }
        iL[currentVertex]["cy"] = 100;
      }

      updatePosition(iL[currentVertex]["next"]);
    }
  }

  function populatePseudocode(act) {
    switch (act) {
      case 4: // search
        $('#code1').html('if empty, return NOT_FOUND');
        $('#code2').html('index = 0, tmp = head');
        $('#code3').html('while (tmp.item != v)');
        $('#code4').html('&nbsp&nbsp' + 'index++, tmp = tmp.next');
        $('#code5').html('&nbsp&nbspif tmp == null');
        $('#code6').html('&nbsp&nbsp&nbsp&nbspreturn NOT_FOUND');
        $('#code7').html('return index');
        break;
      case 3: // peek
        $('#code1').html('if empty, return NOT_FOUND');
        $('#code2').html('return head.item');
        $('#code3').html('');
        $('#code4').html('');
        $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;
      case 9: // peek back
        $('#code1').html('if empty, return NOT_FOUND');
        $('#code2').html('return tail.item');
        $('#code3').html('');
        $('#code4').html('');
        $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;
      case 10: // pop k times
        $('#code1').html('for (i = 0; i < K; ++i)');  // TODO: save the for loop code into varlist as an element
        $('#code2').html('&nbsp&nbsptmp = head');
        $('#code3').html('&nbsp&nbsphead = head.next');
        $('#code4').html('&nbsp&nbspdelete tmp');
        $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;

      case 1: // insertHead
        $('#code1').html('Vertex vtx = new Vertex(v)');
        $('#code2').html('vtx.next = head');
        if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
          $('#code3').html('if (head != null) head.prev = vtx');
          if (amountVertex == 1)
            $('#code4').html('head = vtx, tail = head');
          else
            $('#code4').html('head = vtx');
        }
        else if (amountVertex == 1) {
          $('#code3').html('head = vtx, tail = head');
          $('#code4').html('');
        }
        else {
          $('#code3').html('head = vtx');
          $('#code4').html('');
        }
        $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;
      case 2: // insertTail
        $('#code1').html('Vertex vtx = new Vertex(v)');
        if ((activeStatus == "doublylist") || (activeStatus == "deque"))
          $('#code2').html('tail.next = vtx, vtx.prev = tail');
        else
          $('#code2').html('tail.next = vtx');
        $('#code3').html('tail = vtx');
        $('#code4').html('');
        $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;
      case 0: // Insert
        $('#code1').html('Vertex pre = head');
        $('#code2').html('for (k = 0; k < i-1; k++)');
        $('#code3').html('&nbsp&nbsp' + 'pre = pre.next');
        $('#code4').html('Vertex aft = pre.next');
        $('#code5').html('Vertex vtx = new Vertex(v)');
        if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
          $('#code6').html('vtx.next = aft, aft.prev = vtx');
          $('#code7').html('pre.next = vtx, vtx.prev = pre');
        }
        else {
          $('#code6').html('vtx.next = aft');
          $('#code7').html('pre.next = vtx');
        }
        break;

      case 5: // remove head
        $('#code1').html('if empty, do nothing');
        $('#code2').html('tmp = head');
        $('#code3').html('head = head.next');
        $('#code4').html('delete tmp');
        if ((activeStatus == "doublylist") || (activeStatus == "deque"))
          $('#code5').html('if (head != null) head.prev = null');
        else
          $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;
      case 6: // remove tail (SLL)
        $('#code1').html('if empty, do nothing');
        $('#code2').html('Vertex pre = head');
        $('#code3').html('tmp = head.next');
        $('#code4').html('while (tmp.next != null)');
        $('#code5').html('&nbsp&nbsp' + 'pre = pre.next');
        $('#code6').html('pre.next = null');
        $('#code7').html('delete tmp, tail = pre');
        break;
      case 7: // remove kth
        $('#code1').html('if empty, do nothing');
        $('#code2').html('Vertex pre = head');
        $('#code3').html('for (k = 0; k < i-1; k++)');
        $('#code4').html('&nbsp&nbsp' + 'pre = pre.next');
        $('#code5').html('Vertex del = pre.next, aft = del.next');
        if ((activeStatus == "doublylist") || (activeStatus == "deque"))
          $('#code6').html('pre.next = aft, aft.prev = pre');
        else
          $('#code6').html('pre.next = aft // bypass del');
        $('#code7').html('delete del');
        break;
      case 8: // remove tail (DLL, easier)
        $('#code1').html('if empty, do nothing');
        $('#code2').html('tmp = tail');
        $('#code3').html('tail = tail.prev');
        $('#code4').html('tail.next = null');
        $('#code5').html('delete tmp');
        $('#code6').html('');
        $('#code7').html('');
        break;
    }
  }
}



// List actions
// actions panel stuff
var actionsWidth = 150;
var statusCodetraceWidth = 420;

// local
// title changing
function SOP() {
  if (isPlaying) stop();
  showActionsPanel();
  hideStatusPanel();
  hideCodetracePanel();
  $("#title-LL").text("LL");
  $("#title-DLL").text("DLL");
}

$('#title-LL').click(function() {
  SOP();
  displayList();
  changeTextList();
  lw.setActiveStatus("list");
  $("#title-LL").text('Linked List');
});

$('#title-Stack').click(function() {
  SOP();
  displayStack();
  changeTextStack();
  lw.setActiveStatus("stack");
});

$('#title-Queue').click(function() {
  SOP();
  displayQueue();
  changeTextQueue();
  lw.setActiveStatus("queue");
});

$('#title-DLL').click(function() {
  SOP();
  displayList();
  changeTextDoublyList();
  lw.setActiveStatus("doublylist");
  $("#title-DLL").text('Doubly Linked List');
});

$('#title-Deque').click(function() {
  SOP();
  displayDeque();
  changeTextDeque();
  lw.setActiveStatus("deque");
});

var lw, gw;

$(function() {
  $('#play').hide();
  lw = new List();
  gw = lw.getGraphWidget();
  gw.setAnimationDuration(700 / speedVal);
  var five_modes = ["LL", "Stack", "Queue", "DLL", "Deque"];
  var rand_mode = Math.floor(Math.random()*5);
  $('#title-'+five_modes[rand_mode]).click(); // randomly open one of the five default example every time

  var llMode = getQueryVariable("mode");
  if (llMode.length > 0) {
    $('#title-' + llMode).click();
  }
  var createLL = getQueryVariable("create");
  if (createLL.length > 0) {
    var newLL = createLL.split(",");
    lw.generate(newLL);
  }
  var operation = getQueryVariable("operation");
  var operationValue = getQueryVariable("operationValue");
  var operationMode = getQueryVariable("operationMode");
  if (operation.length > 0) {
    switch (operation) {
      case "insert":
        //openInsert();
        openAction("insert");
        console.log("going to the insert model with " + operationMode);
        //toggleChildExtras("insert");
        insertModelingOpen(operationMode);
        $("#" + operationMode + "-input input").val(operationValue);
    }
  }

  if (rand_mode == 1) // Stack
    $('#v-create-size').val(2 + Math.floor(Math.random()*6)); // [2..7] // smaller
  else
    $('#v-create-size').val(5 + Math.floor(Math.random()*11)); // [5..15] // longer

  if (Math.random() > 0.5) // 50% chance totally random
    $('#v-search').val(1 + Math.floor(Math.random()*99));
  else { // 50% something that is inside the list
    var a = lw.getA();
    $('#v-search').val(a[Math.floor(Math.random()*a.length)]);
  }

  $('#v-insert-head-value').val(1 + Math.floor(Math.random()*99));
  $('#v-insert-tail-value').val(1 + Math.floor(Math.random()*99));
  $('#v-insert-kth').val(1 + Math.floor(Math.random()*(lw.getN()-1))); // [1..N-1]
  $('#v-insert-kth-value').val(1 + Math.floor(Math.random()*99));

  $('#v-push-top-value').val((1 + Math.floor(Math.random()*99)) + ',' + (1 + Math.floor(Math.random()*99)));
  
  $('#v-enqueue-back-value').val((1 + Math.floor(Math.random()*99)) + ',' + (1 + Math.floor(Math.random()*99)));

  $('#v-remove-kth').val(1 + Math.floor(Math.random()*(lw.getN()-2))); // [1..N-2]
});

/*
function setDefaultScale() {
  if (isPlaying) stop();
  isPlaying = false;
  if (scale) {
    scale = !scale;
    gw.redrawAllForMediumScale();
    gw.setMediumScale(false);
  }
}

function setMediumScale() {
  if (isPlaying) stop();
  isPlaying = false;
  if (!scale) {
    scale = !scale;
    gw.redrawAllForMediumScale();
    gw.setMediumScale(true);
  }
}

function toggleVertexNumber() {
  if (isPlaying) stop();
  isPlaying = false;
  if (scale)
    gw.toggleVertexNumber();
}
*/

function allOff() {
  $("#search-input").css("display", "none");
  $("#search-go").css("display", "none");
  $("#search-peek-front").css("display", "none");
  $("#search-peek-back").css("display", "none");

  $("#insert-head").css("display", "none");
  $("#insert-tail").css("display", "none");
  $("#insert-kth").css("display", "none");
  $("#pushtop-input").css("display", "none");
  $("#pushtop-go").css("display", "none");
  $("#enqueueback-input").css("display", "none");
  $("#enqueueback-go").css("display", "none");
  $("#insert-deque-input").css("display", "none");
  $("#insert-deque-front").css("display", "none");
  $("#insert-deque-back").css("display", "none");

  $("#remove-head").css("display", "none");
  $("#remove-tail").css("display", "none");
  $("#remove-kth").css("display", "none");
  $("#remove-deque-input").css("display", "none");
  $("#remove-deque-front").css("display", "none");
  $("#remove-deque-back").css("display", "none");
  $("#remove-queue-once").css("display", "none");
  $("#remove-queue-input").css("display", "none");
  $("#remove-queue-ktimes").css("display", "none");
  $("#pop-once").css("display", "none");
  $("#pop-ktimes-input").css("display", "none");
  $("#pop-ktimes").css("display", "none");
}

function displayList() {
  allOff();

  $("#search-input").css("display", "");
  $("#search-go").css("display", "");

  $("#insert-head").css("display", "");
  $("#insert-tail").css("display", "");
  $("#insert-kth").css("display", "");

  $("#remove-head").css("display", "");
  $("#remove-tail").css("display", "");
  $("#remove-kth").css("display", "");
}

function displayStack() {
  allOff();

  $("#pushtop-input").css("display", "");
  $("#pushtop-go").css("display", "");

  $("#pop-once").css("display", "");
  $("#pop-ktimes-input").css("display", "");
  $("#pop-ktimes").css("display", "");
}

function displayQueue() {
  allOff();

  $("#search-peek-front").css("display", "");
  $("#search-peek-back").css("display", "");

  $("#enqueueback-input").css("display", "");
  $("#enqueueback-go").css("display", "");

  $("#remove-queue-once").css("display", "");
  $("#remove-queue-input").css("display", "");
  $("#remove-queue-ktimes").css("display", "");
}

function displayDeque() {
  allOff();

  $("#search-peek-front").css("display", "");
  $("#search-peek-back").css("display", "");

  $("#insert-deque-input").css("display", "");
  $("#insert-deque-front").css("display", "");
  $("#insert-deque-back").css("display", "");

  $("#remove-deque-input").css("display", "");
  $("#remove-deque-front").css("display", "");
  $("#remove-deque-back").css("display", "");
}

function changeTextList() {
  $("#search").text('Search');
  $("#insert").text('Insert');
  $("#remove").text('Remove');
}

function changeTextStack() {
  $("#search").text('Peek');
  $("#insert").text('Push');
  $("#remove").text('Pop');
}

function changeTextQueue() {
  $("#search").text('Peek');
  $("#insert").text('Enqueue');
  $("#remove").text('Dequeue');
}

function changeTextDoublyList() {
  $("#search").text('Search');
  $("#insert").text('Insert');
  $("#remove").text('Remove');
}

function changeTextDeque() {
  $("#search").text('Peek');
  $("#insert").text('Enqueue');
  $("#remove").text('Dequeue');
}

function empty() {
  event.stopPropagation();
  if (isPlaying) stop();
  if (lw.generateRandomFixedSize(0, false)) {
    $('#progress-bar').slider("option", "max", 0);
    isPlaying = false;
  }
  hideStatusPanel();
  hideCodetracePanel();
}

function nonRandom() {
/*
  try {
    event.stopPropagation(); // crucial line to add for all methods that are called from a third tier
    console.log("successfully stopped propagation");
  } catch(error) {
    console.log('complication occured in nonRandom()');
  }
*/
  if (isPlaying) stop();
  var input = $('#v-create-arr').val();
  input = input.split(",");
  if (lw.generateUserDefined(input)) {
    $('#progress-bar').slider("option", "max", 0);
    isPlaying = false;
  }
  hideStatusPanel();
  hideCodetracePanel();
}

function random() {
  event.stopPropagation();
  if (isPlaying) stop();
  var N = parseInt($('#v-create-size').val());
  if (lw.generateRandomFixedSize(N, false)) {
    $('#progress-bar').slider("option", "max", 0);
    isPlaying = false;
  }
  hideStatusPanel();
  hideCodetracePanel();
}

function randomSorted() {
  event.stopPropagation();
  if (isPlaying) stop();
  var N = parseInt($('#v-create-size').val());
  if (lw.generateRandomFixedSize(N, true)) {
    $('#progress-bar').slider("option", "max", 0);
    isPlaying = false;
  }
  hideStatusPanel();
  hideCodetracePanel();
}

function searchVertex(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#v-search').val());
  commonAction(lw.search(input, callback), "Search " + input);
  setTimeout(function() {
    if (Math.random() > 0.5) // 50% chance totally random
      $('#v-search').val(1 + Math.floor(Math.random()*99));
    else { // 50% something that is inside the list
      var a = lw.getA();
      $('#v-search').val(a[Math.floor(Math.random()*a.length)]);
    }
  }, 500);
}

function peekStack(callback) {
  if (isPlaying) stop();
  commonAction(lw.peek(true, callback), 'Peek top (head)');
}

function searchGeneric(callback) {
  if (lw.getActiveStatus() == "stack")
    peekStack(callback);
}

function peekQueueDeque(location, callback) {
  if (isPlaying) stop();
  if (location == "front")
    commonAction(lw.peek(true, callback), 'Peek front (head)');
  else
    commonAction(lw.peek(false, callback), 'Peek back (tail)');
}

function insertHead(callback) {
  try {
    event.stopPropagation(); //crucial line to add for all methods that are called from a third tier
  } catch(error) {
    console.log(error);
  }
  if (isPlaying) stop();
  var input = $('#v-insert-head-value').val();
  commonAction(lw.insertHead([input], callback), 'Insert {input} at head'.replace("{input}", input));
  setTimeout(function() { $('#v-insert-head-value').val(1 + Math.floor(Math.random()*99)); }, 500);
}

function insertTail(callback) {
  try {
    event.stopPropagation(); //crucial line to add for all methods that are called from a third tier
  } catch(error) {
    console.log(error);
  }
  if (isPlaying) stop();
  var input = parseInt($('#v-insert-tail-value').val());
  commonAction(lw.insertTail([input], callback), 'Insert {input} at tail'.replace("{input}", input));
  setTimeout(function() { $('#v-insert-tail-value').val(1 + Math.floor(Math.random()*99)); }, 500);
}

function insertKth(callback) {
  event.stopPropagation(); //crucial line to add for all methods that are called from a third tier
  if (isPlaying) stop();
  var index = parseInt($('#v-insert-kth').val());
  var input = parseInt($('#v-insert-kth-value').val());
  commonAction(lw.insertKth(index, input, callback), 'Insert {input} at index {index}'.replace("{input}", input).replace("{index}", index));
  setTimeout(function() {
    $('#v-insert-kth').val(1 + Math.floor(Math.random()*(lw.getN()-1))); // [1..N-1]
    $('#v-insert-kth-value').val(1 + Math.floor(Math.random()*99));
  }, 500);
}

function pushTop(callback) {
  if (isPlaying) stop();
  var input = $('#v-push-top-value').val();
  commonAction(lw.insertHead(input.split(","), callback), 'Push {input} at top (head)'.replace("{input}", input));
  setTimeout(function() { $('#v-push-top-value').val(1 + Math.floor(Math.random()*99)); }, 500);
}

function enqueueBack(callback) {
  if (isPlaying) stop();
  var input = $('#v-enqueue-back-value').val();
  commonAction(lw.insertTail(input.split(","), callback), 'Enqueue {input} at back (tail)'.replace("{input}", input));
  setTimeout(function() { $('#v-enqueue-back-value').val(1 + Math.floor(Math.random()*99)); }, 500);
}

function insertDeque(location) {
  if (isPlaying) stop();
  var input = $('#v-insert-deque-value').val();
  if (location == "front")
    commonAction(lw.insertHead(input.split(",")), 'Enqueue {input} to front (head)'.replace("{input}", input));
  else
    commonAction(lw.insertTail(input.split(",")), 'Enqueue {input} to back (tail)'.replace("{input}", input));
  setTimeout(function() { $('#v-insert-deque-value').val(1 + Math.floor(Math.random()*99)); }, 500);
}

function removeHead(callback) { // PS both pop/stack and dequeue/queue also calls the same thing: remove head
  if (isPlaying) stop();
  commonAction(lw.removeHead(callback), 'Remove i = 0 (Head)');
}

function popKTimes(callback) {
  if (isPlaying) stop();
  var input = parseInt($("#K-remove-stack").val());
  if (lw.getActiveStatus() == "queue")
    input = parseInt($("#K-remove-queue").val());
    
  commonAction(lw.popKTimes(input, callback), 'Remove i = 0 (Head)' + ", K = " + input)
}

function removeTail(callback) {
  if (isPlaying) stop();
  if (lw.getActiveStatus() == "doublylist" || lw.getActiveStatus() == "deque")
    commonAction(lw.removeTailDLL(true, callback), 'Remove i = N-1 (Tail)');
  else
    commonAction(lw.removeTail(callback), 'Remove i = N-1 (Tail)');
}

function removeKth(callback) {
  event.stopPropagation(); //crucial line to add for all methods that are called from a third tier
  if (isPlaying) stop();
  var input = parseInt($('#v-remove-kth').val());
  commonAction(lw.removeKth(input, callback), 'Remove index {input}'.replace("{input}", input));
  setTimeout(function() { $('#v-remove-kth').val(1 + Math.floor(Math.random()*(lw.getN()-2))); }, 500); // [1..N-2]
}

function removeDeque(location) {
  if (isPlaying) stop();
  var input = parseInt($("#K-remove-deque").val());
  if (location == "front")
    commonAction(lw.popKTimes(input), 'Remove front (head)');
  else
    commonAction(lw.removeKTailDLL(input), 'Remove back (tail)');
  setTimeout(function() { $('#K-remove-deque').val(1); }, 500);
}

// Implement these functions in each visualisation
// var userGraph = {
//   'vl': {},
//   'el': {},
// };

// This function will be called before entering E-Lecture Mode
function ENTER_LECTURE_MODE() {
  //if (lw) userGraph = lw.getGraph();
}

// This function will be called before returning to Explore Mode
function ENTER_EXPLORE_MODE() {
  //loadGraph(userGraph);
}

// Lecture action functions
function CUSTOM_ACTION(action, data, mode) {
       if (action == 'search') {
    hideSlide(function() {
      $('#v-search').val(data); // force
      searchVertex(showSlide);
    });
  }
  else if (action == 'peek') {
    hideSlide(function() {
      searchGeneric(showSlide);
    });
  }
  else if (action == 'insert_head') {
    hideSlide(function() {
      $('#v-insert-head-value').val(data); // force
      insertHead(showSlide);
    });
  }
  else if (action == 'insert_tail') {
    hideSlide(function() {
      $('#v-insert-tail-value').val(data); // force
      insertTail(showSlide);
    });
  }
  else if (action == 'insert_kth') {
    hideSlide(function() {
      $('#v-insert-kth').val(data.split(",")[0]); // force
      $('#v-insert-kth-value').val(data.split(",")[1]); // force
      insertKth(showSlide);
    });
  }
  else if (action == 'remove_head') {
    var a = lw.getA();
    if (a.length > 0) {
      hideSlide(function() {
        removeHead(true, showSlide);
      });
    }
    else
      alert('The Linked List is already empty'); // put in variable?
  }
  else if (action == 'remove_tail') {
    var a = lw.getA();
    if (a.length > 0) {
      hideSlide(function() {
        removeTail(showSlide);
      });
    }
    else
      alert('The Linked List is already empty'); // put in variable?
  }
  else if (action == 'remove_kth') {
    hideSlide(function() {
      $('#v-remove-kth').val(data); // force
      removeKth(showSlide);
    });
  }
  else if (action == 'push') {
    hideSlide(function() {
      $('#v-push-top-value').val(data); // force
      pushTop(showSlide);
    });
  }
  else if (action == 'enqueue') {
    var a = lw.getA();
    if (a.length < 10) {
      var randval = 1 + Math.floor(Math.random()*99);
      while (a.includes(randval))
        randval = 1 + Math.floor(Math.random()*99);
      hideSlide(function() {
        $('#v-enqueue-back-value').val(randval); // force random
        enqueueBack(showSlide);
      });
    }
    else
      alert('The Linked List is already too long for this visualization'); // put in variable?
  }
}

// This function will be called before returning to Explore Mode
function redraw() {
  // still very buggy
  // lw.redraw();
}
</script>
</body>

<!-- Mirrored from visualgo.net/en/list?slide=2-3 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:17:58 GMT -->
</html>
