<!--
IMPORTANT NOTE:
Name the ID of the $actions of any new algorithms to be the same as the one used as a variable in the
countmaxflow algorithm of MaxFlow.countmaxflow. Refer to that algorithm for more clarity.
Current names that the algo checks for:
  1. 'fordfulkerson'
  2. 'edmondskarp'
  3. 'dinic'
-->




<!DOCTYPE html>
<html lang="en">

<!-- Mirrored from visualgo.net/en/maxflow by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:17:59 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="description" content="Maximum (Max) Flow is one of the problems in the family of problems involving flow in networks.In Max Flow problem, we aim to find the maximum flow from a particular source vertex s to a particular sink vertex t in a directed weighted&amp;nbsp;graph G.There are several algorithms for finding the maximum flow including Ford-Fulkerson method, Edmonds-Karp algorithm, and Dinic&amp;#39;s algorithm (there are a few others, but they are not included in this visualization yet).The dual problem of Max Flow is Min Cut, i.e., by finding the max s-t flow of G, we also simultaneously find the min s-t cut of G, i.e., the set of edges with minimum weight that have to be removed from G so that there is no path from s to t in G.">
<meta name="keywords" content="Maximum Flow Network Flow MF Minimum Cut Ford-Fulkerson Edmonds-Karp Dinic Dinitz">
 
<meta name="csrf-token" content="dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../img/png/maxflow.png">
<title>Network Flow (Max Flow, Min Cut) - VisuAlgo</title>
<link rel="icon" href="../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../img/favicon.png">
<link rel="stylesheet" href="../css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../css/common-1.0.2.css">
<link rel="stylesheet" href="../css/viz-1.0.4.css">
<link rel="stylesheet" href="../css/visual.css">
<link rel="stylesheet" href="../css/drawgraph-1.0.2.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
        z-index: 8001;
      }
      #e-lecture-timeline {
        top: 80px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }
      .e-lecture-timeline-slide {
        height: 5px;
        width: 2px;
        background: black;
        float: left;
      }
      .e-lecture-timeline-checkpoint {
        height: 20px;
        width: 3px;
        margin-left: 2px;
        margin-top: -7.5px;
        background: black;
        float: left;
      }

      #e-lecture-f1map {
        top: 102.5px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }

      .e-lecture-f1map-sector {
        flex-grow: 1;
        background: black;
        float: left;
        height: 5px;
        margin-right: 1px;
      }

      .e-lecture-f1map-sector:last-child {
        margin-right: 0px;
      }

      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }

      .electure-read-status {
        position: absolute;
        bottom: 4px;
        right: 4px;
        font-size: 14px;
        cursor: default;
        color: #00FF7F;
        display: none;
      }

      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
      .electure-print, .electure-end {
        position: fixed;
        top: 45px;
        height: 20px;
        width: 17px;
        right: 80px;
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
        text-align: center;
      }
      .electure-end {
        right: 45px; /* beside the X */
      }

      #change-lang-popup {
        position: fixed;
        background: green;
        left: 40px;
        top: 50px;
        width: 250px;
        height: 125px;
        border: transparent;
        border-radius: 10px;
        padding: 10px 20px;
        z-index: 9000;
      }

      #change-lang-popup p {
        font-size: medium;
        color: white;
        line-height: 2;
        font-family: "PT Sans", sans-serif;
      }

      #change-lang-popup-btn {
        text-decoration: underline;
        margin-left: 50px;
      }

      #change-lang-popup-btn:hover {
        cursor: pointer;
      }

      #rotateDeviceOverlay {
        z-index: 10000;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        background-color: white;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        overflow: hidden;
      }

      #mobile-playback-overlay {
        z-index: 9600;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        gap: 100px;
        background-color: black;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        opacity: 0.3;
        overflow: hidden;
      }
      .mobile-playback-item {
        min-width: 2.5%;
        max-width: 35px;
      }
      .mobile-playback-item img {
        width: 100%
      }
      .mobile-playback-label {
        opacity: 0;
        color: white;
        font-size: 25px;
        font-weight: bold;
        min-width: 1.5%;
        max-width: 25px;
        transition: opacity 0.25s ease-out;
        -webkit-backface-visibility: hidden;
      }
      #mobile-playback-rewind-label {
        margin-right: -70px;
      }
      #mobile-playback-forward-label {
        margin-left: -70px;
      }
      #viz-speed-value {
          font-size: 15px;
          width: 10%;
      }

      #scale {
        position: fixed;
        left: 5px;
      }
    </style>
<style>
/* #rookattack-input input {
  width: 20px;
  padding: 8px;
  margin-right: 2px;
  float:left;
}
#rookattack-input p { padding: 5px 8px; float : left;}
#rookattack-go p { 
  padding: 8px 8px 7px; 
  float:right;
}
#rookattack-board {
  height: 470px;
  width: 600px;
  margin-left: -300px;
  margin-top: -235px;
}

#baseball-input input {
  width: 25px;
  padding: 8px;
  margin-right: 2px;
  float:left;
}
#baseball-input p { padding: 5px 8px; float : left;}
#baseball-go p { 
  padding: 8px 8px 7px; 
  float:right;
}
#baseball-board {
  height: 470px;
  width: 600px;
  margin-left: -300px;
  margin-top: -235px;
}
#baseball-board input {
  width: 25px;
  padding: 8px;
  margin-right: 2px;
}
*/
</style>
<style>
/* copied here from common.css (perhaps need to use version numbering) until caches worldwide settles */
#reload-mobile-popup, #message-popup { /* #gdpr-popup, */
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  min-width: 320px;
  bottom: 62px;
  height: 300px;
  background-color: #0275d8;
  border-radius: 15px;
  padding: 30px 40px;
  z-index: 9500;
}
#reload-mobile-popup {
  background-color: green;
  height: 200px;
}
#message-popup {
  z-index: 9000;
  width: 40%;
  height: 130px;
  background-color: #d9534f;
}

#reload-mobile-popup p, #message-popup p { /* #gdpr-popup p, */
  font-size: large;
  color: white;
  line-height: 2;
  font-family: "PT Sans", sans-serif;
}

#reload-mobile-popup .inner-button, #message-popup .inner-button { /* #gdpr-popup .gdpr-button, */
  border: white solid 2px;
  border-radius: 4px;
  font-weight: bold;
  font-size: x-large;
  padding: 2px 8px;
  color: white;
  width: 90px;
  text-align: center;
  position: absolute;
  letter-spacing: 1px;
  text-decoration: none;
  cursor: pointer;
}

#gdpr-accept, #reload-mobile-button, #dismiss-message-btn {
  bottom: 30px;
  right: 40px;
}

#gdpr-reject, #cancel-reload-mobile-button {
  bottom: 30px;
  right: 170px;
}
    </style>
</head>
<body>
<div id="body-container" style="display: flex; flex-direction: column; min-height: 100vh;">
<style>
  #topbar {
    background-color: rgb(0,0,0);
    font-family: "PT Sans", sans-serif;
    font-size: 13px;
    height: 40px;

    padding-left: 40px;
    padding-right: 40px;

    display: flex;
    flex-wrap: wrap;
    align-items: center;
    position: relative;
    justify-content: flex-start;
  }

  #topbar a:hover {
    text-decoration: none;
  }

  #account-dropdown-btn {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;
    height: 24px;
    line-height: 1.5;
  }

  #account-dropdown-btn:hover {
    color: #0a58ca!important;
    border-color: #198754;
    text-decoration: none;
  }

  #login-button {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;

    height: 24px;
    line-height: 1.5;
  }

  #login-button a:hover {
    color: #0a58ca!important;
    text-decoration: none;
  }

  #account-dropdown-menu {
    display: none;
    position: absolute;
    background-color: white;
    z-index: 1000;
    min-width: 10rem;
    padding: 0.5rem 0;
    margin: 0;
    font-size: 1rem;
    color: rgb(0,0,0);
    text-align: left;
    list-style: none;
    background-clip: padding-box;
    border: 1px solid rgba(0,0,0,.15);
    border-radius: 0.25rem;
    top: 45px;
    right: 40px;
    line-height: 1.5;
  }

  .account-dropdown-item {
    display: block;
    width: auto;
    padding: 0.25rem 1rem;
    clear: both;
    font-weight: 400;
    color: rgb(0,0,0);
    text-align: inherit;
    text-decoration: none;
    white-space: nowrap;
    background-color: transparent;
    border: 0;
    height: 24px;
    font-family: SilkscreenNormal, sans-serif;
  }

  .account-dropdown-item:hover {
    background-color: #e9ecef;
    color: #0a58ca;
    text-decoration: none;
  }
</style>
<nav id="topbar">
<span style="margin-right: 0.25rem">
<a href="https://www.comp.nus.edu.sg/~stevenha" style="text-decoration: none; color: white">
<span class="colour" style="border: 1px solid; border-color: #198754!important; border-radius: .25rem!important">7</span>
</a>
<a href="https://visualgo.net/" style="font-family: SilkscreenNormal,sans-serif; font-size: 20px; margin-left: 4px;">
<span style="color: white">Visu</span><span class="colour">Algo</span><span style="font-size: 40%; color: white">.net</span>
</a>
<span style="color: white">/</span>
<select id="Language" class="select2-dropdown" onchange="changeURL()">
<option value="en" selected>en</option>
<option value="zh">zh</option>
<option value="id">id</option>
</select>
<span style="color: white; font-family: monospace">/maxflow</span>
</span>
<span style="max-height: 30px">
<span id="title">
<a id="title-maxflow" class="selected-viz">Max Flow/Min Cut</a>
</span>
</span>
<span style="max-height: 30px; background-color:rgb(0,0,0)!important; color: white; margin-left: auto">
<div id="mode-menu">
<div id="mode-button" style="background-color: rgb(0,0,0)!important;" title="exploration">Exploration Mode &#9663;</div>
<div id="other-modes" style="background-color: rgb(0,0,0)!important; padding-top: 11px">
<a title="e-Lecture" style="background-color: rgb(0,0,0)!important;">e-Lecture Mode</a>
</div>
</div>
</span>
<span id="login-button" style="font-family: SilkscreenNormal,sans-serif">
<a href="https://visualgo.net/login">Login</a>
</span>
</nav>
<ul id="account-dropdown-menu">
<li><a class="account-dropdown-item" href="https://visualgo.net/profile">Profile</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/training">Training</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/tests">Tests</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/logout">Log Out</a></li>
</ul>
<script>
  function changeURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    URL[3] = document.getElementById("Language").value;
    window.location.assign(URL.join('https://visualgo.net/'));
  }

  function changeDefaultLanguageAndURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    let val = document.getElementById("Language").value;
    URL[3] = val;

    let data = {
      '_token': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
      'lang'  : val
    }
    $.post('https://visualgo.net/changeLanguage', data, function (res, status) {
      if(res['status'] === 'success') {
        window.location.assign(URL.join('https://visualgo.net/'));
      } else if (res['status'] === 'failed') {
        alert(res['message']);
      } else {
        alert('An unknown error occurred');
      }
    })
  }
</script>
<div id="dark-overlay"></div>
<div id="main-content-container" style="flex: 1">

<div id="mobile-playback-overlay" class="playing" style="display: none;">
<span id="mobile-playback-rewind-label" class="mobile-playback-label">-7</span>
<span id="mobile-playback-rewind" class="mobile-playback-item" onclick="mobilePlaybackRewind()"><img src="../img/prevFrame.png" alt="rewind 7 frames"></span>
<span id="mobile-playback-pause" class="mobile-playback-item" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/pause.png" alt="pause"></span>
<span id="mobile-playback-play" class="mobile-playback-item" style="display: none;" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/play.png" alt="play"></span>
<span id="mobile-playback-forward" class="mobile-playback-item" onclick="mobilePlaybackForward()"><img src="../img/nextFrame.png" alt="forward 7 frames"></span>
<span id="mobile-playback-forward-label" class="mobile-playback-label">+7</span>
</div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id="speed-control"><div id="speed-input"></div><div id="viz-speed-value">1x</div></div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick="goToBeginning()"><img src="../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick="stepBackward()"><img src="../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick="pause()"><img src="../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick="play()"><img src="../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick="stepForward()"><img src="../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick="goToEnd()"><img src="../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id="viz">
<p id="info" "></p>
</div>
<div id="current-action" class="panel"></div>
<div id="e-lecture" class="panel"></div> 
<div id="e-lecture-timeline"></div>
<div id="e-lecture-f1map">
<div class="e-lecture-f1map-sector" sectorNo="1"></div>
<div class="e-lecture-f1map-sector" sectorNo="2"></div>
<div class="e-lecture-f1map-sector" sectorNo="3"></div>
</div>
<div id="overlay" hidden onclick="end_eLecture()"> 
<div id="electure-dropdown">
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. Maximum (Max) Flow</option>
<option value="1-1">&nbsp;&nbsp;&nbsp;1-1. Motivation-Applications</option>
<option value="2">2. Visualization</option>
<option value="2-1">&nbsp;&nbsp;&nbsp;2-1. Input</option>
<option value="2-2">&nbsp;&nbsp;&nbsp;2-2. Output</option>
<option value="2-3">&nbsp;&nbsp;&nbsp;2-3. The Answer</option>
<option value="2-4">&nbsp;&nbsp;&nbsp;2-4. Residual Graph</option>
<option value="3">3. Specifying Input Flow Graph</option>
<option value="4">4. Max Flow Algorithms</option>
<option value="4-1">&nbsp;&nbsp;&nbsp;4-1. Similar But Not The Same</option>
<option value="5">5. Ford-Fulkerson Method</option>
<option value="5-1">&nbsp;&nbsp;&nbsp;5-1. Max-Flow/Min-Cut Theorem</option>
<option value="5-2">&nbsp;&nbsp;&nbsp;5-2. Cuts and Flows, Definitions</option>
<option value="5-3">&nbsp;&nbsp;&nbsp;5-3. Cuts and Flows, Equal</option>
<option value="5-4">&nbsp;&nbsp;&nbsp;5-4. Cuts and Flows, Weak Duality</option>
<option value="5-5">&nbsp;&nbsp;&nbsp;5-5. Max-Flow/Min-Cut Theorem, Formally</option>
<option value="5-6">&nbsp;&nbsp;&nbsp;5-6. Augmenting Path Theorem</option>
<option value="5-7">&nbsp;&nbsp;&nbsp;5-7. Finding Edges in the Min-Cut</option>
<option value="5-8">&nbsp;&nbsp;&nbsp;5-8. The Proofs</option>
<option value="5-9">&nbsp;&nbsp;&nbsp;5-9. Analysis of Ford-Fulkerson Method</option>
<option value="5-10">&nbsp;&nbsp;&nbsp;5-10. Non-Integer Capacities</option>
<option value="6">6. Shortest Augmenting Paths First</option>
<option value="6-1">&nbsp;&nbsp;&nbsp;6-1. Idea 1: Edmonds-Karp</option>
<option value="6-2">&nbsp;&nbsp;&nbsp;6-2. The Proofs</option>
<option value="6-3">&nbsp;&nbsp;&nbsp;6-3. Idea 2: Dinic&#39;s</option>
<option value="7">7. Efficient Max Flow Algorithm Implementation</option>
</select>
</div>
<div class="electure-print" title="Print the e-Lecture note" style="z-index=8001;">&#9997;</div>
<div class="electure-end" title="Close the e-Lecture mode" style="z-index=8001;">&#10008;</div>
</div>
<div id="dropdown-temp-holder" hidden></div>

<div id="electure-1" class="electure-dialog" style="top:80px;left:60px;width:500px;">
<p>Maximum (Max) Flow is one of the problems in the family of problems involving flow in networks.</p><br><p>In Max Flow problem, we aim to find the maximum flow from a particular source vertex <b>s</b> to a particular sink vertex <b>t</b> in a directed weighted&nbsp;graph <b>G</b>.</p><br><p>There are several algorithms for finding the maximum flow including Ford-Fulkerson method, Edmonds-Karp algorithm, and Dinic&#39;s algorithm (there are a few others, but they are not included in this visualization yet).</p><br><p>The dual problem of Max Flow is Min Cut, i.e., by finding the max <b>s-t</b> flow of <b>G</b>, we also simultaneously find the min <b>s-t</b> cut of <b>G</b>, i.e., the set of edges with minimum weight that have to be removed from <b>G</b> so that there is no path from <b>s</b> to <b>t</b> in <b>G</b>.</p>
<div class="electure-addition">
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
If you are an NUS student and a repeat visitor, please <a href="https://visualgo.net/login"><u>login</u></a>.</p>
</div>
<div class="electure-next" data-nextid="1-1" title="Go to the next slide 1-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-1-1" class="electure-dialog" style="top:80px;left:60px;width:500px;">
<p>Max-Flow (or Min-Cut) problems arise in various applications, e.g.,</p><ol><li>Transportation-related problems (what is the best way to send goods/material from <b>s</b> (perhaps a factory) to <b>t</b> (perhaps a super-sink of all end-users)</li><li>Network attacks problems (sabotage/destroy some edges to disconnect two important points <b>s</b> and <b>t</b>)</li><li>(Bipartite) Matching and Assignment problems (that also has specialized algorithms, see <a href="matching.html"><u>Graph Matching</u></a> visualization</li><li><a href="https://en.wikipedia.org/wiki/Maximum_flow_problem#Baseball_elimination" target="_blank"><u>Sport teams prospects</u></a></li><li><a href="https://en.wikipedia.org/wiki/Maximum_flow_problem#Image_segmentation" target="_blank"><u>Image segmentation</u></a>, etc...</li></ol>
<div class="electure-addition">
<hr>
<p>Pro-tip 1: Since you are not <a href="https://visualgo.net/login"><u>logged-in</u></a>, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b>/<b>[PageUp]</b> to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use <b>[&rarr; or &darr;/&larr; or &uarr;]</b> to do the same),and <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
</div>
<div class="electure-prev" data-nextid="1" title="Go to the previous slide 1">&larr;</div>
<div class="electure-next" data-nextid="2" title="Go to the next slide 2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2" class="electure-dialog" style="top:400px;left:50%;margin-left:-250px;width:500px;">
<p>This visualization page will show the execution of a chosen Max Flow algorithm running on a flow (residual) graph.</p><br><p>To make the visualization of these flow graphs consistent, we enforce a graph drawing rule for this page whereby the source vertex <b>s</b>/sink vertex <b>t</b> is always vertex 0/<b>V</b>-1 and is always drawn on the leftmost/rightmost side of the visualization, respectively. Another visualization-specific constraint is that the edge capacities are integers between [1..99].</p><br><p>These visualization-specific constraints do&nbsp;<b>not</b> exist in the standard max flow problems.</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
</div>
<div class="electure-prev" data-nextid="1-1" title="Go to the previous slide 1-1">&larr;</div>
<div class="electure-next" data-nextid="2-1" title="Go to the next slide 2-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-1" class="electure-dialog" style="bottom:250px;left:60px;width:500px;">
<p>The input for a Max Flow algorithm is a flow graph (a <b>directed weighted</b> graph <b>G</b> = <b>(V, E)</b> where edge weight of edge <b>e</b> represent the capacity <b>c(e)</b> (the unit is problem-dependent, e.g., liters/second, person/hour, etc) of flow that can go through that edge) with two distinguished vertices: The source vertex <b>s</b>&nbsp;(with in-degree 0) and the sink/target/destination vertex <b>t </b>(with out-degree 0). The flow graph is usually <b>s</b>-<b>t</b> connected, i.e., there is at least one path from <b>s</b> to <b>t </b>(otherwise the max flow is trivially 0).</p><br><p>In this visualization, these two additional inputs of <b>s</b> (usually vertex 0) and <b>t</b> (usually vertex <b>V</b>-1) are asked before the execution of the chosen Max Flow algorithm and can be customized by the user.</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode): <b>Spacebar</b> to play/pause/replay the animation, <b>&larr;</b>/<b>&rarr;</b> to step the animation backwards/forwards, respectively, and <b>-</b>/<b>+</b> to decrease/increase the animation speed, respectively.</p>
</div>
<div class="electure-prev" data-nextid="2" title="Go to the previous slide 2">&larr;</div>
<div class="electure-next" data-nextid="2-2" title="Go to the next slide 2-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-2" class="electure-dialog" style="top:440px;left:50%;margin-left:-250px;width:500px;">
<p>The output for a Max Flow algorithm is the max flow value and an assignment of flow <b>f</b> to each edge that satisfies two important constraints:</p><ol><li><b>Capacity constraints</b> (flow on each edge (<b>f(e)</b>) is between 0 and its (unit) capacity (<b>c(e)</b>), i.e., 0 ≤ <b>f(e)</b> ≤ <b>c(e)</b> — not negative and not more than the capacity), and</li><li><b>Equilibrium constraints</b> (for every vertex except <b>s</b> and <b>t</b>, flow-in = flow-out)</li></ol> so that the value of the flow (<b>value(f) = ∑<sub>v: (s, v) ∈ E</sub> f(s,v)</b>) is maximum.<p></p><br><p>In this visualization, we focus on showing the final max flow value and the final ST-min cut components at the end of each max flow algorithm execution, instead of the precise assignment of flow <b>f</b> to each edge, i.e., <b>f(e)</b> must be computed manually from the initial capacity <b>c(e)</b> (first frame of the animation) minus the final residual capacity of that edge <b>e</b> (last frame of the animation). This missing feature will likely be added in the next iteration of this visualization page.</p><br><p>Discussion: Is there other ways to compute the value of the flow <b>value(f)</b>?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-1" title="Go to the previous slide 2-1">&larr;</div>
<div class="electure-next" data-nextid="2-3" title="Go to the next slide 2-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-3" class="electure-dialog" style="top:440px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-2" title="Go to the previous slide 2-2">&larr;</div>
<div class="electure-next" data-nextid="2-4" title="Go to the next slide 2-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-4" class="electure-dialog" style="top:440px;left:50%;margin-left:-250px;width:500px;">
<p>At the start of the three Max Flow algorithms discussed in this visualization (Ford-Fulkerson method, Edmonds-Karp algorithm, and Dinic&#39;s algorithm), the initial flow graph is converted into residual graph (with potential addition of back flow edges with initial capacity of zeroes).</p><br><p>The edges in the residual graph store the <i>remaining</i> capacities of those edges that can be used by future flow(s). At the beginning, these remaining capacities equal to the original capacities as specified in the input flow graph.</p><br><p>A Max Flow algorithm will send flows to use some (or all) of these available capacities, iteratively.</p><br><p>Once the remaining capacity of an edge reaches 0, that edge can no longer admit any more flow. In the near future, we will update this visualization so that any edge in the residual graph that has capacity 0 (including the initial zeroes of the back flow edges) is <b>not</b> shown in the visualization.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-3" title="Go to the previous slide 2-3">&larr;</div>
<div class="electure-next" data-nextid="3" title="Go to the next slide 3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3" class="electure-dialog" style="bottom:250px;left:60px;width:500px;">
<p>There are three different sources for specifying an input flow graph:</p><ol><li><b>Draw Graph</b>: You can draw <b>any</b> directed weighted (weight ∈ [1..99]) graph as the input flow graph with vertex 0 as the default source vertex (the left side of the screen) and vertex <b>V</b>-1 as the default sink vertex (the right side of the screen),</li><li><b>Modeling</b>: Several graph problems can be reduced into a Max Flow problem. In this visualization, we have the modeling examples for the famous Maximum Cardinality Bipartite Matching (MCBM) problem, Rook Attack problem (currently disabled), and Baseball Elimination problem (currently disabled),</li><li><b>Example Graphs</b>: You can select from the list of our selected example flow graphs to get you started.</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-4" title="Go to the previous slide 2-4">&larr;</div>
<div class="electure-next" data-nextid="4" title="Go to the next slide 4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4" class="electure-dialog" style="bottom:250px;left:60px;width:500px;">
<p>There are three different max flow algorithms in this visualization:</p><ol><li>The slow O(<b>mf × E</b>) <b>Ford-Fulkerson</b> method,</li><li>The O(<b>V × E^2</b>) <b>Edmonds-Karp</b> algorithm, or</li><li>The O(<b>V^2 × E</b>) <b>Dinic&#39;s</b> algorithm.</li></ol><p>There are a few other <a href="https://en.wikipedia.org/wiki/Maximum_flow_problem#Algorithms" target="_blank"><u>max flow algorithms</u></a> out there, but they are not available in this visualization yet.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3" title="Go to the previous slide 3">&larr;</div>
<div class="electure-next" data-nextid="4-1" title="Go to the next slide 4-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-1" class="electure-dialog" style="bottom:250px;left:60px;width:500px;">
<p>For the three Max Flow algorithms discussed in this visualization, successive flows are sent from the source vertex <b>s</b> to the sink vertex <b>t</b> via available <b>augmenting paths</b> (augmenting path is a path from <b>s</b> to <b>t</b> that goes through edges with positive weight residual capacity (<b>c(e)-f(e)</b>) left).</p><br><p>The three Max Flow algorithms in this visualization have different behavior on how they find augmenting paths.</p><br><p>However, all three Max Flow algorithms in this visualization stop when there is no more augmenting path possible and report the max flow value (and the assignment of flow on each edge in the flow graph).</p><br><p>Later we will discuss that this max flow value is also the min cut value of the flow graph (that famous Max-Flow/Min-Cut Theorem).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4" title="Go to the previous slide 4">&larr;</div>
<div class="electure-next" data-nextid="5" title="Go to the next slide 5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5" class="electure-dialog" style="bottom:250px;left:60px;width:500px;">
<pre>start with 0 flow<br>while there exists an augmenting path: // iterative algorithm<br>  find an augmenting path (for now, &#39;any&#39; graph traversal will do)<br>  compute bottleneck capacity<br>  increase flow on the path by the bottleneck capacity</pre>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-1" title="Go to the previous slide 4-1">&larr;</div>
<div class="electure-next" data-nextid="5-1" title="Go to the next slide 5-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-1" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>This famous theorem states that in a flow network, the <b>maximum flow</b> from <b>s</b> to <b>t</b> is equal to the total weight of the edges in a <b>minimum cut</b>, i.e., the smallest total weight of the edges that have to be removed to disconnect <b>s</b> from <b>t</b>.</p><br><p>In a typical Computer Science classes, the lecturer will usually spend some time to properly explain this theorem (explaining what is an st-cut, capacity of an st-cut, net flow across an st-cut equals to current flow f assignment that will never exceed the capacity of the cut, and finally that Max-Flow/Min-Cut Theorem). For this visualization, we just take this statement as it is.</p><br><p>Discussion: For live class in NUS, we will actually discuss these theorem.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5" title="Go to the previous slide 5">&larr;</div>
<div class="electure-next" data-nextid="5-2" title="Go to the next slide 5-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-2" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-1" title="Go to the previous slide 5-1">&larr;</div>
<div class="electure-next" data-nextid="5-3" title="Go to the next slide 5-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-3" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-2" title="Go to the previous slide 5-2">&larr;</div>
<div class="electure-next" data-nextid="5-4" title="Go to the next slide 5-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-4" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-3" title="Go to the previous slide 5-3">&larr;</div>
<div class="electure-next" data-nextid="5-5" title="Go to the next slide 5-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-5" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-4" title="Go to the previous slide 5-4">&larr;</div>
<div class="electure-next" data-nextid="5-6" title="Go to the next slide 5-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-6" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>Using the Max-Flow/Min-Cut Theorem, we can then prove that flow <b>f</b> is a maximum flow if and only if there is no (more) augmenting path remaining in the residual graph.</p><br><p>As this is what Ford-Fulkerson Method is doing, we can conclude the correctness of this Ford-Fulkerson Method, i.e., if Ford-Fulkerson Method terminates, then there is no augmenting path left and thus the resulting flow is maximum (and we can also construct the equivalent Min-Cut, next slide).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-5" title="Go to the previous slide 5-5">&larr;</div>
<div class="electure-next" data-nextid="5-7" title="Go to the next slide 5-7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-7" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>We can constructively identify the edges in the Min-Cut as follows:</p><ol><li>Run Ford-Fulkerson (or any other Max Flow) algorithm until it terminates.</li><li>Let <b>S</b> be the set of vertices that are still reachable from the source <b>s</b>.<br>We can run DFS (or BFS) in the residual graph from the source vertex <b>s</b>.<br>All the vertices that are still reachable are in <b>S</b>.<br>Let <b>T</b> be the remaining vertices, i.e., <b>T = V &bsol; S</b>.</li><li>For every edge in <b>S</b>, enumerate outgoing edges:<br>If edge exits <b>S</b> (and into <b>T</b>), add to min-cut.<br>If both ends of edge are in <b>S</b>, then continue.</li></ol><p>That&#39;s it, <b>(S,T)</b> is an st-cut, edges from (<b>S &rarr; T</b>) are the minimum cut, and the flow that goes through this minimum cut <b>(S,T)</b> is the maximum possible.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-6" title="Go to the previous slide 5-6">&larr;</div>
<div class="electure-next" data-nextid="5-8" title="Go to the next slide 5-8">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-8" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-7" title="Go to the previous slide 5-7">&larr;</div>
<div class="electure-next" data-nextid="5-9" title="Go to the next slide 5-9">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-9" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>Ford-Fulkerson method always terminates if the capacities are integers.</p><br><p>This is because every iteration of Ford-Fulkerson method always finds a new augmenting path and each augmenting path must has bottleneck capacity at least 1 (due to that integer constraint). Therefore, each iteration increases the flow of at least one edge by at least 1, edging the Ford-Fulkerson closer to termination.</p><br><p>As the number of edges is finite (as well as the finite max capacity per edge), this guarantees the eventual termination of Ford-Fulkerson method when the max flow <b>mf</b> is reached and there is no more augmenting path left.</p><br><p>In the worst case, Ford-Fulkerson method runs for <b>mf</b> iterations, and each time it uses O(<b>E</b>) DFS. The rough overall runtime is thus O(<b>mf × E</b>) &mdash; this is actually not desirable especially if the value of <b>mf</b> is a huge number.</p><br><p>Discussion: What if the capacities are rational numbers? What if the capacities are floating-point numbers?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-8" title="Go to the previous slide 5-8">&larr;</div>
<div class="electure-next" data-nextid="5-10" title="Go to the next slide 5-10">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-10" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-9" title="Go to the previous slide 5-9">&larr;</div>
<div class="electure-next" data-nextid="6" title="Go to the next slide 6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>Idea: What if we don&#39;t consider <b>any</b> augmenting paths but consider augmenting paths with the smallest number of edges involved first (so we don&#39;t put flow on more edges than necessary).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-10" title="Go to the previous slide 5-10">&larr;</div>
<div class="electure-next" data-nextid="6-1" title="Go to the next slide 6-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6-1" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>Implementation: We first ignore capacity of the edges first (assume all edges in the residual graph have weight 1), and we run O(E) BFS to find the shortest (in terms of # of edges used) augmenting path. Everything else is the same as the basic Ford-Fulkerson Method outlined earlier.</p><br><p>It can be proven that Edmonds-Karp will use at most O(VE) iterations thus it runs in at most in O(VE * E) = O(VE^2) time.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6" title="Go to the previous slide 6">&larr;</div>
<div class="electure-next" data-nextid="6-2" title="Go to the next slide 6-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6-2" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6-1" title="Go to the previous slide 6-1">&larr;</div>
<div class="electure-next" data-nextid="6-3" title="Go to the next slide 6-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6-3" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>Dinic&#39;s algorithm also uses similar strategy of finding shortest augmenting paths first.</p><br><p>But Dinic&#39;s algorithm runs in a faster time of O(V^2 × E) due to the more efficient usage of BFS shortest path information.</p><br><p>This slide will be expanded.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6-2" title="Go to the previous slide 6-2">&larr;</div>
<div class="electure-next" data-nextid="7" title="Go to the next slide 7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7" class="electure-dialog" style="top:80px;left:60px;width:500px;">
<p>When you are presented with a Max Flow (or a Min Cut)-related problem, we do not have to reinvent the wheel every time.</p><br><p>You are allowed to use/modify/adapt/enhance our implementation code for Max Flow Algorithms (Edmonds-Karp/Dinic&#39;s): <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch8/maxflow.cpp" target="_blank"><u>maxflow.cpp</u></a>&nbsp;|&nbsp;<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch8/maxflow.py" target="_blank"><u>py</u></a>&nbsp;|&nbsp;<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch8/maxflow.java" target="_blank"><u>java</u></a>&nbsp;|&nbsp;<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch8/maxflow.ml" target="_blank"><u>ml</u></a>.</p>
<div class="electure-addition">
<hr>
<p>You have reached the last slide. Return to 'Exploration Mode' to start exploring!</p>
<p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
</div>
<div class="electure-prev" data-nextid="6-3" title="Go to the previous slide 6-3">&larr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>Close</u></span>
</div>
<div id="rotateDeviceOverlay" style="display: none;">
<div id="rotateDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please rotate your device to landscape mode for a better user experience</div>
<div id="widenDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please make the window wider for a better user experience</div>
</div>

<style>
        .mediumscale {
            bottom: 254px
        }
    </style>
<style>
        .draw {
            bottom: 200px
        }
    </style>
<style>
        .modeling {
            bottom: 173px
        }
    </style>
<style>
        .examples {
            bottom: 146px
        }
    </style>
<style>
        .fordfulkerson {
            bottom: 119px
        }
    </style>
<style>
        .edmondskarp {
            bottom: 92px
        }
    </style>
<style>
        .dinic {
            bottom: 65px
        }
    </style>
<div id="actions" class="panel">
<p id="mediumscale">Visualisation Scale</p>
<p class="execAction" id="vertexnumber" onClick="toggleVertexNumber()">Toggle V. Number for 0.5x</p>
<p class="execAction" id="draw" onClick="drawGraph()">Edit Graph</p>
<p id="modeling">Modeling</p>
<p id="examples">Example Graphs</p>
<p id="fordfulkerson">Ford-Fulkerson</p>
<p id="edmondskarp">Edmonds-Karp</p>
<p id="dinic">Dinic</p>
</div>
<div id="actions-hide" class="panel-hide"><span style="color:white; font-size: x-large; display: inline-block;">&gt;</span></div>
<div id="actions-extras">
<div class="mediumscale action-menu-pullout">
<div id="defaultScale" class="execAction new-menu-option coloured-menu-option" onClick="setDefaultScale()">
<p>1.0x (Default)</p>
</div>
<div id="mediumScale" class="execAction new-menu-option coloured-menu-option" onClick="setMediumScale()">
<p>0.5x (Minimal Details)</p>
</div>
<div id="mediumscale-err" class="err" style="float: left;"></div>
</div>
<div class="draw action-menu-pullout">
<div id="draw-err" class="err" style="float: left;"></div>
</div>
<div class="modeling action-menu-pullout">
<div id="bipartite" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;modeling&#039;, &#039;bipartite&#039;)">
<p>Bipartite Matching</p>
<div id="bipartite-third-tier" class="bipartite-third-tier new-menu-option" style="display: none;">
<div id="bipartite3" class="execAction coloured-menu-option" style="float: right;" onClick="bipartiteRandom(3)">
<p>all 1</p>
</div>
<div id="bipartite2" class="execAction coloured-menu-option" style="float: right;" onClick="bipartiteRandom(2)">
<p>right 1</p>
</div>
<div id="bipartite1" class="execAction coloured-menu-option" style="float: right;" onClick="bipartiteRandom(1)">
<p>left 1</p>
</div>
<div id="bipartite0" class="execAction coloured-menu-option" style="float: right;" onClick="bipartiteRandom(0)">
<p>random</p>
</div>
</div>
</div>
<div id="modeling-err" class="err" style="float: left;"></div>
</div>
<div class="examples action-menu-pullout">
<div id="example-corner-case" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;examples&#039;, &#039;example-corner-case&#039;)">
<p>Corner Case</p>
<div id="example-corner-case-third-tier" class="example-corner-case-third-tier new-menu-option" style="display: none;">
<div id="example-corner-case-3" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;CP4_8_5_3_1_correct&#039;)">
<p>CP4 Ex 8.5.3.1* (correct)</p>
</div>
<div id="example-corner-case-2" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;CP4_8_5_3_1&#039;)">
<p>CP4 Ex 8.5.3.1* (wrong)</p>
</div>
<div id="example-corner-case-1" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;CP4_8_11&#039;)">
<p>CP4 8.11* (FF Killer)</p>
</div>
</div>
</div>
<div id="example-special-case" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;examples&#039;, &#039;example-special-case&#039;)">
<p>Special Case</p>
<div id="example-special-case-third-tier" class="example-special-case-third-tier new-menu-option" style="display: none;">
<div id="example-special-case-normal" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;CP4_8_17_C&#039;)">
<p>CP4 8.17.C*</p>
</div>
<div id="example-special-case-t-lim" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;CP4_8_17_B&#039;)">
<p>CP4 8.17.B* (MC T = {t})</p>
</div>
<div id="example-special-case-s-lim" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;CP4_8_17_A&#039;)">
<p>CP4 8.17.A* (MC S = {s})</p>
</div>
</div>
</div>
<div id="exampleA" class="execAction new-menu-option coloured-menu-option" onClick="example(&#039;CS4234&#039;)">
<p>CS4234 MF Demo</p>
</div>
<div id="exampleB" class="execAction new-menu-option coloured-menu-option" onClick="example(DINIC_SHOWCASE)">
<p>CP4 8.15* (Dinic Showcase)</p>
</div>
<div id="exampleC" class="execAction new-menu-option coloured-menu-option" onClick="example(&#039;MatchingWithCapacity&#039;)">
<p>Matching with Capacity</p>
</div>
<div id="exampleD" class="execAction new-menu-option coloured-menu-option" onClick="example(&#039;waif_AC&#039;)">
<p>waif (AC)</p>
</div>
<div id="example-reduction" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;examples&#039;, &#039;example-reduction&#039;)">
<p>Reduction</p>
<div id="example-reduction-third-tier" class="example-reduction-third-tier new-menu-option" style="display: none;">
<div id="example-edge-mwvc" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;CP4_8_29&#039;)">
<p>CP4 8.29* (MWVC)</p>
</div>
<div id="example-edge-disjoint" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;CP4_8_20_B&#039;)">
<p>CP4 8.20.B* (MEDP)</p>
</div>
<div id="example-independent" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;CP4_8_20_A&#039;)">
<p>CP4 8.20.A* (MVDP/MIP)</p>
</div>
</div>
</div>
<div id="examples-err" class="err" style="float: left;"></div>
</div>
<div class="fordfulkerson action-menu-pullout">
<div id="fordfulkerson-s-input" class="new-menu-option">
s = <input id="fordfulkerson-sourcevertex" type="number" title="Enter the source vertex" autocomplete="off" min="0" max="99" value="3"> </div>
<div id="fordfulkerson-t-input" class="new-menu-option">
t = <input id="fordfulkerson-sinkvertex" type="number" title="Enter the sink vertex" autocomplete="off" min="0" max="0" value="9"> </div>
<div id="fordfulkerson-go" class="execAction new-menu-option coloured-menu-option" onClick="countmaxflow(&#039;fordfulkerson&#039;)">
<p>Go</p>
</div>
<div id="fordfulkerson-err" class="err" style="float: left;"></div>
</div>
<div class="edmondskarp action-menu-pullout">
<div id="edmondskarp-s-input" class="new-menu-option">
s = <input id="edmondskarp-sourcevertex" type="number" title="Enter the source vertex" autocomplete="off" min="0" max="99" value="3"> </div>
<div id="edmondskarp-t-input" class="new-menu-option">
t = <input id="edmondskarp-sinkvertex" type="number" title="Enter the sink vertex" autocomplete="off" min="0" max="0" value="9"> </div>
<div id="edmondskarp-go" class="execAction new-menu-option coloured-menu-option" onClick="countmaxflow(&#039;edmondskarp&#039;)">
<p>Go</p>
</div>
<div id="edmondskarp-err" class="err" style="float: left;"></div>
</div>
<div class="dinic action-menu-pullout">
<div id="dinic-s-input" class="new-menu-option">
s = <input id="dinic-sourcevertex" type="number" title="Enter the source vertex" autocomplete="off" min="0" max="99" value="3"> </div>
<div id="dinic-t-input" class="new-menu-option">
t = <input id="dinic-sinkvertex" type="number" title="Enter the sink vertex" autocomplete="off" min="0" max="0" value="9"> </div>
<div id="dinic-go" class="execAction new-menu-option coloured-menu-option" onClick="countmaxflow(&#039;dinic&#039;)">
<p>Go</p>
</div>
<div id="dinic-err" class="err" style="float: left;"></div>
</div>
</div>

<div id="drawgraph" class="overlays"></div>
<div id="rookattack-board" class="overlays"></div>
<div id="baseball-board" class="overlays"></div>
</div>

<div id="bottom-bar">
<a id="scale" style="display: none;">1.0x</a>
<a id="trigger-about">About</a>
<a id="trigger-team">Team</a>
<a id="trigger-terms">Terms of use</a>
<a id="trigger-privacy">Privacy Policy</a>
</div>
<div id="about" class="overlays">
<h4>About</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.</p><p>Featuring numerous advanced algorithms discussed in Dr. Steven Halim&#39;s book, &#39;Competitive Programming&#39; — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.</p><p>While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.</p><p>Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.</p><p>VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.</p><p>Equipped with a built-in question generator and answer verifier, VisuAlgo&#39;s "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students&#39; answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students&#39; mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.</p><p>VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:</p>
<a href="https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689" target="_blank"><u>id</u></a>,
<a href="http://blog.naver.com/visualgo_nus" target="_blank"><u>kr</u></a>,
<a href="https://www.facebook.com/groups/163215593699283/permalink/824003417620494/" target="_blank"><u>vn</u></a>,
<a href="http://pantip.com/topic/32736343" target="_blank"><u>th</u></a>.
</div>
</div>
<div id="team" class="overlays">
<h4>Team</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>
<strong><span style="line-height: 150%;">Project Leader &amp; Advisor (Jul 2011-present)</span></strong><br>
<a href="https://www.comp.nus.edu.sg/~stevenha/" target="_blank">Associate Professor Steven Halim</a>, School of Computing (SoC), National University of Singapore (NUS)<br>
<a href="https://www.linkedin.com/in/felixhalim/" target="_blank">Dr Felix Halim</a>, Senior Software Engineer, Google (Mountain View)
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 1</span></strong><br>
<b>CDTL TEG 1: Jul 2011-Apr 2012</b>: Koh Zi Chun, Victor Loh Bo Huai
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 1</span></strong><br>
<b>Jul 2012-Dec 2013</b>: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang Duy<br>
<b>Jun 2013-Apr 2014</b> <a href="https://www.rosemarietan.com/" target="_blank">Rose Marie Tan Zhao Yun</a>, Ivan Reinaldo
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 2</span></strong><br>
<b>CDTL TEG 2: May 2014-Jul 2014</b>: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 2</span></strong><br>
<b>Jun 2014-Apr 2015</b>: Erin Teo Yi Ling, Wang Zi<br>
<b>Jun 2016-Dec 2017</b>: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin Mudzakir<br>
<b>Aug 2021-Apr 2023</b>: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius<br>
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 3</span></strong><br>
<b>Optiver: Aug 2023-Oct 2023</b>: Bui Hong Duc, Oleh Naver, Tay Ngan Lin<br>
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 3</span></strong><br>
<b>Aug 2023-Apr 2024</b>: Xiong Jingya, Radian Krisno, Ng Wee Han<br>
</p>
<p>
List of translators who have contributed &ge; 100 translations can be found at <a href="https://visualgo.net/statistics">statistics</a> page.
</p>
<p>
<strong><span style="line-height: 150%;">Acknowledgements</span></strong><br>
NUS <a href="https://nus.edu.sg/cdtl" target="_blank"><u>CDTL</u></a> gave Teaching Enhancement Grant to kickstart this project.<div>For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.</div>
</p>
</div>
</div>
<div id="termsofuse" class="overlays">
<h4>Terms of use</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that you <b>spread the word about its existence to fellow Computer Science students and instructors</b>. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.</p><p>Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (<a href="https://visualgo.net/">https://visualgo.net</a>) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo&#39;s client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.</p><p>Please note that VisuAlgo&#39;s online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the &#39;training mode.&#39; The &#39;test mode&#39; offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.</p><p><strong><span style="line-height: 200%;">List of Publications</span></strong></p> <p>This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can click <a href="https://ioinformatics.org/journal/INFOL099.pdf" target="_blank">this link</a> to read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) and <a href="https://ioinformatics.org/journal/v9_2015_243_245.pdf" target="_blank">this link</a> for the short update in 2015 (to link VisuAlgo name with the previous project).</p><p><strong><span style="line-height: 200%;">Bug Reports or Request for New Features</span></strong></p> <p>VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.</p>
</div>
</div>
<div id="privacy-policy" class="overlays">
<h4>Privacy Policy</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p><b>Version 1.2 (Updated Fri, 18 Aug 2023).</b></p><p>Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.</p><p>Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).</p><p>Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.</p><p>For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.<br></p><p>For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.</p>
</div>
</div>
</div>


<script src="../../code.jquery.com/jquery-3.7.0.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
<script src="../../cdn.jsdelivr.net/npm/bootstrap%405.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<script src="../../unpkg.com/d3-force-boundary%400.0.1/dist/d3-force-boundary.min.js"></script>
<script>
  $(function () {
    // overlays stuffs
    $('#trigger-about').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#about').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-team').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#team').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-terms').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#termsofuse').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-privacy').click(function () {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#privacy-policy').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    })

    $('.close-overlay').click(function() {
      $('.overlays').fadeOut(function() {
        $('#dark-overlay').fadeOut();
      });
    });

    $('#dark-overlay').click(function() {
      $('.overlays').fadeOut();
      $('#dark-overlay').fadeOut();
      if (typeof GeometryWidget !== 'undefined') {
        GeometryWidget.stopLoop();
      }
    });
  })
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-1566631-4"></script>
<script>
      $.ajaxSetup({
        headers: {
          'X-CSRF-TOKEN': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H"
        }
      });

      // handles account dropdown menu
      $(function () {
        $('#language-dropdown-btn').click(function (e) {
          $('#language-dropdown-menu').css('display', 'block');
          $('#account-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function () {
          $('#language-dropdown-menu').css('display', 'none')
        })
      })

      $(function () {
        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        })
      })

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        if (retval) {
          $('#current-action').show();
          $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
          $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
          triggerRightPanels();
          isPlaying = true;
        }
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; ++i) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      const MOBILE_WIDTH = 1000;
      const matchMediaMobile = window.matchMedia(`only screen and (max-width: ${MOBILE_WIDTH}px)`);
      const matchMediaNarrow = window.matchMedia(`only screen and (max-width: 500px)`);
      function isMobile() {
        return matchMediaMobile.matches;
      }
      //To fix the issue of a narrow desktop window being asked to rotate, I am now checking for it based on the navigator.userAgent to see if its mobile or not.
      //This may change in the future if browsers decide to change the naming of userAgent for mobile browsers so may need to keep an eye on this.
      function isMobileOS() {
        return /Mobi/i.test(navigator.userAgent) && !/ipad/i.test(navigator.userAgent);
      }
      let portraitMatcher = window.matchMedia("(orientation:portrait)");
      function isPortrait() {
        return portraitMatcher.matches;
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.colour').css("color", surpriseColour);
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
        });
      });

/*
      // GA dropped 26 Jun 2023 and then made official on 18 Aug 2023
/*
      // the sunset-ed GA, commented on 26 Jun 2023, and Prof Halim doesn't bother to use anymore
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
*/

      // function setCookie(cname, cvalue, exdays) {
      //   const d = new Date();
      //   d.setTime(d.getTime() + (exdays*24*60*60*1000));
      //   let expires = "expires="+ d.toUTCString();
      //   document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
      // }

//       //         $(function() {
//           $('#gdpr-accept').click(function () {
// /*
//             // added on 26 Jun 2023
//             window.dataLayer = window.dataLayer || [];
//             function gtag(){dataLayer.push(arguments);}
//             gtag('js', new Date());

//             gtag('config', 'UA-1566631-4');
// */
// //            ga('create', 'UA-1566631-4', 'auto');
// //            ga('send', 'pageview');
//             setCookie('use_google_analytics', 'true', 365)
//             $('#gdpr-popup').hide()
//           });
//           $('#gdpr-reject').click(function () {
//             setCookie('use_google_analytics', 'false', 365)
//             $('#gdpr-popup').hide()
//           });
//         });
//       
      $('#gdpr-privacy-policy').click(function () {
        if ($(window).width() > 600) {
          $('#dark-overlay').fadeIn(function() {
            $('#privacy-policy').fadeIn();
          });
        }
        else
          alert('Sorry, this dialog is too big. Please load it on bigger screen');
      })
    </script>

<script src="../js/jquery-ui.min.js"></script>

<script src="../js/d3.min.js"></script>
<script src="../js/viz-1.0.10.js"></script>

<script src="../js/graph_library/constant.js"></script>
<script src="../js/graph_library/drawgraph.js"></script>
<script src="../js/graph_library/GraphEdgeWidget.js"></script>
<script src="../js/graph_library/GraphPolygonWidget.js"></script>
<script src="../js/graph_library/GraphVertexWidget.js"></script>
<script src="../js/graph_library/GraphWidget.js"></script>
<script src="../js/graph_library/helperObjects89db.js?refresh22aug9pm"></script> 
<script src="../js/graph_library/misc.js"></script>
<script src="../js/graph_library/properties.js"></script>
<script src="../js/graph_library/Widget.js"></script>
<script src="../js/graph_library/force_directed_library.js"></script>

<script>
      $(function () {
        let defaultPlaybackSpeed = 1;
                createPlaybackSpeedSlider(defaultPlaybackSpeed);


        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        });
        //Mobile Design Related DOM Manipulations
        if (isMobile()) {
          $("#status").css({
            "bottom": "10%",
            "height": "12%",
            "max-height": "54px"
          });
          $("#current-action").css("bottom", "22%");
          $('#status-hide').remove();
          $('#left-bar').remove();
          $('#right-bar').remove();
          $("#mode-menu").remove();
          $("#codetrace").css("z-index", 1);
          $("#bottom-bar a").hide();
          $("#bottom-bar").css("height", $("#topbar").css("height"));
          $(".speed-dropup-btn").show();
          $("#go-to-beginning").remove();
          $("#go-to-end").remove();
          $("#pause").remove();
          $("#play").remove();
          $("#previous").remove();
          $("#next").remove();

          //make progress bar longer
          $("#progress-bar").css({
            left: "30%",
            width: "60%",
            'margin-left': 0
          })
        }
      })

      let mobilePlaybackOverlayTimeout;
      $(function() {
        $("#viz").on("click", () => {
          if (isMobile()) {
            if ($("#mobile-playback-overlay").is(":hidden") && isPlaying) {
              $("#mobile-playback-overlay").fadeIn();
              hideMobilePlaybackOverlay(6000);
            } else {
              $("#mobile-playback-overlay").fadeOut();
            }
          }
        });
        $("#mobile-playback-overlay").on("click", (event) => {
          if (event.target === event.currentTarget) //to ensure clicks on the controls dont fade the overlay
            $("#mobile-playback-overlay").fadeOut();
          else
            hideMobilePlaybackOverlay(5000);
        })
      });
      function hideMobilePlaybackOverlay(timeOut) {
        if (mobilePlaybackOverlayTimeout)
          clearTimeout(mobilePlaybackOverlayTimeout);
        mobilePlaybackOverlayTimeout = setTimeout(() => {
            $("#mobile-playback-overlay").fadeOut();
        }, timeOut);
      }
      function mobilePlaybackPauseOrPlay() {
        if ($("#mobile-playback-overlay").hasClass("playing")) {
          pause();
          hideMobilePlaybackOverlay(5000);
        } else {
          play();
          hideMobilePlaybackOverlay(3000);
        }
      }
      let rewindLabelTimeout, forwardLabelTimeout;
      function mobilePlaybackRewind() {
        $("#mobile-playback-rewind-label").css("opacity", 1);
        if (rewindLabelTimeout)
          clearTimeout(rewindLabelTimeout);
        rewindLabelTimeout = setTimeout(() => {
          $("#mobile-playback-rewind-label").css("opacity", 0);
        }, 800);
        stepBackward(7);
      }
      function mobilePlaybackForward() {
        $("#mobile-playback-forward-label").css("opacity", 1);
        if (forwardLabelTimeout)
          clearTimeout(forwardLabelTimeout);
        forwardLabelTimeout = setTimeout(() => {
          $("#mobile-playback-forward-label").css("opacity", 0);
        }, 800);
        stepForward(7);
      }

      //let eLectureSessionHistory = {};
      const sectorColors = ['#05a4d0', '#f1c706', '#fa0202'];
      function setSlideTimelineColor(slideNo) {
        const sectionNo = slideNo.split('-')[0];
        $(`[slideNo="${slideNo}"]`).css('background', sectorColors[(parseInt(sectionNo) % 3)]);
      }

      let currSlideTimer = null; //global so that we can clear the timeout when required

      const lectureIds = [{"id":57,"category":"maxflow","order":1,"top":"80px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:17:33","updated_at":"2022-09-08 08:27:33","section":-1,"code":"","section_order":-1,"value":"1","text":"<p>Maximum (Max) Flow is one of the problems in the family of problems involving flow in networks.<\/p><br><p>In Max Flow problem, we aim to find the maximum flow from a particular source vertex <b>s<\/b> to a particular sink vertex <b>t<\/b> in a directed weighted&nbsp;graph <b>G<\/b>.<\/p><br><p>There are several algorithms for finding the maximum flow including Ford-Fulkerson method, Edmonds-Karp algorithm, and Dinic&#39;s algorithm (there are a few others, but they are not included in this visualization yet).<\/p><br><p>The dual problem of Max Flow is Min Cut, i.e., by finding the max <b>s-t<\/b> flow of <b>G<\/b>, we also simultaneously find the min <b>s-t<\/b> cut of <b>G<\/b>, i.e., the set of edges with minimum weight that have to be removed from <b>G<\/b> so that there is no path from <b>s<\/b> to <b>t<\/b> in <b>G<\/b>.<\/p>","title":"Maximum (Max) Flow"},{"id":753,"category":"maxflow","order":1,"top":"80px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2021-09-09 03:20:08","updated_at":"2021-09-09 07:18:18","section":57,"code":"","section_order":1,"value":"1-1","text":"<p>Max-Flow (or Min-Cut) problems arise in various applications, e.g.,<\/p><ol><li>Transportation-related problems (what is the best way to send goods\/material from <b>s<\/b> (perhaps a factory) to <b>t<\/b> (perhaps a super-sink of all end-users)<\/li><li>Network attacks problems (sabotage\/destroy some edges to disconnect two important points <b>s<\/b> and <b>t<\/b>)<\/li><li>(Bipartite) Matching and Assignment problems (that also has specialized algorithms, see <a href=\".\/matching\"><u>Graph Matching<\/u><\/a> visualization<\/li><li><a href=\"https:\/\/en.wikipedia.org\/wiki\/Maximum_flow_problem#Baseball_elimination\" target=\"_blank\"><u>Sport teams prospects<\/u><\/a><\/li><li><a href=\"https:\/\/en.wikipedia.org\/wiki\/Maximum_flow_problem#Image_segmentation\" target=\"_blank\"><u>Image segmentation<\/u><\/a>, etc...<\/li><\/ol>","title":"Motivation-Applications"},{"id":58,"category":"maxflow","order":2,"top":"400px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:18:11","updated_at":"2022-09-08 03:18:06","section":-1,"code":"","section_order":-1,"value":"2","text":"<p>This visualization page will show the execution of a chosen Max Flow algorithm running on a flow (residual) graph.<\/p><br><p>To make the visualization of these flow graphs consistent, we enforce a graph drawing rule for this page whereby the source vertex <b>s<\/b>\/sink vertex <b>t<\/b> is always vertex 0\/<b>V<\/b>-1 and is always drawn on the leftmost\/rightmost side of the visualization, respectively. Another visualization-specific constraint is that the edge capacities are integers between [1..99].<\/p><br><p>These visualization-specific constraints do&nbsp;<b>not<\/b> exist in the standard max flow problems.<\/p>","title":"Visualization"},{"id":747,"category":"maxflow","order":1,"top":"","right":"","bottom":"250px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2021-09-09 02:50:41","updated_at":"2022-09-08 08:28:08","section":58,"code":"$(\"#draw\").addClass(\"menu-highlighted\");\n$(\"#modeling\").addClass(\"menu-highlighted\");\n\/\/ $(\"#random\").addClass(\"menu-highlighted\");\n$(\"#examples\").click().addClass(\"menu-highlighted\");","section_order":2,"value":"2-1","text":"<p>The input for a Max Flow algorithm is a flow graph (a <b>directed weighted<\/b> graph <b>G<\/b> = <b>(V, E)<\/b> where edge weight of edge <b>e<\/b> represent the capacity <b>c(e)<\/b> (the unit is problem-dependent, e.g., liters\/second, person\/hour, etc) of flow that can go through that edge) with two distinguished vertices: The source vertex <b>s<\/b>&nbsp;(with in-degree 0) and the sink\/target\/destination vertex <b>t <\/b>(with out-degree 0). The flow graph is usually <b>s<\/b>-<b>t<\/b> connected, i.e., there is at least one path from <b>s<\/b> to <b>t <\/b>(otherwise the max flow is trivially 0).<\/p><br><p>In this visualization, these two additional inputs of <b>s<\/b> (usually vertex 0) and <b>t<\/b> (usually vertex <b>V<\/b>-1) are asked before the execution of the chosen Max Flow algorithm and can be customized by the user.<\/p>","title":"Input"},{"id":756,"category":"maxflow","order":2,"top":"440px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2021-09-09 07:21:29","updated_at":"2022-09-08 08:28:55","section":58,"code":"","section_order":2,"value":"2-2","text":"<p>The output for a Max Flow algorithm is the max flow value and an assignment of flow <b>f<\/b> to each edge that satisfies two important constraints:<\/p><ol><li><b>Capacity constraints<\/b> (flow on each edge (<b>f(e)<\/b>) is between 0 and its (unit) capacity (<b>c(e)<\/b>), i.e., 0 \u2264 <b>f(e)<\/b> \u2264 <b>c(e)<\/b> \u2014 not negative and not more than the capacity), and<\/li><li><b>Equilibrium constraints<\/b> (for every vertex except <b>s<\/b> and <b>t<\/b>, flow-in = flow-out)<\/li><\/ol> so that the value of the flow (<b>value(f) = \u2211<sub>v: (s, v) \u2208 E<\/sub> f(s,v)<\/b>) is maximum.<p><\/p><br><p>In this visualization, we focus on showing the final max flow value and the final ST-min cut components at the end of each max flow algorithm execution, instead of the precise assignment of flow <b>f<\/b> to each edge, i.e., <b>f(e)<\/b> must be computed manually from the initial capacity <b>c(e)<\/b> (first frame of the animation) minus the final residual capacity of that edge <b>e<\/b> (last frame of the animation). This missing feature will likely be added in the next iteration of this visualization page.<\/p><br><p>Discussion: Is there other ways to compute the value of the flow <b>value(f)<\/b>?<\/p>","title":"Output"},{"id":788,"category":"maxflow","order":3,"top":"440px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-09-05 03:31:45","updated_at":"2022-09-05 03:36:34","section":58,"code":"","section_order":2,"value":"2-3","text":"<p>We can also compute the value of the flow  as <b>value(f) = \u2211<sub>v: (v,t) \u2208 E<\/sub> f(v,t)<\/b>.<\/p><br><p>In fact, we can take any st-cut (to be elaborated later) and compute the value of the flow across that st-cut too, however these two (flows that go out from the source vertex <b>s<\/b> or flows that go in to the sink vertex <b>t<\/b>) are the easiest to compute.<\/p>","title":"The Answer"},{"id":643,"category":"maxflow","order":4,"top":"440px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-09-12 03:02:12","updated_at":"2022-09-08 08:31:28","section":58,"code":"","section_order":2,"value":"2-4","text":"<p>At the start of the three Max Flow algorithms discussed in this visualization (Ford-Fulkerson method, Edmonds-Karp algorithm, and Dinic&#39;s algorithm), the initial flow graph is converted into residual graph (with potential addition of back flow edges with initial capacity of zeroes).<\/p><br><p>The edges in the residual graph store the <i>remaining<\/i> capacities of those edges that can be used by future flow(s). At the beginning, these remaining capacities equal to the original capacities as specified in the input flow graph.<\/p><br><p>A Max Flow algorithm will send flows to use some (or all) of these available capacities, iteratively.<\/p><br><p>Once the remaining capacity of an edge reaches 0, that edge can no longer admit any more flow. In the near future, we will update this visualization so that any edge in the residual graph that has capacity 0 (including the initial zeroes of the back flow edges) is <b>not<\/b> shown in the visualization.<\/p>","title":"Residual Graph"},{"id":59,"category":"maxflow","order":3,"top":"","right":"","bottom":"250px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:19:00","updated_at":"2022-09-05 04:36:45","section":-1,"code":"$(\"#draw\").addClass(\"menu-highlighted\");\n$(\"#modeling\").addClass(\"menu-highlighted\");\n\/\/ $(\"#random\").addClass(\"menu-highlighted\");\n$(\"#examples\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"3","text":"<p>There are three different sources for specifying an input flow graph:<\/p><ol><li><b>Draw Graph<\/b>: You can draw <b>any<\/b> directed weighted (weight \u2208 [1..99]) graph as the input flow graph with vertex 0 as the default source vertex (the left side of the screen) and vertex <b>V<\/b>-1 as the default sink vertex (the right side of the screen),<\/li><li><b>Modeling<\/b>: Several graph problems can be reduced into a Max Flow problem. In this visualization, we have the modeling examples for the famous Maximum Cardinality Bipartite Matching (MCBM) problem, Rook Attack problem (currently disabled), and Baseball Elimination problem (currently disabled),<\/li><li><b>Example Graphs<\/b>: You can select from the list of our selected example flow graphs to get you started.<\/li><\/ol>","title":"Specifying Input Flow Graph"},{"id":794,"category":"maxflow","order":4,"top":"","right":"","bottom":"250px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-09-05 04:36:40","updated_at":"2022-09-05 04:37:46","section":-1,"code":"hideAllThirdTiers();\n$(\"#fordfulkerson\").addClass(\"menu-highlighted\");\n$(\"#edmondskarp\").addClass(\"menu-highlighted\");\n$(\"#dinic\").addClass(\"menu-highlighted\");","section_order":-1,"value":"4","text":"<p>There are three different max flow algorithms in this visualization:<\/p><ol><li>The slow O(<b>mf \u00d7 E<\/b>) <b>Ford-Fulkerson<\/b> method,<\/li><li>The O(<b>V \u00d7 E^2<\/b>) <b>Edmonds-Karp<\/b> algorithm, or<\/li><li>The O(<b>V^2 \u00d7 E<\/b>) <b>Dinic&#39;s<\/b> algorithm.<\/li><\/ol><p>There are a few other <a href=\"https:\/\/en.wikipedia.org\/wiki\/Maximum_flow_problem#Algorithms\" target=\"_blank\"><u>max flow algorithms<\/u><\/a> out there, but they are not available in this visualization yet.<\/p>","title":"Max Flow Algorithms"},{"id":795,"category":"maxflow","order":1,"top":"","right":"","bottom":"250px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-09-05 04:37:19","updated_at":"2022-09-05 04:38:10","section":794,"code":"$(\"#fordfulkerson\").addClass(\"menu-highlighted\");\n$(\"#edmondskarp\").addClass(\"menu-highlighted\");\n$(\"#dinic\").addClass(\"menu-highlighted\");","section_order":4,"value":"4-1","text":"<p>For the three Max Flow algorithms discussed in this visualization, successive flows are sent from the source vertex <b>s<\/b> to the sink vertex <b>t<\/b> via available <b>augmenting paths<\/b> (augmenting path is a path from <b>s<\/b> to <b>t<\/b> that goes through edges with positive weight residual capacity (<b>c(e)-f(e)<\/b>) left).<\/p><br><p>The three Max Flow algorithms in this visualization have different behavior on how they find augmenting paths.<\/p><br><p>However, all three Max Flow algorithms in this visualization stop when there is no more augmenting path possible and report the max flow value (and the assignment of flow on each edge in the flow graph).<\/p><br><p>Later we will discuss that this max flow value is also the min cut value of the flow graph (that famous Max-Flow\/Min-Cut Theorem).<\/p>","title":"Similar But Not The Same"},{"id":60,"category":"maxflow","order":5,"top":"","right":"","bottom":"250px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:19:35","updated_at":"2022-09-05 04:38:28","section":-1,"code":"$(\"#fordfulkerson\").addClass(\"menu-highlighted\");","section_order":-1,"value":"5","text":"<pre>start with 0 flow<br>while there exists an augmenting path: \/\/ iterative algorithm<br>\u2009\u2009find an augmenting path (for now, &#39;any&#39; graph traversal will do)<br>\u2009\u2009compute bottleneck capacity<br>\u2009\u2009increase flow on the path by the bottleneck capacity<\/pre>","title":"Ford-Fulkerson Method"},{"id":749,"category":"maxflow","order":1,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2021-09-09 03:01:03","updated_at":"2022-09-08 08:33:26","section":60,"code":"$(\"#fordfulkerson\").addClass(\"menu-highlighted\");","section_order":5,"value":"5-1","text":"<p>This famous theorem states that in a flow network, the <b>maximum flow<\/b> from <b>s<\/b> to <b>t<\/b> is equal to the total weight of the edges in a <b>minimum cut<\/b>, i.e., the smallest total weight of the edges that have to be removed to disconnect <b>s<\/b> from <b>t<\/b>.<\/p><br><p>In a typical Computer Science classes, the lecturer will usually spend some time to properly explain this theorem (explaining what is an st-cut, capacity of an st-cut, net flow across an st-cut equals to current flow f assignment that will never exceed the capacity of the cut, and finally that Max-Flow\/Min-Cut Theorem). For this visualization, we just take this statement as it is.<\/p><br><p>Discussion: For live class in NUS, we will actually discuss these theorem.<\/p>","title":"Max-Flow\/Min-Cut Theorem"},{"id":789,"category":"maxflow","order":2,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-09-05 03:51:17","updated_at":"2022-09-05 04:38:32","section":60,"code":"$(\"#fordfulkerson\").addClass(\"menu-highlighted\");","section_order":5,"value":"5-2","text":"<p>An <b>st-cut<\/b> partitions the vertices of a graph into two disjoint sets <b>S<\/b> and <b>T<\/b> where source <b>s &in; S<\/b> and sink <b>t &in; T<\/b>.<\/p><br><p>The <b>capacity<\/b> of an st-cut is the sum of the capacities of the edges that cross the cut from <b>S<\/b> to <b>T<\/b>.<\/p><br><p>The <b>net flow<\/b> across an st-cut is the sum of the flows on edges from <b>S &rarr; T<\/b> minus the flows from <b>T &rarr; S<\/b>.<\/p><br><p>Steven has not properly digitize this slide, so please refer to the PowerPoint version.<\/p>","title":"Cuts and Flows, Definitions"},{"id":790,"category":"maxflow","order":3,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-09-05 03:56:20","updated_at":"2022-09-05 04:38:32","section":60,"code":"$(\"#fordfulkerson\").addClass(\"menu-highlighted\");","section_order":5,"value":"5-3","text":"<p>Let <b>f<\/b> be a flow, and let <b>(S,T)<\/b> be an st-cut.<br>Then the net flow across <b>(S,T)<\/b> equals the value of <b>f<\/b>.<\/p><br><p>This can be proven using Proof by induction.<\/p><br><p>Steven has not properly digitize this slide, so please refer to the PowerPoint version.<\/p>","title":"Cuts and Flows, Equal"},{"id":791,"category":"maxflow","order":4,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-09-05 03:59:23","updated_at":"2022-09-05 04:38:32","section":60,"code":"$(\"#fordfulkerson\").addClass(\"menu-highlighted\");","section_order":5,"value":"5-4","text":"<p>Let <b>f<\/b> be a flow, and let <b>(S,T)<\/b> be an st-cut.<br>Then <b>value(f) \u2264 capacity(S,T)<\/b>.<\/p><br><p>Simple proof:<br><b>value(f)<\/b> = flow across cut <b>(S,T)<\/b> by flow value proposition, and<br>flow across cut <b>(S,T)<\/b> \u2264 capacity <b>(S,T)<\/b> as flow is bounded by the capacity of the st-cut.<\/p>","title":"Cuts and Flows, Weak Duality"},{"id":792,"category":"maxflow","order":5,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-09-05 04:03:11","updated_at":"2022-09-05 04:41:20","section":60,"code":"$(\"#fordfulkerson\").addClass(\"menu-highlighted\");","section_order":5,"value":"5-5","text":"<p>Let <b>f<\/b> be a maximum flow.<br>Let <b>(S,T)<\/b> be an st-cut with minimum capacity.<br>Then <b>value(f) = capacity(S,T)<\/b>.<\/p><br><p>Compare this with the previous slide.<\/p>","title":"Max-Flow\/Min-Cut Theorem, Formally"},{"id":750,"category":"maxflow","order":6,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2021-09-09 03:04:25","updated_at":"2022-09-08 08:34:36","section":60,"code":"$(\"#fordfulkerson\").addClass(\"menu-highlighted\");","section_order":5,"value":"5-6","text":"<p>Using the Max-Flow\/Min-Cut Theorem, we can then prove that flow <b>f<\/b> is a maximum flow if and only if there is no (more) augmenting path remaining in the residual graph.<\/p><br><p>As this is what Ford-Fulkerson Method is doing, we can conclude the correctness of this Ford-Fulkerson Method, i.e., if Ford-Fulkerson Method terminates, then there is no augmenting path left and thus the resulting flow is maximum (and we can also construct the equivalent Min-Cut, next slide).<\/p>","title":"Augmenting Path Theorem"},{"id":755,"category":"maxflow","order":7,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2021-09-09 03:37:17","updated_at":"2022-09-08 08:37:28","section":60,"code":"$(\"#fordfulkerson\").addClass(\"menu-highlighted\");","section_order":5,"value":"5-7","text":"<p>We can constructively identify the edges in the Min-Cut as follows:<\/p><ol><li>Run Ford-Fulkerson (or any other Max Flow) algorithm until it terminates.<\/li><li>Let <b>S<\/b> be the set of vertices that are still reachable from the source <b>s<\/b>.<br>We can run DFS (or BFS) in the residual graph from the source vertex <b>s<\/b>.<br>All the vertices that are still reachable are in <b>S<\/b>.<br>Let <b>T<\/b> be the remaining vertices, i.e., <b>T = V &bsol; S<\/b>.<\/li><li>For every edge in <b>S<\/b>, enumerate outgoing edges:<br>If edge exits <b>S<\/b> (and into <b>T<\/b>), add to min-cut.<br>If both ends of edge are in <b>S<\/b>, then continue.<\/li><\/ol><p>That&#39;s it, <b>(S,T)<\/b> is an st-cut, edges from (<b>S &rarr; T<\/b>) are the minimum cut, and the flow that goes through this minimum cut <b>(S,T)<\/b> is the maximum possible.<\/p>","title":"Finding Edges in the Min-Cut"},{"id":793,"category":"maxflow","order":8,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-09-05 04:13:08","updated_at":"2022-09-05 04:38:32","section":60,"code":"$(\"#fordfulkerson\").addClass(\"menu-highlighted\");","section_order":5,"value":"5-8","text":"<p>Steven has not properly digitize this slide, so please refer to the PowerPoint version.<\/p>","title":"The Proofs"},{"id":751,"category":"maxflow","order":9,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2021-09-09 03:10:24","updated_at":"2022-09-08 08:38:30","section":60,"code":"$(\"#fordfulkerson\").addClass(\"menu-highlighted\");","section_order":5,"value":"5-9","text":"<p>Ford-Fulkerson method always terminates if the capacities are integers.<\/p><br><p>This is because every iteration of Ford-Fulkerson method always finds a new augmenting path and each augmenting path must has bottleneck capacity at least 1 (due to that integer constraint). Therefore, each iteration increases the flow of at least one edge by at least 1, edging the Ford-Fulkerson closer to termination.<\/p><br><p>As the number of edges is finite (as well as the finite max capacity per edge), this guarantees the eventual termination of Ford-Fulkerson method when the max flow <b>mf<\/b> is reached and there is no more augmenting path left.<\/p><br><p>In the worst case, Ford-Fulkerson method runs for <b>mf<\/b> iterations, and each time it uses O(<b>E<\/b>) DFS. The rough overall runtime is thus O(<b>mf \u00d7 E<\/b>) &mdash; this is actually not desirable especially if the value of <b>mf<\/b> is a huge number.<\/p><br><p>Discussion: What if the capacities are rational numbers? What if the capacities are floating-point numbers?<\/p>","title":"Analysis of Ford-Fulkerson Method"},{"id":801,"category":"maxflow","order":10,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-09-08 08:38:40","updated_at":"2022-09-08 08:40:56","section":60,"code":"$(\"#fordfulkerson\").addClass(\"menu-highlighted\");","section_order":5,"value":"5-10","text":"<p>If the capacities are rational numbers, we can still convert these capacities to integer again, by multiplying all capacities with the LCM(all denominators).<\/p><br><p>If the capacities are floating-point numbers, e.g., 1\/3 = 0.33....., algorithms that are based on Ford-Fulkerson method may be trapped in an infinite loop due to 1\/3+1\/3+1\/3 != 1 as 0.33..+0.33...+0.33.. = 0.99...<\/p>","title":"Non-Integer Capacities"},{"id":796,"category":"maxflow","order":6,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-09-05 04:41:59","updated_at":"2022-09-08 08:39:12","section":-1,"code":"$(\"#edmondskarp\").addClass(\"menu-highlighted\");\n$(\"#dinic\").addClass(\"menu-highlighted\");","section_order":-1,"value":"6","text":"<p>Idea: What if we don&#39;t consider <b>any<\/b> augmenting paths but consider augmenting paths with the smallest number of edges involved first (so we don&#39;t put flow on more edges than necessary).<\/p>","title":"Shortest Augmenting Paths First"},{"id":797,"category":"maxflow","order":1,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-09-05 04:42:26","updated_at":"2022-09-05 04:44:04","section":796,"code":"$(\"#edmondskarp\").addClass(\"menu-highlighted\");","section_order":6,"value":"6-1","text":"<p>Implementation: We first ignore capacity of the edges first (assume all edges in the residual graph have weight 1), and we run O(E) BFS to find the shortest (in terms of # of edges used) augmenting path. Everything else is the same as the basic Ford-Fulkerson Method outlined earlier.<\/p><br><p>It can be proven that Edmonds-Karp will use at most O(VE) iterations thus it runs in at most in O(VE * E) = O(VE^2) time.<\/p>","title":"Idea 1: Edmonds-Karp"},{"id":799,"category":"maxflow","order":2,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-09-05 04:46:21","updated_at":"2022-09-08 08:42:38","section":796,"code":"$(\"#edmondskarp\").addClass(\"menu-highlighted\");","section_order":6,"value":"6-2","text":"<p>Steven has not properly digitize this slide, so please refer to the PowerPoint version.<\/p><br><p>Also, empirically (but not yet proven), this O(mn) iterations worst-case bound is very hard to achieve and the current known hardest flow graph can only force Edmonds-Karp (and Dinic&#39;s) algorithm to run in O(mn\/12) iterations.<\/p>","title":"The Proofs"},{"id":798,"category":"maxflow","order":3,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-09-05 04:44:15","updated_at":"2022-09-08 08:43:37","section":796,"code":"$(\"#dinic\").addClass(\"menu-highlighted\");","section_order":6,"value":"6-3","text":"<p>Dinic&#39;s algorithm also uses similar strategy of finding shortest augmenting paths first.<\/p><br><p>But Dinic&#39;s algorithm runs in a faster time of O(V^2 \u00d7 E) due to the more efficient usage of BFS shortest path information.<\/p><br><p>This slide will be expanded.<\/p>","title":"Idea 2: Dinic&#39;s"},{"id":731,"category":"maxflow","order":7,"top":"80px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2020-07-24 05:09:41","updated_at":"2022-09-08 08:43:56","section":-1,"code":"","section_order":-1,"value":"7","text":"<p>When you are presented with a Max Flow (or a Min Cut)-related problem, we do not have to reinvent the wheel every time.<\/p><br><p>You are allowed to use\/modify\/adapt\/enhance our implementation code for Max Flow Algorithms (Edmonds-Karp\/Dinic&#39;s): <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch8\/maxflow.cpp\" target=\"_blank\"><u>maxflow.cpp<\/u><\/a>&nbsp;|&nbsp;<a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch8\/maxflow.py\" target=\"_blank\"><u>py<\/u><\/a>&nbsp;|&nbsp;<a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch8\/maxflow.java\" target=\"_blank\"><u>java<\/u><\/a>&nbsp;|&nbsp;<a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch8\/maxflow.ml\" target=\"_blank\"><u>ml<\/u><\/a>.<\/p>","title":"Efficient Max Flow Algorithm Implementation"}];
      const numSlides = lectureIds.length;
      var sectorJunction12Section = 0, sectorJunction12Slide = 0;
      var sectorJunction23Section = 0, sectorJunction23Slide = 0;
      var sector1Count = 0, sector2Count = 0, sector3Count = 0;
      const sectorLength = Math.floor(numSlides / 3);
      function createELectureTimelineDisplay() {
        for (let j = 0; j < numSlides; ++j) {
          const currLecture = lectureIds[j].value;
          if (currLecture.includes('-')) {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-slide" slideNo=${lectureIds[j].value}></div>`)
            );
          } else {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-checkpoint" slideNo=${lectureIds[j].value}></div>`)
            );
          }
        }
      }

      function setSectorJunctionInfo() {
          //setting the sector junction slide numbers
          const j12 = sectorLength !== 0 ? (sectorLength - 1): 0;
          const j23 = sectorLength !== 0 ? (2 * sectorLength - 1) : 0;

          const sectorJunction12 = lectureIds[j12].value.split('-');
          sectorJunction12Section = parseInt(sectorJunction12[0]);
          sectorJunction12Slide = sectorJunction12.length > 1 ? parseInt(sectorJunction12[1]) : sectorJunction12Slide;

          const sectorJunction23 = lectureIds[j23].value.split('-');
          sectorJunction23Section = parseInt(sectorJunction23[0]);
          sectorJunction23Slide = sectorJunction23.length > 1 ? parseInt(sectorJunction23[1]) : sectorJunction23Slide;
      }

      function runSlide(slide) { // Steven's patch on 28 Jan 2022: Properly remove slide 99, 99-1, 99-2, 99-3, integrate with the earlier slides
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 3 + "%)");
          
        }
        if (slide == '1-1') {
          $("#e-lecture").html("slide " + slide + " (" + 7 + "%)");
          
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 11 + "%)");
          
        }
        if (slide == '2-1') {
          $("#e-lecture").html("slide " + slide + " (" + 15 + "%)");
          $("#draw").addClass("menu-highlighted");
$("#modeling").addClass("menu-highlighted");
// $("#random").addClass("menu-highlighted");
$("#examples").click().addClass("menu-highlighted");
        }
        if (slide == '2-2') {
          $("#e-lecture").html("slide " + slide + " (" + 19 + "%)");
          
        }
        if (slide == '2-3') {
          $("#e-lecture").html("slide " + slide + " (" + 23 + "%)");
          
        }
        if (slide == '2-4') {
          $("#e-lecture").html("slide " + slide + " (" + 26 + "%)");
          
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 30 + "%)");
          $("#draw").addClass("menu-highlighted");
$("#modeling").addClass("menu-highlighted");
// $("#random").addClass("menu-highlighted");
$("#examples").click().addClass("menu-highlighted");
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 34 + "%)");
          hideAllThirdTiers();
$("#fordfulkerson").addClass("menu-highlighted");
$("#edmondskarp").addClass("menu-highlighted");
$("#dinic").addClass("menu-highlighted");
        }
        if (slide == '4-1') {
          $("#e-lecture").html("slide " + slide + " (" + 38 + "%)");
          $("#fordfulkerson").addClass("menu-highlighted");
$("#edmondskarp").addClass("menu-highlighted");
$("#dinic").addClass("menu-highlighted");
        }
        if (slide == '5') {
          $("#e-lecture").html("slide " + slide + " (" + 42 + "%)");
          $("#fordfulkerson").addClass("menu-highlighted");
        }
        if (slide == '5-1') {
          $("#e-lecture").html("slide " + slide + " (" + 46 + "%)");
          $("#fordfulkerson").addClass("menu-highlighted");
        }
        if (slide == '5-2') {
          $("#e-lecture").html("slide " + slide + " (" + 50 + "%)");
          $("#fordfulkerson").addClass("menu-highlighted");
        }
        if (slide == '5-3') {
          $("#e-lecture").html("slide " + slide + " (" + 53 + "%)");
          $("#fordfulkerson").addClass("menu-highlighted");
        }
        if (slide == '5-4') {
          $("#e-lecture").html("slide " + slide + " (" + 57 + "%)");
          $("#fordfulkerson").addClass("menu-highlighted");
        }
        if (slide == '5-5') {
          $("#e-lecture").html("slide " + slide + " (" + 61 + "%)");
          $("#fordfulkerson").addClass("menu-highlighted");
        }
        if (slide == '5-6') {
          $("#e-lecture").html("slide " + slide + " (" + 65 + "%)");
          $("#fordfulkerson").addClass("menu-highlighted");
        }
        if (slide == '5-7') {
          $("#e-lecture").html("slide " + slide + " (" + 69 + "%)");
          $("#fordfulkerson").addClass("menu-highlighted");
        }
        if (slide == '5-8') {
          $("#e-lecture").html("slide " + slide + " (" + 73 + "%)");
          $("#fordfulkerson").addClass("menu-highlighted");
        }
        if (slide == '5-9') {
          $("#e-lecture").html("slide " + slide + " (" + 76 + "%)");
          $("#fordfulkerson").addClass("menu-highlighted");
        }
        if (slide == '5-10') {
          $("#e-lecture").html("slide " + slide + " (" + 80 + "%)");
          $("#fordfulkerson").addClass("menu-highlighted");
        }
        if (slide == '6') {
          $("#e-lecture").html("slide " + slide + " (" + 84 + "%)");
          $("#edmondskarp").addClass("menu-highlighted");
$("#dinic").addClass("menu-highlighted");
        }
        if (slide == '6-1') {
          $("#e-lecture").html("slide " + slide + " (" + 88 + "%)");
          $("#edmondskarp").addClass("menu-highlighted");
        }
        if (slide == '6-2') {
          $("#e-lecture").html("slide " + slide + " (" + 92 + "%)");
          $("#edmondskarp").addClass("menu-highlighted");
        }
        if (slide == '6-3') {
          $("#e-lecture").html("slide " + slide + " (" + 96 + "%)");
          $("#dinic").addClass("menu-highlighted");
        }
        if (slide == '7') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
        }
        clearTimeout(currSlideTimer);
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };
      var slideTimeline = {};

      //reads all visited slides in the slideTimeline and gives them their sector color
      function setVisitedSlideTimelineColors() {
        for(const [sectionNo, visitedSlides] of Object.entries(slideTimeline)) {
          const visitedSlides = slideTimeline[sectionNo];
          for(const visitedSlideNo of visitedSlides) {
            setSlideTimelineColor(visitedSlideNo);
          }
        }
      }

      //only called on load if there is nothing in session
      function setTimelineForCompletedSector(sectorNum) {
        let len = sectorLength;
        switch (sectorNum) {
          case 1 : len = sectorLength; break;
          case 2 : len = 2 * sectorLength; break;
          default: len = numSlides;
        }
        let i = 0;
        switch (sectorNum) {
          case 1 : i = 0; break;
          case 2 : i = sectorLength; break;
          default: i = 2 * sectorLength;
        }
        for (; i < len; i++) {
          saveELectureTimeline(lectureIds[i].value, true);
        }
      }

      function getUserSectorHistory(callback) {
        $.ajax({
          type: 'GET',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            topic: "/maxflow".substring(1)
          }
        }
        ).done(function (data) {
            if (data.data[0] === 1) {
              setF1SectorColor(1);
              setTimelineForCompletedSector(1);
            }
            if (data.data[1] === 1) {
              setF1SectorColor(2);
              setTimelineForCompletedSector(2);
            }
            if (data.data[2] === 1) {
              setF1SectorColor(3);
              setTimelineForCompletedSector(3);
            }
            callback();
        }).fail(function (data) {
            console.log('get user sector history failed!');
        });
      }

      function getELectureTimelineFromSession() {
        const page = "/maxflow".substring(1);
        const timelineKey = page + '-slide-timeline';
        const storedTimeline = window.sessionStorage.getItem(timelineKey);
        if (storedTimeline) {
          slideTimeline = JSON.parse(storedTimeline);
        } else {
          return false;
        }
        let slideInfo = [];
        for (const [sectionNum, slides] of Object.entries(slideTimeline)) {
          for (const slide of slides) {
            indicateSlideCompletedUI(slide);
            slideInfo = slide.split('-');
            incrementSectorVisits(parseInt(sectionNum), slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0);
          }
        }
        return true;
      }

      async function initializeELectureTimeline() {
        setSectorJunctionInfo();
        if (!getELectureTimelineFromSession())
          getUserSectorHistory(sectorBasedModeSelection);
        else
          sectorBasedModeSelection();

        createELectureTimelineDisplay();
        setVisitedSlideTimelineColors();
      }

      function setF1SectorColor(sectorNum) {
        $(`[sectorNo="${sectorNum}"]`).css('background', sectorColors[(parseInt(sectorNum) % 3)]);
      }

      function updateSectorInDB(sectorNum) {
        $.ajax({
          type: 'POST',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            section: (sectorNum - 1),
            topic: "/maxflow".substring(1)
          }
        }
        ).done(function (data) {
            //console.log("Saved the sector " + sectorNum + " as done " + JSON.stringify(data));
        }).fail(function (data) {
            console.log("Setting sector done failed new attempt! "+ JSON.stringify(data));
        });
      }

      //If 87.5% or more of the slides in sector are done
      function setF1SectorCompleted(sectorNum, isInitializationCall) {
        setF1SectorColor(sectorNum);
        //avoid api call on initialization
        if (!isInitializationCall) {
          updateSectorInDB(sectorNum);
          $(`[sectorNo="${sectorNum}"]`).css("animation", "green-pulse 2s 4");
          setTimeout(() => {
            $(`[sectorNo="${sectorNum}"]`).css("animation", "");
          }, 8000);
        }
      }

      function incrementSectorVisits(sectionNum, slideNumWithinSection, isInitializationCall) {
        //updating sector count
        if (sectionNum < sectorJunction12Section
          || (sectionNum === sectorJunction12Section && slideNumWithinSection <= sectorJunction12Slide)) {
          ++sector1Count;
          if (sector1Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(1, isInitializationCall);
        } else if (sectionNum < sectorJunction23Section
          || (sectionNum === sectorJunction23Section && slideNumWithinSection <= sectorJunction23Slide)) {
          ++sector2Count;
          if (sector2Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(2, isInitializationCall);
        } else {
          ++sector3Count;
          if (sector3Count >= Math.ceil(0.875 * (numSlides - 2 * sectorLength)))
            setF1SectorCompleted(3, isInitializationCall);
        }
      }

      function saveELectureTimeline(slideNo, isInitialization) {
        const slideInfo = slideNo.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        if (slideTimeline[sectionNo]) {
          if (!slideTimeline[sectionNo].includes(slideNo)) {
            slideTimeline[sectionNo].push(slideNo);
            const sectionNum = parseInt(sectionNo);
            incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
          }
        } else {
          slideTimeline[sectionNo] = [];
          slideTimeline[sectionNo].push(slideNo);
          const sectionNum = parseInt(sectionNo);
          incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
        }
        setSlideTimelineColor(slideNo);
        indicateSlideCompletedUI(slideNo);
      }

      function saveELectureTimelineToSession() {
        const page = "/maxflow".substring(1);
        const timelineKey = page + '-slide-timeline';
        window.sessionStorage.setItem(timelineKey, JSON.stringify(slideTimeline));
      }

      function handleTimelineOnRunSlide(slideValue) {
        const slideInfo = slideValue.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        //start timer only if the slide isnt already done
        if (!slideTimeline[sectionNo] || !slideTimeline[sectionNo].includes(slideValue)) {
          const slideTextLength = $('#electure-'+slideValue + " p").text().length + $('#electure-'+slideValue + " li").text().length;
          const CHARS_READ_PER_MS = 0.05; //when fast, 50 characters a second
          //setting max reading time as 10 seconds for around 500 character slide
          const minSlideReadingTime = Math.min(Math.max(2000, (slideTextLength / CHARS_READ_PER_MS) +  + (2000 * $('#electure-'+slideValue + " img").length)), 10000);
          currSlideTimer = setTimeout(() => {
            saveELectureTimeline(slideValue);
          }, minSlideReadingTime);
        }
      }

      function indicateSlideCompletedUI(slide) {
        $('#electure-'+slide).css("box-shadow", "3px 3px 8px green"); //set green shadow for completed slides
        $('#electure-'+slide + ' .electure-read-status').html("&#10004;");
        $('#electure-'+slide + ' .electure-read-status').attr("title", "Slide Completed!");
        $('#electure-'+slide + ' .electure-read-status').css("font-size", "17px");
      }

      function pushState(slideValue) {
        var url = '/en/maxflow';
        if (typeof slideValue != 'undefined' && slideValue != null) {
          url += '?slide=' + slideValue;
                  }
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5);
        $('#overlay').show();

        $("#e-lecture-timeline").show();
        $("#e-lecture-f1map").show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
        $("#e-lecture-timeline").hide();
        $("#e-lecture-f1map").hide();
        clearTimeout(currSlideTimer);
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      function sectorBasedModeSelection() {
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        //check params are empty and then that all sectors are completed or not
        if (!Object.keys(params).length
          && sector1Count === sectorLength && sector2Count === sectorLength && sector3Count === (numSlides - 2 * sectorLength)) {
            hideOverlay();
        }
        else
          $('#mode-menu a').click();
      }

      $(function() {
        if (isMobileOS() && portraitMatcher.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').show();
          $('#widenDeviceText').hide();
          $('#topbar').css("z-index", 10001);
        } else if (matchMediaNarrow.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').hide();
          $('#widenDeviceText').show();
          $('#topbar').css("z-index", 10001);
        } else {
          $('#rotateDeviceOverlay').hide();
          $('#topbar').css("z-index", "");
        }

        matchMediaNarrow.addEventListener('change', e => {
          //screws up for square device! NEED RESIZE EVENT
          if (e.matches) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').hide();
              $('#widenDeviceText').show();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        portraitMatcher.addEventListener('change', e => {
          if (e.matches && isMobileOS()) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').show();
              $('#widenDeviceText').hide();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        let slide = getUrlParameter('slide');
        if (typeof slide !== undefined && slide != null) {
          cur_slide = slide;
        }
        //do all timeline and slide stuff only if specific params not provided
        if (!Object.keys(params).length || params["slide"]) {
          if (!isMobile()) {
                            $('#mode-menu a').click();
                      }
        }
        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
        $('#electure-1-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-1-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
        $('#electure-2-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2-2');
          pushState('2-2');
        });
        $('#electure-2-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-2-2 .electure-next').click(function() {
          hidePopup();
          runSlide('2-3');
          pushState('2-3');
        });
        $('#electure-2-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
        $('#electure-2-3 .electure-next').click(function() {
          hidePopup();
          runSlide('2-4');
          pushState('2-4');
        });
        $('#electure-2-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-2');
          pushState('2-2');
        });
        $('#electure-2-4 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-3');
          pushState('2-3');
        });
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-4');
          pushState('2-4');
        });
        $('#electure-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-4-1 .electure-next').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-4-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
        $('#electure-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-5-1 .electure-next').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
        $('#electure-5-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-5-2 .electure-next').click(function() {
          hidePopup();
          runSlide('5-3');
          pushState('5-3');
        });
        $('#electure-5-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
        $('#electure-5-3 .electure-next').click(function() {
          hidePopup();
          runSlide('5-4');
          pushState('5-4');
        });
        $('#electure-5-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
        $('#electure-5-4 .electure-next').click(function() {
          hidePopup();
          runSlide('5-5');
          pushState('5-5');
        });
        $('#electure-5-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-3');
          pushState('5-3');
        });
        $('#electure-5-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-6');
          pushState('5-6');
        });
        $('#electure-5-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-4');
          pushState('5-4');
        });
        $('#electure-5-6 .electure-next').click(function() {
          hidePopup();
          runSlide('5-7');
          pushState('5-7');
        });
        $('#electure-5-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-5');
          pushState('5-5');
        });
        $('#electure-5-7 .electure-next').click(function() {
          hidePopup();
          runSlide('5-8');
          pushState('5-8');
        });
        $('#electure-5-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-6');
          pushState('5-6');
        });
        $('#electure-5-8 .electure-next').click(function() {
          hidePopup();
          runSlide('5-9');
          pushState('5-9');
        });
        $('#electure-5-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-7');
          pushState('5-7');
        });
        $('#electure-5-9 .electure-next').click(function() {
          hidePopup();
          runSlide('5-10');
          pushState('5-10');
        });
        $('#electure-5-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-8');
          pushState('5-8');
        });
        $('#electure-5-10 .electure-next').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-5-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-9');
          pushState('5-9');
        });
        $('#electure-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-10');
          pushState('5-10');
        });
        $('#electure-6-1 .electure-next').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-6-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-6-2 .electure-next').click(function() {
          hidePopup();
          runSlide('6-3');
          pushState('6-3');
        });
        $('#electure-6-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6-3 .electure-next').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-6-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-3');
          pushState('6-3');
        });
      });


      $('.electure-print').click(() => {
        window.open(`/en/maxflow/print`);
      });
      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url.html) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}

      // This function will be called everytime 1.0x is changed to 0.5x or vice versa
      function redraw() {}

      $(document).ready(function () {
        setTimeout(function () {
          $('#change-lang-popup').fadeOut('slow')
        }, 5000)
      })
    </script>
<script type="text/javascript">
    var extraCSS = {"dinic":"65px","edmondskarp":"92px","fordfulkerson":"119px","examples":"146px","modeling":"173px","draw":"200px","vertexnumber":"227px","mediumscale":"254px"};
    var actionsIds = {"mediumscale":{"p":"Visualisation Scale"},"vertexnumber":{"p":"Toggle V. Number for 0.5x","onClick":"toggleVertexNumber()"},"draw":{"p":"Edit Graph","onClick":"drawGraph()"},"modeling":{"p":"Modeling","parents":["bipartite"]},"examples":{"p":"Example Graphs","parents":["example-corner-case","example-special-case","example-reduction"]},"fordfulkerson":{"p":"Ford-Fulkerson"},"edmondskarp":{"p":"Edmonds-Karp"},"dinic":{"p":"Dinic"}};
    var isOpens = {};
    var len = 8;
    var keys = ["mediumscale","vertexnumber","draw","modeling","examples","fordfulkerson","edmondskarp","dinic"]; 
    for (i = 0; i < len; i++) {
        var actionDetails = keys[i];
        isOpens[actionDetails] = false;
    }
    function openAction(id) {
        hideThirdTiers(id);
        $("." + id).css("bottom", extraCSS[id]);
        if (!isOpens[id]) {
            $('.' + id).fadeIn('fast');
            isOpens[id] = true;
        }
    }
    function closeAction(id) {
        hideThirdTiers(id);
        if (isOpens[id]) {
            $('.' + id).fadeOut('fast');
            $('#' + id + '-err').html("");
            isOpens[id] = false;
        }
    }

    function hideEntireActionsPanel() {
        //hideAllThirdTiers();
                    closeAction('mediumscale');
                    closeAction('vertexnumber');
                    closeAction('draw');
                    closeAction('modeling');
                    closeAction('examples');
                    closeAction('fordfulkerson');
                    closeAction('edmondskarp');
                    closeAction('dinic');
                hideActionsPanel();
    }

    function hideThirdTiers(tier1Action) {
        if ("parents" in actionsIds[tier1Action]) {
            for (const secondTierAction of actionsIds[tier1Action]["parents"]) {
                $('#' + secondTierAction + '-third-tier').fadeOut('fast');
            }
        }
    }

    function hideAllThirdTiers() {
        for (const tier1Action in actionsIds) {
            hideThirdTiers(tier1Action);
        }
    }

    function toggleChildExtras(tier1, selectedParentTier2) {
        hideThirdTiers(tier1);
        //this actionId must have childExtras
        var style = extraCSS[tier1];
        $("." + tier1).css("bottom", (parseInt(style.substring(0, style.length - 2)) - 27));
        //fade ins and outs are done on the ID whereas css class is set on the class
        //fade in the third tier of the selected 2nd tier parent
        $('#' + selectedParentTier2 + '-third-tier').fadeIn('fast');

        // //fade out all other third tiers of that 'action'
        // for (const parent of actions[tier1]["parents"]) {
        //     console.log("parent is " + parent + " for " + selectedParentTier2);
        //     if (parent != selectedParentTier2) {
        //         $('#' + parent + '-third-tier').fadeOut('fast');
        //     }
        // }
    }

    function setActionHeightOriginal(tier1Action) {
        $("." + tier1Action).css("bottom", extraCSS[tier1Action]);
    }

            $('#' + 'mediumscale').click(function() {
            openAction('mediumscale');
                                                                            closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('modeling');
                                                                closeAction('examples');
                                                                closeAction('fordfulkerson');
                                                                closeAction('edmondskarp');
                                                                closeAction('dinic');
                                    });
            $('#' + 'vertexnumber').click(function() {
            openAction('vertexnumber');
                                                closeAction('mediumscale');
                                                                                            closeAction('draw');
                                                                closeAction('modeling');
                                                                closeAction('examples');
                                                                closeAction('fordfulkerson');
                                                                closeAction('edmondskarp');
                                                                closeAction('dinic');
                                    });
            $('#' + 'draw').click(function() {
            openAction('draw');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                                            closeAction('modeling');
                                                                closeAction('examples');
                                                                closeAction('fordfulkerson');
                                                                closeAction('edmondskarp');
                                                                closeAction('dinic');
                                    });
            $('#' + 'modeling').click(function() {
            openAction('modeling');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                                            closeAction('examples');
                                                                closeAction('fordfulkerson');
                                                                closeAction('edmondskarp');
                                                                closeAction('dinic');
                                    });
            $('#' + 'examples').click(function() {
            openAction('examples');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('modeling');
                                                                                            closeAction('fordfulkerson');
                                                                closeAction('edmondskarp');
                                                                closeAction('dinic');
                                    });
            $('#' + 'fordfulkerson').click(function() {
            openAction('fordfulkerson');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('modeling');
                                                                closeAction('examples');
                                                                                            closeAction('edmondskarp');
                                                                closeAction('dinic');
                                    });
            $('#' + 'edmondskarp').click(function() {
            openAction('edmondskarp');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('modeling');
                                                                closeAction('examples');
                                                                closeAction('fordfulkerson');
                                                                                            closeAction('dinic');
                                    });
            $('#' + 'dinic').click(function() {
            openAction('dinic');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('modeling');
                                                                closeAction('examples');
                                                                closeAction('fordfulkerson');
                                                                closeAction('edmondskarp');
                                                                });
    
    //important to have all the input fields in actions menu take an id containing '-input'
    $("[id*='-input']").on("keypress keydown keyup", (event) => {
        event.stopPropagation();
    });
</script>
<script type="text/javascript">
// MaxFlow Widget
// original author: Jonathan Irvin Gunawan, then maintained by Steven Halim

// Maximum Flow Example Constants
var noOfExamples = 6;
var INF = 1000000000;

var scale = false;
var MaxFlow = function() {
  var gw = new GraphWidget();

  var iVL = {};
  var iEL = {};
  var amountVertex = 0;
  var amountEdge = 0;
  var stateList = [];
  this.getiVL = function() {
    return iVL;
  }
  this.getiEL = function() {
    return iEL;
  }
  this.getGraphWidget = function() { return gw; }

  fixJSON = function() {
    amountVertex = 0;
    amountEdge = 0;
    for (var key in iVL) ++amountVertex;
    for (var key in iEL) ++amountEdge;

    for (var key in iEL) iEL[key]["w"] = +iEL[key]["w"]; // make it integer weight

    // for (var key in iEL) {
    //   iEL[key]["type"] = EDGE_TYPE_UDE;
    //   iEL[key]["displayWeight"] = true;
    // }
    // for (var key in iVL)
    //   iVL[key]["text"] = key;
    // for (var key in iEL) {
    //   iVL[iEL[key]["vertexA"]][iEL[key]["vertexB"]] = +key;
    //   iVL[iEL[key]["vertexB"]][iEL[key]["vertexA"]] = +key;
    //   iEL[key]["weight"] = +iEL[key]["weight"];
    // }
  }

  takeJSON = function(graph) {
    if (graph == null) return;
    graph = JSON.parse(graph);
    iVL = graph["vl"];
    iEL = graph["el"];
    fixJSON();
  }

  statusChecking = function() {
    if (currentGraphVisu.amountVertex() == 0) $("#draw-status p").html("Graph is empty.<br>Please draw a <b>weighted flow</b> graph");
    else                   $("#draw-status p").html("Please draw a <b>weighted flow</b> graph that connects <b>source vertex #0 to sink vertex #{lastVertex}</b> (last vertex). Note: edge weight represents the capacity of the edge".replace("{lastVertex}", currentGraphVisu.amountVertex()-1));
    $("#sinkvertex").val(currentGraphVisu.amountVertex()-1);
  }

  warnChecking = function() {
    var warn = "";
    if (currentGraphVisu.amountVertex() >= 10) warn += "Too much vertex on screen, consider drawing smaller graph. ";

    if (warn == "") $("#draw-warn p").html("No Warning");
    else $("#draw-warn p").html(warn);
  }

  errorChecking = function() {
    var error = "";
    if (currentGraphVisu.amountVertex() == 0) {
      $("#draw-err p").html("Graph cannot be empty. ");
      return;
    }
    const [curiVL, curiEL] = parseCurrentJSONresult()
    var visited = [];
    var stack = [];
    stack.push(0);
    visited[0] = true;
    while (stack.length > 0) {
      var now = stack.pop();
      for (var key2 in curiEL) if(curiEL[key2]["u"] == now) {
        if (!visited[curiEL[key2]["v"]]) {
          visited[curiEL[key2]["v"]] = true;
          stack.push(+curiEL[key2]["v"]);
        }
      }
    }
    if (!visited[currentGraphVisu.amountVertex()-1]) 
      error = error + "Source and sink is not connected. "
    var leftmost = INF, rightmost = -INF;
    for (var key in curiVL) {
      leftmost = Math.min(leftmost,curiVL[key]["x"]);
      rightmost = Math.max(rightmost,curiVL[key]["x"]);
    }
    if (leftmost < curiVL[0]["x"])
      error = error + "Source is not the left most vertex. "
    if (rightmost > curiVL[currentGraphVisu.amountVertex()-1]["x"])
      error = error + "Sink is not the right most vertex. "

    if (error == "") $("#draw-err p").html("No Error");
    else $("#draw-err p").html(error);
  }

  var intervalID;

  this.startLoop = function() {
    intervalID = setInterval(function() {
      //takeJSON(JSONresult);
      warnChecking();
      errorChecking();
      statusChecking();
    }, 100);
  }

  this.stopLoop = function() { clearInterval(intervalID); }

  this.draw = function() {
    if ($("#draw-err p").html() != "No Error") return false;
    takeJSON(JSONresult);
    if ($("#submit").is(':checked'))
      this.submit(JSONresult);
    if ($("#copy").is(':checked'))
      window.prompt("Copy to clipboard:",JSONresult);
    
    gw.removeAll(); 
    graph = createState(iVL, iEL);
    gw.updateGraph(graph, 500);
    return true;
  }

  this.submit = function(graph) {
    $.ajax({
      url: PHP_DOMAIN + "/php/Graph.php?mode=" + MODE_SUBMIT_GRAPH + "&sessionID=" + $.cookie("sessionID"),
      type: "POST",
      data: {canvasWidth: 1000, canvasHeight: 500, graphTopics: 'Max Flow', graphState: graph},
      error: function(xhr, errorType, exception) { //Triggered if an error communicating with server  
          var errorMessage = exception || xhr.statusText; //If exception null, then default to xhr.statusText  

          alert("There was an error submitting your graph " + errorMessage);
      }
    }).done(function(data) {
      console.log(data);
    });
  }

  this.importjson = function(text) {
    //var text = $("#samplejson-input").val();
    takeJSON(text);
    //statusChecking();
    graph = createState(iVL,iEL);
    gw.updateGraph(graph, 500);
  }

  this.initRandom = function(graph) {
    iVL = graph.iVL;
    iEL = graph.iEL;
    amountVertex = iVL.length;
    amountEdge = iEL.length;
    fixJSON();
    statusChecking();
    var newState = createState(iVL, iEL);

    gw.updateGraph(newState, 500);
  }

  //returns index of edge in iEL that connects vertexA to vertexB, eh this can be put in helper object...
  var findEdgeIndex = function(vertexA, vertexB) {
    for (i in iEL)
      if (iEL[i]["u"] == vertexA && iEL[i]["v"] == vertexB)
        return i;
    return -1;
  }

  this.fordfulkerson = function(sourceVertex, sinkVertex) {
    var existAugmentingPath = true;
    var MaxFlow = 0;
    var numberOfAugmentingPaths = 0;

    while (existAugmentingPath) {
      numberOfAugmentingPaths++;
      existAugmentingPath = false;
      var edgeYellow = {};
      var edgeRed = {};
      var edgeBlue = {};
      var vertexTraversed = {};
      var vertexHighlighted = {};
      var parent = new Array(amountVertex);
      var visited = new Array(amountVertex);
      for (i in iVL) {
        parent[i] = -1;
        visited[i] = false;
      }

      var DFSStack = [];
      DFSStack.push([sourceVertex,INF]);
      while (DFSStack.length > 0) {
        var now = DFSStack.pop(); // last most item
        var nowVertex = now[0];
        var nowCapacity = +now[1];
        if (visited[nowVertex]) continue;
        visited[nowVertex] = true;
        if (nowVertex == sinkVertex) {
          var path = [];
          while (nowVertex != sourceVertex) {
            path.push(nowVertex);
            nowVertex = parent[nowVertex];
          }
          path.push(sourceVertex);
          var bottleneck = [-1,-1]; //[forward edge,back edge]

          for (var i = path.length-1; i >= 1; --i) {
            var backEdge = findEdgeIndex(path[i-1],path[i]);
            var forwardEdge = findEdgeIndex(path[i],path[i-1]);
            if (bottleneck[0] == -1 || iEL[forwardEdge]["w"] < iEL[bottleneck[0]]["w"]) {
              if (bottleneck[0] != -1) {
                delete edgeRed[bottleneck[0]];
                delete edgeRed[bottleneck[1]];
                edgeYellow[bottleneck[0]] = true;
                edgeYellow[bottleneck[1]] = true;
              }
              edgeRed[backEdge] = true;
              edgeRed[forwardEdge] = true;
              bottleneck = [forwardEdge, backEdge];
            }
            else {
              edgeYellow[backEdge] = true;
              edgeYellow[forwardEdge] = true;
            }
            cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow);
            cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                              .replace("{sourceVertex}", sourceVertex)
                              .replace("{sinkVertex}", sinkVertex)
                              .replace("{MaxFlow}", MaxFlow);
            cs["status"] += "<br>Find an augmenting path. Bottleneck is {bottleneck} (red edge)</br>".replace("{bottleneck}", iEL[bottleneck[0]]["w"]);
            cs["lineNo"] = [3];
            stateList.push(cs);
          }

          cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
          cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                            .replace("{sourceVertex}", sourceVertex)
                            .replace("{sinkVertex}", sinkVertex)
                            .replace("{MaxFlow}", MaxFlow);
          cs["status"] += "<br>Got an augmenting path. Bottleneck is {bottleneck} (red edge)<br>".replace("{bottleneck}", nowCapacity);
          cs["lineNo"] = [3];
          stateList.push(cs);

          nowVertex = sinkVertex;
          while (nowVertex != sourceVertex) {
            var backEdge = findEdgeIndex(nowVertex,parent[nowVertex]);
            var forwardEdge = findEdgeIndex(parent[nowVertex],nowVertex);

            iEL[forwardEdge]["w"] -= nowCapacity;
            iEL[backEdge]["w"] += nowCapacity;

            var bottleneck = false;

            if (edgeRed.hasOwnProperty(backEdge)) bottleneck = true;

            if (bottleneck) {
              delete edgeRed[forwardEdge];
              delete edgeRed[backEdge];
            }
            else {
              delete edgeYellow[forwardEdge];
              delete edgeYellow[backEdge];
            }

            edgeBlue[forwardEdge] = true;
            edgeBlue[backEdge] = true;

            cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
            cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                              .replace("{sourceVertex}", sourceVertex)
                              .replace("{sinkVertex}", sinkVertex)
                              .replace("{MaxFlow}", MaxFlow);
            cs["status"] += "<br>Bottleneck is {bottleneck} (red edge). Updating edge from {parent} to {nowVertex} (blue edge)</br>"
                              .replace("{bottleneck}", nowCapacity)
                              .replace("{parent}", parent[nowVertex])
                              .replace("{nowVertex}", nowVertex);
            cs["lineNo"] = [4, 5, 6];

            nowVertex = parent[nowVertex];
            stateList.push(cs);

            delete edgeBlue[forwardEdge];
            delete edgeBlue[backEdge];

            if (bottleneck) {
              edgeRed[forwardEdge] = true;
              edgeRed[backEdge] = true;
            }
            else {
              edgeYellow[forwardEdge] = true;
              edgeYellow[backEdge] = true;
            }

          }
          existAugmentingPath = true;
          MaxFlow += nowCapacity;
          cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
          cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                            .replace("{sourceVertex}", sourceVertex)
                            .replace("{sinkVertex}", sinkVertex)
                            .replace("{MaxFlow}", MaxFlow);
          cs["status"] += "<br>Maximum flow increased by {nowCapacity}</br>".replace("{nowCapacity}", nowCapacity);
          cs["lineNo"] = [7];
          stateList.push(cs);
          break;
        }
        var DFStempStack = [];
        for (i in iEL) {
          var vertexA = iEL[i]["u"];
          var vertexB = iEL[i]["v"];
          var capacity = iEL[i]["w"];
          if (nowVertex == vertexA && !visited[vertexB] && capacity > 0) {
            parent[vertexB] = vertexA;
            if (numberOfAugmentingPaths % 2 == 0 && nowVertex == 0) {
              if (capacity < nowCapacity)
                DFStempStack.push([vertexB,capacity]);
              else DFStempStack.push([vertexB,nowCapacity]);
            }
            else {
              if (capacity < nowCapacity)
                DFSStack.push([vertexB,capacity]);
              else DFSStack.push([vertexB,nowCapacity]);
            }
          }
        }
        while (DFStempStack.length > 0)
          DFSStack.push(DFStempStack.pop());
      }
    }

    cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
    cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is {MaxFlow}.<br>No more augmenting path."
                      .replace("{sourceVertex}", sourceVertex)
                      .replace("{sinkVertex}", sinkVertex)
                      .replace("{MaxFlow}", MaxFlow);
    cs["lineNo"] = [];
    stateList.push(cs);
    populatePseudocode(1);

    return MaxFlow;
  }

  this.edmondskarp = function(sourceVertex, sinkVertex) {
    var existAugmentingPath = true;
    var MaxFlow = 0;

    while (existAugmentingPath) {
      existAugmentingPath = false;
      var edgeYellow = {};
      var edgeRed = {};
      var edgeBlue = {};
      var vertexTraversed = {};
      var vertexHighlighted = {};
      var parent = new Array(amountVertex);
      var visited = new Array(amountVertex);
      for (i in iVL) {
        parent[i] = -1;
        visited[i] = false;
      }

      var BFSQueue = [];
      BFSQueue.push([sourceVertex,INF]);
      visited[sourceVertex] = true;
      while (BFSQueue.length > 0)  {
        var now = BFSQueue.shift(); // pop front item
        var nowVertex = now[0];
        var nowCapacity = +now[1];
        if (nowVertex == sinkVertex) {
          var path = [];
          while (nowVertex != sourceVertex) {
            path.push(nowVertex);
            nowVertex = parent[nowVertex];
          }
          path.push(sourceVertex);
          var bottleneck = [-1, -1]; //[forward edge,back edge]

          for (var i = path.length-1; i >= 1; i--) {
            var backEdge = findEdgeIndex(path[i-1],path[i]);
            var forwardEdge = findEdgeIndex(path[i],path[i-1]);
            //if capacity < bottleneck
            if (bottleneck[0] == -1 || iEL[forwardEdge]["w"] < iEL[bottleneck[0]]["w"]) {
              // update bottleneck
              if (bottleneck[0] != -1) {
                delete edgeRed[bottleneck[0]];
                delete edgeRed[bottleneck[1]];
                edgeYellow[bottleneck[0]] = true;
                edgeYellow[bottleneck[1]] = true;
              }
              edgeRed[backEdge] = true;
              edgeRed[forwardEdge] = true;
              bottleneck = [forwardEdge,backEdge];
            }
            else {
              edgeYellow[backEdge] = true;
              edgeYellow[forwardEdge] = true;
            }
            cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow);
             cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                              .replace("{sourceVertex}", sourceVertex)
                              .replace("{sinkVertex}", sinkVertex)
                              .replace("{MaxFlow}", MaxFlow);
            cs["status"] += "<br>Find an augmenting path. Bottleneck is {bottleneck} (red edge)</br>".replace("{bottleneck}", iEL[bottleneck[0]]["w"]);
            cs["lineNo"] = [3];
            //stateList.push(cs); // SH7: quick visual bug fix (EK's BFS looks like DFS) by not saving this state in the stateList
          }

          cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow);
          cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                            .replace("{sourceVertex}", sourceVertex)
                            .replace("{sinkVertex}", sinkVertex)
                            .replace("{MaxFlow}", MaxFlow);
          cs["status"] += "<br>Got an augmenting path. Bottleneck is {bottleneck} (red edge)<br>".replace("{bottleneck}", nowCapacity);
          cs["lineNo"] = [3];
          stateList.push(cs);

          nowVertex = sinkVertex;

          while (nowVertex != sourceVertex) {
            var backEdge = findEdgeIndex(nowVertex,parent[nowVertex]);
            var forwardEdge = findEdgeIndex(parent[nowVertex],nowVertex);

            iEL[forwardEdge]["w"] -= nowCapacity;
            iEL[backEdge]["w"] += nowCapacity;

            var bottleneck = false;

            if (edgeRed.hasOwnProperty(backEdge)) bottleneck = true;

            if (bottleneck) {
              delete edgeRed[forwardEdge];
              delete edgeRed[backEdge];
            }
            else {
              delete edgeYellow[forwardEdge];
              delete edgeYellow[backEdge];
            }

            edgeBlue[forwardEdge] = true;
            edgeBlue[backEdge] = true;

            cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
            cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                              .replace("{sourceVertex}", sourceVertex)
                              .replace("{sinkVertex}", sinkVertex)
                              .replace("{MaxFlow}", MaxFlow);
            cs["status"] += "<br>Bottleneck is {bottleneck} (red edge). Updating edge from {parent} to {nowVertex} (blue edge)</br>"
                              .replace("{bottleneck}", nowCapacity)
                              .replace("{parent}", parent[nowVertex])
                              .replace("{nowVertex}", nowVertex);
            cs["lineNo"] = [4, 5, 6];

            nowVertex = parent[nowVertex];
            stateList.push(cs);

            delete edgeBlue[forwardEdge];
            delete edgeBlue[backEdge];

            if (bottleneck) {
              edgeRed[forwardEdge] = true;
              edgeRed[backEdge] = true;
            }
            else {
              edgeYellow[forwardEdge] = true;
              edgeYellow[backEdge] = true;
            }
          }

          existAugmentingPath = true;
          MaxFlow += nowCapacity;
          cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
          cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                            .replace("{sourceVertex}", sourceVertex)
                            .replace("{sinkVertex}", sinkVertex)
                            .replace("{MaxFlow}", MaxFlow);
          cs["status"] += "<br>Maximum flow increased by {nowCapacity}</br>".replace("{nowCapacity}", nowCapacity);
          cs["lineNo"] = [7];
          stateList.push(cs);
          break;
        }
        for (i in iEL) {
          var vertexA = iEL[i]["u"];
          var vertexB = iEL[i]["v"];
          var capacity = iEL[i]["w"];
          if (nowVertex == vertexA && !visited[vertexB] && capacity > 0) {
            visited[vertexB] = true;
            parent[vertexB] = vertexA;
            if (capacity < nowCapacity)
              BFSQueue.push([vertexB,capacity]);
            else BFSQueue.push([vertexB,nowCapacity]);
          }
        }
      }
    }

    cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
    cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is {MaxFlow}.<br>No more augmenting path."
                      .replace("{sourceVertex}", sourceVertex)
                      .replace("{sinkVertex}", sinkVertex)
                      .replace("{MaxFlow}", MaxFlow);
    cs["lineNo"] = [];
    stateList.push(cs);
    populatePseudocode(0);

    return MaxFlow;
  }

  this.dinic = function(sourceVertex, sinkVertex) {
    var existBlockingFlow = true;
    var MaxFlow = 0;

    while (existBlockingFlow) {
      existBlockingFlow = false;
      var edgeBlue = {};
      var vertexTraversed = {};
      var vertexHighlighted = {};
      var visited = new Array(amountVertex);
      var distance = new Array(amountVertex);
      for (i in iVL) {
        visited[i] = false;
        distance[i] = INF;
      }

      var BFSQueue = [];
      BFSQueue.push(sourceVertex);
      distance[sourceVertex] = 0;
      while (BFSQueue.length > 0) {
        var nowVertex = BFSQueue.shift();
        for (i in iEL) {
          var vertexA = iEL[i]["u"];
          var vertexB = iEL[i]["v"];
          var capacity = iEL[i]["w"];
          if (nowVertex == vertexA && distance[vertexB] == INF && capacity > 0) {
            distance[vertexB] = distance[vertexA] + 1;
            BFSQueue.push(vertexB);
          }
        }
      }
      for (i in iEL) {
        var vertexA = iEL[i]["u"];
        var vertexB = iEL[i]["v"];
        var capacity = iEL[i]["w"];
        if (capacity > 0 && distance[vertexB] == distance[vertexA]+1 && distance[vertexB] <= distance[sinkVertex]) {
          edgeBlue[i] = true;
          edgeBlue[findEdgeIndex(vertexB,vertexA)] = true;
        }
      }

      if (distance[sinkVertex] == INF) break;

      cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
      cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is {MaxFlow}.<br>Got the level graph (blue edges). Sink is level {distance}."
                      .replace("{sourceVertex}", sourceVertex)
                      .replace("{sinkVertex}", sinkVertex)
                      .replace("{MaxFlow}", MaxFlow)
                      .replace("{distance}", distance[sinkVertex]);
      cs["lineNo"] = [3];
      stateList.push(cs);

      var edgeBlueTemp = edgeBlue;
      var existAugmentingPath = true;
      while (existAugmentingPath) {
        existAugmentingPath = false;
        edgeBlue = edgeBlueTemp;
        var edgeYellow = {};
        var edgeRed = {};
        var parent = new Array(amountVertex);

        var DFSStack = [];
        DFSStack.push([sourceVertex,INF]);
        while (DFSStack.length > 0) {
          var now = DFSStack.pop(); //last most item
          var nowVertex = now[0];
          var nowCapacity = +now[1];
          if (nowVertex == sinkVertex) {
            while (nowVertex != sourceVertex) { 
              var backEdge = findEdgeIndex(nowVertex,parent[nowVertex]);
              var forwardEdge = findEdgeIndex(parent[nowVertex],nowVertex);

              delete edgeBlue[backEdge]; 
              delete edgeBlue[forwardEdge];

              if (iEL[forwardEdge]["w"] != nowCapacity) {
                edgeYellow[backEdge] = true;
                edgeYellow[forwardEdge] = true;
              }
              else {
                edgeRed[backEdge] = true;
                edgeRed[forwardEdge] = true;
              }

              nowVertex = parent[nowVertex];
            }
            cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
            cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                            .replace("{sourceVertex}", sourceVertex)
                            .replace("{sinkVertex}", sinkVertex)
                            .replace("{MaxFlow}", MaxFlow);
            cs["status"] += "<br>Found a blocking flow. Bottleneck is {bottleneck} (red edge)<br>".replace("{bottleneck}", nowCapacity);
            cs["lineNo"] = [4];
            stateList.push(cs);

            nowVertex = sinkVertex;
            while (nowVertex != sourceVertex) {
              var backEdge = findEdgeIndex(nowVertex, parent[nowVertex]);
              var forwardEdge = findEdgeIndex(parent[nowVertex], nowVertex);

              iEL[forwardEdge]["w"] -= nowCapacity;
              iEL[backEdge]["w"] += nowCapacity;

              var bottleneck = false;

              if (edgeRed.hasOwnProperty(backEdge)) bottleneck = true;

              cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
              cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                            .replace("{sourceVertex}", sourceVertex)
                            .replace("{sinkVertex}", sinkVertex)
                            .replace("{MaxFlow}", MaxFlow);
              cs["status"] += "<br>Bottleneck is {bottleneck} (red edge). Updating edge from {parent} to {nowVertex} (blue edge)</br>"
                              .replace("{bottleneck}", nowCapacity)
                              .replace("{parent}", parent[nowVertex])
                              .replace("{nowVertex}", nowVertex);
              cs["lineNo"] = [5];

              nowVertex = parent[nowVertex];
              stateList.push(cs);
            }

            existAugmentingPath = true;
            existBlockingFlow = true;
            MaxFlow += nowCapacity;
            cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
            cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                            .replace("{sourceVertex}", sourceVertex)
                            .replace("{sinkVertex}", sinkVertex)
                            .replace("{MaxFlow}", MaxFlow);
            cs["status"] += "<br>Maximum flow increased by {nowCapacity}</br>".replace("{nowCapacity}", nowCapacity);
            cs["lineNo"] = [6];
            stateList.push(cs);
            break;
          }
          for (i in iEL) {
            var vertexA = iEL[i]["u"];
            var vertexB = iEL[i]["v"];
            var capacity = iEL[i]["w"];
            if (nowVertex == vertexA && capacity > 0 && distance[vertexA]+1 == distance[vertexB]) {
              parent[vertexB] = vertexA;
              if (capacity < nowCapacity)
                DFSStack.push([vertexB,capacity]);
              else DFSStack.push([vertexB,nowCapacity]);
            }
          }
        }
      }
    }

    cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
    cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is {MaxFlow}.<br>No more flow from source to sink."
                    .replace("{sourceVertex}", sourceVertex)
                    .replace("{sinkVertex}", sinkVertex)
                    .replace("{MaxFlow}", MaxFlow);
    cs["lineNo"] = [];
    stateList.push(cs);
    populatePseudocode(2);

    return MaxFlow;
  }

  this.countmincut = function(sourceVertex, sinkVertex, originalCap, mf) {
    var edgeRed = {};
    var vertexTraversed = {};
    var vertexHighlighted = {};
    var visited = new Array(amountVertex);
    var distance = new Array(amountVertex);
    for (i in iVL) {
      visited[i] = false;
      distance[i] = INF;
    }

    var BFSQueue = [];
    BFSQueue.push(sourceVertex);
    distance[sourceVertex] = 0;
    while (BFSQueue.length > 0) {
      var nowVertex = BFSQueue.shift();
      vertexTraversed[nowVertex] = true;
      if (nowVertex != sourceVertex)
        iVL[nowVertex]["extratext"] = "S";
      for (i in iEL) {
        var vertexA = iEL[i]["u"];
        var vertexB = iEL[i]["v"];
        var capacity = iEL[i]["w"];
        if (nowVertex == vertexA && distance[vertexB] == INF && capacity > 0) {
          distance[vertexB] = distance[vertexA] + 1;
          BFSQueue.push(vertexB);
        }
      }
    }

    for (i in iVL)
      if (!vertexTraversed[i]) { // in T-component
        vertexHighlighted[i] = true;
        if (i != sinkVertex)
          iVL[i]["extratext"] = "T";
      }

    for (j in iEL) {
      var vertexA = iEL[j]["u"];
      var vertexB = iEL[j]["v"];
      var capacity = iEL[j]["w"];
      if (vertexTraversed[vertexA] && vertexHighlighted[vertexB]) { // highlight edges that crosses S-component to T-component
        edgeRed[j] = true;
        edgeRed[findEdgeIndex(vertexB,vertexA)] = true;
      }
      // this part still confusing, take more time to think... use the uni-directional flow strategy, if both f(u, v) > 0 and f(v, u) > 0, they will cancel out eah other
      // if (originalCap[j] != 0) // not a new back flow
      //   iEL[j]["w"] = (originalCap[j]-iEL[j]["w"]) + "/" + originalCap[j]; // show the actual flow on this edge w.r.t original capacity of this edge
      // else
      //   iEL[j]["w"] = "N/A";
    }

    cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, {}, {});
    cs["status"] = "Maximum flow = Minimum Cut from {sourceVertex} to {sinkVertex} is {mf}.<br>Edge(s) that cross(es) the ST-cut is/are highlighted."
                    .replace("{sourceVertex}", sourceVertex)
                    .replace("{sinkVertex}", sinkVertex)
                    .replace("{mf}", mf);
    cs["lineNo"] = [];
    stateList.push(cs);
  }

  this.countmaxflow = function(algorithm, sourceVertex, sinkVertex) {
    stateList = [];

    // error checks
    //the id used to display the err message is dependent on the 'algorithm' parameter
    if (amountVertex == 0) { // no graph
      $(`#${algorithm}-err`).html("There is no graph to run this on. Please select a sample graph first.");
      return false;
    }

    if (sourceVertex >= amountVertex || sourceVertex < 0) { // source vertex not in range
      $(`#${algorithm}-err`).html("The source vertex does not exist in the graph.");
      return false;
    }

    if (sinkVertex >= amountVertex || sinkVertex < 0) { // sink vertex not in range
      $(`#${algorithm}-err`).html("The sink vertex does not exist in the graph.");
      return false;
    }

    if (sourceVertex == sinkVertex) {
      $(`#${algorithm}-err`).html("The source vertex is the same as the sink vertex.");
      return false;
    }
    for (i in iVL) {
      if (i >= amountVertex) delete iVL[i];
      iVL[i]["extratext"] = "";
    }

    iVL[sourceVertex]["extratext"] = "source";
    iVL[sinkVertex]["extratext"] = "sink";
    var cs = createState(iVL, iEL);
    cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                    .replace("{sourceVertex}", sourceVertex)
                    .replace("{sinkVertex}", sinkVertex)
                    .replace("{MaxFlow}", 0);
    cs["status"] += "<br>The original flow graph.";
    cs["lineNo"] = [1];
    stateList.push(cs);

    //creating residual graph (backedges for every edge)
    for (i in iEL) {
      var backEdge = new Object();
      backEdge["u"] = iEL[i]["v"];
      backEdge["v"] = iEL[i]["u"];
      backEdge["w"] = 0;
      // if backEdge is not on the iEL yet
      if (findEdgeIndex(backEdge["u"], backEdge["v"]) == -1) { // insert backEdge to iEL
        iEL[amountEdge] = (backEdge);
        amountEdge++;
      }
    }

    var originalCap = {};
    for (i in iEL) {
      if (i >= amountEdge) delete iEL[i];
      originalCap[i] = +iEL[i]["w"];
    }

    var cs = createState(iVL, iEL);
    cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                    .replace("{sourceVertex}", sourceVertex)
                    .replace("{sinkVertex}", sinkVertex)
                    .replace("{MaxFlow}", 0);
    cs["status"] += "<br>Preparing residual graph.";
    cs["lineNo"] = [1];
    stateList.push(cs);

    // run the maxflow algorithm
    var mf = 0;
         if (algorithm == "fordfulkerson") mf = this.fordfulkerson(sourceVertex,sinkVertex);
    else if (algorithm == "edmondskarp")   mf = this.edmondskarp(sourceVertex,sinkVertex);
    else if (algorithm == "dinic")         mf = this.dinic(sourceVertex,sinkVertex);

    this.countmincut(sourceVertex, sinkVertex, originalCap, mf);

    gw.startAnimation(stateList);
    return true;
  }

  this.rookattack = function() {
    var numOfRows = parseInt($('#rows').val());
    var numOfColumns = parseInt($('#columns').val());
    var blocked = new Array(numOfRows);

    for (var i = 0; i < numOfRows; i++) {
      blocked[i] = new Array(numOfColumns);
      for (var j = 0; j < numOfColumns; j++)
        blocked[i][j] = false;
    }

    if (numOfRows < 1 || numOfColumns < 1 || numOfRows > 6 || numOfColumns > 6) { // no graph
      $('#modeling-err').html("Invalid size. Row and column size must be between 1 and 6 inclusive.");
      return false;
    }

    this.changeState = function(rowIndex,columnIndex) {
      var temp = '#cell' + rowIndex + columnIndex;
      if (blocked[rowIndex][columnIndex]) {
        $(temp).attr("bgcolor","white");
        blocked[rowIndex][columnIndex] = false;
      }
      else {
        $(temp).attr("bgcolor","black");
        blocked[rowIndex][columnIndex] = true;
      }
    }

    this.createBipartiteGraph = function() {
      iVL = {};
      iEL = {};
      vertexHighlighted = {};
      edgeRed = {};
      stateList = [];
      var cs;
      amountEdge = 0;
      amountVertex = 2 + numOfRows + numOfColumns;

      iVL[0] = {
        "x": 25,
        "y": 175,
      }

      iVL[amountVertex-1] = {
        "x": 625,
        "y": 175,
      }

      vertexHighlighted[0] = vertexHighlighted[amountVertex-1] = true;
      cs = createState(iVL, iEL,vertexHighlighted);
      cs["status"] = "Create source and sink vertex";
      cs["lineNo"] = [1];
      stateList.push(cs);
      delete vertexHighlighted[0]; delete vertexHighlighted[amountVertex-1];

      for (var i = 1; i <= numOfRows; i++) {
        iVL[i] = {
          "x": 225,
          "y": (175 + (i - (numOfRows+1)/2) * (numOfRows == 1 ? 0 : 300/(numOfRows-1))),
          "text": "R"+i
        }
        iEL[amountEdge] = {
          "u": 0,
          "v": i,
          "w": 1
        }
        amountEdge++;
        vertexHighlighted[i] = true;
      }

      cs = createState(iVL, iEL,vertexHighlighted);
      cs["status"] = "Create a vertex for each rows<br>and connect the source vertex to each vertex with capacity 1</br>";
      cs["lineNo"] = [2];
      stateList.push(cs);
      for (var i = 1; i <= numOfRows; ++i)
        delete vertexHighlighted[i];

      for (var i = 1; i <= numOfColumns; ++i) {
        iVL[i+numOfRows] = {
          "x": 425,
          "y": (175 + (i-(numOfColumns+1)/2) * (numOfColumns == 1 ? 0 : 300/(numOfColumns-1))),
          "text": "C"+i
        }
        iEL[amountEdge] = {
          "u": i+numOfRows,
          "v": amountVertex-1,
          "w": 1
        }
        amountEdge++;
        vertexHighlighted[i+numOfRows] = true;
      }
      cs = createState(iVL, iEL,vertexHighlighted);
      cs["status"] = "Create a vertex for each columns<br>and connect each vertex to the sink vertex with capacity 1</br>";
      cs["lineNo"] = [3];
      stateList.push(cs);
      for (var i = 1; i <= numOfColumns; i++)
        delete vertexHighlighted[i+numOfRows];

      for (var i = 0; i < numOfRows; i++) {
        for (var j = 0; j < numOfColumns; j++) {
          var existEdge = 1-blocked[i][j];
          if (existEdge == 1) {
            iEL[amountEdge] = {
              "u": i+1,
              "v": j+1+numOfRows,
              "w": 9
            }
            amountEdge++;
            edgeRed[amountEdge-1] = true;
            cs = createState(iVL, iEL,vertexHighlighted, edgeRed);
            cs["status"] = "Adding edge from R{row} to C{column}."
                            .replace("{row}", i+1)
                            .replace("{column}", j+1);
            cs["lineNo"] = [4,5];
            stateList.push(cs);
            delete edgeRed[amountEdge-1];
          }
        }
      }

      amountVertex = 0;
      amountEdge = 0;
      for (var i in iVL) amountVertex++;
      for (var i in iEL) amountEdge++;

      $('[id$=sourcevertex]').val(0);
      $('[id$=sinkvertex]').val(amountVertex-1);

      cs = createState(iVL, iEL);
      cs["status"] = "Run any maximum flow algorithm from 0 to {lastVertex}<br>to get the value of the maximum rooks that can be placed</br>".replace("{lastVertex}", amountVertex-1);
      cs["lineNo"] = [6];
      stateList.push(cs);
      gw.startAnimation(stateList);
      return true;
    }

    this.inputFinished = function() {
      $('.overlays').hide("slow");
      $('#dark-overlay').hide("slow");
      $('#rookattack-board').hide("slow");
      mfw.createBipartiteGraph();
      $('#current-action').show();
      $('#current-action p').html("Modeling()");
      $('#progress-bar').slider( "option", "max", gw.getTotalIteration()-1);
      triggerRightPanels();
      populatePseudocode(3);
      isPlaying = true;
      return true;
    }

    this.cancel = function() {
      $('.overlays').hide("slow");
      $('#dark-overlay').hide("slow");
      $('#rookattack-board').hide("slow");
      $('#progress-bar').slider( "option", "max", gw.getTotalIteration()-1);
      return true;
    }

    this.inputRandomized = function() {
      for (var i = 0; i < numOfRows; ++i)
        for (var j = 0; j < numOfColumns; ++j)
          if (Math.random() < 0.5) this.changeState(i,j);
    }

    $('#dark-overlay').show("slow");
    var toWrite = '<html>\n';
    toWrite += "<p>Click on any cell to toggle between black/white cell</p>\n";
    toWrite += "<p>Rooks can&#39;t be placed in black cells</p>\n";
    toWrite += '<table border="1" id="board">'
    for (var j = 0; j < numOfColumns; j++)
      toWrite += '<col width="50">';
    for (var i = 0; i < numOfRows; i++) {
      toWrite += '<tr>';
      for (var j = 0; j < numOfColumns; j++)
        toWrite += '<td height="50" bgcolor="white" id="cell' + i + j + '" onclick=mfw.changeState('+i+','+j+')></td>';
      toWrite += '</tr>';
    }

    toWrite += '</table>\n';
    toWrite += '<div class="modeling-actions">';
    toWrite += '<p onclick=mfw.inputRandomized()>Randomized</p>';
    toWrite += '<p onclick=mfw.inputFinished()>Done</p>';
    toWrite += '<p onclick=mfw.cancel()>Cancel</p>';
    toWrite += '</div>\n'
    toWrite += '</html>\n';
    $('#rookattack-board').html(toWrite);
    $('#rookattack-board').show("slow");
  }

  // this.baseball = function() {
  //   var numOfTeams = parseInt($('#teams').val());
  //   var numOfGames = new Array(numOfTeams);
  //   var initialPoints = new Array(numOfTeams);
  
  //   for (var i = 0; i < numOfTeams; ++i)
  //     numOfGames[i] = new Array(numOfTeams);

  //   if (numOfTeams < 1 || numOfTeams > 6) { // no graph
  //     $('#modeling-err').html("Invalid number of teams. Number of teams must be between 1 and 6 inclusive.");
  //     return false;
  //   }

  //   setInterval(function()
  //   {
  //     for (var i = 0; i < numOfTeams; ++i)
  //     {
  //       numOfGames[i][i] = 0;
  //       $("#game" + i + i).val(0);
  //       for (var j = 0; j < i; ++j)
  //       {
  //         $("#game" + i + j).val($("#game" + j + i).val());
  //       }
  //     }
  //   },100);

  //   this.inputRandomized = function()
  //   {
  //     for (var i = 0; i < numOfTeams; ++i)
  //     {
  //       initialPoints[i] = Math.floor(Math.random() * 10); //0 - 9
  //       $("#point" + i).val(initialPoints[i]);
  //       for (var j = 0; j < numOfTeams; ++j)
  //       {
  //         numOfGames[i][j] = Math.floor(Math.random() * 10); //0 - 9
  //         $("#game" + i + j).val(numOfGames[i][j]);
  //       }
  //     }
  //   }

  //   this.createGraph = function(checkTeamIndex)
  //   {
  //     iVL = {};
  //     iEL = {};
  //     vertexHighlighted = {};
  //     edgeRed = {};
  //     stateList = [];
  //     var cs;
  //     var numOfMatches = ((numOfTeams - 1) * (numOfTeams - 2)) / 2;
  //     var totalMaxFlow = 0;
  //     amountEdge = 0;
  //     amountVertex = 2 + numOfMatches + (numOfTeams - 1);
  //     var totalNumberOfGames = new Array(numOfTeams);
  //     var vertexIndex = new Array(numOfTeams);
  //     for (var i = 0; i < numOfTeams; ++i)
  //     {
  //       totalNumberOfGames[i] = 0;
  //       vertexIndex[i] = new Array(numOfTeams);
  //       initialPoints[i] = (+$("#point" + i).val());
  //       for (var j = 0; j < numOfTeams; ++j)
  //       {
  //         numOfGames[i][j] = +($("#game" + i + j).val());
  //         totalNumberOfGames[i] += (numOfGames[i][j]);
  //         console.log(i + " " + j + " " + numOfGames[i][j]);
  //       }
  //     }

  //     cs = createState(iVL, iEL,vertexHighlighted);
  //     cs["status"] = 'Assume Team ' + checkTeamIndex + ' wins all remaining games';
  //     cs["status"] += '<br>Team ' + checkTeamIndex + ' will win ' + initialPoints[checkTeamIndex] + ' + ' + totalNumberOfGames[checkTeamIndex];
  //     cs["status"] += ' = ' + (initialPoints[checkTeamIndex] + totalNumberOfGames[checkTeamIndex]) + ' games</br>';
  //     cs["lineNo"] = [1];
  //     stateList.push(cs);

  //     for (var i = 0; i < numOfTeams; ++i) if (i != checkTeamIndex)
  //     {
  //       cs = createState(iVL, iEL,vertexHighlighted);
  //       cs["status"] = 'Assume T' + i + ' loses all remaining games. ';
  //       cs["status"] += 'T' + i + ' will win ' + initialPoints[i] + ' games';
  //       if (initialPoints[i] <= initialPoints[checkTeamIndex] + totalNumberOfGames[checkTeamIndex])
  //       {
  //         cs["status"] += '<br>Because ' + initialPoints[i] + '<=' + (initialPoints[checkTeamIndex] + totalNumberOfGames[checkTeamIndex]) + ', team ' + checkTeamIndex + ' can still win the league</br>';
  //         cs["lineNo"] = [1];
  //         stateList.push(cs);     
  //       } else
  //       {
  //         cs["status"] += '<br>Because ' + initialPoints[i] + '>' + (initialPoints[checkTeamIndex] + totalNumberOfGames[checkTeamIndex]) + ', team ' + checkTeamIndex + ' is obviously eliminated</br>';
  //         cs["lineNo"] = [1];
  //         stateList.push(cs);
  //         gw.startAnimation(stateList);
  //         return true;
  //       }   
  //     }


  //     iVL[0] = {"cx": 25, "cy": 175, "text": 0}

  //     iVL[amountVertex - 1] = { "cx": 625, "cy": 175, "text": amountVertex - 1 }

  //     vertexHighlighted[0] = vertexHighlighted[amountVertex-1] = true;
  //     cs = createState(iVL, iEL,vertexHighlighted);
  //     cs["status"] = 'Create source and sink vertex';
  //     cs["lineNo"] = [];
  //     stateList.push(cs);
  //     delete vertexHighlighted[0]; delete vertexHighlighted[amountVertex-1];

  //     amountVertex = 1;


  //     //create left set of vertices
  //     for (var i = 0; i < numOfTeams; ++i) if(i != checkTeamIndex)
  //     {
  //       for (var j = i + 1; j < numOfTeams; ++j) if(j != checkTeamIndex)
  //       {
  //         totalMaxFlow += numOfGames[i][j];
  //         iVL[amountVertex] = 
  //         {
  //           "cx": 225,
  //           "cy": (175 + (amountVertex - (numOfMatches + 1) / 2) * (numOfMatches == 1 ? 0 : 300 / (numOfMatches - 1))),
  //           "text": i + "v" + j
  //         }
  //         iEL[amountEdge] = 
  //         {
  //           "vertexA": 0,
  //           "vertexB": amountVertex,
  //           "weight": numOfGames[i][j]
  //         }
  //         vertexHighlighted[amountVertex] = true;
  //         edgeRed[amountEdge] = true;
  //         cs = createState(iVL, iEL,vertexHighlighted, edgeRed);
  //         cs["status"] = 'Create a node for a match between T' + i + ' and T' + j + '. There are ' + numOfGames[i][j] + ' matches remaining';
  //         cs["status"] += '. Connect source vertex to that node with capacity ' + numOfGames[i][j];
  //         cs["lineNo"] = [2,3];
  //         stateList.push(cs);
  //         delete vertexHighlighted[amountVertex];
  //         delete edgeRed[amountEdge];

  //         vertexIndex[i][j] = amountVertex;
  //         ++amountVertex;
  //         ++amountEdge;
  //       }
  //     }

      

  //     //create right set of vertices
  //     for (var i = 0; i < numOfTeams; ++i) if (i != checkTeamIndex)
  //     {
  //       iVL[amountVertex] = 
  //       {
  //         "cx": 425,
  //         "cy": (175 + ((i+(i<checkTeamIndex?1:0)) - (numOfTeams) / 2) * (numOfTeams == 2 ? 0 : 300 / (numOfTeams - 2))),
  //         "text": "T" + i
  //       }
  //       var weight = (+initialPoints[checkTeamIndex]) + (+totalNumberOfGames[checkTeamIndex]) - (+initialPoints[i]);
  //       iEL[amountEdge] = 
  //       {
  //         "vertexA": amountVertex,
  //         "vertexB": 1 + numOfMatches + (numOfTeams - 1),
  //         "weight": weight
  //       }
  //       vertexHighlighted[amountVertex] = true;
  //       edgeRed[amountEdge] = true;
  //       cs = createState(iVL, iEL,vertexHighlighted, edgeRed);
  //       cs["status"] = 'Create a node for a Team ' + i + '. Team ' + i + ' may win ';
  //       cs["status"] += (initialPoints[checkTeamIndex] + totalNumberOfGames[checkTeamIndex]) + '-' + initialPoints[i] + ' = ' + weight + ' matches more';
  //       cs["status"] += '. Connect that node to sink vertex with capacity ' + weight;
  //       cs["lineNo"] = [4,5];
  //       stateList.push(cs);
  //       delete vertexHighlighted[amountVertex];
  //       delete edgeRed[amountEdge];

  //       ++amountVertex;
  //       ++amountEdge;
  //     }



  //     //create middle edges
  //     for (var i = 0; i < numOfTeams; ++i) if (i != checkTeamIndex)
  //     {
  //       for (var j = i + 1; j < numOfTeams; ++j) if (j != checkTeamIndex)
  //       {
  //         iEL[amountEdge] = 
  //         {
  //           "vertexA": vertexIndex[i][j],
  //           "vertexB": amountVertex - numOfTeams + i + (i < checkTeamIndex ? 1 : 0),
  //           "weight": 9
  //         }
  //         edgeRed[amountEdge] = true;
  //         ++amountEdge;

  //         iEL[amountEdge] = 
  //         {
  //           "vertexA": vertexIndex[i][j],
  //           "vertexB": amountVertex - numOfTeams + j + (j < checkTeamIndex ? 1 : 0),
  //           "weight": 9
  //         }
  //         edgeRed[amountEdge] = true;
  //         ++amountEdge;

  //         cs = createState(iVL, iEL,vertexHighlighted, edgeRed);
  //         cs["status"] = 'Adding edge from R' + i + ' to C' + j + ' with capacity INF';
  //         cs["lineNo"] = [6];
  //         //cs["status"] += '<br>Adding edge from R' + i + ' to C' + j + '</br>';
  //         stateList.push(cs);
  //         delete edgeRed[amountEdge-1];
  //         delete edgeRed[amountEdge-2];
  //       }
  //     }

  //     amountVertex = 0;
  //     amountEdge = 0;
  //     for (var i in iVL) ++amountVertex;
  //     for (var i in iEL) ++amountEdge;

  //     $('[id$=sourcevertex]').val(0);
  //     $('[id$=sinkvertex]').val(amountVertex-1);

  //     cs = createState(iVL, iEL);
  //     cs["status"] = 'Run any maximum flow algorithm from 0 to ' + (amountVertex - 1);
  //     cs["status"] += '. Iff all source edges are saturated (maxflow = ' + totalMaxFlow + '), '
  //     cs["status"] += 'then Team ' + checkTeamIndex + ' is not eliminated';
  //     cs["lineNo"] = [7];
  //     stateList.push(cs);
  //     gw.startAnimation(stateList);
  //     return true;
  //   }

  //   this.inputFinished = function(checkTeamIndex)
  //   {
  //     $('.overlays').hide("slow");
  //     $('#dark-overlay').hide("slow");
  //     $('#baseball-board').hide("slow");
  //     mfw.createGraph(checkTeamIndex);
  //     $('#current-action').show();
  //     $('#current-action p').html("Modeling()");
  //     $('#progress-bar').slider( "option", "max", gw.getTotalIteration()-1);
  //     triggerRightPanels();
  //     populatePseudocode(4);
  //     isPlaying = true;
  //     return true;
  //   }

  //   this.cancel = function()
  //   {
  //     $('.overlays').hide("slow");
  //     $('#dark-overlay').hide("slow");
  //     $('#rookattack-board').hide("slow");
  //     $('#progress-bar').slider( "option", "max", gw.getTotalIteration()-1);
  //     return true;
  //   }

  //   $('#dark-overlay').show("slow");
  //   var toWrite = '<html>\n';
  //   toWrite += '<p>Fill in the table below.\n';
  //   toWrite += ' Don\'t modify the black cells, they will be updated automatically</p>\n';
  //   toWrite += '<p>Click on any team to check whether the team is eliminated or not</p>\n';
  //   toWrite += '<table border="1" id="board">\n';
  //   for (var j = 0; j < numOfTeams + 2; ++j)
  //   {
  //     toWrite += '<col width="50">';
  //   }

  //   toWrite += '<tr>';
  //   toWrite += '<td rowspan="2">Team Index</td><td rowspan="2">Initial Points</td>';
  //   toWrite += '<td colspan="5" align="center">Remaining Games</td>';
  //   toWrite += '</tr>';
  //   toWrite += '<tr>';
  //   for (var i = 0; i < numOfTeams; ++i)
  //   {
  //     toWrite += '<td>Team ' + i + '</td>';
  //   }
  //   toWrite += '</tr>';

  //   for (var i = 0; i < numOfTeams; ++i)
  //   {
  //     toWrite += '<tr>';
  //     toWrite += '<td><div class="modeling-actions">';
  //     toWrite += '<p onclick=mfw.inputFinished('+i+')>Team ' + i + '</p>';
  //     toWrite += '</div></td>';
  //     toWrite += '<td height="50" bgcolor="white"><input id="point' + i + '" value=0 /></td>';
  //     for (var j = 0; j < numOfTeams; ++j) 
  //     {
  //       if (j > i)
  //       {
  //         toWrite += '<td height="50" bgcolor="white"><input id="game' + i + j + '" value=0 /></td>';
  //       }
  //       else 
  //       {
  //         toWrite += '<td height="50" bgcolor="black"><input style="background-color:black;color:white;" id="game' + i + j + '" value=0 /></td>';
  //       }
  //     }
  //     toWrite += '</tr>';
  //   }

  //   toWrite += '</table>\n';
  //   toWrite += '<div class="modeling-actions">';
  //   toWrite += '<p onclick=mfw.inputRandomized()>Randomized</p>';
  //   toWrite += '<p onclick=mfw.cancel()>Cancel</p>';
  //   toWrite += '</div>';
  //   toWrite += '</html>\n';
  //   $('#baseball-board').html(toWrite);
  //   $('#baseball-board').show("slow");
  // }

  this.modeling = function(modelingType) {
    iVL = {};
    iEL = {};
    if (modelingType == "rookattack") this.rookattack();
    if (modelingType == "baseball") this.baseball();
    return true;
  }

  this.examples = function(id) {
    // quick patch on 8 Sep 2022 to add a few example graphs without touching graph library yet
    if (id == 'CP4_8_11') { // "Ford-Fulkerson Killer" test case
      iVL = {
        0: { "x": 300, "y": 125 },
        1: { "x": 425, "y":  25 },
        2: { "x": 375, "y": 225 },
        3: { "x": 500, "y": 125 },
      };
      iEL = { // the edge ordering must be like this for the current FF implementation to showcase "that flip-flop behavior", dunno what Jonathan Irvin did in the past
        0: { "u": 0, "v": 1, "w": 8 },
        1: { "u": 0, "v": 2, "w": 8 },
        2: { "u": 1, "v": 3, "w": 8 },
        3: { "u": 2, "v": 3, "w": 8 },
        4: { "u": 2, "v": 1, "w": 1 }, // this edge direction is slightly different from CP4 8.11, but needed to show the FF killer test case...
      };
    }
    else if (id == 'CP4_8_5_3_1') { // the wrong MCBM modeling using bidirectional edges
      iVL = {
        0: { "x": 300, "y": 125 },
        1: { "x": 400, "y":  25 },
        2: { "x": 400, "y": 125 },
        3: { "x": 400, "y": 225 },
        4: { "x": 500, "y":  25 },
        5: { "x": 500, "y": 125 },
        6: { "x": 500, "y": 225 },
        7: { "x": 600, "y": 125 },
      };
      iEL = {
        0: { "u": 0, "v": 1, "w": 1 },
        1: { "u": 0, "v": 2, "w": 1 },
        2: { "u": 0, "v": 3, "w": 1 },
        3: { "u": 1, "v": 4, "w": 1 },
        4: { "u": 1, "v": 5, "w": 1 },
        5: { "u": 1, "v": 6, "w": 1 },
        6: { "u": 2, "v": 5, "w": 1 },
        7: { "u": 3, "v": 5, "w": 1 },
        8: { "u": 4, "v": 1, "w": 1 }, // wrong bidirectional edge
        9: { "u": 4, "v": 7, "w": 1 },
        10: { "u": 5, "v": 1, "w": 1 }, // also wrong
        11: { "u": 5, "v": 2, "w": 1 }, // also wrong
        12: { "u": 5, "v": 3, "w": 1 }, // also wrong
        13: { "u": 5, "v": 7, "w": 1 },
        14: { "u": 6, "v": 1, "w": 1 }, // also wrong
        15: { "u": 6, "v": 7, "w": 1 },
      };
    }
    else if (id == 'CP4_8_5_3_1_correct') { // the correct MCBM modeling using directed edges
      iVL = {
        0: { "x": 300, "y": 125 },
        1: { "x": 400, "y":  25 },
        2: { "x": 400, "y": 125 },
        3: { "x": 400, "y": 225 },
        4: { "x": 500, "y":  25 },
        5: { "x": 500, "y": 125 },
        6: { "x": 500, "y": 225 },
        7: { "x": 600, "y": 125 },
      };
      iEL = {
        0: { "u": 0, "v": 1, "w": 1 },
        1: { "u": 0, "v": 2, "w": 1 },
        2: { "u": 0, "v": 3, "w": 1 },
        3: { "u": 1, "v": 4, "w": 1 },
        4: { "u": 1, "v": 5, "w": 1 },
        5: { "u": 1, "v": 6, "w": 1 },
        6: { "u": 2, "v": 5, "w": 1 },
        7: { "u": 3, "v": 5, "w": 1 },
        8: { "u": 4, "v": 7, "w": 1 },
        9: { "u": 5, "v": 7, "w": 1 },
        10: { "u": 6, "v": 7, "w": 1 },
      };
    }
    else if (id == 'CP4_8_17_A') {
      iVL = {
        0: { "x": 300, "y": 125 },
        1: { "x": 500, "y": 225 },
        2: { "x": 400, "y":  25 },
        3: { "x": 400, "y": 225 },
        4: { "x": 600, "y": 125 }
      };
      iEL = {
        0: { "u": 0, "v": 2, "w": 5 },
        1: { "u": 0, "v": 3, "w": 3 },
        2: { "u": 2, "v": 3, "w": 2 },
        3: { "u": 3, "v": 1, "w": 6 },
        4: { "u": 2, "v": 1, "w": 3 },
        5: { "u": 2, "v": 4, "w": 99 }, // even though this is big
        6: { "u": 1, "v": 4, "w": 99 }, // or this is big
      };
    }
    else if (id == 'CP4_8_17_B') {
      iVL = {
        0: { "x": 300, "y": 125 },
        1: { "x": 500, "y": 225 },
        2: { "x": 400, "y":  25 },
        3: { "x": 400, "y": 225 },
        4: { "x": 600, "y": 125 },
      };
      iEL = {
        0: { "u": 0, "v": 2, "w": 99 }, // even though this is big
        1: { "u": 0, "v": 3, "w": 99 }, // or this is big
        2: { "u": 2, "v": 3, "w": 2 },
        3: { "u": 3, "v": 1, "w": 6 },
        4: { "u": 2, "v": 1, "w": 3 },
        5: { "u": 2, "v": 4, "w": 3 },
        6: { "u": 1, "v": 4, "w": 4 },
      };
    }
    else if (id == 'CP4_8_17_C') {
      iVL = {
        0: { "x": 300, "y": 125 },
        1: { "x": 500, "y": 225 },
        2: { "x": 400, "y":  25 },
        3: { "x": 400, "y": 225 },
        4: { "x": 600, "y": 125 },
      };
      iEL = {
        0: { "u": 0, "v": 2, "w": 99 },
        1: { "u": 0, "v": 3, "w": 3 },
        2: { "u": 2, "v": 3, "w": 2 },
        3: { "u": 3, "v": 1, "w": 6 },
        4: { "u": 2, "v": 1, "w": 3 },
        5: { "u": 2, "v": 4, "w": 3 },
        6: { "u": 1, "v": 4, "w": 99 },
      };
    }
    else if (id == 'CS4234') {
      iVL = {
        0: { "x": 300, "y": 125 },
        1: { "x": 400, "y":  25 },
        2: { "x": 400, "y": 125 },
        3: { "x": 400, "y": 225 },
        4: { "x": 500, "y":  25 },
        5: { "x": 500, "y": 125 },
        6: { "x": 500, "y": 225 },
        7: { "x": 600, "y": 125 },
      };
      iEL = {
        0: { "u": 0, "v": 1, "w": 10 },
        1: { "u": 0, "v": 2, "w": 5 },
        2: { "u": 0, "v": 3, "w": 15 },
        3: { "u": 1, "v": 2, "w": 4 },
        4: { "u": 1, "v": 4, "w": 9 },
        5: { "u": 1, "v": 5, "w": 15 },
        6: { "u": 2, "v": 3, "w": 4 },
        7: { "u": 2, "v": 5, "w": 8 },
        8: { "u": 3, "v": 6, "w": 16 },
        9: { "u": 4, "v": 5, "w": 15 },
        10: { "u": 4, "v": 7, "w": 10 },
        11: { "u": 5, "v": 6, "w": 15 },
        12: { "u": 5, "v": 7, "w": 10 },
        13: { "u": 6, "v": 2, "w": 6 },
        14: { "u": 6, "v": 7, "w": 10 },
      };
    }
    else if (id == 'MatchingWithCapacity') {
      iVL = {
        0: { "x": 300, "y": 125 },
        1: { "x": 400, "y":  25 },
        2: { "x": 400, "y": 225 },
        3: { "x": 500, "y":  25 },
        4: { "x": 500, "y": 225 },
        5: { "x": 600, "y": 125 },
      };
      iEL = {
        0: { "u": 0, "v": 1, "w": 1 },
        1: { "u": 0, "v": 2, "w": 3 },
        2: { "u": 1, "v": 3, "w": 99 },
        3: { "u": 1, "v": 4, "w": 99 },
        4: { "u": 2, "v": 4, "w": 99 },
        5: { "u": 3, "v": 5, "w": 2 },
        6: { "u": 4, "v": 5, "w": 2 },
      };
    }
    else if (id == 'waif_AC') {
      iVL = {
        0: { "x": 200, "y": 125 },
        1: { "x": 300, "y":  25, "text": "c1" },
        2: { "x": 300, "y":  92, "text": "c2" },
        3: { "x": 300, "y": 159, "text": "c3" },
        4: { "x": 300, "y": 225, "text": "c4" },
        5: { "x": 400, "y":  25, "text": "t1" },
        6: { "x": 400, "y": 125, "text": "t2" },
        7: { "x": 400, "y": 225, "text": "t3" },
        8: { "x": 500, "y":  75, "text": "cat1" },
        9: { "x": 600, "y": 125 },
      };
      iEL = {
        0: { "u": 0, "v": 1, "w": 1 },
        1: { "u": 0, "v": 2, "w": 1 },
        2: { "u": 0, "v": 3, "w": 1 },
        3: { "u": 0, "v": 4, "w": 1 },
        4: { "u": 1, "v": 5, "w": 1 },
        5: { "u": 1, "v": 6, "w": 1 },
        6: { "u": 2, "v": 5, "w": 1 },
        7: { "u": 2, "v": 6, "w": 1 },
        8: { "u": 3, "v": 7, "w": 1 },
        9: { "u": 4, "v": 7, "w": 1 },
        10: { "u": 5, "v": 8, "w": 1 },
        11: { "u": 6, "v": 8, "w": 1 },
        12: { "u": 8, "v": 9, "w": 1 },
        13: { "u": 7, "v": 9, "w": 1 },
      };
    }
    else if (id == 'CP4_8_20_A') { // Max-Independent-Paths reduced to Max-Flow
      iVL = {
        0: { "x": 330, "y": 125 },
        1: { "x": 370, "y":  25 },
        2: { "x": 430, "y":  25 },
        3: { "x": 470, "y": 125 },
        4: { "x": 530, "y": 125 },
        5: { "x": 570, "y":  25 },
        6: { "x": 630, "y":  25 },
        7: { "x": 670, "y": 125 },
      };
      iEL = {
        0: { "u": 0, "v": 1, "w": 1 },
        1: { "u": 0, "v": 3, "w": 1 },
        2: { "u": 1, "v": 2, "w": 1 },
        3: { "u": 2, "v": 3, "w": 1 },
        4: { "u": 3, "v": 4, "w": 1 },
        5: { "u": 4, "v": 5, "w": 1 },
        6: { "u": 4, "v": 7, "w": 1 },
        7: { "u": 5, "v": 6, "w": 1 },
        8: { "u": 6, "v": 7, "w": 1 },
      };
    }
    else if (id == 'CP4_8_20_B') { // Max-Edge-Disjoint-Paths reduced to Max-Flow
      iVL = {
        0: { "x": 300, "y": 125 },
        1: { "x": 400, "y":  25 },
        2: { "x": 500, "y": 125 },
        3: { "x": 600, "y":  25 },
        4: { "x": 700, "y": 125 },
      };
      iEL = {
        0: { "u": 0, "v": 1, "w": 1 },
        1: { "u": 0, "v": 2, "w": 1 },
        2: { "u": 1, "v": 2, "w": 1 },
        3: { "u": 2, "v": 3, "w": 1 },
        4: { "u": 2, "v": 4, "w": 1 },
        5: { "u": 3, "v": 4, "w": 1 },
      };
    }
    else if (id == 'CP4_8_29') { // MWVC reduced to Max-Flow
      iVL = {
        0: { "x": 300, "y": 125 },
        1: { "x": 400, "y":  25 },
        2: { "x": 400, "y": 125 },
        3: { "x": 400, "y": 225 },
        4: { "x": 500, "y":  25 },
        5: { "x": 500, "y": 125 },
        6: { "x": 500, "y": 225 },
        7: { "x": 600, "y": 125 },
      };
      iEL = {
        0: { "u": 0, "v": 1, "w": 2 },
        1: { "u": 0, "v": 2, "w": 3 },
        2: { "u": 0, "v": 3, "w": 4 },
        3: { "u": 1, "v": 4, "w": 99 },
        4: { "u": 1, "v": 5, "w": 99 },
        5: { "u": 1, "v": 6, "w": 99 },
        6: { "u": 2, "v": 6, "w": 99 },
        7: { "u": 3, "v": 6, "w": 99 },
        8: { "u": 4, "v": 7, "w": 7 },
        9: { "u": 5, "v": 7, "w": 1 },
        10: { "u": 6, "v": 7, "w": 5 },
      };
    }
    else {
      iVL = getExampleGraph(id, VL);
      iEL = getExampleGraph(id, EL);
    }

    amountVertex = 0;
    amountEdge = 0;
    for (var key in iVL) amountVertex++;
    for (var key in iEL) amountEdge++;

    var newState = createState(iVL, iEL);
    gw.removeAll();
    gw.updateGraph(newState, 500);
    $('[id$=sourcevertex]').val(0);
    $('[id$=sinkvertex]').val(amountVertex-1);
    return true;
  }

  this.completelyRandom = function() {
    var templateNo = Math.floor(Math.random()*noOfExamples); //0-4
    iVL = $.extend(true, {}, TEMPLATES[templateNo][0]);
    iEL = $.extend(true, {}, TEMPLATES[templateNo][1]);
    amountVertex = TEMPLATES[templateNo][2];
    amountEdge = TEMPLATES[templateNo][3];

    //change edge weights
    var keys = Object.keys(iEL);
    var nVertices = Object.keys(iVL).length/2;
    var nEdges = keys.length/2;
    for(var i=0; i<nEdges; i++) {
      //var newWeight = Math.floor(Math.random()*100)-50; //-50-49
      var newWeight = Math.floor(Math.random()*10); //0 - 9
      iEL[keys[i]]["w"] = newWeight;
    }

    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
    return true;
  }

  this.bipartiteRandom = function(randomType) {
    // 0: random
    // 1: left 1
    // 2: right 1
    // 3: all 1
    amountVertex = Math.floor(Math.random()*9) + 4; // 4 to 12
    var numL = Math.floor(Math.random()*(amountVertex-3)) + 1; // 1 to N-3
    if (numL > 6) numL = 6;
    var numR = amountVertex-2-numL;

    iVL = {};
    iEL = {};
    amountEdge = 0;

    iVL[0] = {
      "x": 50,
      "y": 175,
    }

    iVL[amountVertex-1] = {
      "x": 650,
      "y": 175,
    }

    for (var i = 1; i <= numL; i++) {
      iVL[i] = {
        "x": 250,
        "y": (175 + (i - (numL+1)/2) * (numL == 1 ? 0 : 300/(numL-1))),
      }
      iEL[amountEdge] = {
        "u": 0,
        "v": i,
        "w": 1
      }
      if (randomType == 0 || randomType == 2)
        iEL[amountEdge]["w"] = 1+Math.floor(Math.random()*9);
      amountEdge++;
    }

    for (var i = 1; i <= numR; i++) {
      iVL[i+numL] = {
        "x": 450,
        "y": (175 + (i - (numR+1)/2) * (numR == 1 ? 0 : 300/(numR-1))),
      }
      iEL[amountEdge] = {
        "u": i+numL,
        "v": amountVertex-1,
        "w": 1
      }
      if (randomType == 0 || randomType == 1)
        iEL[amountEdge]["w"] = 1+Math.floor(Math.random()*9);
      amountEdge++;
    }

    for (var i = 1; i <= numL; i++) {
      for (var j = 1; j <= numR; j++) {
        var existEdge = Math.floor(Math.random()*2);
        if (existEdge == 1) {
          iEL[amountEdge] = {
            "u": i,
            "v": j+numL,
            "w": 9
          }
          amountEdge++;
        }
      }
    }

    amountVertex = 0;
    amountEdge = 0;
    for (var i in iVL) amountVertex++;
    for (var i in iEL) amountEdge++;
    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);

    $('[id$=sourcevertex]').val(0);
    $('[id$=sinkvertex]').val(amountVertex-1);
    return true;
  }

  function createState(iVLObject, iELObject, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue, edgeGrey) {
    if (vertexHighlighted == null) vertexHighlighted = {};
    if (edgeRed == null) edgeRed = {};
    if (vertexTraversed == null) vertexTraversed = {};
    if (edgeYellow == null) edgeYellow = {};
    if (edgeBlue == null) edgeBlue = {};
    if (edgeGrey == null) edgeGrey = {};

    var key;
    var state = {
      "vl":{},
      "el":{}
    };

    for (key in iVLObject) {
      state["vl"][key] = {};
      state["vl"][key]["cx"] = iVLObject[key]["x"];
      state["vl"][key]["cy"] = iVLObject[key]["y"];
      if (iVLObject[key]["text"] == null)
        state["vl"][key]["text"] = +key;
      else
        state["vl"][key]["text"] = iVLObject[key]["text"];
      if (iVLObject[key]["state"] == OBJ_HIDDEN)
        state["vl"][key]["state"] = OBJ_HIDDEN;
      else
        state["vl"][key]["state"] = VERTEX_DEFAULT;
      state["vl"][key]["extratext"] = iVLObject[key]["extratext"];
    }

    for (key in iELObject) {
      state["el"][key] = {};
      state["el"][key]["vertexA"] = iELObject[key]["u"];
      state["el"][key]["vertexB"] = iELObject[key]["v"];
      state["el"][key]["type"] = EDGE_TYPE_DE;
      state["el"][key]["weight"] = iELObject[key]["w"];
      if (iELObject[key]["state"] == OBJ_HIDDEN)
        state["el"][key]["state"] = OBJ_HIDDEN;
      else
        state["el"][key]["state"] = EDGE_DEFAULT;
      state["el"][key]["displayWeight"] = true;
      state["el"][key]["animateHighlighted"] = false;
    }

    for (key in vertexHighlighted)
      state["vl"][key]["state"] = VERTEX_HIGHLIGHTED;

    for (key in edgeRed)
      state["el"][key]["state"] = EDGE_RED;

    for (key in vertexTraversed)
      state["vl"][key]["state"] = VERTEX_TRAVERSED;

    for (key in edgeYellow)
      state["el"][key]["state"] = EDGE_TRAVERSED;

    for (key in edgeBlue)
      state["el"][key]["state"] = EDGE_BLUE;

    for (key in edgeGrey)
      state["el"][key]["state"] = EDGE_GREY;

    return state;
  }
  
  function populatePseudocode(act) {
    switch (act) {
      case 0: // Edmonds Karp
        // $('#code1').html('initMaxFlow');
        // $('#code2').html('while there is an augmenting path');
        // $('#code3').html('&nbsp;&nbsp;find an augmenting path using BFS');
        // $('#code4').html('&nbsp;&nbsp;for each edge u->v in the path');
        // $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;decrease capacity u->v by bottleneck');
        // $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;increase capacity v->u by bottleneck');
        // $('#code7').html('&nbsp;&nbsp;increase maxflow by bottleneck');
        $('#code1').html('initMaxFlow');
        $('#code2').html('while there is an augmenting path');
        $('#code3').html('&nbsp;&nbsp;find an augmenting path using BFS');
        $('#code4').html('&nbsp;&nbsp;for each edge u-&gt;v in the path');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;decrease capacity u-&gt;v by bottleneck');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;increase capacity v-&gt;u by bottleneck');
        $('#code7').html('&nbsp;&nbsp;increase maxflow by bottleneck');
        break;
      case 1: // Ford Fulkerson
        // $('#code1').html('initMaxFlow');
        // $('#code2').html('while there is an augmenting path');
        // $('#code3').html('&nbsp;&nbsp;find an augmenting path using DFS');
        // $('#code4').html('&nbsp;&nbsp;for each edge u->v in the path');
        // $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;decrease capacity u->v by bottleneck');
        // $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;increase capacity v->u by bottleneck');
        // $('#code7').html('&nbsp;&nbsp;increase maxflow by bottleneck');
        $('#code1').html('initMaxFlow');
        $('#code2').html('while there is an augmenting path');
        $('#code3').html('&nbsp;&nbsp;find an augmenting path using DFS');
        $('#code4').html('&nbsp;&nbsp;for each edge u-&gt;v in the path');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;decrease capacity u-&gt;v by bottleneck');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;increase capacity v-&gt;u by bottleneck');
        $('#code7').html('&nbsp;&nbsp;increase maxflow by bottleneck');
        break;
      case 2: // Dinic
        // $('#code1').html('initMaxFlow');
        // $('#code2').html('while t is reachable from s in the residual graph');
        // $('#code3').html('&nbsp;&nbsp;find the level graph (BFS)');
        // $('#code4').html('&nbsp;&nbsp;for each blocking flow in the level graph (DFS)');
        // $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;update the capacity in the blocking flow');
        // $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;increase maxflow by bottleneck');
        // $('#code7').html('');
        $('#code1').html('initMaxFlow');
        $('#code2').html('while t is reachable from s in the residual graph');
        $('#code3').html('&nbsp;&nbsp;find the level graph (BFS)');
        $('#code4').html('&nbsp;&nbsp;for each blocking flow in the level graph (DFS)');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;update the capacity in the blocking flow');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;increase maxflow by bottleneck');
        $('#code7').html('');
        break;
      case 3: // Rook Attack Modeling
        // $('#code1').html('Create source and sink vertex');
        // $('#code2').html('Create one vertex Ri for each row i');
        // $('#code3').html('Create one vertex Cj for each column j');
        // $('#code4').html('For each rook-placable cell (i,j)');
        // $('#code5').html('&nbsp;&nbsp;Add an edge from Ri to Cj with capacity INF');
        // $('#code6').html('Run any maxflow algorithm');
        $('#code1').html('Create source and sink vertex');
        $('#code2').html('Create one vertex Ri for each row i');
        $('#code3').html('Create one vertex Cj for each column j');
        $('#code4').html('For each rook-placable cell (i,j)');
        $('#code5').html('&nbsp;&nbsp;Add an edge from Ri to Cj with capacity INF');
        $('#code6').html('Run any maxflow algorithm');
        $('#code7').html('');
        break;
      case 4: // Baseball Elimination Modeling
        // $('#code1').html('Checking for obvious cases');
        // $('#code2').html('For every team X,Y');
        // $('#code3').html('&nbsp;&nbsp;Create XvY vertex. Connect source to the vertex');
        // $('#code4').html('For every team X');
        // $('#code5').html('&nbsp;&nbsp;Create TX vertex. Connect the vertex to sink');
        // $('#code6').html('Connect XvY vertex to TX and TY with capacity INF');
        // $('#code7').html('Run any maxflow algorithm');
        $('#code1').html('Checking for obvious cases');
        $('#code2').html('For every team X,Y');
        $('#code3').html('&nbsp;&nbsp;Create XvY vertex. Connect source to the vertex');
        $('#code4').html('For every team X');
        $('#code5').html('&nbsp;&nbsp;Create TX vertex. Connect the vertex to sink');
        $('#code6').html('Connect XvY vertex to TX and TY with capacity INF');
        $('#code7').html('Run any maxflow algorithm');
        break;
    }
  }
}



// MaxFlow_action.js
var actionsWidth = 180;
var statusCodetraceWidth = 410;

// local
var mfw, gw, randomGraphID = -1;

$(function() {
  write(false, false);
  $('#play').hide();
  mfw = new MaxFlow();
  gw = mfw.getGraphWidget();
  gw.setAnimationDuration(700 / speedVal);
  var options = ['CP4_8_11', 'CP4_8_5_3_1', 'CP4_8_17_A', 'CP4_8_17_B', 'CP4_8_17_C', 'CS4234', DINIC_SHOWCASE, 'MatchingWithCapacity', 'CP4_8_20_A', 'CP4_8_20_B', 'CP4_8_29'];
  mfw.examples(options[Math.floor(Math.random()*11)]);
  randomGraphID = -1;

  var graphJSON = getQueryVariable("create");
//console.log(graphJSON);
  if (graphJSON.length > 0) {
    importjson(graphJSON);
    window.history.pushState("object or string", "Title", window.location.href.split('?')[0]);
  }

  // userGraph = mfw.getGraph(); // save the current graph
});

function importjson(text) {
  if (isPlaying) stop();
  if (mode == "exploration") {
    mfw.importjson(text);
    //closeExamples();
    closeAction('examples');
    isPlaying = false;
  }
}

function setDefaultScale() {
    if (isPlaying) stop();
    isPlaying = false;
    if (scale) {
        scale = !scale;
        gw.redrawAllForMediumScale();
        gw.setMediumScale(false);

        userGraph = mfw.getGraph();
    } 
}

function setMediumScale() {
    if (isPlaying) stop();
    isPlaying = false;
    if (!scale) {
        scale = !scale;
        gw.redrawAllForMediumScale();
        gw.setMediumScale(true);

        userGraph = mfw.getGraph();
    }
}

function toggleVertexNumber() {
    if (isPlaying) stop();
    isPlaying = false;
    if (scale) {
        gw.toggleVertexNumber();
    }
}

function drawGraph() {
  if (isPlaying) stop();
  const [newiVL, newiEL] = representationConvert(mfw.getiVL(), mfw.getiEL())
  currentGraphVisu = new GraphVisu(false, false, true, newiVL, newiEL, true)
  if (mode == "exploration") {
    $('#dark-overlay').fadeIn(function() {
      $('#drawgraph').fadeIn();
    });
    mfw.startLoop();
    isPlaying = false;
  }
}

function drawDone() {
  if (!mfw.draw()) return false;
  mfw.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

function drawCancel() {
  mfw.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

function bipartiteRandom(randomType) {
  mfw.bipartiteRandom(randomType);
}

function createRandom() {
  if (isPlaying) stop();
  if (mode == "exploration") {
    var n = Math.floor(5 + Math.random()*6);
    $.ajax({
      url: PHP_DOMAIN + "/php/Graph.php?mode=" + MODE_GET_RANDOM_SUBMITTED_GRAPH + "&directed=" + 1 + "&connected=" + 1
    }).done(function(data){
      data = JSON.parse(data);
      var graph = extractQnGraph(data.graph);
      if (data.graphID == randomGraphID) // make sure it is different, make sure #graph > 1
        createRandom();
      randomGraphID = data.graphID;
      mfw.initRandom(graph);
      $('#rate-sample-graph').show();
    })
    $('#progress-bar').slider( "option", "max", 0);
    closeAction('examples');
    isPlaying = false;
  }
}

function modelingOpen(modelingType) {
  if (modelingType != "rookattack") $('#rookattack-input').fadeOut('fast');
  if (modelingType != "baseball")   $('#baseball-input').fadeOut('fast');
  if (modelingType != "bipartite")  $('#bipartite-input').fadeOut('fast');
  $('#' + modelingType + '-input').fadeIn('fast');
}

function modeling(modelingType) {
  if (isPlaying) stop();
  setTimeout(function() {
    if (mode != "exploration") return;
    if (!mfw.modeling(modelingType)) return;
  }, 500);
}

function example(id) {
  if (isPlaying) stop();
  setTimeout(function() {
    if ((mode == "exploration") && mfw.examples(id)) {
      $('#progress-bar').slider( "option", "max", 0);
      closeAction('examples');
      closeAction('fordfulkerson');
      closeAction('edmondskarp');
      closeAction('dinic');
      isPlaying = false;
    }
  }, 500);
}

function countmaxflow(algorithm) {
  if (isPlaying) stop();
  var source = parseInt($(`#${algorithm}-sourcevertex`).val());
  var sink = parseInt($(`#${algorithm}-sinkvertex`).val());
  setTimeout( function()  {
    if (mode != "exploration") return;
    if (!mfw.countmaxflow(algorithm,source,sink)) return;
    $('#current-action').show();
    if (algorithm == "edmondskarp")
      $('#current-action p').html("Edmonds-Karp(" + source + "," + sink + ")");
    if (algorithm == "fordfulkerson")
      $('#current-action p').html("Ford-Fulkerson(" + source + "," + sink + ")");
    if (algorithm == "dinic")
      $('#current-action p').html("Dinic(" + source + "," + sink + ")");
    $('#progress-bar').slider( "option", "max", gw.getTotalIteration()-1);
    triggerRightPanels();
    isPlaying = true;
  }, 500);
}
</script>
</body>

<!-- Mirrored from visualgo.net/en/maxflow by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:18:00 GMT -->
</html>
