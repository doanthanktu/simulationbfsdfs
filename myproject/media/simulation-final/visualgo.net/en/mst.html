<!DOCTYPE html>
<html lang="en">

<!-- Mirrored from visualgo.net/en/mst by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:17:28 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="description" content="A Spanning Tree (ST) of a connected undirected weighted graph G is a subgraph of G that is a tree and connects (spans) all vertices of G. A graph G can have many STs (see this or this), each with different total weight (the sum of edge weights in the ST).A Min(imum) Spanning Tree (MST) of G is an ST of G that has the smallest total weight among the various STs.">
<meta name="keywords" content="Minimum Spanning Tree MST Jarnik Prim Priority Queue Kruskal Sorting Union Find Disjoint Sets">
 
<meta name="csrf-token" content="dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../img/png/mst.png">
<title>Minimum Spanning Tree (Prim&amp;#39;s, Kruskal&amp;#39;s) - VisuAlgo</title>
<link rel="icon" href="../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../img/favicon.png">
<link rel="stylesheet" href="../css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../css/common-1.0.2.css">
<link rel="stylesheet" href="../css/viz-1.0.4.css">
<link rel="stylesheet" href="../css/visual.css">
<link rel="stylesheet" href="../css/drawgraph-1.0.2.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
        z-index: 8001;
      }
      #e-lecture-timeline {
        top: 80px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }
      .e-lecture-timeline-slide {
        height: 5px;
        width: 2px;
        background: black;
        float: left;
      }
      .e-lecture-timeline-checkpoint {
        height: 20px;
        width: 3px;
        margin-left: 2px;
        margin-top: -7.5px;
        background: black;
        float: left;
      }

      #e-lecture-f1map {
        top: 102.5px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }

      .e-lecture-f1map-sector {
        flex-grow: 1;
        background: black;
        float: left;
        height: 5px;
        margin-right: 1px;
      }

      .e-lecture-f1map-sector:last-child {
        margin-right: 0px;
      }

      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }

      .electure-read-status {
        position: absolute;
        bottom: 4px;
        right: 4px;
        font-size: 14px;
        cursor: default;
        color: #00FF7F;
        display: none;
      }

      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
      .electure-print, .electure-end {
        position: fixed;
        top: 45px;
        height: 20px;
        width: 17px;
        right: 80px;
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
        text-align: center;
      }
      .electure-end {
        right: 45px; /* beside the X */
      }

      #change-lang-popup {
        position: fixed;
        background: green;
        left: 40px;
        top: 50px;
        width: 250px;
        height: 125px;
        border: transparent;
        border-radius: 10px;
        padding: 10px 20px;
        z-index: 9000;
      }

      #change-lang-popup p {
        font-size: medium;
        color: white;
        line-height: 2;
        font-family: "PT Sans", sans-serif;
      }

      #change-lang-popup-btn {
        text-decoration: underline;
        margin-left: 50px;
      }

      #change-lang-popup-btn:hover {
        cursor: pointer;
      }

      #rotateDeviceOverlay {
        z-index: 10000;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        background-color: white;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        overflow: hidden;
      }

      #mobile-playback-overlay {
        z-index: 9600;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        gap: 100px;
        background-color: black;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        opacity: 0.3;
        overflow: hidden;
      }
      .mobile-playback-item {
        min-width: 2.5%;
        max-width: 35px;
      }
      .mobile-playback-item img {
        width: 100%
      }
      .mobile-playback-label {
        opacity: 0;
        color: white;
        font-size: 25px;
        font-weight: bold;
        min-width: 1.5%;
        max-width: 25px;
        transition: opacity 0.25s ease-out;
        -webkit-backface-visibility: hidden;
      }
      #mobile-playback-rewind-label {
        margin-right: -70px;
      }
      #mobile-playback-forward-label {
        margin-left: -70px;
      }
      #viz-speed-value {
          font-size: 15px;
          width: 10%;
      }

      #scale {
        position: fixed;
        left: 5px;
      }
    </style>
<style>
/* copied here from common.css (perhaps need to use version numbering) until caches worldwide settles */
#reload-mobile-popup, #message-popup { /* #gdpr-popup, */
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  min-width: 320px;
  bottom: 62px;
  height: 300px;
  background-color: #0275d8;
  border-radius: 15px;
  padding: 30px 40px;
  z-index: 9500;
}
#reload-mobile-popup {
  background-color: green;
  height: 200px;
}
#message-popup {
  z-index: 9000;
  width: 40%;
  height: 130px;
  background-color: #d9534f;
}

#reload-mobile-popup p, #message-popup p { /* #gdpr-popup p, */
  font-size: large;
  color: white;
  line-height: 2;
  font-family: "PT Sans", sans-serif;
}

#reload-mobile-popup .inner-button, #message-popup .inner-button { /* #gdpr-popup .gdpr-button, */
  border: white solid 2px;
  border-radius: 4px;
  font-weight: bold;
  font-size: x-large;
  padding: 2px 8px;
  color: white;
  width: 90px;
  text-align: center;
  position: absolute;
  letter-spacing: 1px;
  text-decoration: none;
  cursor: pointer;
}

#gdpr-accept, #reload-mobile-button, #dismiss-message-btn {
  bottom: 30px;
  right: 40px;
}

#gdpr-reject, #cancel-reload-mobile-button {
  bottom: 30px;
  right: 170px;
}
    </style>
</head>
<body>
<div id="body-container" style="display: flex; flex-direction: column; min-height: 100vh;">
<style>
  #topbar {
    background-color: rgb(0,0,0);
    font-family: "PT Sans", sans-serif;
    font-size: 13px;
    height: 40px;

    padding-left: 40px;
    padding-right: 40px;

    display: flex;
    flex-wrap: wrap;
    align-items: center;
    position: relative;
    justify-content: flex-start;
  }

  #topbar a:hover {
    text-decoration: none;
  }

  #account-dropdown-btn {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;
    height: 24px;
    line-height: 1.5;
  }

  #account-dropdown-btn:hover {
    color: #0a58ca!important;
    border-color: #198754;
    text-decoration: none;
  }

  #login-button {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;

    height: 24px;
    line-height: 1.5;
  }

  #login-button a:hover {
    color: #0a58ca!important;
    text-decoration: none;
  }

  #account-dropdown-menu {
    display: none;
    position: absolute;
    background-color: white;
    z-index: 1000;
    min-width: 10rem;
    padding: 0.5rem 0;
    margin: 0;
    font-size: 1rem;
    color: rgb(0,0,0);
    text-align: left;
    list-style: none;
    background-clip: padding-box;
    border: 1px solid rgba(0,0,0,.15);
    border-radius: 0.25rem;
    top: 45px;
    right: 40px;
    line-height: 1.5;
  }

  .account-dropdown-item {
    display: block;
    width: auto;
    padding: 0.25rem 1rem;
    clear: both;
    font-weight: 400;
    color: rgb(0,0,0);
    text-align: inherit;
    text-decoration: none;
    white-space: nowrap;
    background-color: transparent;
    border: 0;
    height: 24px;
    font-family: SilkscreenNormal, sans-serif;
  }

  .account-dropdown-item:hover {
    background-color: #e9ecef;
    color: #0a58ca;
    text-decoration: none;
  }
</style>
<nav id="topbar">
<span style="margin-right: 0.25rem">
<a href="https://www.comp.nus.edu.sg/~stevenha" style="text-decoration: none; color: white">
<span class="colour" style="border: 1px solid; border-color: #198754!important; border-radius: .25rem!important">7</span>
</a>
<a href="https://visualgo.net/" style="font-family: SilkscreenNormal,sans-serif; font-size: 20px; margin-left: 4px;">
<span style="color: white">Visu</span><span class="colour">Algo</span><span style="font-size: 40%; color: white">.net</span>
</a>
<span style="color: white">/</span>
<select id="Language" class="select2-dropdown" onchange="changeURL()">
<option value="en" selected>en</option>
<option value="zh">zh</option>
<option value="id">id</option>
</select>
<span style="color: white; font-family: monospace">/mst</span>
</span>
<span style="max-height: 30px">
<span id="title">
<a id="title-mst" class="selected-viz">Min Spanning Tree</a>
</span>
</span>
<span style="max-height: 30px; background-color:rgb(0,0,0)!important; color: white; margin-left: auto">
<div id="mode-menu">
<div id="mode-button" style="background-color: rgb(0,0,0)!important;" title="exploration">Exploration Mode &#9663;</div>
<div id="other-modes" style="background-color: rgb(0,0,0)!important; padding-top: 11px">
<a title="e-Lecture" style="background-color: rgb(0,0,0)!important;">e-Lecture Mode</a>
</div>
</div>
</span>
<span id="login-button" style="font-family: SilkscreenNormal,sans-serif">
<a href="https://visualgo.net/login">Login</a>
</span>
</nav>
<ul id="account-dropdown-menu">
<li><a class="account-dropdown-item" href="https://visualgo.net/profile">Profile</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/training">Training</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/tests">Tests</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/logout">Log Out</a></li>
</ul>
<script>
  function changeURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    URL[3] = document.getElementById("Language").value;
    window.location.assign(URL.join('https://visualgo.net/'));
  }

  function changeDefaultLanguageAndURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    let val = document.getElementById("Language").value;
    URL[3] = val;

    let data = {
      '_token': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
      'lang'  : val
    }
    $.post('https://visualgo.net/changeLanguage', data, function (res, status) {
      if(res['status'] === 'success') {
        window.location.assign(URL.join('https://visualgo.net/'));
      } else if (res['status'] === 'failed') {
        alert(res['message']);
      } else {
        alert('An unknown error occurred');
      }
    })
  }
</script>
<div id="dark-overlay"></div>
<div id="main-content-container" style="flex: 1">

<div id="mobile-playback-overlay" class="playing" style="display: none;">
<span id="mobile-playback-rewind-label" class="mobile-playback-label">-7</span>
<span id="mobile-playback-rewind" class="mobile-playback-item" onclick="mobilePlaybackRewind()"><img src="../img/prevFrame.png" alt="rewind 7 frames"></span>
<span id="mobile-playback-pause" class="mobile-playback-item" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/pause.png" alt="pause"></span>
<span id="mobile-playback-play" class="mobile-playback-item" style="display: none;" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/play.png" alt="play"></span>
<span id="mobile-playback-forward" class="mobile-playback-item" onclick="mobilePlaybackForward()"><img src="../img/nextFrame.png" alt="forward 7 frames"></span>
<span id="mobile-playback-forward-label" class="mobile-playback-label">+7</span>
</div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id="speed-control"><div id="speed-input"></div><div id="viz-speed-value">1x</div></div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick="goToBeginning()"><img src="../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick="stepBackward()"><img src="../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick="pause()"><img src="../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick="play()"><img src="../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick="stepForward()"><img src="../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick="goToEnd()"><img src="../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id="viz">
<p id="info" "></p>
</div>
<div id="current-action" class="panel"></div>
<div id="e-lecture" class="panel"></div> 
<div id="e-lecture-timeline"></div>
<div id="e-lecture-f1map">
<div class="e-lecture-f1map-sector" sectorNo="1"></div>
<div class="e-lecture-f1map-sector" sectorNo="2"></div>
<div class="e-lecture-f1map-sector" sectorNo="3"></div>
</div>
<div id="overlay" hidden onclick="end_eLecture()"> 
<div id="electure-dropdown">
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. Min(imum) Spanning Tree (MST)</option>
<option value="1-1">&nbsp;&nbsp;&nbsp;1-1. MST Problem</option>
<option value="1-2">&nbsp;&nbsp;&nbsp;1-2. Motivating Example</option>
<option value="1-3">&nbsp;&nbsp;&nbsp;1-3. MST Algorithms</option>
<option value="2">2. Visualisation</option>
<option value="3">3. Input Graph</option>
<option value="4">4. Kruskal&#39;s Algorithm</option>
<option value="4-1">&nbsp;&nbsp;&nbsp;4-1. The Basic Idea</option>
<option value="4-2">&nbsp;&nbsp;&nbsp;4-2. The Answer</option>
<option value="4-3">&nbsp;&nbsp;&nbsp;4-3. The Basic Idea - Continued</option>
<option value="4-4">&nbsp;&nbsp;&nbsp;4-4. Short Proof of Correctness - 1</option>
<option value="4-5">&nbsp;&nbsp;&nbsp;4-5. Short Proof of Correctness - 2</option>
<option value="4-6">&nbsp;&nbsp;&nbsp;4-6. Short Proof of Correctness - 3</option>
<option value="4-7">&nbsp;&nbsp;&nbsp;4-7. Implementation Sketch</option>
<option value="5">5. Prim&#39;s Algorithm</option>
<option value="5-1">&nbsp;&nbsp;&nbsp;5-1. The Basic Idea</option>
<option value="5-2">&nbsp;&nbsp;&nbsp;5-2. Short Proof of Correctness - Part 1</option>
<option value="5-3">&nbsp;&nbsp;&nbsp;5-3. If T != T*, Part 1</option>
<option value="5-4">&nbsp;&nbsp;&nbsp;5-4. If T != T*, Part 2</option>
<option value="5-5">&nbsp;&nbsp;&nbsp;5-5. Short Proof of Correctness - Part 2</option>
<option value="5-6">&nbsp;&nbsp;&nbsp;5-6. Implementation Sketch</option>
<option value="6">6. Poll</option>
<option value="6-1">&nbsp;&nbsp;&nbsp;6-1. The Answer</option>
<option value="7">7. Extras</option>
<option value="7-1">&nbsp;&nbsp;&nbsp;7-1. MST Problem Variants</option>
<option value="7-2">&nbsp;&nbsp;&nbsp;7-2. Online Quiz</option>
<option value="7-3">&nbsp;&nbsp;&nbsp;7-3. Online Judge Exercises</option>
<option value="7-4">&nbsp;&nbsp;&nbsp;7-4. Discussion</option>
</select>
</div>
<div class="electure-print" title="Print the e-Lecture note" style="z-index=8001;">&#9997;</div>
<div class="electure-end" title="Close the e-Lecture mode" style="z-index=8001;">&#10008;</div>
</div>
<div id="dropdown-temp-holder" hidden></div>

<div id="electure-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>A <strong>Spanning Tree (ST)</strong> of a connected undirected weighted graph <b>G</b> is a subgraph of <b>G</b> that is a <strong>tree</strong> and <strong>connects (spans) all vertices of <b>G</b></strong>. A graph <b>G</b> can have many STs (see <a href="https://en.wikipedia.org/wiki/Cayley%27s_formula" target="_blank"><u>this</u></a> or <a href="https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem" target="_blank"><u>this</u></a>), each with different total weight (the sum of edge weights in the ST).</p><br><p>A <strong>Min(imum) Spanning Tree (MST)</strong> of <b>G</b> is an ST of <b>G</b> that has the <strong>smallest total weight</strong> among the various STs.</p>
<div class="electure-addition">
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
If you are an NUS student and a repeat visitor, please <a href="https://visualgo.net/login"><u>login</u></a>.</p>
</div>
<div class="electure-next" data-nextid="1-1" title="Go to the next slide 1-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-1-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>The <b>MST</b> problem is a standard graph (and also optimization) problem defined as follows: Given a connected undirected weighted graph <b>G = (V, E)</b>, select a <b>subset</b> of edges of <b>G</b> such that the graph is still connected but with minimum total weight. The output is either the actual MST of <b>G</b> (there can be several possible MSTs of <b>G</b>) or usually just the minimum total weight itself (this is unique).</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 1: Since you are not <a href="https://visualgo.net/login"><u>logged-in</u></a>, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b>/<b>[PageUp]</b> to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use <b>[&rarr; or &darr;/&larr; or &uarr;]</b> to do the same),and <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
</div>
<div class="electure-prev" data-nextid="1" title="Go to the previous slide 1">&larr;</div>
<div class="electure-next" data-nextid="1-2" title="Go to the next slide 1-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-1-2" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Government wants to link <b>N</b> rural villages in the country with <b>N-1</b> roads.<br>(that is a <i>spanning tree</i> with <b>N</b> vertices and <b>N-1</b> edges).</p><br><p>The cost to build a road to connect two villages depends on the terrain, distance, etc.<br>(that is a <i>complete undirected weighted graph</i> of <b>N*(N-1)/2</b> weighted edges).</p><br><p>You want to minimize the total building cost. How are you going to build the roads?<br>(that is <i>minimum spanning tree</i>).</p><br><p>PS: There is a variant of this problem that requires more advanced solution, e.g., see <a href="steinertree.html"><u>this</u></a>.</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
</div>
<div class="electure-prev" data-nextid="1-1" title="Go to the previous slide 1-1">&larr;</div>
<div class="electure-next" data-nextid="1-3" title="Go to the next slide 1-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-1-3" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>The <b>MST</b> problem has polynomial solutions.</p><br><p>In this visualization, we will learn two of them: Kruskal&#39;s algorithm and Prim&#39;s algorithm. Both are classified as <b>Greedy</b> Algorithms. Note that there are other MST algorithms outside the two presented here.</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode): <b>Spacebar</b> to play/pause/replay the animation, <b>&larr;</b>/<b>&rarr;</b> to step the animation backwards/forwards, respectively, and <b>-</b>/<b>+</b> to decrease/increase the animation speed, respectively.</p>
</div>
<div class="electure-prev" data-nextid="1-2" title="Go to the previous slide 1-2">&larr;</div>
<div class="electure-next" data-nextid="2" title="Go to the next slide 2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2" class="electure-dialog" style="right:70px;bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>View the visualisation of MST algorithm above.</p><br><p>Originally, all vertices and edges in the input graph are colored with the standard <span style="background-color: white; color: black">black color on white background</span>.</p><br><p>At the end of the MST algorithm, <b>|V|-1</b> MST edges (and all <b>|V|</b> vertices) will be colored <span style="color: orange;">orange</span> and non-MST edges will be colored <span style="color: grey;">grey</span>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="1-3" title="Go to the previous slide 1-3">&larr;</div>
<div class="electure-next" data-nextid="3" title="Go to the next slide 3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3" class="electure-dialog" style="bottom:250px;left:60px;width:500px;">
<p>There are two different sources for specifying an input graph:</p><ol><li><b>Edit Graph</b>: You can edit the currently displayed connected undirected weighted graph or draw your own input graph.</li><li><b>Example Graphs</b>: You can select from the list of example connected undirected weighted graphs to get you started.</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2" title="Go to the previous slide 2">&larr;</div>
<div class="electure-next" data-nextid="4" title="Go to the next slide 4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p><b>Kruskal&#39;s algorithm</b>: An O(<b>E</b> log <b>V</b>) greedy MST algorithm that grows a forest of minimum spanning trees and eventually combine them into one MST.</p><br><p>Kruskal&#39;s requires <a href="sorting.html"><u>a good sorting algorithm</u></a> to sort edges of the input graph (usually stored in an <a href="graphds.html"><u>Edge List</u></a> data structure) by non-decreasing weight and another data structure called <a href="ufds.html"><u>Union-Find Disjoint Sets (UFDS)</u></a> to help in checking/preventing cycle.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3" title="Go to the previous slide 3">&larr;</div>
<div class="electure-next" data-nextid="4-1" title="Go to the next slide 4-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-1" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>Kruskal&#39;s algorithm first sort the set of edges <b>E</b> in non-decreasing weight (there can be edges with the same weight), and if ties, by increasing smaller vertex number of the edge, and if still ties, by increasing larger vertex number of the edge.</p><br><p>Discussion: Is this the only possible sort criteria?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4" title="Go to the previous slide 4">&larr;</div>
<div class="electure-next" data-nextid="4-2" title="Go to the next slide 4-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-2" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-1" title="Go to the previous slide 4-1">&larr;</div>
<div class="electure-next" data-nextid="4-3" title="Go to the next slide 4-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-3" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>Then, Kruskal&#39;s algorithm will perform a loop through these sorted edges (that already have non-decreasing weight property) and <b>greedily</b> taking the next edge <b>e</b> if it does <b>not</b> create any cycle w.r.t. edges that have been taken earlier.</p><br><p>Without further ado, let&#39;s try <span class="slide-actions" onclick="doButtonAction30()">Kruskal</span> on the default example graph (that has three edges with the same weight). Go through this animated example first before continuing.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-2" title="Go to the previous slide 4-2">&larr;</div>
<div class="electure-next" data-nextid="4-4" title="Go to the next slide 4-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-4" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>To see on why the <b>Greedy Strategy</b> of Kruskal&#39;s algorithm works, we define a <b>loop invariant</b>: Every edge <b>e</b> that is added into tree <b>T</b> by Kruskal&#39;s algorithm is part of the <b>MST</b>.</p><br><p>At the start of Kruskal&#39;s main loop, <b>T = {}</b> is always part of <b>MST</b> by definition.</p><br><p>Kruskal&#39;s has a special cycle check in its main loop (using <a href="ufds.html"><u>UFDS</u></a> data structure) and only add an edge <b>e</b> into <b>T</b> if it will never form a cycle w.r.t. the previously selected edges.</p><br><p>At the end of the main loop, Kruskal&#39;s can only select <b>V</b>-1 edges from a connected undirected weighted graph <b>G</b> without having any cycle. This implies that Kruskal&#39;s produces a Spanning Tree.</p><br><p>On the default example, notice that after taking the first 2 edges: 0-1 and 0-3, in that order, Kruskal&#39;s <b>cannot</b> take edge 1-3 as it will cause a cycle 0-1-3-0. Kruskal&#39;s then take edge 0-2 but it cannot take edge 2-3 as it will cause cycle 0-2-3-0.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-3" title="Go to the previous slide 4-3">&larr;</div>
<div class="electure-next" data-nextid="4-5" title="Go to the next slide 4-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-5" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>We have seen in the previous slide that Kruskal&#39;s algorithm will produce a tree <b>T</b> that is a Spanning Tree (ST) when it stops. But is it the minimum ST, i.e., the <b>MST</b>?</p><br><p>To prove this, we need to recall that <b>before</b> running Kruskal&#39;s main loop, we have already sort the edges in non-decreasing weight, i.e., the latter edges will have equal or <b>larger</b> weight than the earlier edges.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-4" title="Go to the previous slide 4-4">&larr;</div>
<div class="electure-next" data-nextid="4-6" title="Go to the next slide 4-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-6" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>At the start of every loop, <b>T</b> is always part of MST.</p><br><p>If Kruskal&#39;s only add a legal edge <b>e</b> (that will not cause cycle w.r.t. the edges that have been taken earlier) with <b>min cost</b>, then we can be sure that <b>w(T U e) ≤ w(T U any other unprocessed edge e&#39; that does not form cycle)</b> (by virtue that Kruskal&#39;s has sorted the edges, so <b>w(e) ≤ w(e&#39;)</b>).</p><br><p>Therefore, at the end of the loop, the Spanning Tree <b>T</b> must have minimal overall weight <b>w(T)</b>, so <b>T</b> is the final MST.</p><br><p>On the default example, notice that after taking the first 2 edges: 0-1 and 0-3, in that order, and ignoring edge 1-3 as it will cause a cycle 0-1-3-0, we can safely take the next smallest legal edge 0-2 (with weight 2) as taking any other legal edge (e.g., edge 2-3 with <b>larger</b> weight 3) will either create <b>another</b> MST with equal weight (not in this example) or <b>another</b> ST that is not minimum (which is this example).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-5" title="Go to the previous slide 4-5">&larr;</div>
<div class="electure-next" data-nextid="4-7" title="Go to the next slide 4-7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-7" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>There are two parts of Kruskal&#39;s algorithm: Sorting and the Kruskal&#39;s main loop.</p><br><p>The sorting of edges is easy. We just store the graph using <b>Edge List</b> <a href="graphds.html"><u>data structure</u></a> and sort <b>E</b> edges using any O(<b>E</b> log <b>E</b>) = O(<b>E</b> log <b>V</b>) <a href="sorting.html"><u>sorting algorithm</u></a> (or just use C++/Python/Java sorting library routine) by non-decreasing weight, smaller vertex number, higher vertex number. This O(<b>E</b> log <b>V</b>) is the bottleneck part of Kruskal&#39;s algorithm as the second part is actually lighter, see below.</p><br><p>Kruskal&#39;s main loop can be easily implemented using <a href="ufds.html"><u>Union-Find Disjoint Sets</u></a> data structure. We use <b>IsSameSet(u, v)</b> to test if taking edge <b>e</b> with endpoints <b>u</b> and <b>v</b> will cause a cycle (same connected component -- there is another path in the subtree that can connect <b>u</b> to <b>v</b>, thus adding edge <b>(u, v)</b> will cause a cycle) or not. If <b>IsSameSet(u, v)</b> returns false, we greedily take this next smallest and legal edge <b>e</b> and call <b>UnionSet(u, v)</b> to prevent future cycles involving this edge. This part runs in O(<b>E</b>) as we assume UFDS <b>IsSameSet(u, v)</b> and <b>UnionSet(u, v)</b> operations run in O(<b>1</b>) for a relatively small graph.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-6" title="Go to the previous slide 4-6">&larr;</div>
<div class="electure-next" data-nextid="5" title="Go to the next slide 5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p><b>Prim&#39;s algorithm</b>: Another O(<b>E</b> log <b>V</b>) greedy MST algorithm that grows a Minimum Spanning Tree from a starting source vertex until it spans the entire graph.</p><br><p>Prim&#39;s requires a Priority Queue data structure (usually implemented using <a href="heap.html"><u>Binary Heap</u></a> but we can also use <a href="bstb4ef.html"><u>Balanced Binary Search Tree</u></a> too) to dynamically order the currently considered edges based on non-decreasing weight, an <a href="graphds.html"><u>Adjacency List data structure</u></a> for fast neighbor enumeration of a vertex, and a Boolean array (<a href="hashtableec4c.html?slide=2-2"><u>a Direct Addressing Table</u></a>) to help in checking cycle.</p><br><p>Another name of Prim&#39;s algorithm is Jarnik-Prim&#39;s algorithm.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-7" title="Go to the previous slide 4-7">&larr;</div>
<div class="electure-next" data-nextid="5-1" title="Go to the next slide 5-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-1" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>Prim&#39;s algorithm starts from a designated source vertex <b>s</b> (usually vertex 0) and enqueues all edges incident to <b>s</b> into a Priority Queue (PQ) according to non-decreasing weight, and if ties, by increasing vertex number (of the neighboring vertex number). Then it will repeatedly do the following greedy steps: If the vertex <b>v</b> of the front-most edge pair information <b>e: (w, v)</b> in the PQ has <b>not</b> been visited, it means that we can greedily extends the tree <b>T</b> to include vertex <b>v</b> and enqueue edges connected to <b>v</b> into the PQ, otherwise we discard edge <b>e</b> (because Prim&#39;s grows one spanning tree from <b>s</b>, the fact that <b>v</b> is already visited implies that there is another path from <b>s</b> to <b>v</b> and adding this edge will cause a cycle).</p><br><p>Without further ado, let&#39;s try <span class="slide-actions" onclick="doButtonAction31()">Prim(1)</span> on the default example graph (that has three edges with the same weight). That&#39;s it, we start Prim&#39;s algorithm from source vertex <b>s = 1</b>. Go through this animated example first before continuing.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5" title="Go to the previous slide 5">&larr;</div>
<div class="electure-next" data-nextid="5-2" title="Go to the next slide 5-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-2" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>Prim&#39;s algorithm is a <b>Greedy Algorithm</b> because at each step of its main loop, it always try to select the next valid edge <b>e</b> with minimal weight (that is greedy!).</p><br><p>To convince us that Prim&#39;s algorithm is correct, let&#39;s go through the following simple proof: Let <b>T</b> be the spanning tree of graph <b>G</b> generated by Prim&#39;s algorithm and <b>T*</b> be the spanning tree of <b>G</b> that is known to have minimal cost, i.e. <b>T*</b> is the <b>MST</b>.</p><br><p>If <b>T == T*</b>, that&#39;s it, Prim&#39;s algorithm produces exactly the same <b>MST</b> as <b>T*</b>, we are done.</p><br><p>But if <b>T != T*</b>...</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-1" title="Go to the previous slide 5-1">&larr;</div>
<div class="electure-next" data-nextid="5-3" title="Go to the next slide 5-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-3" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>Assume that on the default example, <b>T = {0-1, 0-3, 0-2}</b> but <b>T* = {0-1, 1-3, 0-2}</b> instead.</p><br><p>Let <b>e<sub>k</sub> = (u, v)</b> be the first edge chosen by Prim&#39;s Algorithm at the <b>k</b>-th iteration that is not in <b>T*</b> (on the default example, <b>k = 2</b>, <b>e<sub>2</sub> = (0, 3)</b>, note that <b>(0, 3)</b> is not in <b>T*</b>).</p><br><p>Let <b>P</b> be the path from <b>u</b> to <b>v</b> in <b>T*</b>, and let <b>e*</b> be an edge in <b>P</b> such that one endpoint is in the tree generated at the (<b>k</b>−1)-th iteration of Prim&#39;s algorithm and the other is not (on the default example, <b>P = 0-1-3</b> and <b>e* = (1, 3)</b>, note that vertex <b>1</b> is inside <b>T</b> at first iteration <b>k = 1</b>).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-2" title="Go to the previous slide 5-2">&larr;</div>
<div class="electure-next" data-nextid="5-4" title="Go to the next slide 5-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-4" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>If the weight of <b>e*</b> is less than the weight of <b>e<sub>k</sub></b>, then Prim&#39;s algorithm would have chosen <b>e*</b> on its <b>k</b>-th iteration as that is how Prim&#39;s algorithm works.</p><br><p>So, it is certain that <b>w(e*) ≥ w(e<sub>k</sub>)</b>.<br>(on the example graph, <b>e* = (1, 3)</b> has weight 1 and <b>e<sub>k</sub> = (0, 3)</b> also has weight 1).</p><br><p>When weight <b>e*</b> is = weight <b>e<sub>k</sub></b>, the choice between the <b>e*</b> or <b>e<sub>k</sub></b> is actually arbitrary. And whether the weight of <b>e*</b> is ≥ weight of <b>e<sub>k</sub></b>, <b>e*</b> can always be substituted with <b>e<sub>k</sub></b> while preserving minimal total weight of <b>T*</b>. (on the example graph, when we replace <b>e* = (1, 3)</b> with <b>e<sub>k</sub> = (0, 3)</b>, we manage to transform <b>T*</b> into <b>T</b>).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-3" title="Go to the previous slide 5-3">&larr;</div>
<div class="electure-next" data-nextid="5-5" title="Go to the next slide 5-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-5" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>But if <b>T != T*</b>... (continued)</p><br><p>We can repeat the substitution process outlined earlier repeatedly until <b>T* = T</b> and thereby we have shown that the spanning tree generated by any instance of Prim&#39;s algorithm (from any source vertex <b>s</b>) is an MST as whatever the optimal MST is, it can be transformed to the output of Prim&#39;s algorithm.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-4" title="Go to the previous slide 5-4">&larr;</div>
<div class="electure-next" data-nextid="5-6" title="Go to the next slide 5-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-6" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>We can easily implement Prim&#39;s algorithm with two well-known data structures:</p><ol><li>A Priority Queue PQ (<a href="heap.html"><u>Binary Heap</u></a> inside C++ STL priority_queue/Python heapq/Java PriorityQueue or <a href="bstb4ef.html"><u>Balanced BST</u></a> inside C++ STL set/Java TreeSet), and</li><li>A Boolean array of size <b>V</b>, essentially a <a href="hashtableec4c.html?slide=2-2"><u>Direct Addressing Table</u></a> (to decide if a vertex has been taken or not, i.e., in the same connected component as the source vertex <b>s</b> or not).</li></ol><p>With these, we can run Prim&#39;s Algorithm in O(<b>E</b> log <b>V</b>) because we process each edge once and each time, we call <b>Insert((w, v))</b> and <b>(w, v) = ExtractMax()</b> from a PQ in O(log <b>E</b>) = O(log <b>V<sup>2</sup></b>) = O(2 log <b>V</b>) = O(log <b>V</b>). As there are <b>E</b> edges, Prim&#39;s Algorithm runs in O(<b>E</b> log <b>V</b>).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-5" title="Go to the previous slide 5-5">&larr;</div>
<div class="electure-next" data-nextid="6" title="Go to the next slide 6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<input class="mcq-answer" id="mcq-answer-12" value="55" hidden><p>Quiz: <b>Having seen both Kruskal's and Prim's Algorithms, which one is the better MST algorithm?</b></p><form><input type="radio" name="mcq-12-choice" value="55"> It Depends<br><input type="radio" name="mcq-12-choice" value="54"> Kruskal's Algorithm<br><input type="radio" name="mcq-12-choice" value="53"> Prim's Algorithm<br></form><button class="mcq-submit" id="submit-12">Submit</button> <span id="answer-status-12"></span><br><br><p>Discussion: Why?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-6" title="Go to the previous slide 5-6">&larr;</div>
<div class="electure-next" data-nextid="6-1" title="Go to the next slide 6-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6" title="Go to the previous slide 6">&larr;</div>
<div class="electure-next" data-nextid="7" title="Go to the next slide 7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>You have reached the end of the basic stuffs of this Min(imum) Spanning Tree graph problem and its two classic algorithms: Kruskal&#39;s and Prim&#39;s (there are others, like another O(E log V) <a href="https://en.wikipedia.org/wiki/Borůvka%27s_algorithm" target="_blank"><u>Boruvka&#39;s</u></a> algorithm, but not discussed in this visualization). We encourage you to explore further in the <b>Exploration Mode</b>.</p><br><p>However, the harder MST problems can be (much) more challenging that its basic version.</p><br><p>Once you have (roughly) mastered this MST topic, we encourage you to study more on harder graph problems where MST is used as a component, e.g., approximation algorithm for NP-hard <a href="tsp.html"><u>(Metric No-Repeat) TSP</u></a> and <a href="steinertree.html"><u>Steiner Tree</u></a> problems.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6-1" title="Go to the previous slide 6-1">&larr;</div>
<div class="electure-next" data-nextid="7-1" title="Go to the next slide 7-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>We write a few MST problem variants in the <a href="https://cpbook.net/" target="_blank"><u>Competitive Programming book</u></a>.</p><ol><li>Max(imum) Spanning Tree,</li><li>Min(imum) Spanning Subgraph,</li><li>Min(imum) Spanning Forest,</li><li>Second Best Spanning Tree,</li><li>Minimax (Maximin) Path Problem, etc</li></ol><p>Advertisement: Buy CP book to study more about these variants and see that sometimes Kruskal&#39;s is better and sometimes Prim&#39;s is better at some of these variants.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7" title="Go to the previous slide 7">&larr;</div>
<div class="electure-next" data-nextid="7-2" title="Go to the next slide 7-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-2" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>For a few more challenging questions about this MST problem and/or Kruskal&#39;s/Prim&#39;s Algorithms, please practice on <a href="https://visualgo.net/training?diff=Medium&amp;n=10&amp;tl=0&amp;module=mst"><u>MST</u></a> training module (no login is required, but on medium difficulty setting only).</p><br><p>However, for NUS students, you should login to officially clear this module and such achievement will be recorded in your user account.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-1" title="Go to the previous slide 7-1">&larr;</div>
<div class="electure-next" data-nextid="7-3" title="Go to the next slide 7-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-3" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>This MST problem can be much more challenging than this basic form. Therefore we encourage you to try the following two ACM ICPC contest problems about MST: <a href="https://uva.onlinejudge.org/external/12/1234.pdf" title target="_blank"><u>UVa 01234 - RACING</u></a> and <a href="https://open.kattis.com/problems/arcticnetwork" title target="_blank"><u>Kattis - arcticnetwork</u></a>.</p><br><p>Try them to consolidate and improve your understanding about this graph problem.</p><br><p>You are allowed to use/modify our implementation code for Kruskal&#39;s/Prim&#39;s Algorithms:<br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mst/kruskal.cpp" target="_blank"><u>kruskal.cpp</u></a> | <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mst/kruskal.py" target="_blank"><u>py</u></a> | <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mst/kruskal.java" target="_blank"><u>java</u></a> | <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mst/kruskal.ml" target="_blank"><u>ml</u></a><br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mst/prim.cpp" target="_blank"><u>prim.cpp</u></a> | <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mst/prim.py" target="_blank"><u>py</u></a> | <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mst/prim.java" target="_blank"><u>java</u></a> | <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mst/prim.ml" target="_blank"><u>ml</u></a><br></p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-2" title="Go to the previous slide 7-2">&larr;</div>
<div class="electure-next" data-nextid="7-4" title="Go to the next slide 7-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-4" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
<hr>
<p>You have reached the last slide. Return to 'Exploration Mode' to start exploring!</p>
<p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
</div>
<div class="electure-prev" data-nextid="7-3" title="Go to the previous slide 7-3">&larr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>Close</u></span>
</div>
<div id="rotateDeviceOverlay" style="display: none;">
<div id="rotateDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please rotate your device to landscape mode for a better user experience</div>
<div id="widenDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please make the window wider for a better user experience</div>
</div>

<style>
        .mediumscale {
            bottom: 200px
        }
    </style>
<style>
        .draw {
            bottom: 146px
        }
    </style>
<style>
        .examples {
            bottom: 119px
        }
    </style>
<style>
        .kruskals {
            bottom: 92px
        }
    </style>
<style>
        .prims {
            bottom: 65px
        }
    </style>
<div id="actions" class="panel">
<p id="mediumscale">Visualisation Scale</p>
<p class="execAction" id="vertexnumber" onClick="toggleVertexNumber()">Toggle V. Number for 0.5x</p>
<p class="execAction" id="draw" onClick="drawGraph()">Edit Graph</p>
<p id="examples">Example Graphs</p>
<p class="execAction" id="kruskals" onClick="kruskals()">Kruskal&#39;s Algorithm</p>
<p id="prims">Prim&#39;s Algorithm(s)</p>
</div>
<div id="actions-hide" class="panel-hide"><span style="color:white; font-size: x-large; display: inline-block;">&gt;</span></div>
<div id="actions-extras">
<div class="mediumscale action-menu-pullout">
<div id="defaultScale" class="execAction new-menu-option coloured-menu-option" onClick="setDefaultScale()">
<p>1.0x (Default)</p>
</div>
<div id="mediumScale" class="execAction new-menu-option coloured-menu-option" onClick="setMediumScale()">
<p>0.5x (Minimal Details)</p>
</div>
<div id="mediumscale-err" class="err" style="float: left;"></div>
</div>
<div class="draw action-menu-pullout">
<div id="draw-err" class="err" style="float: left;"></div>
</div>
<div class="examples action-menu-pullout">
<div id="example1" class="execAction new-menu-option coloured-menu-option" onClick="example(CP3_4_10)">
<p>CP 4.10</p>
</div>
<div id="example2" class="execAction new-menu-option coloured-menu-option" onClick="example(CP3_4_14)">
<p>CP 4.14</p>
</div>
<div id="example3" class="execAction new-menu-option coloured-menu-option" onClick="example(K5)">
<p>K5</p>
</div>
<div id="example4" class="execAction new-menu-option coloured-menu-option" onClick="example(RAIL)">
<p>Rail</p>
</div>
<div id="example5" class="execAction new-menu-option coloured-menu-option" onClick="example(TESSELLATION)">
<p>Tessellation</p>
</div>
<div id="example6" class="execAction new-menu-option coloured-menu-option" onClick="example(MSTLARGE)">
<p>Large</p>
</div>
<div id="examples-err" class="err" style="float: left;"></div>
</div>
<div class="kruskals action-menu-pullout">
<div id="kruskals-err" class="err" style="float: left;"></div>
</div>
<div class="prims action-menu-pullout">
<div id="prims-input" class="new-menu-option">
s = <input id="prim-v" type="number" title="Enter the source vertex" autocomplete="off" min="0" max="99" value="0"> </div>
<div id="prims-go" class="execAction new-menu-option coloured-menu-option" onClick="prims()">
<p>Go</p>
</div>
<div id="prims-err" class="err" style="float: left;"></div>
</div>
</div>

<div id="drawgraph" class="overlays"></div>
</div>

<div id="bottom-bar">
<a id="scale" style="display: none;">1.0x</a>
<a id="trigger-about">About</a>
<a id="trigger-team">Team</a>
<a id="trigger-terms">Terms of use</a>
<a id="trigger-privacy">Privacy Policy</a>
</div>
<div id="about" class="overlays">
<h4>About</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.</p><p>Featuring numerous advanced algorithms discussed in Dr. Steven Halim&#39;s book, &#39;Competitive Programming&#39; — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.</p><p>While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.</p><p>Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.</p><p>VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.</p><p>Equipped with a built-in question generator and answer verifier, VisuAlgo&#39;s "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students&#39; answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students&#39; mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.</p><p>VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:</p>
<a href="https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689" target="_blank"><u>id</u></a>,
<a href="http://blog.naver.com/visualgo_nus" target="_blank"><u>kr</u></a>,
<a href="https://www.facebook.com/groups/163215593699283/permalink/824003417620494/" target="_blank"><u>vn</u></a>,
<a href="http://pantip.com/topic/32736343" target="_blank"><u>th</u></a>.
</div>
</div>
<div id="team" class="overlays">
<h4>Team</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>
<strong><span style="line-height: 150%;">Project Leader &amp; Advisor (Jul 2011-present)</span></strong><br>
<a href="https://www.comp.nus.edu.sg/~stevenha/" target="_blank">Associate Professor Steven Halim</a>, School of Computing (SoC), National University of Singapore (NUS)<br>
<a href="https://www.linkedin.com/in/felixhalim/" target="_blank">Dr Felix Halim</a>, Senior Software Engineer, Google (Mountain View)
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 1</span></strong><br>
<b>CDTL TEG 1: Jul 2011-Apr 2012</b>: Koh Zi Chun, Victor Loh Bo Huai
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 1</span></strong><br>
<b>Jul 2012-Dec 2013</b>: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang Duy<br>
<b>Jun 2013-Apr 2014</b> <a href="https://www.rosemarietan.com/" target="_blank">Rose Marie Tan Zhao Yun</a>, Ivan Reinaldo
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 2</span></strong><br>
<b>CDTL TEG 2: May 2014-Jul 2014</b>: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 2</span></strong><br>
<b>Jun 2014-Apr 2015</b>: Erin Teo Yi Ling, Wang Zi<br>
<b>Jun 2016-Dec 2017</b>: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin Mudzakir<br>
<b>Aug 2021-Apr 2023</b>: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius<br>
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 3</span></strong><br>
<b>Optiver: Aug 2023-Oct 2023</b>: Bui Hong Duc, Oleh Naver, Tay Ngan Lin<br>
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 3</span></strong><br>
<b>Aug 2023-Apr 2024</b>: Xiong Jingya, Radian Krisno, Ng Wee Han<br>
</p>
<p>
List of translators who have contributed &ge; 100 translations can be found at <a href="https://visualgo.net/statistics">statistics</a> page.
</p>
<p>
<strong><span style="line-height: 150%;">Acknowledgements</span></strong><br>
NUS <a href="https://nus.edu.sg/cdtl" target="_blank"><u>CDTL</u></a> gave Teaching Enhancement Grant to kickstart this project.<div>For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.</div>
</p>
</div>
</div>
<div id="termsofuse" class="overlays">
<h4>Terms of use</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that you <b>spread the word about its existence to fellow Computer Science students and instructors</b>. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.</p><p>Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (<a href="https://visualgo.net/">https://visualgo.net</a>) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo&#39;s client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.</p><p>Please note that VisuAlgo&#39;s online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the &#39;training mode.&#39; The &#39;test mode&#39; offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.</p><p><strong><span style="line-height: 200%;">List of Publications</span></strong></p> <p>This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can click <a href="https://ioinformatics.org/journal/INFOL099.pdf" target="_blank">this link</a> to read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) and <a href="https://ioinformatics.org/journal/v9_2015_243_245.pdf" target="_blank">this link</a> for the short update in 2015 (to link VisuAlgo name with the previous project).</p><p><strong><span style="line-height: 200%;">Bug Reports or Request for New Features</span></strong></p> <p>VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.</p>
</div>
</div>
<div id="privacy-policy" class="overlays">
<h4>Privacy Policy</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p><b>Version 1.2 (Updated Fri, 18 Aug 2023).</b></p><p>Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.</p><p>Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).</p><p>Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.</p><p>For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.<br></p><p>For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.</p>
</div>
</div>
</div>


<script src="../../code.jquery.com/jquery-3.7.0.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
<script src="../../cdn.jsdelivr.net/npm/bootstrap%405.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<script src="../../unpkg.com/d3-force-boundary%400.0.1/dist/d3-force-boundary.min.js"></script>
<script>
  $(function () {
    // overlays stuffs
    $('#trigger-about').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#about').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-team').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#team').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-terms').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#termsofuse').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-privacy').click(function () {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#privacy-policy').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    })

    $('.close-overlay').click(function() {
      $('.overlays').fadeOut(function() {
        $('#dark-overlay').fadeOut();
      });
    });

    $('#dark-overlay').click(function() {
      $('.overlays').fadeOut();
      $('#dark-overlay').fadeOut();
      if (typeof GeometryWidget !== 'undefined') {
        GeometryWidget.stopLoop();
      }
    });
  })
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-1566631-4"></script>
<script>
      $.ajaxSetup({
        headers: {
          'X-CSRF-TOKEN': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H"
        }
      });

      // handles account dropdown menu
      $(function () {
        $('#language-dropdown-btn').click(function (e) {
          $('#language-dropdown-menu').css('display', 'block');
          $('#account-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function () {
          $('#language-dropdown-menu').css('display', 'none')
        })
      })

      $(function () {
        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        })
      })

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        if (retval) {
          $('#current-action').show();
          $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
          $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
          triggerRightPanels();
          isPlaying = true;
        }
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; ++i) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      const MOBILE_WIDTH = 1000;
      const matchMediaMobile = window.matchMedia(`only screen and (max-width: ${MOBILE_WIDTH}px)`);
      const matchMediaNarrow = window.matchMedia(`only screen and (max-width: 500px)`);
      function isMobile() {
        return matchMediaMobile.matches;
      }
      //To fix the issue of a narrow desktop window being asked to rotate, I am now checking for it based on the navigator.userAgent to see if its mobile or not.
      //This may change in the future if browsers decide to change the naming of userAgent for mobile browsers so may need to keep an eye on this.
      function isMobileOS() {
        return /Mobi/i.test(navigator.userAgent) && !/ipad/i.test(navigator.userAgent);
      }
      let portraitMatcher = window.matchMedia("(orientation:portrait)");
      function isPortrait() {
        return portraitMatcher.matches;
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.colour').css("color", surpriseColour);
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
        });
      });

/*
      // GA dropped 26 Jun 2023 and then made official on 18 Aug 2023
/*
      // the sunset-ed GA, commented on 26 Jun 2023, and Prof Halim doesn't bother to use anymore
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
*/

      // function setCookie(cname, cvalue, exdays) {
      //   const d = new Date();
      //   d.setTime(d.getTime() + (exdays*24*60*60*1000));
      //   let expires = "expires="+ d.toUTCString();
      //   document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
      // }

//       //         $(function() {
//           $('#gdpr-accept').click(function () {
// /*
//             // added on 26 Jun 2023
//             window.dataLayer = window.dataLayer || [];
//             function gtag(){dataLayer.push(arguments);}
//             gtag('js', new Date());

//             gtag('config', 'UA-1566631-4');
// */
// //            ga('create', 'UA-1566631-4', 'auto');
// //            ga('send', 'pageview');
//             setCookie('use_google_analytics', 'true', 365)
//             $('#gdpr-popup').hide()
//           });
//           $('#gdpr-reject').click(function () {
//             setCookie('use_google_analytics', 'false', 365)
//             $('#gdpr-popup').hide()
//           });
//         });
//       
      $('#gdpr-privacy-policy').click(function () {
        if ($(window).width() > 600) {
          $('#dark-overlay').fadeIn(function() {
            $('#privacy-policy').fadeIn();
          });
        }
        else
          alert('Sorry, this dialog is too big. Please load it on bigger screen');
      })
    </script>

<script src="../js/jquery-ui.min.js"></script>

<script src="../js/d3.min.js"></script>
<script src="../js/viz-1.0.10.js"></script>

<script src="../js/graph_library/constant.js"></script>
<script src="../js/graph_library/drawgraph.js"></script>
<script src="../js/graph_library/GraphEdgeWidget.js"></script>
<script src="../js/graph_library/GraphPolygonWidget.js"></script>
<script src="../js/graph_library/GraphVertexWidget.js"></script>
<script src="../js/graph_library/GraphWidget.js"></script>
<script src="../js/graph_library/helperObjects89db.js?refresh22aug9pm"></script> 
<script src="../js/graph_library/misc.js"></script>
<script src="../js/graph_library/properties.js"></script>
<script src="../js/graph_library/Widget.js"></script>
<script src="../js/graph_library/force_directed_library.js"></script>

<script>
      $(function () {
        let defaultPlaybackSpeed = 1;
                createPlaybackSpeedSlider(defaultPlaybackSpeed);


        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        });
        //Mobile Design Related DOM Manipulations
        if (isMobile()) {
          $("#status").css({
            "bottom": "10%",
            "height": "12%",
            "max-height": "54px"
          });
          $("#current-action").css("bottom", "22%");
          $('#status-hide').remove();
          $('#left-bar').remove();
          $('#right-bar').remove();
          $("#mode-menu").remove();
          $("#codetrace").css("z-index", 1);
          $("#bottom-bar a").hide();
          $("#bottom-bar").css("height", $("#topbar").css("height"));
          $(".speed-dropup-btn").show();
          $("#go-to-beginning").remove();
          $("#go-to-end").remove();
          $("#pause").remove();
          $("#play").remove();
          $("#previous").remove();
          $("#next").remove();

          //make progress bar longer
          $("#progress-bar").css({
            left: "30%",
            width: "60%",
            'margin-left': 0
          })
        }
      })

      let mobilePlaybackOverlayTimeout;
      $(function() {
        $("#viz").on("click", () => {
          if (isMobile()) {
            if ($("#mobile-playback-overlay").is(":hidden") && isPlaying) {
              $("#mobile-playback-overlay").fadeIn();
              hideMobilePlaybackOverlay(6000);
            } else {
              $("#mobile-playback-overlay").fadeOut();
            }
          }
        });
        $("#mobile-playback-overlay").on("click", (event) => {
          if (event.target === event.currentTarget) //to ensure clicks on the controls dont fade the overlay
            $("#mobile-playback-overlay").fadeOut();
          else
            hideMobilePlaybackOverlay(5000);
        })
      });
      function hideMobilePlaybackOverlay(timeOut) {
        if (mobilePlaybackOverlayTimeout)
          clearTimeout(mobilePlaybackOverlayTimeout);
        mobilePlaybackOverlayTimeout = setTimeout(() => {
            $("#mobile-playback-overlay").fadeOut();
        }, timeOut);
      }
      function mobilePlaybackPauseOrPlay() {
        if ($("#mobile-playback-overlay").hasClass("playing")) {
          pause();
          hideMobilePlaybackOverlay(5000);
        } else {
          play();
          hideMobilePlaybackOverlay(3000);
        }
      }
      let rewindLabelTimeout, forwardLabelTimeout;
      function mobilePlaybackRewind() {
        $("#mobile-playback-rewind-label").css("opacity", 1);
        if (rewindLabelTimeout)
          clearTimeout(rewindLabelTimeout);
        rewindLabelTimeout = setTimeout(() => {
          $("#mobile-playback-rewind-label").css("opacity", 0);
        }, 800);
        stepBackward(7);
      }
      function mobilePlaybackForward() {
        $("#mobile-playback-forward-label").css("opacity", 1);
        if (forwardLabelTimeout)
          clearTimeout(forwardLabelTimeout);
        forwardLabelTimeout = setTimeout(() => {
          $("#mobile-playback-forward-label").css("opacity", 0);
        }, 800);
        stepForward(7);
      }

      //let eLectureSessionHistory = {};
      const sectorColors = ['#05a4d0', '#f1c706', '#fa0202'];
      function setSlideTimelineColor(slideNo) {
        const sectionNo = slideNo.split('-')[0];
        $(`[slideNo="${slideNo}"]`).css('background', sectorColors[(parseInt(sectionNo) % 3)]);
      }

      let currSlideTimer = null; //global so that we can clear the timeout when required

      const lectureIds = [{"id":44,"category":"mst","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:03:26","updated_at":"2023-11-09 08:52:12","section":-1,"code":"","section_order":-1,"value":"1","text":"<p>A <strong>Spanning Tree (ST)<\/strong> of a connected undirected weighted graph <b>G<\/b> is a subgraph of <b>G<\/b> that is a <strong>tree<\/strong> and <strong>connects (spans) all vertices of <b>G<\/b><\/strong>. A graph <b>G<\/b> can have many STs (see <a href=\"https:\/\/en.wikipedia.org\/wiki\/Cayley%27s_formula\" target=\"_blank\"><u>this<\/u><\/a> or <a href=\"https:\/\/en.wikipedia.org\/wiki\/Kirchhoff%27s_theorem\" target=\"_blank\"><u>this<\/u><\/a>), each with different total weight (the sum of edge weights in the ST).<\/p><br><p>A <strong>Min(imum) Spanning Tree (MST)<\/strong> of <b>G<\/b> is an ST of <b>G<\/b> that has the <strong>smallest total weight<\/strong> among the various STs.<\/p>","title":"Min(imum) Spanning Tree (MST)"},{"id":266,"category":"mst","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-04 05:58:22","updated_at":"2023-11-09 08:52:16","section":44,"code":"","section_order":1,"value":"1-1","text":"<p>The <b>MST<\/b> problem is a standard graph (and also optimization) problem defined as follows: Given a connected undirected weighted graph <b>G = (V, E)<\/b>, select a <b>subset<\/b> of edges of <b>G<\/b> such that the graph is still connected but with minimum total weight. The output is either the actual MST of <b>G<\/b> (there can be several possible MSTs of <b>G<\/b>) or usually just the minimum total weight itself (this is unique).<\/p>","title":"MST Problem"},{"id":411,"category":"mst","order":2,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-18 06:26:58","updated_at":"2023-11-09 08:52:19","section":44,"code":"","section_order":1,"value":"1-2","text":"<p>Government wants to link <b>N<\/b> rural villages in the country with <b>N-1<\/b> roads.<br>(that is a <i>spanning tree<\/i> with <b>N<\/b> vertices and <b>N-1<\/b> edges).<\/p><br><p>The cost to build a road to connect two villages depends on the terrain, distance, etc.<br>(that is a <i>complete undirected weighted graph<\/i> of <b>N*(N-1)\/2<\/b> weighted edges).<\/p><br><p>You want to minimize the total building cost. How are you going to build the roads?<br>(that is <i>minimum spanning tree<\/i>).<\/p><br><p>PS: There is a variant of this problem that requires more advanced solution, e.g., see <a href=\".\/steinertree\"><u>this<\/u><\/a>.<\/p>","title":"Motivating Example"},{"id":267,"category":"mst","order":3,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-04 06:03:10","updated_at":"2023-11-09 08:52:48","section":44,"code":"","section_order":1,"value":"1-3","text":"<p>The <b>MST<\/b> problem has polynomial solutions.<\/p><br><p>In this visualization, we will learn two of them: Kruskal&#39;s algorithm and Prim&#39;s algorithm. Both are classified as <b>Greedy<\/b> Algorithms. Note that there are other MST algorithms outside the two presented here.<\/p>","title":"MST Algorithms"},{"id":45,"category":"mst","order":2,"top":"","right":"70px","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:04:17","updated_at":"2022-01-30 13:46:17","section":-1,"code":"","section_order":-1,"value":"2","text":"<p>View the visualisation of MST algorithm above.<\/p><br><p>Originally, all vertices and edges in the input graph are colored with the standard <span style=\"background-color: white; color: black\">black color on white background<\/span>.<\/p><br><p>At the end of the MST algorithm, <b>|V|-1<\/b> MST edges (and all <b>|V|<\/b> vertices) will be colored <span style=\"color: orange;\">orange<\/span> and non-MST edges will be colored <span style=\"color: grey;\">grey<\/span>.<\/p>","title":"Visualisation"},{"id":46,"category":"mst","order":3,"top":"","right":"","bottom":"250px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:05:36","updated_at":"2023-11-09 08:53:06","section":-1,"code":"$(\"#draw\").addClass(\"menu-highlighted\");\n$(\"#examples\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"3","text":"<p>There are two different sources for specifying an input graph:<\/p><ol><li><b>Edit Graph<\/b>: You can edit the currently displayed connected undirected weighted graph or draw your own input graph.<\/li><li><b>Example Graphs<\/b>: You can select from the list of example connected undirected weighted graphs to get you started.<\/li><\/ol>","title":"Input Graph"},{"id":47,"category":"mst","order":4,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:05:59","updated_at":"2022-01-30 13:47:26","section":-1,"code":"$(\"#kruskals\").addClass(\"menu-highlighted\");","section_order":-1,"value":"4","text":"<p><b>Kruskal&#39;s algorithm<\/b>: An O(<b>E<\/b> log <b>V<\/b>) greedy MST algorithm that grows a forest of minimum spanning trees and eventually combine them into one MST.<\/p><br><p>Kruskal&#39;s requires <a href=\".\/sorting\"><u>a good sorting algorithm<\/u><\/a> to sort edges of the input graph (usually stored in an <a href=\".\/graphds\"><u>Edge List<\/u><\/a> data structure) by non-decreasing weight and another data structure called <a href=\".\/ufds\"><u>Union-Find Disjoint Sets (UFDS)<\/u><\/a> to help in checking\/preventing cycle.<\/p>","title":"Kruskal&#39;s Algorithm"},{"id":268,"category":"mst","order":1,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-04 06:13:07","updated_at":"2022-01-30 13:47:29","section":47,"code":"$(\"#kruskals\").addClass(\"menu-highlighted\");\nloadGraph({\n  'vl': {\n    0: { \"x\": 50, \"y\": 50 },\n    1: { \"x\": 250, \"y\": 50 },\n    2: { \"x\": 50, \"y\": 250 },\n    3: { \"x\": 250, \"y\": 250 }\n  },\n  'el': {\n    0: { \"u\": 0, \"v\": 1, \"w\": 1 },\n    1: { \"u\": 0, \"v\": 2, \"w\": 2 },\n    2: { \"u\": 0, \"v\": 3, \"w\": 1 },\n    3: { \"u\": 1, \"v\": 3, \"w\": 1 },\n    4: { \"u\": 2, \"v\": 3, \"w\": 3 }\n  }\n});","section_order":4,"value":"4-1","text":"<p>Kruskal&#39;s algorithm first sort the set of edges <b>E<\/b> in non-decreasing weight (there can be edges with the same weight), and if ties, by increasing smaller vertex number of the edge, and if still ties, by increasing larger vertex number of the edge.<\/p><br><p>Discussion: Is this the only possible sort criteria?<\/p>","title":"The Basic Idea"},{"id":407,"category":"mst","order":2,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-18 05:51:22","updated_at":"2022-01-30 13:47:32","section":47,"code":"$(\"#kruskals\").addClass(\"menu-highlighted\");\nloadGraph({\n  'vl': {\n    0: { \"x\": 50, \"y\": 50 },\n    1: { \"x\": 250, \"y\": 50 },\n    2: { \"x\": 50, \"y\": 250 },\n    3: { \"x\": 250, \"y\": 250 }\n  },\n  'el': {\n    0: { \"u\": 0, \"v\": 1, \"w\": 1 },\n    1: { \"u\": 0, \"v\": 2, \"w\": 2 },\n    2: { \"u\": 0, \"v\": 3, \"w\": 1 },\n    3: { \"u\": 1, \"v\": 3, \"w\": 1 },\n    4: { \"u\": 2, \"v\": 3, \"w\": 3 }\n  }\n});","section_order":4,"value":"4-2","text":"<p>The first sort criteria (by non-decreasing weight) is important. It is the main criteria.<\/p><br><p>Then the sorting of edges with similar weight based on smaller vertex number first is just our individual preference.<\/p>","title":"The Answer"},{"id":408,"category":"mst","order":3,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-18 05:52:00","updated_at":"2022-01-30 13:47:17","section":47,"code":"$(\"#kruskals\").addClass(\"menu-highlighted\");\nloadGraph({\n  'vl': {\n    0: { \"x\": 50, \"y\": 50 },\n    1: { \"x\": 250, \"y\": 50 },\n    2: { \"x\": 50, \"y\": 250 },\n    3: { \"x\": 250, \"y\": 250 }\n  },\n  'el': {\n    0: { \"u\": 0, \"v\": 1, \"w\": 1 },\n    1: { \"u\": 0, \"v\": 2, \"w\": 2 },\n    2: { \"u\": 0, \"v\": 3, \"w\": 1 },\n    3: { \"u\": 1, \"v\": 3, \"w\": 1 },\n    4: { \"u\": 2, \"v\": 3, \"w\": 3 }\n  }\n});","section_order":4,"value":"4-3","text":"<p>Then, Kruskal&#39;s algorithm will perform a loop through these sorted edges (that already have non-decreasing weight property) and <b>greedily<\/b> taking the next edge <b>e<\/b> if it does <b>not<\/b> create any cycle w.r.t. edges that have been taken earlier.<\/p><br><p>Without further ado, let&#39;s try <span class=\"slide-actions\" onclick=\"doButtonAction30()\">Kruskal<\/span> on the default example graph (that has three edges with the same weight). Go through this animated example first before continuing.<\/p>","title":"The Basic Idea - Continued"},{"id":269,"category":"mst","order":4,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-04 06:15:12","updated_at":"2022-01-30 13:47:44","section":47,"code":"$(\"#kruskals\").addClass(\"menu-highlighted\");\nloadGraph({\n  'vl': {\n    0: { \"x\": 50, \"y\": 50 },\n    1: { \"x\": 250, \"y\": 50 },\n    2: { \"x\": 50, \"y\": 250 },\n    3: { \"x\": 250, \"y\": 250 }\n  },\n  'el': {\n    0: { \"u\": 0, \"v\": 1, \"w\": 1 },\n    1: { \"u\": 0, \"v\": 2, \"w\": 2 },\n    2: { \"u\": 0, \"v\": 3, \"w\": 1 },\n    3: { \"u\": 1, \"v\": 3, \"w\": 1 },\n    4: { \"u\": 2, \"v\": 3, \"w\": 3 }\n  }\n});","section_order":4,"value":"4-4","text":"<p>To see on why the <b>Greedy Strategy<\/b> of Kruskal&#39;s algorithm works, we define a <b>loop invariant<\/b>: Every edge <b>e<\/b> that is added into tree <b>T<\/b> by Kruskal&#39;s algorithm is part of the <b>MST<\/b>.<\/p><br><p>At the start of Kruskal&#39;s main loop, <b>T = {}<\/b> is always part of <b>MST<\/b> by definition.<\/p><br><p>Kruskal&#39;s has a special cycle check in its main loop (using <a href=\".\/ufds\"><u>UFDS<\/u><\/a> data structure) and only add an edge <b>e<\/b> into <b>T<\/b> if it will never form a cycle w.r.t. the previously selected edges.<\/p><br><p>At the end of the main loop, Kruskal&#39;s can only select <b>V<\/b>-1 edges from a connected undirected weighted graph <b>G<\/b> without having any cycle. This implies that Kruskal&#39;s produces a Spanning Tree.<\/p><br><p>On the default example, notice that after taking the first 2 edges: 0-1 and 0-3, in that order, Kruskal&#39;s <b>cannot<\/b> take edge 1-3 as it will cause a cycle 0-1-3-0. Kruskal&#39;s then take edge 0-2 but it cannot take edge 2-3 as it will cause cycle 0-2-3-0.<\/p>","title":"Short Proof of Correctness - 1"},{"id":270,"category":"mst","order":5,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-04 06:29:53","updated_at":"2022-01-30 13:47:54","section":47,"code":"$(\"#kruskals\").addClass(\"menu-highlighted\");\nloadGraph({\n  'vl': {\n    0: { \"x\": 50, \"y\": 50 },\n    1: { \"x\": 250, \"y\": 50 },\n    2: { \"x\": 50, \"y\": 250 },\n    3: { \"x\": 250, \"y\": 250 }\n  },\n  'el': {\n    0: { \"u\": 0, \"v\": 1, \"w\": 1 },\n    1: { \"u\": 0, \"v\": 2, \"w\": 2 },\n    2: { \"u\": 0, \"v\": 3, \"w\": 1 },\n    3: { \"u\": 1, \"v\": 3, \"w\": 1 },\n    4: { \"u\": 2, \"v\": 3, \"w\": 3 }\n  }\n});","section_order":4,"value":"4-5","text":"<p>We have seen in the previous slide that Kruskal&#39;s algorithm will produce a tree <b>T<\/b> that is a Spanning Tree (ST) when it stops. But is it the minimum ST, i.e., the <b>MST<\/b>?<\/p><br><p>To prove this, we need to recall that <b>before<\/b> running Kruskal&#39;s main loop, we have already sort the edges in non-decreasing weight, i.e., the latter edges will have equal or <b>larger<\/b> weight than the earlier edges.<\/p>","title":"Short Proof of Correctness - 2"},{"id":271,"category":"mst","order":6,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-04 06:49:34","updated_at":"2022-01-30 13:48:05","section":47,"code":"$(\"#kruskals\").addClass(\"menu-highlighted\");\nloadGraph({\n  'vl': {\n    0: { \"x\": 50, \"y\": 50 },\n    1: { \"x\": 250, \"y\": 50 },\n    2: { \"x\": 50, \"y\": 250 },\n    3: { \"x\": 250, \"y\": 250 }\n  },\n  'el': {\n    0: { \"u\": 0, \"v\": 1, \"w\": 1 },\n    1: { \"u\": 0, \"v\": 2, \"w\": 2 },\n    2: { \"u\": 0, \"v\": 3, \"w\": 1 },\n    3: { \"u\": 1, \"v\": 3, \"w\": 1 },\n    4: { \"u\": 2, \"v\": 3, \"w\": 3 }\n  }\n});","section_order":4,"value":"4-6","text":"<p>At the start of every loop, <b>T<\/b> is always part of MST.<\/p><br><p>If Kruskal&#39;s only add a legal edge <b>e<\/b> (that will not cause cycle w.r.t. the edges that have been taken earlier) with <b>min cost<\/b>, then we can be sure that <b>w(T U e) \u2264 w(T U any other unprocessed edge e&#39; that does not form cycle)<\/b> (by virtue that Kruskal&#39;s has sorted the edges, so <b>w(e) \u2264 w(e&#39;)<\/b>).<\/p><br><p>Therefore, at the end of the loop, the Spanning Tree <b>T<\/b> must have minimal overall weight <b>w(T)<\/b>, so <b>T<\/b> is the final MST.<\/p><br><p>On the default example, notice that after taking the first 2 edges: 0-1 and 0-3, in that order, and ignoring edge 1-3 as it will cause a cycle 0-1-3-0, we can safely take the next smallest legal edge 0-2 (with weight 2) as taking any other legal edge (e.g., edge 2-3 with <b>larger<\/b> weight 3) will either create <b>another<\/b> MST with equal weight (not in this example) or <b>another<\/b> ST that is not minimum (which is this example).<\/p>","title":"Short Proof of Correctness - 3"},{"id":272,"category":"mst","order":7,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-04 06:56:37","updated_at":"2022-01-30 13:48:13","section":47,"code":"$(\"#kruskals\").addClass(\"menu-highlighted\");","section_order":4,"value":"4-7","text":"<p>There are two parts of Kruskal&#39;s algorithm: Sorting and the Kruskal&#39;s main loop.<\/p><br><p>The sorting of edges is easy. We just store the graph using <b>Edge List<\/b> <a href=\".\/graphds\"><u>data structure<\/u><\/a> and sort <b>E<\/b> edges using any O(<b>E<\/b> log <b>E<\/b>) = O(<b>E<\/b> log <b>V<\/b>) <a href=\".\/sorting\"><u>sorting algorithm<\/u><\/a> (or just use C++\/Python\/Java sorting library routine) by non-decreasing weight, smaller vertex number, higher vertex number. This O(<b>E<\/b> log <b>V<\/b>) is the bottleneck part of Kruskal&#39;s algorithm as the second part is actually lighter, see below.<\/p><br><p>Kruskal&#39;s main loop can be easily implemented using <a href=\".\/ufds\"><u>Union-Find Disjoint Sets<\/u><\/a> data structure. We use <b>IsSameSet(u, v)<\/b> to test if taking edge <b>e<\/b> with endpoints <b>u<\/b> and <b>v<\/b> will cause a cycle (same connected component -- there is another path in the subtree that can connect <b>u<\/b> to <b>v<\/b>, thus adding edge <b>(u, v)<\/b> will cause a cycle) or not. If <b>IsSameSet(u, v)<\/b> returns false, we greedily take this next smallest and legal edge <b>e<\/b> and call <b>UnionSet(u, v)<\/b> to prevent future cycles involving this edge. This part runs in O(<b>E<\/b>) as we assume UFDS <b>IsSameSet(u, v)<\/b> and <b>UnionSet(u, v)<\/b> operations run in O(<b>1<\/b>) for a relatively small graph.<\/p>","title":"Implementation Sketch"},{"id":48,"category":"mst","order":5,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:06:27","updated_at":"2022-01-30 13:49:36","section":-1,"code":"$(\"#prims\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"5","text":"<p><b>Prim&#39;s algorithm<\/b>: Another O(<b>E<\/b> log <b>V<\/b>) greedy MST algorithm that grows a Minimum Spanning Tree from a starting source vertex until it spans the entire graph.<\/p><br><p>Prim&#39;s requires a Priority Queue data structure (usually implemented using <a href=\".\/heap\"><u>Binary Heap<\/u><\/a> but we can also use <a href=\".\/avl\"><u>Balanced Binary Search Tree<\/u><\/a> too) to dynamically order the currently considered edges based on non-decreasing weight, an <a href=\".\/graphds\"><u>Adjacency List data structure<\/u><\/a> for fast neighbor enumeration of a vertex, and a Boolean array (<a href=\".\/hashtable?slide=2-2\"><u>a Direct Addressing Table<\/u><\/a>) to help in checking cycle.<\/p><br><p>Another name of Prim&#39;s algorithm is Jarnik-Prim&#39;s algorithm.<\/p>","title":"Prim&#39;s Algorithm"},{"id":273,"category":"mst","order":1,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-04 07:07:41","updated_at":"2022-01-30 13:49:46","section":48,"code":"$(\"#prims\").click().addClass(\"menu-highlighted\");\nloadGraph({\n  'vl': {\n    0: { \"x\": 50, \"y\": 50 },\n    1: { \"x\": 250, \"y\": 50 },\n    2: { \"x\": 50, \"y\": 250 },\n    3: { \"x\": 250, \"y\": 250 }\n  },\n  'el': {\n    0: { \"u\": 0, \"v\": 1, \"w\": 1 },\n    1: { \"u\": 0, \"v\": 2, \"w\": 2 },\n    2: { \"u\": 0, \"v\": 3, \"w\": 1 },\n    3: { \"u\": 1, \"v\": 3, \"w\": 1 },\n    4: { \"u\": 2, \"v\": 3, \"w\": 3 }\n  }\n});","section_order":5,"value":"5-1","text":"<p>Prim&#39;s algorithm starts from a designated source vertex <b>s<\/b> (usually vertex 0) and enqueues all edges incident to <b>s<\/b> into a Priority Queue (PQ) according to non-decreasing weight, and if ties, by increasing vertex number (of the neighboring vertex number). Then it will repeatedly do the following greedy steps: If the vertex <b>v<\/b> of the front-most edge pair information <b>e: (w, v)<\/b> in the PQ has <b>not<\/b> been visited, it means that we can greedily extends the tree <b>T<\/b> to include vertex <b>v<\/b> and enqueue edges connected to <b>v<\/b> into the PQ, otherwise we discard edge <b>e<\/b> (because Prim&#39;s grows one spanning tree from <b>s<\/b>, the fact that <b>v<\/b> is already visited implies that there is another path from <b>s<\/b> to <b>v<\/b> and adding this edge will cause a cycle).<\/p><br><p>Without further ado, let&#39;s try <span class=\"slide-actions\" onclick=\"doButtonAction31()\">Prim(1)<\/span> on the default example graph (that has three edges with the same weight). That&#39;s it, we start Prim&#39;s algorithm from source vertex <b>s = 1<\/b>. Go through this animated example first before continuing.<\/p>","title":"The Basic Idea"},{"id":274,"category":"mst","order":2,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-04 07:17:03","updated_at":"2022-01-30 13:49:56","section":48,"code":"$(\"#prims\").click().addClass(\"menu-highlighted\");\nloadGraph({\n  'vl': {\n    0: { \"x\": 50, \"y\": 50 },\n    1: { \"x\": 250, \"y\": 50 },\n    2: { \"x\": 50, \"y\": 250 },\n    3: { \"x\": 250, \"y\": 250 }\n  },\n  'el': {\n    0: { \"u\": 0, \"v\": 1, \"w\": 1 },\n    1: { \"u\": 0, \"v\": 2, \"w\": 2 },\n    2: { \"u\": 0, \"v\": 3, \"w\": 1 },\n    3: { \"u\": 1, \"v\": 3, \"w\": 1 },\n    4: { \"u\": 2, \"v\": 3, \"w\": 3 }\n  }\n});","section_order":5,"value":"5-2","text":"<p>Prim&#39;s algorithm is a <b>Greedy Algorithm<\/b> because at each step of its main loop, it always try to select the next valid edge <b>e<\/b> with minimal weight (that is greedy!).<\/p><br><p>To convince us that Prim&#39;s algorithm is correct, let&#39;s go through the following simple proof: Let <b>T<\/b> be the spanning tree of graph <b>G<\/b> generated by Prim&#39;s algorithm and <b>T*<\/b> be the spanning tree of <b>G<\/b> that is known to have minimal cost, i.e. <b>T*<\/b> is the <b>MST<\/b>.<\/p><br><p>If <b>T == T*<\/b>, that&#39;s it, Prim&#39;s algorithm produces exactly the same <b>MST<\/b> as <b>T*<\/b>, we are done.<\/p><br><p>But if <b>T != T*<\/b>...<\/p>","title":"Short Proof of Correctness - Part 1"},{"id":275,"category":"mst","order":3,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-04 07:17:40","updated_at":"2022-01-30 13:50:04","section":48,"code":"$(\"#prims\").click().addClass(\"menu-highlighted\");\nloadGraph({\n  'vl': {\n    0: { \"x\": 50, \"y\": 50 },\n    1: { \"x\": 250, \"y\": 50 },\n    2: { \"x\": 50, \"y\": 250 },\n    3: { \"x\": 250, \"y\": 250 }\n  },\n  'el': {\n    0: { \"u\": 0, \"v\": 1, \"w\": 1 },\n    1: { \"u\": 0, \"v\": 2, \"w\": 2 },\n    2: { \"u\": 0, \"v\": 3, \"w\": 1 },\n    3: { \"u\": 1, \"v\": 3, \"w\": 1 },\n    4: { \"u\": 2, \"v\": 3, \"w\": 3 }\n  }\n});","section_order":5,"value":"5-3","text":"<p>Assume that on the default example, <b>T = {0-1, 0-3, 0-2}<\/b> but <b>T* = {0-1, 1-3, 0-2}<\/b> instead.<\/p><br><p>Let <b>e<sub>k<\/sub> = (u, v)<\/b> be the first edge chosen by Prim&#39;s Algorithm at the <b>k<\/b>-th iteration that is not in <b>T*<\/b> (on the default example, <b>k = 2<\/b>, <b>e<sub>2<\/sub> = (0, 3)<\/b>, note that <b>(0, 3)<\/b> is not in <b>T*<\/b>).<\/p><br><p>Let <b>P<\/b> be the path from <b>u<\/b> to <b>v<\/b> in <b>T*<\/b>, and let <b>e*<\/b> be an edge in <b>P<\/b> such that one endpoint is in the tree generated at the (<b>k<\/b>\u22121)-th iteration of Prim&#39;s algorithm and the other is not (on the default example, <b>P = 0-1-3<\/b> and <b>e* = (1, 3)<\/b>, note that vertex <b>1<\/b> is inside <b>T<\/b> at first iteration <b>k = 1<\/b>).<\/p>","title":"If T != T*, Part 1"},{"id":276,"category":"mst","order":4,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-04 07:17:57","updated_at":"2022-01-30 13:50:15","section":48,"code":"$(\"#prims\").click().addClass(\"menu-highlighted\");\nloadGraph({\n  'vl': {\n    0: { \"x\": 50, \"y\": 50 },\n    1: { \"x\": 250, \"y\": 50 },\n    2: { \"x\": 50, \"y\": 250 },\n    3: { \"x\": 250, \"y\": 250 }\n  },\n  'el': {\n    0: { \"u\": 0, \"v\": 1, \"w\": 1 },\n    1: { \"u\": 0, \"v\": 2, \"w\": 2 },\n    2: { \"u\": 0, \"v\": 3, \"w\": 1 },\n    3: { \"u\": 1, \"v\": 3, \"w\": 1 },\n    4: { \"u\": 2, \"v\": 3, \"w\": 3 }\n  }\n});","section_order":5,"value":"5-4","text":"<p>If the weight of <b>e*<\/b> is less than the weight of <b>e<sub>k<\/sub><\/b>, then Prim&#39;s algorithm would have chosen <b>e*<\/b> on its <b>k<\/b>-th iteration as that is how Prim&#39;s algorithm works.<\/p><br><p>So, it is certain that <b>w(e*) \u2265 w(e<sub>k<\/sub>)<\/b>.<br>(on the example graph, <b>e* = (1, 3)<\/b> has weight 1 and <b>e<sub>k<\/sub> = (0, 3)<\/b> also has weight 1).<\/p><br><p>When weight <b>e*<\/b> is = weight <b>e<sub>k<\/sub><\/b>, the choice between the <b>e*<\/b> or <b>e<sub>k<\/sub><\/b> is actually arbitrary. And whether the weight of <b>e*<\/b> is \u2265 weight of <b>e<sub>k<\/sub><\/b>, <b>e*<\/b> can always be substituted with <b>e<sub>k<\/sub><\/b> while preserving minimal total weight of <b>T*<\/b>. (on the example graph, when we replace <b>e* = (1, 3)<\/b> with <b>e<sub>k<\/sub> = (0, 3)<\/b>, we manage to transform <b>T*<\/b> into <b>T<\/b>).<\/p>","title":"If T != T*, Part 2"},{"id":277,"category":"mst","order":5,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-04 07:43:07","updated_at":"2022-01-30 13:50:27","section":48,"code":"$(\"#prims\").click().addClass(\"menu-highlighted\");\nloadGraph({\n  'vl': {\n    0: { \"x\": 50, \"y\": 50 },\n    1: { \"x\": 250, \"y\": 50 },\n    2: { \"x\": 50, \"y\": 250 },\n    3: { \"x\": 250, \"y\": 250 }\n  },\n  'el': {\n    0: { \"u\": 0, \"v\": 1, \"w\": 1 },\n    1: { \"u\": 0, \"v\": 2, \"w\": 2 },\n    2: { \"u\": 0, \"v\": 3, \"w\": 1 },\n    3: { \"u\": 1, \"v\": 3, \"w\": 1 },\n    4: { \"u\": 2, \"v\": 3, \"w\": 3 }\n  }\n});","section_order":5,"value":"5-5","text":"<p>But if <b>T != T*<\/b>... (continued)<\/p><br><p>We can repeat the substitution process outlined earlier repeatedly until <b>T* = T<\/b> and thereby we have shown that the spanning tree generated by any instance of Prim&#39;s algorithm (from any source vertex <b>s<\/b>) is an MST as whatever the optimal MST is, it can be transformed to the output of Prim&#39;s algorithm.<\/p>","title":"Short Proof of Correctness - Part 2"},{"id":278,"category":"mst","order":6,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-04 07:45:25","updated_at":"2022-01-30 13:50:35","section":48,"code":"$(\"#prims\").click().addClass(\"menu-highlighted\");","section_order":5,"value":"5-6","text":"<p>We can easily implement Prim&#39;s algorithm with two well-known data structures:<\/p><ol><li>A Priority Queue PQ (<a href=\".\/heap\"><u>Binary Heap<\/u><\/a> inside C++ STL priority_queue\/Python heapq\/Java PriorityQueue or <a href=\".\/avl\"><u>Balanced BST<\/u><\/a> inside C++ STL set\/Java TreeSet), and<\/li><li>A Boolean array of size <b>V<\/b>, essentially a <a href=\".\/hashtable?slide=2-2\"><u>Direct Addressing Table<\/u><\/a> (to decide if a vertex has been taken or not, i.e., in the same connected component as the source vertex <b>s<\/b> or not).<\/li><\/ol><p>With these, we can run Prim&#39;s Algorithm in O(<b>E<\/b> log <b>V<\/b>) because we process each edge once and each time, we call <b>Insert((w, v))<\/b> and <b>(w, v) = ExtractMax()<\/b> from a PQ in O(log <b>E<\/b>) = O(log <b>V<sup>2<\/sup><\/b>) = O(2 log <b>V<\/b>) = O(log <b>V<\/b>). As there are <b>E<\/b> edges, Prim&#39;s Algorithm runs in O(<b>E<\/b> log <b>V<\/b>).<\/p>","title":"Implementation Sketch"},{"id":282,"category":"mst","order":6,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-04 08:06:25","updated_at":"2023-11-09 08:53:25","section":-1,"code":"","section_order":-1,"value":"6","text":"<input class=\"mcq-answer\" id=\"mcq-answer-12\" value=\"55\" hidden><p>Quiz: <b>Having seen both Kruskal's and Prim's Algorithms, which one is the better MST algorithm?<\/b><\/p><form><input type=\"radio\" name=\"mcq-12-choice\" value=\"55\"> It Depends<br><input type=\"radio\" name=\"mcq-12-choice\" value=\"54\"> Kruskal's Algorithm<br><input type=\"radio\" name=\"mcq-12-choice\" value=\"53\"> Prim's Algorithm<br><\/form><button class=\"mcq-submit\" id=\"submit-12\">Submit<\/button> <span id=\"answer-status-12\"><\/span><br><br><p>Discussion: Why?<\/p>","title":"Poll"},{"id":409,"category":"mst","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-18 06:14:04","updated_at":"2023-11-09 08:53:25","section":282,"code":"","section_order":6,"value":"6-1","text":"<p>If we only need to solve <i>basic<\/i> MST problem, then the choice of Kruskal&#39;s or Prim&#39;s algorithm is arbitrary, as both are asymptotically equal: O(<b>E<\/b> log <b>V<\/b>).<\/p><br><p>However, there are MST problem variants where one is better than the other (see the next few slides).<\/p>","title":"The Answer"},{"id":224,"category":"mst","order":7,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-04-16 17:26:56","updated_at":"2023-11-09 08:53:27","section":-1,"code":"","section_order":-1,"value":"7","text":"<p>You have reached the end of the basic stuffs of this Min(imum) Spanning Tree graph problem and its two classic algorithms: Kruskal&#39;s and Prim&#39;s (there are others, like another O(E log V) <a href=\"https:\/\/en.wikipedia.org\/wiki\/Bor%C5%AFvka%27s_algorithm\" target=\"_blank\"><u>Boruvka&#39;s<\/u><\/a> algorithm, but not discussed in this visualization). We encourage you to explore further in the <b>Exploration Mode<\/b>.<\/p><br><p>However, the harder MST problems can be (much) more challenging that its basic version.<\/p><br><p>Once you have (roughly) mastered this MST topic, we encourage you to study more on harder graph problems where MST is used as a component, e.g., approximation algorithm for NP-hard <a href=\".\/tsp\"><u>(Metric No-Repeat) TSP<\/u><\/a> and <a href=\".\/steinertree\"><u>Steiner Tree<\/u><\/a> problems.<\/p>","title":"Extras"},{"id":410,"category":"mst","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-18 06:15:54","updated_at":"2023-11-09 08:53:29","section":224,"code":"","section_order":7,"value":"7-1","text":"<p>We write a few MST problem variants in the <a href=\"https:\/\/cpbook.net\" target=\"_blank\"><u>Competitive Programming book<\/u><\/a>.<\/p><ol><li>Max(imum) Spanning Tree,<\/li><li>Min(imum) Spanning Subgraph,<\/li><li>Min(imum) Spanning Forest,<\/li><li>Second Best Spanning Tree,<\/li><li>Minimax (Maximin) Path Problem, etc<\/li><\/ol><p>Advertisement: Buy CP book to study more about these variants and see that sometimes Kruskal&#39;s is better and sometimes Prim&#39;s is better at some of these variants.<\/p>","title":"MST Problem Variants"},{"id":279,"category":"mst","order":2,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-04 07:53:17","updated_at":"2023-11-09 08:53:31","section":224,"code":"","section_order":7,"value":"7-2","text":"<p>For a few more challenging questions about this MST problem and\/or Kruskal&#39;s\/Prim&#39;s Algorithms, please practice on <a href=\"https:\/\/visualgo.net\/training?diff=Medium&amp;n=10&amp;tl=0&amp;module=mst\"><u>MST<\/u><\/a> training module (no login is required, but on medium difficulty setting only).<\/p><br><p>However, for NUS students, you should login to officially clear this module and such achievement will be recorded in your user account.<\/p>","title":"Online Quiz"},{"id":280,"category":"mst","order":3,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-04 07:55:18","updated_at":"2023-11-09 08:53:34","section":224,"code":"","section_order":7,"value":"7-3","text":"<p>This MST problem can be much more challenging than this basic form. Therefore we encourage you to try the following two ACM ICPC contest problems about MST: <a href=\"https:\/\/uva.onlinejudge.org\/external\/12\/1234.pdf\" title=\"\" target=\"_blank\"><u>UVa 01234 - RACING<\/u><\/a> and <a href=\"https:\/\/open.kattis.com\/problems\/arcticnetwork\" title=\"\" target=\"_blank\"><u>Kattis - arcticnetwork<\/u><\/a>.<\/p><br><p>Try them to consolidate and improve your understanding about this graph problem.<\/p><br><p>You are allowed to use\/modify our implementation code for Kruskal&#39;s\/Prim&#39;s Algorithms:<br><a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/mst\/kruskal.cpp\" target=\"_blank\"><u>kruskal.cpp<\/u><\/a> | <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/mst\/kruskal.py\" target=\"_blank\"><u>py<\/u><\/a> | <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/mst\/kruskal.java\" target=\"_blank\"><u>java<\/u><\/a> | <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/mst\/kruskal.ml\" target=\"_blank\"><u>ml<\/u><\/a><br><a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/mst\/prim.cpp\" target=\"_blank\"><u>prim.cpp<\/u><\/a> | <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/mst\/prim.py\" target=\"_blank\"><u>py<\/u><\/a> | <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/mst\/prim.java\" target=\"_blank\"><u>java<\/u><\/a> | <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/mst\/prim.ml\" target=\"_blank\"><u>ml<\/u><\/a><br><\/p>","title":"Online Judge Exercises"},{"id":281,"category":"mst","order":4,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-04 07:55:44","updated_at":"2023-11-09 08:53:36","section":224,"code":"","section_order":7,"value":"7-4","text":"<p>For <a href=\"https:\/\/uva.onlinejudge.org\/external\/12\/1234.pdf\" title=\"\" target=\"_blank\"><u>UVa 01234 - RACING<\/u><\/a>, think of <b>max<\/b> instead of <b>min<\/b>.<\/p><br><p>For <a href=\"https:\/\/open.kattis.com\/problems\/arcticnetwork\" title=\"\" target=\"_blank\"><u>Kattis - arcticnetwork<\/u><\/a>, look up the discussion of Minimum Spanning Forest variant of MST problem in Competitive Programming textbook.<\/p>","title":"Discussion"}];
      const numSlides = lectureIds.length;
      var sectorJunction12Section = 0, sectorJunction12Slide = 0;
      var sectorJunction23Section = 0, sectorJunction23Slide = 0;
      var sector1Count = 0, sector2Count = 0, sector3Count = 0;
      const sectorLength = Math.floor(numSlides / 3);
      function createELectureTimelineDisplay() {
        for (let j = 0; j < numSlides; ++j) {
          const currLecture = lectureIds[j].value;
          if (currLecture.includes('-')) {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-slide" slideNo=${lectureIds[j].value}></div>`)
            );
          } else {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-checkpoint" slideNo=${lectureIds[j].value}></div>`)
            );
          }
        }
      }

      function setSectorJunctionInfo() {
          //setting the sector junction slide numbers
          const j12 = sectorLength !== 0 ? (sectorLength - 1): 0;
          const j23 = sectorLength !== 0 ? (2 * sectorLength - 1) : 0;

          const sectorJunction12 = lectureIds[j12].value.split('-');
          sectorJunction12Section = parseInt(sectorJunction12[0]);
          sectorJunction12Slide = sectorJunction12.length > 1 ? parseInt(sectorJunction12[1]) : sectorJunction12Slide;

          const sectorJunction23 = lectureIds[j23].value.split('-');
          sectorJunction23Section = parseInt(sectorJunction23[0]);
          sectorJunction23Slide = sectorJunction23.length > 1 ? parseInt(sectorJunction23[1]) : sectorJunction23Slide;
      }

      function runSlide(slide) { // Steven's patch on 28 Jan 2022: Properly remove slide 99, 99-1, 99-2, 99-3, integrate with the earlier slides
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 3 + "%)");
          
        }
        if (slide == '1-1') {
          $("#e-lecture").html("slide " + slide + " (" + 7 + "%)");
          
        }
        if (slide == '1-2') {
          $("#e-lecture").html("slide " + slide + " (" + 10 + "%)");
          
        }
        if (slide == '1-3') {
          $("#e-lecture").html("slide " + slide + " (" + 14 + "%)");
          
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 17 + "%)");
          
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 21 + "%)");
          $("#draw").addClass("menu-highlighted");
$("#examples").click().addClass("menu-highlighted");
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 25 + "%)");
          $("#kruskals").addClass("menu-highlighted");
        }
        if (slide == '4-1') {
          $("#e-lecture").html("slide " + slide + " (" + 28 + "%)");
          $("#kruskals").addClass("menu-highlighted");
loadGraph({
  'vl': {
    0: { "x": 50, "y": 50 },
    1: { "x": 250, "y": 50 },
    2: { "x": 50, "y": 250 },
    3: { "x": 250, "y": 250 }
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 2 },
    2: { "u": 0, "v": 3, "w": 1 },
    3: { "u": 1, "v": 3, "w": 1 },
    4: { "u": 2, "v": 3, "w": 3 }
  }
});
        }
        if (slide == '4-2') {
          $("#e-lecture").html("slide " + slide + " (" + 32 + "%)");
          $("#kruskals").addClass("menu-highlighted");
loadGraph({
  'vl': {
    0: { "x": 50, "y": 50 },
    1: { "x": 250, "y": 50 },
    2: { "x": 50, "y": 250 },
    3: { "x": 250, "y": 250 }
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 2 },
    2: { "u": 0, "v": 3, "w": 1 },
    3: { "u": 1, "v": 3, "w": 1 },
    4: { "u": 2, "v": 3, "w": 3 }
  }
});
        }
        if (slide == '4-3') {
          $("#e-lecture").html("slide " + slide + " (" + 35 + "%)");
          $("#kruskals").addClass("menu-highlighted");
loadGraph({
  'vl': {
    0: { "x": 50, "y": 50 },
    1: { "x": 250, "y": 50 },
    2: { "x": 50, "y": 250 },
    3: { "x": 250, "y": 250 }
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 2 },
    2: { "u": 0, "v": 3, "w": 1 },
    3: { "u": 1, "v": 3, "w": 1 },
    4: { "u": 2, "v": 3, "w": 3 }
  }
});
        }
        if (slide == '4-4') {
          $("#e-lecture").html("slide " + slide + " (" + 39 + "%)");
          $("#kruskals").addClass("menu-highlighted");
loadGraph({
  'vl': {
    0: { "x": 50, "y": 50 },
    1: { "x": 250, "y": 50 },
    2: { "x": 50, "y": 250 },
    3: { "x": 250, "y": 250 }
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 2 },
    2: { "u": 0, "v": 3, "w": 1 },
    3: { "u": 1, "v": 3, "w": 1 },
    4: { "u": 2, "v": 3, "w": 3 }
  }
});
        }
        if (slide == '4-5') {
          $("#e-lecture").html("slide " + slide + " (" + 42 + "%)");
          $("#kruskals").addClass("menu-highlighted");
loadGraph({
  'vl': {
    0: { "x": 50, "y": 50 },
    1: { "x": 250, "y": 50 },
    2: { "x": 50, "y": 250 },
    3: { "x": 250, "y": 250 }
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 2 },
    2: { "u": 0, "v": 3, "w": 1 },
    3: { "u": 1, "v": 3, "w": 1 },
    4: { "u": 2, "v": 3, "w": 3 }
  }
});
        }
        if (slide == '4-6') {
          $("#e-lecture").html("slide " + slide + " (" + 46 + "%)");
          $("#kruskals").addClass("menu-highlighted");
loadGraph({
  'vl': {
    0: { "x": 50, "y": 50 },
    1: { "x": 250, "y": 50 },
    2: { "x": 50, "y": 250 },
    3: { "x": 250, "y": 250 }
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 2 },
    2: { "u": 0, "v": 3, "w": 1 },
    3: { "u": 1, "v": 3, "w": 1 },
    4: { "u": 2, "v": 3, "w": 3 }
  }
});
        }
        if (slide == '4-7') {
          $("#e-lecture").html("slide " + slide + " (" + 50 + "%)");
          $("#kruskals").addClass("menu-highlighted");
        }
        if (slide == '5') {
          $("#e-lecture").html("slide " + slide + " (" + 53 + "%)");
          $("#prims").click().addClass("menu-highlighted");
        }
        if (slide == '5-1') {
          $("#e-lecture").html("slide " + slide + " (" + 57 + "%)");
          $("#prims").click().addClass("menu-highlighted");
loadGraph({
  'vl': {
    0: { "x": 50, "y": 50 },
    1: { "x": 250, "y": 50 },
    2: { "x": 50, "y": 250 },
    3: { "x": 250, "y": 250 }
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 2 },
    2: { "u": 0, "v": 3, "w": 1 },
    3: { "u": 1, "v": 3, "w": 1 },
    4: { "u": 2, "v": 3, "w": 3 }
  }
});
        }
        if (slide == '5-2') {
          $("#e-lecture").html("slide " + slide + " (" + 60 + "%)");
          $("#prims").click().addClass("menu-highlighted");
loadGraph({
  'vl': {
    0: { "x": 50, "y": 50 },
    1: { "x": 250, "y": 50 },
    2: { "x": 50, "y": 250 },
    3: { "x": 250, "y": 250 }
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 2 },
    2: { "u": 0, "v": 3, "w": 1 },
    3: { "u": 1, "v": 3, "w": 1 },
    4: { "u": 2, "v": 3, "w": 3 }
  }
});
        }
        if (slide == '5-3') {
          $("#e-lecture").html("slide " + slide + " (" + 64 + "%)");
          $("#prims").click().addClass("menu-highlighted");
loadGraph({
  'vl': {
    0: { "x": 50, "y": 50 },
    1: { "x": 250, "y": 50 },
    2: { "x": 50, "y": 250 },
    3: { "x": 250, "y": 250 }
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 2 },
    2: { "u": 0, "v": 3, "w": 1 },
    3: { "u": 1, "v": 3, "w": 1 },
    4: { "u": 2, "v": 3, "w": 3 }
  }
});
        }
        if (slide == '5-4') {
          $("#e-lecture").html("slide " + slide + " (" + 67 + "%)");
          $("#prims").click().addClass("menu-highlighted");
loadGraph({
  'vl': {
    0: { "x": 50, "y": 50 },
    1: { "x": 250, "y": 50 },
    2: { "x": 50, "y": 250 },
    3: { "x": 250, "y": 250 }
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 2 },
    2: { "u": 0, "v": 3, "w": 1 },
    3: { "u": 1, "v": 3, "w": 1 },
    4: { "u": 2, "v": 3, "w": 3 }
  }
});
        }
        if (slide == '5-5') {
          $("#e-lecture").html("slide " + slide + " (" + 71 + "%)");
          $("#prims").click().addClass("menu-highlighted");
loadGraph({
  'vl': {
    0: { "x": 50, "y": 50 },
    1: { "x": 250, "y": 50 },
    2: { "x": 50, "y": 250 },
    3: { "x": 250, "y": 250 }
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 2 },
    2: { "u": 0, "v": 3, "w": 1 },
    3: { "u": 1, "v": 3, "w": 1 },
    4: { "u": 2, "v": 3, "w": 3 }
  }
});
        }
        if (slide == '5-6') {
          $("#e-lecture").html("slide " + slide + " (" + 75 + "%)");
          $("#prims").click().addClass("menu-highlighted");
        }
        if (slide == '6') {
          $("#e-lecture").html("slide " + slide + " (" + 78 + "%)");
          
        }
        if (slide == '6-1') {
          $("#e-lecture").html("slide " + slide + " (" + 82 + "%)");
          
        }
        if (slide == '7') {
          $("#e-lecture").html("slide " + slide + " (" + 85 + "%)");
          
        }
        if (slide == '7-1') {
          $("#e-lecture").html("slide " + slide + " (" + 89 + "%)");
          
        }
        if (slide == '7-2') {
          $("#e-lecture").html("slide " + slide + " (" + 92 + "%)");
          
        }
        if (slide == '7-3') {
          $("#e-lecture").html("slide " + slide + " (" + 96 + "%)");
          
        }
        if (slide == '7-4') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
        }
        clearTimeout(currSlideTimer);
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };
      var slideTimeline = {};

      //reads all visited slides in the slideTimeline and gives them their sector color
      function setVisitedSlideTimelineColors() {
        for(const [sectionNo, visitedSlides] of Object.entries(slideTimeline)) {
          const visitedSlides = slideTimeline[sectionNo];
          for(const visitedSlideNo of visitedSlides) {
            setSlideTimelineColor(visitedSlideNo);
          }
        }
      }

      //only called on load if there is nothing in session
      function setTimelineForCompletedSector(sectorNum) {
        let len = sectorLength;
        switch (sectorNum) {
          case 1 : len = sectorLength; break;
          case 2 : len = 2 * sectorLength; break;
          default: len = numSlides;
        }
        let i = 0;
        switch (sectorNum) {
          case 1 : i = 0; break;
          case 2 : i = sectorLength; break;
          default: i = 2 * sectorLength;
        }
        for (; i < len; i++) {
          saveELectureTimeline(lectureIds[i].value, true);
        }
      }

      function getUserSectorHistory(callback) {
        $.ajax({
          type: 'GET',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            topic: "/mst".substring(1)
          }
        }
        ).done(function (data) {
            if (data.data[0] === 1) {
              setF1SectorColor(1);
              setTimelineForCompletedSector(1);
            }
            if (data.data[1] === 1) {
              setF1SectorColor(2);
              setTimelineForCompletedSector(2);
            }
            if (data.data[2] === 1) {
              setF1SectorColor(3);
              setTimelineForCompletedSector(3);
            }
            callback();
        }).fail(function (data) {
            console.log('get user sector history failed!');
        });
      }

      function getELectureTimelineFromSession() {
        const page = "/mst".substring(1);
        const timelineKey = page + '-slide-timeline';
        const storedTimeline = window.sessionStorage.getItem(timelineKey);
        if (storedTimeline) {
          slideTimeline = JSON.parse(storedTimeline);
        } else {
          return false;
        }
        let slideInfo = [];
        for (const [sectionNum, slides] of Object.entries(slideTimeline)) {
          for (const slide of slides) {
            indicateSlideCompletedUI(slide);
            slideInfo = slide.split('-');
            incrementSectorVisits(parseInt(sectionNum), slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0);
          }
        }
        return true;
      }

      async function initializeELectureTimeline() {
        setSectorJunctionInfo();
        if (!getELectureTimelineFromSession())
          getUserSectorHistory(sectorBasedModeSelection);
        else
          sectorBasedModeSelection();

        createELectureTimelineDisplay();
        setVisitedSlideTimelineColors();
      }

      function setF1SectorColor(sectorNum) {
        $(`[sectorNo="${sectorNum}"]`).css('background', sectorColors[(parseInt(sectorNum) % 3)]);
      }

      function updateSectorInDB(sectorNum) {
        $.ajax({
          type: 'POST',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            section: (sectorNum - 1),
            topic: "/mst".substring(1)
          }
        }
        ).done(function (data) {
            //console.log("Saved the sector " + sectorNum + " as done " + JSON.stringify(data));
        }).fail(function (data) {
            console.log("Setting sector done failed new attempt! "+ JSON.stringify(data));
        });
      }

      //If 87.5% or more of the slides in sector are done
      function setF1SectorCompleted(sectorNum, isInitializationCall) {
        setF1SectorColor(sectorNum);
        //avoid api call on initialization
        if (!isInitializationCall) {
          updateSectorInDB(sectorNum);
          $(`[sectorNo="${sectorNum}"]`).css("animation", "green-pulse 2s 4");
          setTimeout(() => {
            $(`[sectorNo="${sectorNum}"]`).css("animation", "");
          }, 8000);
        }
      }

      function incrementSectorVisits(sectionNum, slideNumWithinSection, isInitializationCall) {
        //updating sector count
        if (sectionNum < sectorJunction12Section
          || (sectionNum === sectorJunction12Section && slideNumWithinSection <= sectorJunction12Slide)) {
          ++sector1Count;
          if (sector1Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(1, isInitializationCall);
        } else if (sectionNum < sectorJunction23Section
          || (sectionNum === sectorJunction23Section && slideNumWithinSection <= sectorJunction23Slide)) {
          ++sector2Count;
          if (sector2Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(2, isInitializationCall);
        } else {
          ++sector3Count;
          if (sector3Count >= Math.ceil(0.875 * (numSlides - 2 * sectorLength)))
            setF1SectorCompleted(3, isInitializationCall);
        }
      }

      function saveELectureTimeline(slideNo, isInitialization) {
        const slideInfo = slideNo.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        if (slideTimeline[sectionNo]) {
          if (!slideTimeline[sectionNo].includes(slideNo)) {
            slideTimeline[sectionNo].push(slideNo);
            const sectionNum = parseInt(sectionNo);
            incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
          }
        } else {
          slideTimeline[sectionNo] = [];
          slideTimeline[sectionNo].push(slideNo);
          const sectionNum = parseInt(sectionNo);
          incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
        }
        setSlideTimelineColor(slideNo);
        indicateSlideCompletedUI(slideNo);
      }

      function saveELectureTimelineToSession() {
        const page = "/mst".substring(1);
        const timelineKey = page + '-slide-timeline';
        window.sessionStorage.setItem(timelineKey, JSON.stringify(slideTimeline));
      }

      function handleTimelineOnRunSlide(slideValue) {
        const slideInfo = slideValue.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        //start timer only if the slide isnt already done
        if (!slideTimeline[sectionNo] || !slideTimeline[sectionNo].includes(slideValue)) {
          const slideTextLength = $('#electure-'+slideValue + " p").text().length + $('#electure-'+slideValue + " li").text().length;
          const CHARS_READ_PER_MS = 0.05; //when fast, 50 characters a second
          //setting max reading time as 10 seconds for around 500 character slide
          const minSlideReadingTime = Math.min(Math.max(2000, (slideTextLength / CHARS_READ_PER_MS) +  + (2000 * $('#electure-'+slideValue + " img").length)), 10000);
          currSlideTimer = setTimeout(() => {
            saveELectureTimeline(slideValue);
          }, minSlideReadingTime);
        }
      }

      function indicateSlideCompletedUI(slide) {
        $('#electure-'+slide).css("box-shadow", "3px 3px 8px green"); //set green shadow for completed slides
        $('#electure-'+slide + ' .electure-read-status').html("&#10004;");
        $('#electure-'+slide + ' .electure-read-status').attr("title", "Slide Completed!");
        $('#electure-'+slide + ' .electure-read-status').css("font-size", "17px");
      }

      function pushState(slideValue) {
        var url = '/en/mst';
        if (typeof slideValue != 'undefined' && slideValue != null) {
          url += '?slide=' + slideValue;
                  }
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5);
        $('#overlay').show();

        $("#e-lecture-timeline").show();
        $("#e-lecture-f1map").show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
        $("#e-lecture-timeline").hide();
        $("#e-lecture-f1map").hide();
        clearTimeout(currSlideTimer);
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      function sectorBasedModeSelection() {
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        //check params are empty and then that all sectors are completed or not
        if (!Object.keys(params).length
          && sector1Count === sectorLength && sector2Count === sectorLength && sector3Count === (numSlides - 2 * sectorLength)) {
            hideOverlay();
        }
        else
          $('#mode-menu a').click();
      }

      $(function() {
        if (isMobileOS() && portraitMatcher.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').show();
          $('#widenDeviceText').hide();
          $('#topbar').css("z-index", 10001);
        } else if (matchMediaNarrow.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').hide();
          $('#widenDeviceText').show();
          $('#topbar').css("z-index", 10001);
        } else {
          $('#rotateDeviceOverlay').hide();
          $('#topbar').css("z-index", "");
        }

        matchMediaNarrow.addEventListener('change', e => {
          //screws up for square device! NEED RESIZE EVENT
          if (e.matches) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').hide();
              $('#widenDeviceText').show();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        portraitMatcher.addEventListener('change', e => {
          if (e.matches && isMobileOS()) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').show();
              $('#widenDeviceText').hide();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        let slide = getUrlParameter('slide');
        if (typeof slide !== undefined && slide != null) {
          cur_slide = slide;
        }
        //do all timeline and slide stuff only if specific params not provided
        if (!Object.keys(params).length || params["slide"]) {
          if (!isMobile()) {
                            $('#mode-menu a').click();
                      }
        }
        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
        $('#electure-1-1 .electure-next').click(function() {
          hidePopup();
          runSlide('1-2');
          pushState('1-2');
        });
        $('#electure-1-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
        $('#electure-1-2 .electure-next').click(function() {
          hidePopup();
          runSlide('1-3');
          pushState('1-3');
        });
        $('#electure-1-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
        $('#electure-1-3 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-1-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-2');
          pushState('1-2');
        });
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-3');
          pushState('1-3');
        });
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-4-1 .electure-next').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-4-2 .electure-next').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
        $('#electure-4-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
        $('#electure-4-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
        $('#electure-4-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
        $('#electure-4-5 .electure-next').click(function() {
          hidePopup();
          runSlide('4-6');
          pushState('4-6');
        });
        $('#electure-4-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
        $('#electure-4-6 .electure-next').click(function() {
          hidePopup();
          runSlide('4-7');
          pushState('4-7');
        });
        $('#electure-4-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
        $('#electure-4-7 .electure-next').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-4-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-6');
          pushState('4-6');
        });
        $('#electure-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
        $('#electure-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-7');
          pushState('4-7');
        });
        $('#electure-5-1 .electure-next').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
        $('#electure-5-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-5-2 .electure-next').click(function() {
          hidePopup();
          runSlide('5-3');
          pushState('5-3');
        });
        $('#electure-5-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
        $('#electure-5-3 .electure-next').click(function() {
          hidePopup();
          runSlide('5-4');
          pushState('5-4');
        });
        $('#electure-5-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
        $('#electure-5-4 .electure-next').click(function() {
          hidePopup();
          runSlide('5-5');
          pushState('5-5');
        });
        $('#electure-5-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-3');
          pushState('5-3');
        });
        $('#electure-5-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-6');
          pushState('5-6');
        });
        $('#electure-5-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-4');
          pushState('5-4');
        });
        $('#electure-5-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-5-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-5');
          pushState('5-5');
        });
        $('#electure-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-6');
          pushState('5-6');
        });
        $('#electure-6-1 .electure-next').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-6-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-7 .electure-next').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-7-1 .electure-next').click(function() {
          hidePopup();
          runSlide('7-2');
          pushState('7-2');
        });
        $('#electure-7-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-7-2 .electure-next').click(function() {
          hidePopup();
          runSlide('7-3');
          pushState('7-3');
        });
        $('#electure-7-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-7-3 .electure-next').click(function() {
          hidePopup();
          runSlide('7-4');
          pushState('7-4');
        });
        $('#electure-7-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-2');
          pushState('7-2');
        });
        $('#electure-7-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-3');
          pushState('7-3');
        });
      });

      function doButtonAction21() {
        URL('https://cpbook.net/code/ch4.zip');
      }
      function doButtonAction30() {
        CUSTOM_ACTION('kruskal');
      }
      function doButtonAction31() {
        CUSTOM_ACTION('prim', 1);
      }

      $('.electure-print').click(() => {
        window.open(`/en/mst/print`);
      });
      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url.html) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}

      // This function will be called everytime 1.0x is changed to 0.5x or vice versa
      function redraw() {}

      $(document).ready(function () {
        setTimeout(function () {
          $('#change-lang-popup').fadeOut('slow')
        }, 5000)
      })
    </script>
<script type="text/javascript">
    var extraCSS = {"prims":"65px","kruskals":"92px","examples":"119px","draw":"146px","vertexnumber":"173px","mediumscale":"200px"};
    var actionsIds = {"mediumscale":{"p":"Visualisation Scale"},"vertexnumber":{"p":"Toggle V. Number for 0.5x","onClick":"toggleVertexNumber()"},"draw":{"p":"Edit Graph","onClick":"drawGraph()"},"examples":{"p":"Example Graphs"},"kruskals":{"p":"Kruskal&#39;s Algorithm","onClick":"kruskals()"},"prims":{"p":"Prim&#39;s Algorithm(s)"}};
    var isOpens = {};
    var len = 6;
    var keys = ["mediumscale","vertexnumber","draw","examples","kruskals","prims"]; 
    for (i = 0; i < len; i++) {
        var actionDetails = keys[i];
        isOpens[actionDetails] = false;
    }
    function openAction(id) {
        hideThirdTiers(id);
        $("." + id).css("bottom", extraCSS[id]);
        if (!isOpens[id]) {
            $('.' + id).fadeIn('fast');
            isOpens[id] = true;
        }
    }
    function closeAction(id) {
        hideThirdTiers(id);
        if (isOpens[id]) {
            $('.' + id).fadeOut('fast');
            $('#' + id + '-err').html("");
            isOpens[id] = false;
        }
    }

    function hideEntireActionsPanel() {
        //hideAllThirdTiers();
                    closeAction('mediumscale');
                    closeAction('vertexnumber');
                    closeAction('draw');
                    closeAction('examples');
                    closeAction('kruskals');
                    closeAction('prims');
                hideActionsPanel();
    }

    function hideThirdTiers(tier1Action) {
        if ("parents" in actionsIds[tier1Action]) {
            for (const secondTierAction of actionsIds[tier1Action]["parents"]) {
                $('#' + secondTierAction + '-third-tier').fadeOut('fast');
            }
        }
    }

    function hideAllThirdTiers() {
        for (const tier1Action in actionsIds) {
            hideThirdTiers(tier1Action);
        }
    }

    function toggleChildExtras(tier1, selectedParentTier2) {
        hideThirdTiers(tier1);
        //this actionId must have childExtras
        var style = extraCSS[tier1];
        $("." + tier1).css("bottom", (parseInt(style.substring(0, style.length - 2)) - 27));
        //fade ins and outs are done on the ID whereas css class is set on the class
        //fade in the third tier of the selected 2nd tier parent
        $('#' + selectedParentTier2 + '-third-tier').fadeIn('fast');

        // //fade out all other third tiers of that 'action'
        // for (const parent of actions[tier1]["parents"]) {
        //     console.log("parent is " + parent + " for " + selectedParentTier2);
        //     if (parent != selectedParentTier2) {
        //         $('#' + parent + '-third-tier').fadeOut('fast');
        //     }
        // }
    }

    function setActionHeightOriginal(tier1Action) {
        $("." + tier1Action).css("bottom", extraCSS[tier1Action]);
    }

            $('#' + 'mediumscale').click(function() {
            openAction('mediumscale');
                                                                            closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('kruskals');
                                                                closeAction('prims');
                                    });
            $('#' + 'vertexnumber').click(function() {
            openAction('vertexnumber');
                                                closeAction('mediumscale');
                                                                                            closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('kruskals');
                                                                closeAction('prims');
                                    });
            $('#' + 'draw').click(function() {
            openAction('draw');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                                            closeAction('examples');
                                                                closeAction('kruskals');
                                                                closeAction('prims');
                                    });
            $('#' + 'examples').click(function() {
            openAction('examples');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                                            closeAction('kruskals');
                                                                closeAction('prims');
                                    });
            $('#' + 'kruskals').click(function() {
            openAction('kruskals');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('examples');
                                                                                            closeAction('prims');
                                    });
            $('#' + 'prims').click(function() {
            openAction('prims');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('kruskals');
                                                                });
    
    //important to have all the input fields in actions menu take an id containing '-input'
    $("[id*='-input']").on("keypress keydown keyup", (event) => {
        event.stopPropagation();
    });
</script>
<script type="text/javascript">
// MST Widget
// original author: Ivan Reinaldo, then maintained by Steven Halim
var scale = false;
var MST = function() {
  var self = this;
  var gw = new GraphWidget();

  var iVL = {};
  var iEL = {};
  var iAL = {}; // special, for Prim's
  this.getiVL = function() {
    return iVL;
  }
  this.getiEL = function() {
    return iEL;
  }
  var amountVertex = 0;
  var amountEdge = 0;

  this.getGraphWidget = function() { return gw; }

  fixJSON = function() {
    amountVertex = 0;
    amountEdge = 0;
    for (var key in iVL) amountVertex++;
    for (var key in iEL) amountEdge++;

    var sortedArray = [];
    for (key in iEL) {
      sortedArray.push(new ObjectTriple(parseInt(iEL[key]["w"]), parseInt(iEL[key]["u"]), parseInt(iEL[key]["v"])));
    }
    sortedArray.sort(ObjectTriple.compare); // sort by increasing w, and if ties, by increasing u, and if still ties, by increasing v

    for (var i = 0; i < sortedArray.length; i++) { // rearrange the keys in iEL based on our custom sort order
      iEL[i]["w"] = sortedArray[i].getFirst();
      iEL[i]["u"] = sortedArray[i].getSecond();
      iEL[i]["v"] = sortedArray[i].getThird();
    }

    for (var key in iVL) iAL[key] = Array();
    for (var key in iEL) { // transform EL to AL (for Prim's)
      iAL[iEL[key]["u"]].push(new ObjectTriple(iEL[key]["v"], iEL[key]["w"], key));
      iAL[iEL[key]["v"]].push(new ObjectTriple(iEL[key]["u"], iEL[key]["w"], key)); // bidirectional
    }
  }

  takeJSON = function(graph) {
    if (graph == null) return;
    graph = JSON.parse(graph);
    iVL = graph["vl"];
    iEL = graph["el"];
    fixJSON();
  }

  statusChecking = function() {
    $("#draw-status p").html("Draw a <b>connected undirected weighted</b> graph, preferably <b>V > 7</b>, <b>minimize edge crossing</b>, and make it <b>challenging for Prim&#39;s/Kruskal&#39;s algorithm</b>");
  }

  warnChecking = function() {
    var warn = "";
    if (currentGraphVisu.amountVertex() >= 17) warn += "Too much vertex on screen, consider drawing smaller graph. ";
    if (warn == "") $("#draw-warn p").html("No Warning");
    else            $("#draw-warn p").html(warn);
  }

  errorChecking = function() {
    var error = "";
    if (currentGraphVisu.amountVertex() == 0) {
      $("#draw-err p").html("Graph cannot be empty. ");
      return;
    }

    if (currentGraphVisu.amountVertex() == 1) {
      $("#draw-err p").html("Graph must contain at least one edge. ");
      return;
    }

    var visited = [];
    var stack = [];
    stack.push(0);
    visited[0] = true;
    while (stack.length > 0) {
      var now = stack.pop();
      for (var key2 in iEL) {
        if (iEL[key2]["u"] == now && !visited[iEL[key2]["v"]]) {
          visited[iEL[key2]["v"]] = true;
          stack.push(+iEL[key2]["v"]);
        }
        if (iEL[key2]["v"] == now && !visited[iEL[key2]["u"]]) {
          visited[iEL[key2]["u"]] = true;
          stack.push(+iEL[key2]["u"]);
        }
      }
    }

    for (var i = 0; i < amountVertex; i++)
      if (!visited[i]) {
        error = error + "Vertex 0 and vertex {i} is not connected. ".replace("{i}", i);
        break;
      }

    if (error == "") $("#draw-err p").html("Graph must contain at least one edge. ");
    else             $("#draw-err p").html(error);
  }

  var intervalID;

  this.startLoop = function() {
    intervalID = setInterval(function() {
      //takeJSON(JSONresult);
      warnChecking();
      errorChecking();
      statusChecking();
    }, 100);
  }

  this.stopLoop = function() {
    clearInterval(intervalID);
  }

  this.draw = function() {
    if ($("#draw-err p").html() != "Graph must contain at least one edge. ")
      return false;
    takeJSON(JSONresult);
    if ($("#submit").is(':checked'))
      this.submit(JSONresult);
    if ($("#copy").is(':checked'))
      window.prompt("Copy to clipboard:", JSONresult);

    fixJSON(); // to re-sort the edges

    gw.removeAll(); 
    graph = createState(iVL, iEL);
    gw.updateGraph(graph, 500);
    return true;
  }

  this.importjson = function(text) {
    takeJSON(text);
    statusChecking();
    graph = createState(iVL, iEL);
    gw.updateGraph(graph, 500);
  }

  



  this.getGraph = function() {
    return {
      'vl': iVL,
      'el': iEL
    };
  }

  this.getV = function() {
    return amountVertex;
  }

  this.kruskal = function(callback) {
    var i, key, totalWeight = 0, cs;
    var stateList = [], sortedArray = [];
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, edgeTraversed = {}, edgeQueued = {};
    var tempUfds = new UfdsHelper();

    if (amountVertex == 0) { // error check, no graph (maybe via empty JSON or faulty db)
      $('#kruskals-err').html("There is no graph to run this on. Please select an example graph first.");
      return false;
    }

    for (key in iVL) tempUfds.insert(key);

    for (key in iEL) {
      edgeQueued[key] = true;
      sortedArray.push(new ObjectPair(parseInt(iEL[key]["w"]), parseInt(key)));
    }
    sortedArray.sort(ObjectPair.compare);

    function sortedArrayToString() {
      var ansStr = "";
      var maxLength = Math.min(sortedArray.length, 9);
      for (var i = 0; i < maxLength; i++) {
        var thisEdgeId = sortedArray[i].getSecond();
        ansStr += "(" + iEL[thisEdgeId]["w"] + ",(" + iEL[thisEdgeId]["u"] + "," + iEL[thisEdgeId]["v"] + "))";
        if (i < (maxLength-1)) ansStr += ", ";
      }
      if (sortedArray.length > 10) ansStr += " ...";
      return ansStr;
    }

    cs = createState(iVL, iEL);
    cs["status"] = "Edges are sorted in increasing order of weight: " + sortedArrayToString() + ".";
    cs["lineNo"] = [1, 2];
    stateList.push(cs);

    numTaken = 0;
    while (sortedArray.length > 0) {
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, edgeQueued);
      cs["status"] = "The remaining edge(s) is/are " + sortedArrayToString() + ".";
      cs["lineNo"] = 3;
      stateList.push(cs);

      var dequeuedEdge = sortedArray.shift();
      var dequeuedEdgeId = dequeuedEdge.getSecond();
      var u = iEL[dequeuedEdgeId]["u"], v = iEL[dequeuedEdgeId]["v"], w = parseInt(iEL[dequeuedEdgeId]["w"]);

      edgeHighlighted[dequeuedEdgeId] = true;
      vertexHighlighted[u] = true;
      vertexHighlighted[v] = true;

      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, edgeQueued);
      cs["status"] = "Checking if a cycle will appear if we add this edge: (" + w + ",(" + u + "," + v + ")).";
      cs["lineNo"] = 4;
      stateList.push(cs);

      var noCycle = false;
      if (!tempUfds.isSameSet(u, v)) {
        noCycle = true;
        tempUfds.unionSet(u, v);
        edgeTraversed[dequeuedEdgeId] = true;
        vertexTraversed[u] = true;
        vertexTraversed[v] = true;
        totalWeight += w;
      }

      delete edgeHighlighted[dequeuedEdgeId];
      delete edgeQueued[dequeuedEdgeId]
      delete vertexHighlighted[u];
      delete vertexHighlighted[v];

      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, edgeQueued);
      if (noCycle) {
        cs["status"] = "Adding that edge will not form a cycle, so we add it to T. The current weight of T is " + totalWeight + ".";
        cs["lineNo"] = 5;
        numTaken++;
      }
      else {
        cs["status"] = " that edge will form a cycle, so we ignore it. The current weight of T remains at " + totalWeight + ".";
        cs["lineNo"] = 6;
      }
      stateList.push(cs);

      if (noCycle && (numTaken == amountVertex-1)) {
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, edgeQueued);
        cs["status"] = (amountVertex-1) + " edges have been taken by Kruskal&#39;s, so the MST has been found.<br>An optimized version of Kruskal&#39;s algorithm can stop here."; // the animation will still run until the end
        cs["lineNo"] = 5;
        stateList.push(cs);
      }
    }

    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, edgeQueued);
    cs["status"] = "The highlighted vertices and edges form an MST with weight = " + totalWeight + ".<br><b><a href=\"https://cpbook.net/#downloads\" target=\"_blank\">ch4_03_kruskal_prim.cpp/java, ch4.zip, CP3</a></b>.";
    cs["lineNo"] = 7;
    stateList.push(cs);

    populatePseudocode(1);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.prim = function(sourceVertex, callback) {
    var i, key, totalWeight = 0, cs;
    var visited = {}, vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, edgeTraversed = {}, edgeQueued = {};
    var stateList = [];

    // error checks
    if (amountVertex == 0) { // no graph
      $('#prims-err').html("There is no graph to run this on. Please select an example graph first.");
      return false;
    }

    if (sourceVertex >= amountVertex || sourceVertex < 0) { // start vertex not in range
      $('#prims-err').html("This vertex does not exist in the graph");
      return false;
    }

    for (key in iVL) visited[key] = false;
    vertexTraversed[sourceVertex] = true;
    for (var key in iVL) iVL[key]["extratext"] = "";
    iVL[sourceVertex]["extratext"] = "source";
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, edgeQueued);
    cs["status"] = "T = {" + sourceVertex + "}.";
    cs["lineNo"] = 1;
    stateList.push(cs);

    delete vertexHighlighted[sourceVertex];
    vertexTraversed[sourceVertex] = true;

    var sortedArray = [];
    var enqueuedToString = "";

    function sortedArrayToString() {
      var ansStr = "";
      var maxLength = Math.min(sortedArray.length, 6);
      for (var i = 0; i < maxLength; i++) {
        var thisTriple = sortedArray[i];
        ansStr += "(" + thisTriple.getFirst() + "," + thisTriple.getSecond() + ")";
        if (i < (maxLength-1)) ansStr += ", ";
      }
      if (sortedArray.length > 6) ansStr += "..";
      if (ansStr == "") ansStr = "empty";
      return ansStr;
    }

    function process(vtx) {
      enqueuedToString = "";
      visited[vtx] = true;
      for (key in iAL[vtx]) {
        var v = iAL[vtx][key].getFirst();
        var w = iAL[vtx][key].getSecond();
        var enqueuedEdgeId = iAL[vtx][key].getThird();
        if (!visited[v]) {
          enqueuedEdge = new ObjectTriple(parseInt(w), parseInt(v), parseInt(enqueuedEdgeId));
          edgeQueued[enqueuedEdgeId] = true;
          enqueuedToString += "(" + w + "," + v + "), ";
          sortedArray.push(enqueuedEdge);
        }
      }
      enqueuedToString = enqueuedToString.substring(0, enqueuedToString.length-2);
      sortedArray.sort(ObjectTriple.compare);
    }

    process(sourceVertex);

    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, edgeQueued);
    cs["status"] = enqueuedToString + " is added to the PQ.<br>The PQ is now " + sortedArrayToString() + ".";
    cs["lineNo"] = 2;
    stateList.push(cs);

    var numTaken = 1;
    while (sortedArray.length > 0) {
      var dequeuedEdge = sortedArray.shift();
      var otherVertex = dequeuedEdge.getSecond();
      var edgeId = dequeuedEdge.getThird();

      vertexHighlighted[otherVertex] = true;
      edgeHighlighted[edgeId] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, edgeQueued);
      cs["status"] = "(" + dequeuedEdge.getFirst() + "," + otherVertex + ") is removed from PQ. Check if vertex " + otherVertex + " is in T.<br>The PQ is now " + sortedArrayToString() + ".";
      cs["lineNo"] = 4;
      stateList.push(cs);

      if (!visited[otherVertex]) {
        delete edgeHighlighted[edgeId];
        edgeHighlighted[edgeId] = true;
        vertexHighlighted[otherVertex] = true;

        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, edgeQueued);
        cs["status"] = otherVertex + " is not in T.";
        cs["lineNo"] = 4;
        stateList.push(cs);

        delete vertexHighlighted[otherVertex];
        delete edgeHighlighted[edgeId];
        edgeTraversed[edgeId] = true;
        vertexTraversed[otherVertex] = true;

        process(otherVertex);

        totalWeight += parseInt(dequeuedEdge.getFirst());
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, edgeQueued);
        cs["status"] = otherVertex + " and this edge are added into T (T\\&#39;s weight = " + totalWeight + "), " + (enqueuedToString.length > 0 ? enqueuedToString : "(null)") + " is also added to PQ. The PQ is now " + sortedArrayToString() + ".";
        cs["lineNo"] = 5;
        stateList.push(cs);

        numTaken++;
        if (numTaken == amountVertex) { // to show that we can optimize Prim's a bit.
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, edgeQueued);
          cs["status"] = numTaken + " vertices have been taken by Prim\\&#39;s, so the MST has been found.<br>An optimized version of Prim\\&#39;s algorithm can stop here."; // For now, we will continue until the PQ is empty
          cs["lineNo"] = 5;
          stateList.push(cs);
        }
      }
      else {
        delete edgeQueued[edgeId];
        delete edgeHighlighted[edgeId];

        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, edgeQueued);
        cs["status"] = otherVertex + " is in T, so ignore this edge.";
        cs["lineNo"] = 6;
        stateList.push(cs);
      }
    }

    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, edgeQueued);
    cs["status"] = "The highlighted vertices and edges form an MST with weight = " + totalWeight + '.<br><b><a href="https://cpbook.net/#downloads" target="_blank">ch4_03_kruskal_prim.cpp/java, ch4.zip, CP3.</a></b>';
    cs["lineNo"] = 7;
    stateList.push(cs);

    populatePseudocode(0);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.examples = function(id) {
    var vertexList = getExampleGraph(id, VL);
    var edgeList = getExampleGraph(id, EL);
    gw.removeAll();
    this.loadGraph(vertexList, edgeList); // auto mediumscale for large examples
    if (id == MSTLARGE) {
        setMediumScale();
    }
    return true;
  }

  this.loadGraph = function(vertexList, edgeList) {
    iVL = vertexList;
    iEL = edgeList;
    fixJSON();
    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
  }

  function createState(iVLObject, iELObject, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, edgeQueued) {
    var isDefaultGrey = true;
    if ((vertexHighlighted == null) && (edgeHighlighted == null) && (vertexTraversed == null) && (edgeTraversed == null) && (edgeQueued == null))
      isDefaultGrey = false;
    if (vertexHighlighted == null) vertexHighlighted = {};
    if (edgeHighlighted == null) edgeHighlighted = {};
    if (vertexTraversed == null) vertexTraversed = {};
    if (edgeTraversed == null) edgeTraversed = {};
    if (edgeQueued == null) edgeQueued = {};

    var key;
    var state = {
      "vl": {},
      "el": {}
    };

    if (isDefaultGrey) {
      for (key in iVLObject) {
        state["vl"][key] = {};
        state["vl"][key]["cx"] = iVLObject[key]["x"];
        state["vl"][key]["cy"] = iVLObject[key]["y"];
        state["vl"][key]["text"] = key;
        state["vl"][key]["state"] = VERTEX_GREY_OUTLINE;
        state["vl"][key]["extratext"] = iVLObject[key]["extratext"];
      }
      for (key in iELObject) {
        state["el"][key] = {};
        state["el"][key]["vertexA"] = iELObject[key]["u"];
        state["el"][key]["vertexB"] = iELObject[key]["v"];
        state["el"][key]["type"] = EDGE_TYPE_UDE;
        state["el"][key]["weight"] = iELObject[key]["w"];
        state["el"][key]["state"] = EDGE_GREY;
        state["el"][key]["displayWeight"] = true;
        state["el"][key]["animateHighlighted"] = false;
      }
    }
    else {
      for (key in iVLObject) {
        state["vl"][key] = {};
        state["vl"][key]["cx"] = iVLObject[key]["x"];
        state["vl"][key]["cy"] = iVLObject[key]["y"];
        state["vl"][key]["text"] = key;
        state["vl"][key]["state"] = VERTEX_DEFAULT;
        state["vl"][key]["extratext"] = iVLObject[key]["extratext"];
      }
      for (key in iELObject) {
        state["el"][key] = {};
        state["el"][key]["vertexA"] = iELObject[key]["u"];
        state["el"][key]["vertexB"] = iELObject[key]["v"];
        state["el"][key]["type"] = EDGE_TYPE_UDE;
        state["el"][key]["weight"] = iELObject[key]["w"];
        state["el"][key]["state"] = EDGE_DEFAULT;
        state["el"][key]["displayWeight"] = true;
        state["el"][key]["animateHighlighted"] = false;
      }
    }

    for (key in edgeQueued) {
      key1 = state["el"][key]["vertexA"];
      key2 = state["el"][key]["vertexB"]
      state["vl"][key1]["state"] = VERTEX_DEFAULT;
      state["vl"][key2]["state"] = VERTEX_DEFAULT;
      state["el"][key]["state"] = EDGE_DEFAULT;
    }

    for (key in vertexHighlighted) state["vl"][key]["state"] = VERTEX_HIGHLIGHTED; // VERTEX_BLUE_FILL;
    for (key in edgeHighlighted) state["el"][key]["state"] = EDGE_HIGHLIGHTED; // EDGE_BLUE;
    for (key in vertexTraversed) state["vl"][key]["state"] = VERTEX_TRAVERSED; // VERTEX_GREEN_FILL;
    for (key in edgeTraversed) state["el"][key]["state"] = EDGE_TRAVERSED; // EDGE_GREEN;

    return state;
  }

  function populatePseudocode(act) {
    switch (act) {
      case 0: // Prim's
        $('#code1').html('T = {s}');
        $('#code2').html("enqueue edges connected to s in PQ (by inc weight)");
        $('#code3').html('while (!PQ.isEmpty)');
        $('#code4').html('&nbsp;&nbsp;if (vertex v linked with e = PQ.remove &notin; T)');
        $('#code5').html("&nbsp;&nbsp;&nbsp;&nbsp;T = T &cup; {v, e}, enqueue edges connected to v");
        $('#code6').html("&nbsp;&nbsp;else ignore e");
        $('#code7').html('MST = T // <b><a href="https://cpbook.net/#downloads" target="_blank">ch4_03_kruskal_prim.cpp/java, ch4, CP3</a></b>');
        break;
      case 1: // Kruskal's
        $('#code1').html("Sort E edges by increasing weight");
        $('#code2').html('T = {}');
        $('#code3').html('for (i = 0; i &lt; edgeList.length; i++)');
        $('#code4').html("&nbsp;&nbsp;if adding e = edgelist[i] does not form a cycle");
        $('#code5').html("&nbsp;&nbsp;&nbsp;&nbsp;add e to T");
        $('#code6').html("&nbsp;&nbsp;else ignore e");
        $('#code7').html('MST = T // <b><a href="https://cpbook.net/#downloads" target="_blank">ch4_03_kruskal_prim.cpp/java, ch4, CP3</a></b>');
        break;
    }
  }
}



// MST Actions
var actionsWidth = 180;
var statusCodetraceWidth = 430;

// local
write(true, false);
var mw, gw, randomGraphID;

$(function() {
  $('#play').hide();
  mw = new MST();
  gw = mw.getGraphWidget();
  gw.setAnimationDuration(700 / speedVal);
  var options = [CP3_4_10, CP3_4_14, K5, RAIL, TESSELLATION, MSTLARGE];
  mw.examples(options[Math.floor(Math.random()*5)]);
  randomGraphID = -1;

  var graphJSON = getQueryVariable("create");
  if (graphJSON.length > 0) {
    importjson(graphJSON);
    window.history.pushState("object or string", "Title", window.location.href.split('?')[0]);
  }

  userGraph = mw.getGraph(); // save the current graph
});

function importjson(text) {
  if (isPlaying) stop();
  if (mode == "exploration") {
    mw.importjson(text);
    //closeExamples();
    isPlaying = false;
  }
}

function setDefaultScale() {
    if (isPlaying) stop();
    isPlaying = false;
    if (scale) {
        scale = !scale;
        gw.redrawAllForMediumScale();
        gw.setMediumScale(false);

        userGraph = mw.getGraph();
    } 
}

function setMediumScale() {
    if (isPlaying) stop();
    isPlaying = false;
    if (!scale) {
        scale = !scale;
        gw.redrawAllForMediumScale();
        gw.setMediumScale(true);

        userGraph = mw.getGraph();
    }
}

function toggleVertexNumber() {
    if (isPlaying) stop();
    isPlaying = false;
    if (scale) {
        gw.toggleVertexNumber();
    }
}

function drawGraph() {
  if (isPlaying) stop();
  if (mode == "exploration") {
    const [newiVL, newiEL] = representationConvert(mw.getiVL(), mw.getiEL())
    currentGraphVisu = new GraphVisu(true, false, true, newiVL, newiEL, true)
    $('#dark-overlay').fadeIn(function() {
      $('#drawgraph').fadeIn();
    });
    mw.startLoop();
    isPlaying = false;
  }
}

function drawDone() {
  if (!mw.draw()) return false;
  mw.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

function drawCancel() {
  mw.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

// function createRandom() {
//   if (isPlaying) stop();
//   if (mode == "exploration") {
//     $.ajax({
//       url: PHP_DOMAIN + "/php/Graph.php?mode=" + MODE_GET_RANDOM_SUBMITTED_GRAPH + "&directed=" + 0 + "&connected=" + 1 // + "&topic=MST"
//     }).done(function(data) {
//       data = jQuery.parseJSON(data); // JSON.parse(data);
//       var graph = extractQnGraph(data.graph);
//       if (data.graphID == randomGraphID) // make sure it is different, make sure #graph > 1
//         createRandom();
//       randomGraphID = data.graphID;
//       mw.initRandom(graph);
//       $('#rate-sample-graph').show();
//     })
//     $('#progress-bar').slider("option", "max", 0);
//     closeExamples();
//     isPlaying = false;
//   }
// }

function example(id) {
  if (isPlaying) stop();
  setTimeout(function() {
    if ((mode == "exploration") && mw.examples(id)) {
      $('#progress-bar').slider("option", "max", 0);
      //closeExamples();
      isPlaying = false;
    }
  }, 500);
}

function kruskals(callback) {
  if (isPlaying) stop();
  commonAction(mw.kruskal(callback), "Kruskal&#39;s Algorithm");
}

function prims() {
  if (isPlaying) stop();
  var input = parseInt($('#prim-v').val());
  primsWithInput(input);
}

function primsWithInput(input, callback) {
  commonAction(mw.prim(input, callback), "Prim&#39;s Algorithm, s = " + input);
  setTimeout(function() { $('#prim-v').val(Math.floor(Math.random()*mw.getV())); }, 500); // randomized for next click between [0..V-1]
}

function loadGraph(graph) {
  if (mw) {
    mw.loadGraph(graph['vl'], graph['el']);
  }
}

// Implement these functions in each visualisation
var userGraph = {
  'vl': {},
  'el': {},
};

// This function will be called before entering E-Lecture Mode
function ENTER_LECTURE_MODE() {
  if (mw) userGraph = mw.getGraph();
}

// This function will be called before returning to Explore Mode
function ENTER_EXPLORE_MODE() {
  loadGraph(userGraph);
}

// Lecture action functions
function CUSTOM_ACTION(action, data, mode) {
  if (action == 'kruskal') {
    hideSlide(function() {
      kruskals(showSlide);
    });
  }
  else if (action == 'prim') {
    hideSlide(function() {
      primsWithInput(data, showSlide);
    });
  }
}
</script>
</body>

<!-- Mirrored from visualgo.net/en/mst by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:17:29 GMT -->
</html>
