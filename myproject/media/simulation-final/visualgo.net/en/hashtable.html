<!DOCTYPE html>
<html lang="en">

<!-- Mirrored from visualgo.net/en/hashtable by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:17:35 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="description" content="Hash Table is a data structure to map key to values (also called Table or Map Abstract Data Type/ADT). It uses a hash function to map large or even non-Integer keys into a small range of Integer indices (typically [0..hash_table_size-1]).The probability of two distinct keys colliding into the same index is relatively high and each of this potential collision needs to be resolved to maintain data integrity.There are several collision resolution strategies that will be highlighted in this visualization: Open Addressing (Linear Probing, Quadratic Probing, and Double Hashing) and Closed Addressing (Separate Chaining). Try clicking Search(7) for a sample animation of searching a specific value 7 in a randomly created Hash Table using Separate Chaining technique (duplicates are allowed).">
<meta name="keywords" content="Hash Table Open Addressing Linear Quadratic Probing Double Hashing Closed Addressing Separate Chaining">
 
<meta name="csrf-token" content="dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../img/png/hashtable.png">
<title>Hash Table (Closed Addressing: Separate Chaining and Open Addressing: Linear Probing, Quadratic Probing, Double Hashing) - VisuAlgo</title>
<link rel="icon" href="../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../img/favicon.png">
<link rel="stylesheet" href="../css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../css/common-1.0.2.css">
<link rel="stylesheet" href="../css/viz-1.0.4.css">
<link rel="stylesheet" href="../css/visual.css">
<link rel="stylesheet" href="../css/drawgraph-1.0.2.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
        z-index: 8001;
      }
      #e-lecture-timeline {
        top: 80px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }
      .e-lecture-timeline-slide {
        height: 5px;
        width: 2px;
        background: black;
        float: left;
      }
      .e-lecture-timeline-checkpoint {
        height: 20px;
        width: 3px;
        margin-left: 2px;
        margin-top: -7.5px;
        background: black;
        float: left;
      }

      #e-lecture-f1map {
        top: 102.5px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }

      .e-lecture-f1map-sector {
        flex-grow: 1;
        background: black;
        float: left;
        height: 5px;
        margin-right: 1px;
      }

      .e-lecture-f1map-sector:last-child {
        margin-right: 0px;
      }

      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }

      .electure-read-status {
        position: absolute;
        bottom: 4px;
        right: 4px;
        font-size: 14px;
        cursor: default;
        color: #00FF7F;
        display: none;
      }

      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
      .electure-print, .electure-end {
        position: fixed;
        top: 45px;
        height: 20px;
        width: 17px;
        right: 80px;
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
        text-align: center;
      }
      .electure-end {
        right: 45px; /* beside the X */
      }

      #change-lang-popup {
        position: fixed;
        background: green;
        left: 40px;
        top: 50px;
        width: 250px;
        height: 125px;
        border: transparent;
        border-radius: 10px;
        padding: 10px 20px;
        z-index: 9000;
      }

      #change-lang-popup p {
        font-size: medium;
        color: white;
        line-height: 2;
        font-family: "PT Sans", sans-serif;
      }

      #change-lang-popup-btn {
        text-decoration: underline;
        margin-left: 50px;
      }

      #change-lang-popup-btn:hover {
        cursor: pointer;
      }

      #rotateDeviceOverlay {
        z-index: 10000;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        background-color: white;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        overflow: hidden;
      }

      #mobile-playback-overlay {
        z-index: 9600;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        gap: 100px;
        background-color: black;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        opacity: 0.3;
        overflow: hidden;
      }
      .mobile-playback-item {
        min-width: 2.5%;
        max-width: 35px;
      }
      .mobile-playback-item img {
        width: 100%
      }
      .mobile-playback-label {
        opacity: 0;
        color: white;
        font-size: 25px;
        font-weight: bold;
        min-width: 1.5%;
        max-width: 25px;
        transition: opacity 0.25s ease-out;
        -webkit-backface-visibility: hidden;
      }
      #mobile-playback-rewind-label {
        margin-right: -70px;
      }
      #mobile-playback-forward-label {
        margin-left: -70px;
      }
      #viz-speed-value {
          font-size: 15px;
          width: 10%;
      }

      #scale {
        position: fixed;
        left: 5px;
      }
    </style>
<style>
/* copied here from common.css (perhaps need to use version numbering) until caches worldwide settles */
#reload-mobile-popup, #message-popup { /* #gdpr-popup, */
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  min-width: 320px;
  bottom: 62px;
  height: 300px;
  background-color: #0275d8;
  border-radius: 15px;
  padding: 30px 40px;
  z-index: 9500;
}
#reload-mobile-popup {
  background-color: green;
  height: 200px;
}
#message-popup {
  z-index: 9000;
  width: 40%;
  height: 130px;
  background-color: #d9534f;
}

#reload-mobile-popup p, #message-popup p { /* #gdpr-popup p, */
  font-size: large;
  color: white;
  line-height: 2;
  font-family: "PT Sans", sans-serif;
}

#reload-mobile-popup .inner-button, #message-popup .inner-button { /* #gdpr-popup .gdpr-button, */
  border: white solid 2px;
  border-radius: 4px;
  font-weight: bold;
  font-size: x-large;
  padding: 2px 8px;
  color: white;
  width: 90px;
  text-align: center;
  position: absolute;
  letter-spacing: 1px;
  text-decoration: none;
  cursor: pointer;
}

#gdpr-accept, #reload-mobile-button, #dismiss-message-btn {
  bottom: 30px;
  right: 40px;
}

#gdpr-reject, #cancel-reload-mobile-button {
  bottom: 30px;
  right: 170px;
}
    </style>
</head>
<body>
<div id="body-container" style="display: flex; flex-direction: column; min-height: 100vh;">
<style>
  #topbar {
    background-color: rgb(0,0,0);
    font-family: "PT Sans", sans-serif;
    font-size: 13px;
    height: 40px;

    padding-left: 40px;
    padding-right: 40px;

    display: flex;
    flex-wrap: wrap;
    align-items: center;
    position: relative;
    justify-content: flex-start;
  }

  #topbar a:hover {
    text-decoration: none;
  }

  #account-dropdown-btn {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;
    height: 24px;
    line-height: 1.5;
  }

  #account-dropdown-btn:hover {
    color: #0a58ca!important;
    border-color: #198754;
    text-decoration: none;
  }

  #login-button {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;

    height: 24px;
    line-height: 1.5;
  }

  #login-button a:hover {
    color: #0a58ca!important;
    text-decoration: none;
  }

  #account-dropdown-menu {
    display: none;
    position: absolute;
    background-color: white;
    z-index: 1000;
    min-width: 10rem;
    padding: 0.5rem 0;
    margin: 0;
    font-size: 1rem;
    color: rgb(0,0,0);
    text-align: left;
    list-style: none;
    background-clip: padding-box;
    border: 1px solid rgba(0,0,0,.15);
    border-radius: 0.25rem;
    top: 45px;
    right: 40px;
    line-height: 1.5;
  }

  .account-dropdown-item {
    display: block;
    width: auto;
    padding: 0.25rem 1rem;
    clear: both;
    font-weight: 400;
    color: rgb(0,0,0);
    text-align: inherit;
    text-decoration: none;
    white-space: nowrap;
    background-color: transparent;
    border: 0;
    height: 24px;
    font-family: SilkscreenNormal, sans-serif;
  }

  .account-dropdown-item:hover {
    background-color: #e9ecef;
    color: #0a58ca;
    text-decoration: none;
  }
</style>
<nav id="topbar">
<span style="margin-right: 0.25rem">
<a href="https://www.comp.nus.edu.sg/~stevenha" style="text-decoration: none; color: white">
<span class="colour" style="border: 1px solid; border-color: #198754!important; border-radius: .25rem!important">7</span>
</a>
<a href="https://visualgo.net/" style="font-family: SilkscreenNormal,sans-serif; font-size: 20px; margin-left: 4px;">
<span style="color: white">Visu</span><span class="colour">Algo</span><span style="font-size: 40%; color: white">.net</span>
</a>
<span style="color: white">/</span>
<select id="Language" class="select2-dropdown" onchange="changeURL()">
<option value="en" selected>en</option>
<option value="zh">zh</option>
<option value="id">id</option>
</select>
<span style="color: white; font-family: monospace">/hashtable</span>
</span>
<span style="max-height: 30px">
<span id="title">
<a id="title-LP" class="selected-viz">LP</a>
<a id="title-QP">QP</a>
<a id="title-DH">DH</a>
<a id="title-SC">SC</a>
</span>
</span>
<span style="max-height: 30px; background-color:rgb(0,0,0)!important; color: white; margin-left: auto">
<div id="mode-menu">
<div id="mode-button" style="background-color: rgb(0,0,0)!important;" title="exploration">Exploration Mode &#9663;</div>
<div id="other-modes" style="background-color: rgb(0,0,0)!important; padding-top: 11px">
<a title="e-Lecture" style="background-color: rgb(0,0,0)!important;">e-Lecture Mode</a>
</div>
</div>
</span>
<span id="login-button" style="font-family: SilkscreenNormal,sans-serif">
<a href="https://visualgo.net/login">Login</a>
</span>
</nav>
<ul id="account-dropdown-menu">
<li><a class="account-dropdown-item" href="https://visualgo.net/profile">Profile</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/training">Training</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/tests">Tests</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/logout">Log Out</a></li>
</ul>
<script>
  function changeURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    URL[3] = document.getElementById("Language").value;
    window.location.assign(URL.join('https://visualgo.net/'));
  }

  function changeDefaultLanguageAndURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    let val = document.getElementById("Language").value;
    URL[3] = val;

    let data = {
      '_token': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
      'lang'  : val
    }
    $.post('https://visualgo.net/changeLanguage', data, function (res, status) {
      if(res['status'] === 'success') {
        window.location.assign(URL.join('https://visualgo.net/'));
      } else if (res['status'] === 'failed') {
        alert(res['message']);
      } else {
        alert('An unknown error occurred');
      }
    })
  }
</script>
<div id="dark-overlay"></div>
<div id="main-content-container" style="flex: 1">

<div id="mobile-playback-overlay" class="playing" style="display: none;">
<span id="mobile-playback-rewind-label" class="mobile-playback-label">-7</span>
<span id="mobile-playback-rewind" class="mobile-playback-item" onclick="mobilePlaybackRewind()"><img src="../img/prevFrame.png" alt="rewind 7 frames"></span>
<span id="mobile-playback-pause" class="mobile-playback-item" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/pause.png" alt="pause"></span>
<span id="mobile-playback-play" class="mobile-playback-item" style="display: none;" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/play.png" alt="play"></span>
<span id="mobile-playback-forward" class="mobile-playback-item" onclick="mobilePlaybackForward()"><img src="../img/nextFrame.png" alt="forward 7 frames"></span>
<span id="mobile-playback-forward-label" class="mobile-playback-label">+7</span>
</div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id="speed-control"><div id="speed-input"></div><div id="viz-speed-value">1x</div></div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick="goToBeginning()"><img src="../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick="stepBackward()"><img src="../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick="pause()"><img src="../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick="play()"><img src="../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick="stepForward()"><img src="../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick="goToEnd()"><img src="../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id="viz">
<p id="info" "></p>
</div>
<div id="current-action" class="panel"></div>
<div id="e-lecture" class="panel"></div> 
<div id="e-lecture-timeline"></div>
<div id="e-lecture-f1map">
<div class="e-lecture-f1map-sector" sectorNo="1"></div>
<div class="e-lecture-f1map-sector" sectorNo="2"></div>
<div class="e-lecture-f1map-sector" sectorNo="3"></div>
</div>
<div id="overlay" hidden onclick="end_eLecture()"> 
<div id="electure-dropdown">
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. Hash Table</option>
<option value="2">2. Motivation</option>
<option value="2-1">&nbsp;&nbsp;&nbsp;2-1. Table ADT</option>
<option value="2-2">&nbsp;&nbsp;&nbsp;2-2. Direct Addressing Table (DAT)</option>
<option value="2-3">&nbsp;&nbsp;&nbsp;2-3. Example of DAT</option>
<option value="2-4">&nbsp;&nbsp;&nbsp;2-4. Example of DAT with Satellite Data</option>
<option value="2-5">&nbsp;&nbsp;&nbsp;2-5. The Answer</option>
<option value="2-6">&nbsp;&nbsp;&nbsp;2-6. DAT Limitations</option>
<option value="3">3. Hashing: Ideas</option>
<option value="3-1">&nbsp;&nbsp;&nbsp;3-1. Phone Numbers Example</option>
<option value="3-2">&nbsp;&nbsp;&nbsp;3-2. Hash Table Preview</option>
<option value="3-3">&nbsp;&nbsp;&nbsp;3-3. Hash Table with Satellite Data</option>
<option value="3-4">&nbsp;&nbsp;&nbsp;3-4. Collision</option>
<option value="3-5">&nbsp;&nbsp;&nbsp;3-5. Probability of Collision</option>
<option value="3-6">&nbsp;&nbsp;&nbsp;3-6. The Calculation</option>
<option value="3-7">&nbsp;&nbsp;&nbsp;3-7. Two Important Issues</option>
<option value="4">4. Hash Functions</option>
<option value="4-1">&nbsp;&nbsp;&nbsp;4-1. Preliminaries</option>
<option value="4-2">&nbsp;&nbsp;&nbsp;4-2. Example of a Bad Hash Function</option>
<option value="4-3">&nbsp;&nbsp;&nbsp;4-3. The Answer</option>
<option value="4-4">&nbsp;&nbsp;&nbsp;4-4. Perfect Hash Function</option>
<option value="4-5">&nbsp;&nbsp;&nbsp;4-5. Hashing Integer - Best Practice</option>
<option value="4-6">&nbsp;&nbsp;&nbsp;4-6. The Answer</option>
<option value="4-7">&nbsp;&nbsp;&nbsp;4-7. Hashing String - Best Practice</option>
<option value="4-8">&nbsp;&nbsp;&nbsp;4-8. The Answer</option>
<option value="5">5. Collision Resolution</option>
<option value="5-1">&nbsp;&nbsp;&nbsp;5-1. Open Addressing (OA)</option>
<option value="5-2">&nbsp;&nbsp;&nbsp;5-2. Separate Chaining (SC)</option>
<option value="6">6. Visualization</option>
<option value="6-1">&nbsp;&nbsp;&nbsp;6-1. Open Addressing Version</option>
<option value="6-2">&nbsp;&nbsp;&nbsp;6-2. Separate Chaining Version</option>
<option value="7">7. Linear Probing (LP)</option>
<option value="7-1">&nbsp;&nbsp;&nbsp;7-1. Insert([18, 14, 21)</option>
<option value="7-2">&nbsp;&nbsp;&nbsp;7-2. Insert([1, 35])</option>
<option value="7-3">&nbsp;&nbsp;&nbsp;7-3. Search(35) and Search(8)</option>
<option value="7-4">&nbsp;&nbsp;&nbsp;7-4. Remove(v) - Preliminary</option>
<option value="7-5">&nbsp;&nbsp;&nbsp;7-5. The Answer</option>
<option value="7-6">&nbsp;&nbsp;&nbsp;7-6. Remove(21)</option>
<option value="7-7">&nbsp;&nbsp;&nbsp;7-7. Search(35) Again</option>
<option value="7-8">&nbsp;&nbsp;&nbsp;7-8. Insert(28) - Overwriting DEL</option>
<option value="7-9">&nbsp;&nbsp;&nbsp;7-9. Primary Clustering, Part 1</option>
<option value="7-10">&nbsp;&nbsp;&nbsp;7-10. Linear Probing Sequence</option>
<option value="7-11">&nbsp;&nbsp;&nbsp;7-11. Primary Clustering, Part 2</option>
<option value="8">8. Quadratic Probing (QP)</option>
<option value="8-1">&nbsp;&nbsp;&nbsp;8-1. Insert(38)</option>
<option value="8-2">&nbsp;&nbsp;&nbsp;8-2. Remove(18) and Search(38) Again</option>
<option value="8-3">&nbsp;&nbsp;&nbsp;8-3. Better than Linear Probing?</option>
<option value="8-4">&nbsp;&nbsp;&nbsp;8-4. The Details</option>
<option value="8-5">&nbsp;&nbsp;&nbsp;8-5. A Theorem</option>
<option value="8-6">&nbsp;&nbsp;&nbsp;8-6. A Proof</option>
<option value="8-7">&nbsp;&nbsp;&nbsp;8-7. Better Quadratic Probing</option>
<option value="8-8">&nbsp;&nbsp;&nbsp;8-8. Secondary Clustering</option>
<option value="9">9. Double Hashing (DH)</option>
<option value="9-1">&nbsp;&nbsp;&nbsp;9-1. Secondary Hash Function h2(v)</option>
<option value="9-2">&nbsp;&nbsp;&nbsp;9-2. Insert([35, 42])</option>
<option value="9-3">&nbsp;&nbsp;&nbsp;9-3. Remove(17) and Search(35) Again</option>
<option value="9-4">&nbsp;&nbsp;&nbsp;9-4. Good OA Collision Resolution Technique</option>
<option value="10">10. Separate Chaining (SC)</option>
<option value="10-1">&nbsp;&nbsp;&nbsp;10-1. Search(35) and Remove(35)</option>
<option value="10-2">&nbsp;&nbsp;&nbsp;10-2. Open Addressing vs Separate Chaining?</option>
<option value="10-3">&nbsp;&nbsp;&nbsp;10-3. The (Current) Answer</option>
<option value="11">11. Extras</option>
<option value="11-1">&nbsp;&nbsp;&nbsp;11-1. Rehash</option>
<option value="11-2">&nbsp;&nbsp;&nbsp;11-2. Hash Table Implementation</option>
<option value="11-3">&nbsp;&nbsp;&nbsp;11-3. Data Structure Combo?</option>
<option value="11-4">&nbsp;&nbsp;&nbsp;11-4. Alternative Data Structure for Table ADT</option>
<option value="11-5">&nbsp;&nbsp;&nbsp;11-5. Online Quiz</option>
<option value="11-6">&nbsp;&nbsp;&nbsp;11-6. Online Judge Exercises</option>
</select>
</div>
<div class="electure-print" title="Print the e-Lecture note" style="z-index=8001;">&#9997;</div>
<div class="electure-end" title="Close the e-Lecture mode" style="z-index=8001;">&#10008;</div>
</div>
<div id="dropdown-temp-holder" hidden></div>

<div id="electure-1" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>Hash Table is a data structure to map key to values (also called Table or Map Abstract Data Type/ADT). It uses a <b>hash function</b> to map large or even non-Integer keys into a small range of Integer indices (typically [0..hash_table_size-1]).</p><br><p>The probability of two distinct keys colliding into the same index is <a href="hashtablee090.html?slide=3-5"><u>relatively high</u></a> and each of this potential collision needs to be resolved to maintain data integrity.</p><br><p>There are several collision resolution strategies that will be highlighted in this visualization: Open Addressing (Linear Probing, Quadratic Probing, and Double Hashing) and Closed Addressing (Separate Chaining). Try clicking <span class="slide-actions" onclick="doButtonAction82()">Search(7)</span> for a sample animation of searching a specific value 7 in a randomly created Hash Table using Separate Chaining technique (duplicates are allowed).</p>
<div class="electure-addition">
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
If you are an NUS student and a repeat visitor, please <a href="https://visualgo.net/login"><u>login</u></a>.</p>
</div>
<div class="electure-next" data-nextid="2" title="Go to the next slide 2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Hashing is an algorithm (via a hash function) that maps large data sets of variable length, called keys, not necessarily Integers, into smaller Integer data sets of a fixed length.</p><br><p>A Hash Table is a data structure that uses a hash function to efficiently map keys to values (Table or Map ADT), for efficient search/retrieval, insertion, and/or removals.</p><br><p>Hash Table is widely used in many kinds of computer software, particularly for <a href="https://en.wikipedia.org/wiki/Associative_array" target="_blank"><u>associative arrays</u></a>, database indexing, caches, and sets.</p><br><p>In this e-Lecture, we will digress to Table ADT, the basic ideas of <a href="hashtable0c37.html?slide=3"><u>Hashing</u></a>, the discussion of <a href="hashtable1438.html?slide=4"><u>Hash Functions</u></a> before going into the details of <a href="hashtable3254.html?slide=5"><u>Hash Table</u></a> data structure itself.</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 1: Since you are not <a href="https://visualgo.net/login"><u>logged-in</u></a>, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b>/<b>[PageUp]</b> to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use <b>[&rarr; or &darr;/&larr; or &uarr;]</b> to do the same),and <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
</div>
<div class="electure-prev" data-nextid="1" title="Go to the previous slide 1">&larr;</div>
<div class="electure-next" data-nextid="2-1" title="Go to the next slide 2-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>A Table ADT must support <b>at least</b> the following three operations as efficient as possible:</p><ol><li>Search(v) — determine if <b>v</b> exists in the ADT or not,</li><li>Insert(v) — insert <b>v</b> into the ADT,</li><li>Remove(v) — remove <b>v</b> from the ADT.</li></ol><p>Hash Table is one possible good implementation for this Table ADT (the other one is <a href="bst345d.html?slide=13-1"><u>this</u></a>).</p><hr><p>PS1: For two weaker implementations of Table ADT, you can click the respective link: <a href="bst48df.html?slide=3-2"><u>unsorted array</u></a> or a <a href="bste0b3.html?slide=3-3"><u>sorted array</u></a> to read the detailed discussions.</p><hr><p>PS2: In live class, you may want to compare the requirements of Table ADT vs <a href="list7d9a.html?slide=2-1" target="_blank"><u>List ADT</u></a>.</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
</div>
<div class="electure-prev" data-nextid="2" title="Go to the previous slide 2">&larr;</div>
<div class="electure-next" data-nextid="2-2" title="Go to the next slide 2-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-2" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>When the range of the <b>Integer</b> keys is <b>small</b>, e.g., [0..<b>M</b>-1], we can use an initially empty (Boolean) array <b>A</b> of size <b>M</b> and implement the following Table ADT operations <b>directly</b>:</p><ol><li>Search(v): Check if <b>A[v]</b> is true (filled) or false (empty),</li><li>Insert(v): Set <b>A[v]</b> to be true (filled),</li><li>Remove(v): Set <b>A[v]</b> to be false (empty).</li></ol><p>That&#39;s it, we use the small Integer key itself to determine the address in array <b>A</b>, hence the name <b>Direct Addressing</b>. It is clear that all three major Table ADT operations are O(<b>1</b>).</p><br><p>PS: This idea is also used elsewhere, e.g., in <a href="sorting3f6c.html?slide=15"><u>Counting Sort</u></a>.</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode): <b>Spacebar</b> to play/pause/replay the animation, <b>&larr;</b>/<b>&rarr;</b> to step the animation backwards/forwards, respectively, and <b>-</b>/<b>+</b> to decrease/increase the animation speed, respectively.</p>
</div>
<div class="electure-prev" data-nextid="2-1" title="Go to the previous slide 2-1">&larr;</div>
<div class="electure-next" data-nextid="2-3" title="Go to the next slide 2-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-3" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>In Singapore (<a href="https://en.wikipedia.org/wiki/List_of_bus_routes_in_Singapore" target="_blank"><u>as of Apr 2023</u></a>), bus routes are numbered from [2..991].</p><br><p>Not all integers between [2..991] are currently used, e.g., there is no bus route 989 — Search(989) should return false. A new bus route <b>x</b> may be introduced, i.e., Insert(<b>x</b>) or an existing bus route <b>y</b> may be discontinued, i.e., Remove(<b>y</b>).</p><br><p>As the range of possible bus routes is <b>small</b>, to record the data whether a bus route number exists or not, we can use a DAT with a Boolean array of size 1000 (generally, it is useful to give a few extra buffer cells on top of the current largest bus number of 991).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-2" title="Go to the previous slide 2-2">&larr;</div>
<div class="electure-next" data-nextid="2-4" title="Go to the next slide 2-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-4" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Notice that we can always add <a href="https://stackoverflow.com/questions/14551845/what-is-satellite-information-in-data-structures" target="_blank"><u><b>satellite data</b></u></a> instead of just using a Boolean array to record the existence of the keys.</p><br><p>For example, we can use an <b>associative</b> String array <b>A</b> instead to map a bus route number to its operator name, e.g.,<br></p><pre>A[2] = "Go-Ahead Singapore",<br>A[10] = "SBS Transit",<br>A[183] = "Tower Transit Singapore",<br>A[188] = "SMRT Buses", etc.</pre><p>Discussion: Can you think of a few other real-life DAT examples?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-3" title="Go to the previous slide 2-3">&larr;</div>
<div class="electure-next" data-nextid="2-5" title="Go to the next slide 2-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-5" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-4" title="Go to the previous slide 2-4">&larr;</div>
<div class="electure-next" data-nextid="2-6" title="Go to the next slide 2-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-6" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>The keys must be (or can be easily mapped to) <b>non-negative Integer</b> values. Note that basic DAT has problem in the full version of the example in the previous few slides as there are actually variations of bus route numbers in Singapore, e.g., 96B, 151A, NR10, etc.</p><br><p>The range of keys must be <b>small</b>.<br>The memory usage will be (insanely) large if we have (insanely) large range.</p><br><p>The keys must be dense, i.e., not many gaps in the key values.<br>DAT will contain too many empty (and wasted) cells otherwise.</p><br><p>We will overcome these restrictions with hashing.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-5" title="Go to the previous slide 2-5">&larr;</div>
<div class="electure-next" data-nextid="3" title="Go to the next slide 3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Using hashing, we can:</p><ol><li>Map (some) <b>non-Integer</b> keys (e.g., Strings) to Integers keys,</li><li>Map <b>large</b> Integers to <b>smaller</b> Integers.</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-6" title="Go to the previous slide 2-6">&larr;</div>
<div class="electure-next" data-nextid="3-1" title="Go to the next slide 3-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>For example, we have <b>N</b> = 400 Singapore phone numbers (Singapore phone number has 8 digits, so there are up to 10^8 = 100M possible phone numbers in Singapore).</p><br><p>Instead of using a DAT and use a <b>gigantic</b> array up to size <b>M</b> = 100 Million, we can use the following simple hash function <b>h(v) = v%997</b>.</p><br><p>This way, we map 8 digits phone numbers <b>6675&thinsp;2378</b> and <b>6874&thinsp;4483</b> into up to 3 digits <b>h(6675&thinsp;2378) = 237</b> and <b>h(6874&thinsp;4483) = 336</b>, respectively. Therefore, we only need to prepare an array of size <b>M</b> = 997 (997 is a prime) instead of <b>M</b> = 100 Million.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3" title="Go to the previous slide 3">&larr;</div>
<div class="electure-next" data-nextid="3-2" title="Go to the next slide 3-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-2" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>With hashing, we can now implement the following Table ADT operations using Integer array (instead of Boolean array) as follows:</p><ol><li>Search(v): Check if <b>A[h(v)] != -1</b> (we use -1 for an empty cell assuming <b>v &ge; 0</b>),</li><li>Insert(v): Set <b>A[h(v)] = v</b> (we hash <b>v</b> into <b>h(v)</b> so we need to somehow record key <b>v</b>),</li><li>Remove(v): Set <b>A[h(v)] = -1</b> &mdash; to be elaborated further.</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-1" title="Go to the previous slide 3-1">&larr;</div>
<div class="electure-next" data-nextid="3-3" title="Go to the next slide 3-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-3" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>If we have keys that map to satellite data and we want to record the original keys too, we can implement the Hash Table using pair of (Integer, satellite-data-type) array as follows:</p><ol><li>Search(v): Return <b>A[h(v)]</b>, which is a <b>pair (v, satellite-data)</b>, possibly empty,</li><li>Insert(v, satellite-data): Set <b>A[h(v)] = pair(v, satellite-data)</b>,</li><li>Remove(v): Set <b>A[h(v)] = (empty pair)</b> &mdash; to be elaborated further.</li></ol><p>However, by now you should notice that something is incomplete...</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-2" title="Go to the previous slide 3-2">&larr;</div>
<div class="electure-next" data-nextid="3-4" title="Go to the next slide 3-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-4" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>A hash function may, and quite likely, map <b>different keys (Integer or not)</b> into the <b>same Integer slot</b>, i.e., a <b>many-to-one</b> mapping instead of <b>one-to-one</b> mapping.</p><br><p>For example, <b>h(6675&thinsp;2378) = 237</b> from <a href="hashtable8592.html?slide=3-1"><u>three slides earlier</u></a> and if we want to insert another phone number <b>6675&thinsp;4372</b>, we will have a problem as <b>h(6675&thinsp;4372) = 237</b> too.</p><br><p>This situation is called a <b>collision</b>, i.e., two (or more) keys have the <b>same hash value</b>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-3" title="Go to the previous slide 3-3">&larr;</div>
<div class="electure-next" data-nextid="3-5" title="Go to the next slide 3-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-5" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>The <a href="https://en.wikipedia.org/wiki/Birthday_problem" target="_blank"><u>Birthday (von Mises) Paradox</u></a> asks: &#39;How many people (number of keys) must be in a room (Hash Table) of size 365 seats (cells) before the probability that some person&nbsp;<b>share a birthday</b> (collision, two keys are hashed to the same cell), ignoring the leap years (i.e., all years have 365 days), becomes &gt; 50 percent (i.e., more likely than not)?&#39;</p><br><p>The answer, which maybe surprising for some of us, is <span id="vonmises" style="color: red;"><span class="slide-actions" onclick="doButtonAction88()">Reveal</span></span>.</p><br><p>Let&#39;s do some calculation.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-4" title="Go to the previous slide 3-4">&larr;</div>
<div class="electure-next" data-nextid="3-6" title="Go to the next slide 3-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-6" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Let <b>Q(n)</b> be the probability of <b>unique</b> birthday for <b>n</b> people in a room.<br><b>Q(n) = 365/365 × 364/365 × 363/365 × ... × (365-n+1)/365</b>,<br>i.e., the first person&#39;s birthday can be any of the 365 days, the second person&#39;s birthday can be any of the 365 days except the first person&#39;s birthday, and so on.</p><br><p>Let <b>P(n)</b> be the probability of <b>same birthday</b> (collision) for <b>n</b> people in a room.<br><b>P(n) = 1-Q(n)</b>.</p><br><p>We compute that&nbsp;<b><a href="https://www.wolframalpha.com/input/?i=1.00-(365%2F365*364%2F365*...*343%2F365)" target="_blank"><u>P(23) = 0.507</u></a> &gt; 0.5 (50%)</b>.</p><br><p>Thus, we only need <b>23 people</b> (a small amount of keys) in the room (Hash Table) of size 365 seats (cells) for a (more than) 50% chance collision to happen (the birthday of two different people in that room is one of 365 days/slots).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-5" title="Go to the previous slide 3-5">&larr;</div>
<div class="electure-next" data-nextid="3-7" title="Go to the next slide 3-7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-7" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Issue 1: We have seen a simple hash function like the <b>h(v) = v%997</b> used in <a href="hashtable8592.html?slide=3-1"><u>Phone Numbers example</u></a> that maps large range of Integer keys into a smaller range of Integer keys, but how about non Integer keys? How to do such hashing efficiently?</p><br><p>Issue 2: We have seen that by hashing, or mapping, large range into smaller range, there will very likely be a collision. How to deal with them?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-6" title="Go to the previous slide 3-6">&larr;</div>
<div class="electure-next" data-nextid="4" title="Go to the next slide 4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>How to create a good hash function with these desirable properties?</p><ol><li>Fast to compute, i.e., in O(<b>1</b>),</li><li>Uses as minimum slots/Hash Table size <b>M</b> as possible,</li><li>Scatter the keys into different base addresses as uniformly as possible &in; [0..<b>M</b>-1],</li><li>Experience as minimum collisions as possible.</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-7" title="Go to the previous slide 3-7">&larr;</div>
<div class="electure-next" data-nextid="4-1" title="Go to the next slide 4-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Suppose we have a hash table of size <b>M</b> where keys are used to identify the satellite-data and a specific hash function is used to compute a hash value.</p><br><p>A <b>hash value/hash code</b> of key <b>v</b> is computed from the key <b>v</b> with the use of a hash function to get an Integer in the range 0 to <b>M</b>-1. This hash value is used as the base/home index/address of the Hash Table entry for the satellite-data.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4" title="Go to the previous slide 4">&larr;</div>
<div class="electure-next" data-nextid="4-2" title="Go to the next slide 4-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-2" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Using the <a href="hashtable8592.html?slide=3-1"><u>Phone Numbers</u></a> example, if we we define <b>h(v) = floor(v/1&thinsp;000&thinsp;000)</b>,<br>i.e., we select the first two digits a phone number.</p><pre>h(<span style="color: red;">66</span>&thinsp;75&thinsp;2378) = 66<br>h(<span style="color: red;">68</span>&thinsp;74&thinsp;4483) = 68</pre><p>Discuss: What happen when you use that hash function? Hint: See <a href="https://en.wikipedia.org/wiki/Telephone_numbers_in_Singapore#Numbering_plan" target="_blank"><u>this</u></a>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-1" title="Go to the previous slide 4-1">&larr;</div>
<div class="electure-next" data-nextid="4-3" title="Go to the next slide 4-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-3" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-2" title="Go to the previous slide 4-2">&larr;</div>
<div class="electure-next" data-nextid="4-4" title="Go to the next slide 4-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-4" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Before discussing the reality, let&#39;s discuss the ideal case: <a href="https://en.wikipedia.org/wiki/Perfect_hash_function" target="_blank"><u><b>perfect hash functions</b></u></a>.</p><br><p>A perfect hash function is a <b>one-to-one</b> mapping between keys and hash values, i.e., no collision at all. It is possible if all keys are known beforehand. For example, a compiler/interpreter search for reserved keywords. However, such cases are rare.</p><br><p>A minimal perfect hash function is achieved when the table size is the same as the number of keywords supplied. This case is even rarer.</p><br><p>If you are interested, you can explore <a href="https://www.gnu.org/software/gperf/"><u>GNU gperf</u></a>, a freely available perfect hash function generator written in C++ that automatically constructs perfect functions (a C++ program) from a user supplied list of keywords.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-3" title="Go to the previous slide 4-3">&larr;</div>
<div class="electure-next" data-nextid="4-5" title="Go to the next slide 4-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-5" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>People has tried various ways to hash a large range of Integers into a smaller range of Integers as uniformly as possible. In this e-Lecture, we jump directly to one of the best and most popular version: <b>h(v) = v%M</b>, i.e., map <b>v</b> into Hash Table of size <b>M</b> slots. The (%) is a modulo operator that gives the remainder after division. This is clearly fast, i.e., O(<b>1</b>) assuming that <b>v</b> does not exceed the natural Integer data type limit.</p><br><p>The Hash Table size <b>M</b> is set to be a reasonably large prime not near a power of 2, about 2+ times larger than the expected number of keys <b>N</b> that will ever be used in the Hash Table. This way, the <a href="https://en.wikipedia.org/wiki/Hash_table#Key_statistics" target="_blank"><u>load factor</u></a> &alpha; = N/M &lt; 0.5 &mdash; we shall see later that having low load factor, thereby sacrificing empty spaces, help improving Hash Table performance.</p><br><p>Discuss: What if we set <b>M</b> to be a power of 10 (decimal) or power of 2 (binary)?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-4" title="Go to the previous slide 4-4">&larr;</div>
<div class="electure-next" data-nextid="4-6" title="Go to the next slide 4-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-6" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-5" title="Go to the previous slide 4-5">&larr;</div>
<div class="electure-next" data-nextid="4-7" title="Go to the next slide 4-7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-7" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>People has also tried various ways to hash Strings into a small range of Integers as uniformly as possible. In this e-Lecture, we jump directly to one of the best and most popular version, shown below:</p><pre>int hash_function(string v) { // assumption 1: v uses [&#39;A&#39;..&#39;Z&#39;] only<br>  int sum = 0;                // assumption 2: v is a short string<br>  for (auto&amp; c : v) // for each character c in v<br>    sum = ((sum*26)%M + (c-&#39;A&#39;+1))%M; // M is table size<br>  return sum;<br>}</pre><p>Interactive (M = ∞), i.e., the modulo operation has no effect<br>v = <input type="text" id="strv" placeholder="Enter string v" maxlength="7">, <span class="slide-actions" onclick="doButtonAction145()">hash_string(v)</span> = <span id="hv">0</span>.</p><br><p>Discussion: In real life class, discuss the components of the hash function above, e.g., why loop through all characters?, will that be slower than O(<b>1</b>)?, why multiply with 26?, what if the string v uses more than just UPPERCASE chars?, etc.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-6" title="Go to the previous slide 4-6">&larr;</div>
<div class="electure-next" data-nextid="4-8" title="Go to the next slide 4-8">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-8" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-7" title="Go to the previous slide 4-7">&larr;</div>
<div class="electure-next" data-nextid="5" title="Go to the next slide 5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5" class="electure-dialog" style="top:70px;left:200px;width:500px;">
<p>There are two major ideas: <b>Open Addressing</b> versus <b>Closed Addressing</b> method.</p><br><p>In Open Addressing, all hashed keys are located in a single array. The hash code of a key gives its base address. Collision is resolved by checking/probing multiple alternative addresses (hence the name <b>open</b>) in the table based on a certain rule.</p><br><p>In Closed Addressing, the Hash Table looks like an <a href="graphds.html"><u>Adjacency List</u></a> (a graph data structure). The hash code of a key gives its fixed/<b>closed</b> base address. Collision is resolved by appending the collided keys inside an auxiliary data structure (usually any form of List ADT) identified by the base address.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-8" title="Go to the previous slide 4-8">&larr;</div>
<div class="electure-next" data-nextid="5-1" title="Go to the next slide 5-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-1" class="electure-dialog" style="top:70px;left:220px;width:500px;">
<p>There are three Open Addressing (OA) collision resolution techniques discussed in this visualization: Linear Probing (LP), Quadratic Probing (QP), and Double Hashing (DH).</p><br><p>To switch between the three modes, please click on the respective header.</p><br><p>Let:<br><b>M</b> = HT.length = the current hash table size,<br>base = (key%HT.length),<br>step = the current probing step,<br>secondary = smaller_prime - key%smaller_prime (to avoid zero &mdash; elaborated soon)<br><br>We will soon see that the probing sequences of the three modes are:<br>Linear Probing: i=(base+step*1) % M,<br>Quadratic Probing: i=(base+step*step) % M, and<br>Double Hashing: i=(base+step*secondary) % M.</p><br><p>All three OA techniques require that the load factor &alpha; = <b>N/M</b> < 1.0 (otherwise no more insertion is possible). If we can bound &alpha; to be a small constant (true if we know the expected largest <b>N</b> in our Hash Table application so that we can set up <b>M</b> accordingly, preferably < 0.5 for most OA variants), then all Search(v), Insert(v), and Remove(v) operations using Open Addressing will be O(<b>1</b>) &mdash; details omitted.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5" title="Go to the previous slide 5">&larr;</div>
<div class="electure-next" data-nextid="5-2" title="Go to the next slide 5-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-2" class="electure-dialog" style="top:70px;left:250px;width:500px;">
<p>Separate Chaining (SC) collision resolution technique is simple. We use <b>M</b> copies of auxiliary data structures, usually <a href="list058a.html?mode=DLL"><u>Doubly Linked Lists</u></a>. If two keys <b>a</b> and <b>b</b> both have the same hash value <b>i</b>, both will be appended to the (front/back) of Doubly Linked List <b>i</b> (in this visualization, we append to the back in O(<b>1</b>) with help of tail pointer). That&#39;s it, where the keys will be slotted in is completely dependent on the hash function itself, hence we also call Separate Chaining as Closed Addressing collision resolution technique.</p><br><p>If we use Separate Chaining, the load factor &alpha; = <b>N/M</b> is the average length of the <b>M</b> lists (unlike in Open Addressing, &alpha; can be "slightly over 1.0") and it will determine the performance of Search(v) as we may have to explore &alpha; elements on average. As Remove(v) also requires Search(v), its performance is similar as Search(v). Insert(v) is clearly O(<b>1</b>).</p><br><p>If we can bound &alpha; to be a small constant (true if we know the expected largest <b>N</b> in our Hash Table application so that we can set up <b>M</b> accordingly), then all Search(v), Insert(v), and Remove(v) operations using Separate Chaining will be O(<b>1</b>).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-1" title="Go to the previous slide 5-1">&larr;</div>
<div class="electure-next" data-nextid="6" title="Go to the next slide 6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>View the visualization of Hash Table above.</p><br><p>In this visualization, we allow the insertion of duplicate keys (i.e., a <i>multi</i>set). Since a multiset is more general than a set, simply just insert distinct integers in this visualization if you want to see how Hash Table works on distict integer keys only.</p><br><p>Due to limited screen space, we switch from default (1.0x) scale to 0.5x scale whenever you want to visualize Hash Table size <b>M</b> &in; [46..90] for OA techniques. The limit is a bit lower, i.e., <b>M</b> &in; [20..31] for SC technique.</p><br><p>The Hash Table is visualized horizontally like an array where index 0 is placed at the leftmost of the first row and index <b>M</b>-1 is placed at the rightmost of the last row but the details are different when we are visualizing Open Addressing (usually spans multiple rows) versus Separate Chaining (only the top row) collision resolution techniques.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-2" title="Go to the previous slide 5-2">&larr;</div>
<div class="electure-next" data-nextid="6-1" title="Go to the next slide 6-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6-1" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>There are three Open Addressing collision resolution techniques discussed in this visualization: Linear Probing (LP), Quadratic Probing (QP), and Double Hashing (DH).</p><br><p>For all three techniques, each Hash Table cell is displayed as a vertex with cell value of [0..99] displayed as the vertex label (in 0.5x scale, the vertex label is displayed on top of the smaller black dot). Without loss of generality, we do not show any satellite data in this visualization as we concentrate only on the arrangement of the keys. We reserve value -1 to indicate an &#39;EMPTY cell&#39; (visualized as a blank vertex) and -2 to indicate a &#39;DELETED cell&#39; (visualized as a vertex with abbreviated label "DEL"). The cell indices ranging from [0..<b>M</b>-1] are shown as <span style="color: red;">red label</span> below each vertex (rows of 15 indices in 1.0x scale or rows of 25 indices in 0.5x scale).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6" title="Go to the previous slide 6">&larr;</div>
<div class="electure-next" data-nextid="6-2" title="Go to the next slide 6-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6-2" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>For Separate Chaining (SC) collision resolution technique, the first row contains the <b>M</b> "H" (Head) pointers of <b>M</b> <a href="list058a.html?mode=DLL"><u>Doubly Linked Lists</u></a>.</p><br><p>Then, each Doubly Linked List <b>i</b> contains all keys that are hashed into <b>i</b> in arbitrary order (in 0.5x scale, the vertex label is displayed on top of the smaller black dot). Mathematically, all keys that can be expressed as <b>i</b> (mod <b>M</b>) &mdash; including all duplicates of <b>i</b> &mdash; are hashed into DLL <b>i</b>. Again, we do not store any satellite data in this visualization.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6-1" title="Go to the previous slide 6-1">&larr;</div>
<div class="electure-next" data-nextid="7" title="Go to the next slide 7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>In <b>Linear Probing</b> collision resolution technique, we scan forwards one index at a time for the <b>next empty/deleted slot</b> (wrapping around when we have reached the last slot) whenever there is a collision.</p><br><p>For example, let&#39;s assume we start with an empty Hash Table <b>HT</b> with table size <b>M = HT.length = 7</b> as shown above that uses index 0 to <b>M</b>-1 = 7-1 = 6. Notice that 7 is a prime number. The (primary) hash function is simple, <b>h(v) = v%M</b>.</p><br><p>This walk-through will show you the steps taken by Insert(v), Search(v), and Remove(v) operations when using Linear Probing as collision resolution technique.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6-2" title="Go to the previous slide 6-2">&larr;</div>
<div class="electure-next" data-nextid="7-1" title="Go to the next slide 7-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-1" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Now click <span class="slide-actions" onclick="doButtonAction79()">Insert([18,14,21])</span> — three individual insertions in one command.</p><br><p><span id="recap1">Recap (to be shown after you click the button above).</span></p><br><p>Formally, we describe <a href="hashtable787b.html?slide=5-1"><u>Linear Probing index <b>i</b></u></a> as <b>i = (base+step*1) % M</b> where <b>base</b> is the (primary) hash value of key <b>v</b>, i.e., <b>h(v)</b> and <b>step</b> is the Linear Probing step starting from 1.</p><br><p>Tips: To do a quick mental calculation of a (small) Integer <b>V</b> modulo <b>M</b>, we simply subtract <b>V</b> with the largest multiple of <b>M</b> ≤ <b>V</b>, e.g., 18%7 = 18-14 = 4, as 14 is the largest multiple of 7 that is ≤ 18.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7" title="Go to the previous slide 7">&larr;</div>
<div class="electure-next" data-nextid="7-2" title="Go to the next slide 7-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-2" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Now click <span class="slide-actions" onclick="doButtonAction80()">Insert([1,35])</span> (on top of the first three values inserted in the previous slide).</p><br><p><span id="recap2">Recap (to be shown after you click the button above)</span></p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-1" title="Go to the previous slide 7-1">&larr;</div>
<div class="electure-next" data-nextid="7-3" title="Go to the next slide 7-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-3" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Now we illustrate Search(v) operation while using Linear Probing as collision resolution technique. The steps taken are very similar as with Insert(v) operation, i.e., we start from the (primary) hash key value and check if we have found <b>v</b>, otherwise we move one index forward at a time (wrapping around if necessary) and recheck on whether we have found <b>v</b>. We stop when we encounter an empty cell which implies that <b>v</b> is not in Hash Table at all (as earlier Insert(v) operation would have placed <b>v</b> there otherwise).</p><br><p>Now click <span class="slide-actions" onclick="doButtonAction81()">Search(35)</span> &mdash; you should see probing sequence [0,1,2,3 (key 35 found)].</p><br><p>Now click <span class="slide-actions" onclick="doButtonAction82()">Search(7)</span> &mdash; [1,2,3,4, 5 (empty cell, so key 8 is not found in the Hash Table)].</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-2" title="Go to the previous slide 7-2">&larr;</div>
<div class="electure-next" data-nextid="7-4" title="Go to the next slide 7-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-4" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Now let&#39;s discuss Remove(v) operation.</p><br><p>If we just set <b>HT[i] = EMPTY</b> cell straightaway where <b>i</b> is the index that contains <b>v</b> (after linear probing if necessary), do you realize that we will cause a problem? Why?</p><br><p>Hint: Review the past three slides on how Insert(v) and Search(v) behave.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-3" title="Go to the previous slide 7-3">&larr;</div>
<div class="electure-next" data-nextid="7-5" title="Go to the next slide 7-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-5" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-4" title="Go to the previous slide 7-4">&larr;</div>
<div class="electure-next" data-nextid="7-6" title="Go to the next slide 7-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-6" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Now let&#39;s see the complete Remove(v). If we find <b>v</b> at index <b>i</b> (after Linear Probing if necessary), we have to set <b>HT[i] = DELETED</b> (abbreviated as <b>DEL</b> in this visualization) where <b>DEL</b> is a special symbol (generally you should only use a symbol that is <b>not</b> used in your application) to indicate that cell can be by-passed if necessary by future Search(v), but can be overwritten by future Insert(w). This strategy is called <b>Lazy Deletion</b>.</p><br><p>Now click <span class="slide-actions" onclick="doButtonAction83()">Remove(21)</span> — [0,1 (key 21 found and we set <b>H[1] = DEL</b>)].</p><br><p>Afterwards, please continue the discussion in the next slide.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-5" title="Go to the previous slide 7-5">&larr;</div>
<div class="electure-next" data-nextid="7-7" title="Go to the next slide 7-7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-7" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Now click <span class="slide-actions" onclick="doButtonAction81()">Search(35)</span> &mdash; [0,1 (bypassing that DELETED cell), 2,3 (found key 35)].</p><br><p>Imagine what would have happened if we <i>wrongly</i> set <b>H[1] = EMPTY</b>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-6" title="Go to the previous slide 7-6">&larr;</div>
<div class="electure-next" data-nextid="7-8" title="Go to the next slide 7-8">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-8" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Now click <span class="slide-actions" onclick="doButtonAction84()">Insert(28)</span> &mdash; you should see probing sequence [0,1 (found a cell with DEL symbol)], so it is actually can be overwritten with a new value without affecting the correctness of future Search(v). Therefore, we put 28 in index 1.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-7" title="Go to the previous slide 7-7">&larr;</div>
<div class="electure-next" data-nextid="7-9" title="Go to the next slide 7-9">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-9" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Although we can resolve collision with Linear Probing, it is not the most effective way.</p><br><p>We define a <b>cluster</b> to be a collection of consecutive occupied slots. A cluster that covers the base address of a key is called the <b>primary cluster</b> of the key.</p><br><p>Now notice that Linear Probing can create large primary clusters that will increase the running time of Search(v)/Insert(v)/Remove(v) operations beyond the advertised O(<b>1</b>).</p><br><p>See an example above with <b>M</b> = 31 and we have inserted 15 keys [0..14] so that they occupy cells [0..14] (&alpha; = 15/31 < 0.5). Now see how &#39;slow&#39; <span class="slide-actions" onclick="doButtonAction92()">Insert(31)</span> (the 16th key) is.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-8" title="Go to the previous slide 7-8">&larr;</div>
<div class="electure-next" data-nextid="7-10" title="Go to the next slide 7-10">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-10" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>The probe sequence of Linear Probing can be formally described as follows:</p><pre> h(v) // base address<br>(h(v) + 1*<span style="color: red;">1</span>) % M // 1st probing step if there is a collision<br>(h(v) + 2*<span style="color: red;">1</span>) % M // 2nd probing step if there is still a collision<br>(h(v) + 3*<span style="color: red;">1</span>) % M // 3rd probing step if there is still a collision<br>...<br>(h(v) + k*<span style="color: red;">1</span>) % M // k-th probing step, etc...</pre><p>During Insert(v), if there is a collision but there is an empty (or DEL) slot remains in the Hash Table, we are sure to find it after at most <b>M</b> Linear Probing steps, i.e., in O(<b>M</b>). And when we do, the collision will be resolved, but the primary cluster of the key <b>v</b> is expanded as a result and future Hash Table operations will get slower too. Try the slow <span class="slide-actions" onclick="doButtonAction127()">Search(31)</span> on the same Hash Table as in the previous slide but with many DEL markers (suppose {4, 5, 8, 9, 10, 12, 14} have just been deleted).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-9" title="Go to the previous slide 7-9">&larr;</div>
<div class="electure-next" data-nextid="7-11" title="Go to the next slide 7-11">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-11" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>In the previous slide (Primary Clustering, Part 1), we break the assumption that the hash function should uniformly distribute keys around [0..<b>M</b>-1]. In the next example, we will show that the problem of primary clustering can still happen even if the hash function distribute the keys into several relatively short primary clusters around [0..<b>M</b>-1].</p><br><p>On screen, you see <b>M</b> = 31 with 15 random integers between [0..99] inserted (there are several random but short primary clusters). If we then insert these next 4 keys {2, 9, 12, 1}, the first three keys will "plug" the three empty cells and accidentally annex (or combine) those neighboring (but previously disjointed) clusters into a (very) long primary cluster. So the next insertion of a key 1 that lands at (the beginning of) this long primary cluster will end up performing almost O(M) probing steps just to find an empty cell. Try <span class="slide-actions" onclick="doButtonAction128()">Insert([2,9,12,1])</span>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-10" title="Go to the previous slide 7-10">&larr;</div>
<div class="electure-next" data-nextid="8" title="Go to the next slide 8">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>To reduce primary clustering, we can modify the probe sequence to:</p><pre> h(v) // base address<br>(h(v) + 1*<span style="color: red;">1</span>) % M // 1st probing step if there is a collision<br>(h(v) + 2*<span style="color: red;">2</span>) % M // 2nd probing step if there is still a collision<br>(h(v) + 3*<span style="color: red;">3</span>) % M // 3rd probing step if there is still a collision<br>...<br>(h(v) + k*<span style="color: red;">k</span>) % M // k-th probing step, etc...</pre><p>That&#39;s it, the probe jumps quadratically, wrapping around the Hash Table as necessary.</p><br><p><font color="red">A very common mistake</font> as this is a different kind of Quadratic Probing:<br>Doing h(v), (h(v)+1) % M, (h(v)+1+4) % M, (h(v)+1+4+9) % M, ... </p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-11" title="Go to the previous slide 7-11">&larr;</div>
<div class="electure-next" data-nextid="8-1" title="Go to the next slide 8-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8-1" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Assume that we have called Insert(18) and Insert(10) into an initially empty Hash Table of size <b>M = HT.length = 7</b>. As 18%7 = 4 and 10%7 = 3, 18 and 3 do not collide and both reside in index 4 and 3 respectively as shown above.</p><br><p>Now, let&#39;s click <span class="slide-actions" onclick="doButtonAction85()">Insert(38)</span>.</p><br><p><span id="recap3">Recap (to be shown after you click the button above).</span></p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="8" title="Go to the previous slide 8">&larr;</div>
<div class="electure-next" data-nextid="8-2" title="Go to the next slide 8-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8-2" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Remove(x) and Search(y) operations are defined similarly. Just that this time we use Quadratic Probing instead of Linear Probing.</p><br><p>For example, assume that we have called Remove(18) after the previous slide and we mark <b>HT[4] = DEL</b>. If we then call <span class="slide-actions" onclick="doButtonAction91()">Search(38)</span>, we will use the same Quadratic Probing sequence as with previous slide, but passing through <b>HT[4]</b> which marked as DELETED.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="8-1" title="Go to the previous slide 8-1">&larr;</div>
<div class="electure-next" data-nextid="8-3" title="Go to the next slide 8-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8-3" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>In a glance, Quadratic Probing that jumps +1, +4, +9, +16, ... quadratically seems able to solve the primary clustering issue that we have with Linear Probing earlier, but is it the perfect collision resolution technique?</p><br><p>Try <span class="slide-actions" onclick="doButtonAction86()">Insert([12,17])</span>.</p><br><p>Do you realized what has just happened?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="8-2" title="Go to the previous slide 8-2">&larr;</div>
<div class="electure-next" data-nextid="8-4" title="Go to the next slide 8-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8-4" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>We can insert 12 easily as h(12) = 12%7 = 5 was empty previously (see above).</p><br><p>However we have major problem inserting key 17 even if we still have 3 empty slots as:<br>h(17) = 17%7 = 3 is already occupied by key 10,<br>(3+1*1) % 7 = 4 is already occupied by key 18, <br>(3+2*2) % 7 = 0 is already occupied by key 38, <br>(3+3*3) % 7 = 5 is already occupied by key 12, <br>(3+4*4) % 7 = 5 again is already occupied by key 12,<br>(3+5*5) % 7 = 0 again is already occupied by key 38,<br>(3+6*6) % 7 = 4 again is already occupied by key 18,<br>(3+7*7) % 7 = 3 again is already occupied by key 10,<br>it will <b>cycle forever</b> if we continue the Quadratic Probing...</p><br><p>Although we still have a few (3) empty cells, we are unable to insert this new value 17 into the Hash Table...</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="8-3" title="Go to the previous slide 8-3">&larr;</div>
<div class="electure-next" data-nextid="8-5" title="Go to the next slide 8-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8-5" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>If &alpha; &lt; 0.5 and <b>M</b> is a prime (&gt; 3), then we can always find an empty slot using (this form of) Quadratic Probing. Recall: &alpha; is the load factor and <b>M</b> is the Hash Table size (HT.length).</p><br><p>If the two requirements above are satisfied, we can prove that the first <b>M</b>/2 Quadratic Probing indices, including the base address <samp>h(v)</samp> are all distinct and unique.</p><br><p>But there is no such guarantee beyond that. Hence if we want to use Quadratic Probing, we need to ensure that &alpha; &lt; 0.5 (not enforced in this visualization but we do break the loop after <b>M</b> steps to prevent infinite loop).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="8-4" title="Go to the previous slide 8-4">&larr;</div>
<div class="electure-next" data-nextid="8-6" title="Go to the next slide 8-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8-6" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>We will use proof by contradiction. We first assume that two Quadratic Probing steps:<br>x and y, x != y (let&#39;s say x &lt; y), can yield the same address modulo <b>M</b>.</p><pre>h(v) + x*x = h(v) + y*y (mod M)<br>x*x = y*y (mod M) // strike out h(v) from both sides<br>x*x - y*y = 0 (mod M) // move y*y to LHS<br>(x-y)*(x+y) = 0 (mod M) // rearrange the formula</pre><p>Now, either <samp>(x-y)</samp> or <samp>(x+y)</samp> has to be equal to zero.<br>As our assumption says <samp>x != y</samp>, then <samp>(x-y)</samp> cannot be 0.<br>As <samp>0 &le; x &lt; y &le; (M/2)</samp> and <samp>M</samp> is a prime &gt; 3 (an odd Integer),<br>then <samp>(x+y)</samp> also cannot be 0 modulo <samp>M</samp>.</p><br><p>Contradiction!</p><br><p>So the first <samp>M/2</samp> Quadratic Probing steps cannot yield the same address modulo <samp>M</samp><br>(if we set <b>M</b> to be a prime number greater than 3).</p><br><p>Discussion: Can we make Quadratic Probing able to use the other ~50% of the table cells?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="8-5" title="Go to the previous slide 8-5">&larr;</div>
<div class="electure-next" data-nextid="8-7" title="Go to the next slide 8-7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8-7" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="8-6" title="Go to the previous slide 8-6">&larr;</div>
<div class="electure-next" data-nextid="8-8" title="Go to the next slide 8-8">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8-8" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>In Quadratic Probing, clusters are formed along the path of probing, instead of around the base address like in Linear Probing. These clusters are called <b>Secondary Clusters</b> and it is &#39;less visible&#39; compared to the Primary Clusters that plagued the Linear Probing.</p><br><p>Secondary clusters are formed as a result of using the same pattern in probing by colliding keys, i.e., if two distinct keys have the same base address, their Quadratic Probing sequences are going to be the same.</p><br><p>To illustrate this, see the screen with <b>M</b> = 31. We have populated this Hash Table with only 10 keys (so load factor α = 10/31 ≤ 0.5) and the Hash Table looks &#39;sparse enough&#39; (no visibly big primary cluster). However, if we then insert <span class="slide-actions" onclick="doButtonAction129()">Insert(62,93)</span>, despite the fact that there are many (31-10 = 21) empty cells and 62 != 93 (different keys that ends up hashed into index 0), we end up doing 10 probing steps along this &#39;less visible&#39; secondary cluster (notice that both {62, 93} follow similar Quadratic Probing sequences).</p><br><p>Secondary clustering in Quadratic Probing is not as bad as primary clustering in Linear Probing as a good hash function should theoretically disperse the keys into different base addresses ∈ [0..<b>M</b>-1] in the first place.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="8-7" title="Go to the previous slide 8-7">&larr;</div>
<div class="electure-next" data-nextid="9" title="Go to the next slide 9">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-9" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>To reduce primary and secondary clustering, we can modify the probe sequence to:</p><pre> h(v) // base address<br>(h(v) + 1*<span style="color: red;">h2(v)</span>) % M // 1st probing step if there is a collision<br>(h(v) + 2*<span style="color: red;">h2(v)</span>) % M // 2nd probing step if there is still a collision<br>(h(v) + 3*<span style="color: red;">h2(v)</span>) % M // 3rd probing step if there is still a collision<br>...<br>(h(v) + k*<span style="color: red;">h2(v)</span>) % M // k-th probing step, etc...</pre><p>That&#39;s it, the probe jumps according to the value of the <b>second hash function</b> <samp>h2(v)</samp>, wrapping around the Hash Table as necessary.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="8-8" title="Go to the previous slide 8-8">&larr;</div>
<div class="electure-next" data-nextid="9-1" title="Go to the next slide 9-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-9-1" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>If <samp>h2(v) = 1</samp>, then Double Hashing works exactly the same as Linear Probing.<br>So we generally wants <samp>h2(v) &gt; 1</samp> to avoid primary clustering.</p><br><p>If <samp>h2(v) = 0</samp>, then Double Hashing does not work for an obvious reason as any probing step multiplied by 0 remains 0, i.e. we stay at the base address forever during a collision. We need to avoid this.</p><br><p>Usually (for Integer keys), <samp>h2(v) = M&#39; - v%M&#39;</samp> where <samp>M&#39;</samp> is a smaller prime than <samp>M</samp>.<br>This makes <samp>h2(v)</samp> &in; [1..<b>M&#39;</b>], which is diverse enough to avoid secondary clustering.</p><br><p>The usage of the secondary hash function makes it theoretically hard to have either primary or secondary clustering issue.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="9" title="Go to the previous slide 9">&larr;</div>
<div class="electure-next" data-nextid="9-2" title="Go to the next slide 9-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-9-2" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Click <span class="slide-actions" onclick="doButtonAction87()">Insert([35,42])</span> to insert 35 and then 42 to the current Hash Table above.</p><br><p><span id="recap4">Recap (to be shown after you click the button above).</span></p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="9-1" title="Go to the previous slide 9-1">&larr;</div>
<div class="electure-next" data-nextid="9-3" title="Go to the next slide 9-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-9-3" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Remove(x) and Search(y) operations are defined similarly. Just that this time we use Double Hashing instead of Linear Probing or Quadratic Probing.</p><br><p>For example, assume that we have called Remove(17) after the previous slide and we mark <b>HT[3] = DEL</b>. If we then call <span class="slide-actions" onclick="doButtonAction81()">Search(35)</span>, we will use the same Double Hashing sequence as with previous slide, but passing through <b>HT[3]</b> which marked as DELETED.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="9-2" title="Go to the previous slide 9-2">&larr;</div>
<div class="electure-next" data-nextid="9-4" title="Go to the next slide 9-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-9-4" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>In summary, a good Open Addressing collision resolution technique needs to:</p><ol><li>Always find an empty slot if it exists,</li><li>Minimize clustering (of any kind),</li><li>Give different probe sequences when 2 different keys collide,</li><li>Fast, O(<b>1</b>).</li></ol><p>Now, let&#39;s see <a href="hashtable3420.html?slide=8-8"><u>the same test case that plagues Quadratic Probing</u></a> earlier. Now try <span class="slide-actions" onclick="doButtonAction129()">Insert(62,93)</span> again. Although h(62) = h(93) = 0 and their collide with 31 that already occupy index 0, their probing steps are not the same: h2(62) = 29-62%29 = 25 is not the same as h2(93) = 29-93%29 = 23.</p><br><p>Discussion: Double Hashing seems to fit the bill. But... Is Double Hashing strategy flexible enough to be used as the default library implementation of a Hash Table? Let&#39;s see...</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="9-3" title="Go to the previous slide 9-3">&larr;</div>
<div class="electure-next" data-nextid="10" title="Go to the next slide 10">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-10" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>Try <span class="slide-actions" onclick="doButtonAction93()">Insert([9,16,23,30,37,44])</span> to see how Insert(v) operation works if we use Separate Chaining as collision resolution technique. On such random insertions, the performance is good and each insertion is clearly O(<b>1</b>).</p><p><br></p><p>However if we try <span class="slide-actions" onclick="doButtonAction126()">Insert([68,90])</span>, notice that all Integers {68,90} are 2 (modulo 11) so all of them will be appended into the (back of) Doubly Linked List 2. We will have a long chain in that list. Note that due to the screen limitation, we limit the length of each Doubly Linked List to be at maximum 6.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="9-4" title="Go to the previous slide 9-4">&larr;</div>
<div class="electure-next" data-nextid="10-1" title="Go to the next slide 10-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-10-1" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>Try <span class="slide-actions" onclick="doButtonAction81()">Search(35)</span> to see that Search(v) can be made to run in O(<b>1+α</b>).</p><br><p>Try <span class="slide-actions" onclick="doButtonAction94()">Remove(35)</span> to see that Remove(v) can be made to run in O(<b>1+α</b>) too.</p><br><p>If <b>α</b> is large, Separate Chaining performance is not really O(<b>1</b>). However, if we roughly know the potential maximum number of keys <b>N</b> that our application will ever use, then we can set table size <b>M</b> accordingly such that <b>α = N/M</b> is a very low positive (floating-point) number, thereby making Separate Chaining performances to be expected O(<b>1</b>).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="10" title="Go to the previous slide 10">&larr;</div>
<div class="electure-next" data-nextid="10-2" title="Go to the next slide 10-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-10-2" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
Discussion: After all these explanations, which of the two collision resolution technique is the better one?
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="10-1" title="Go to the previous slide 10-1">&larr;</div>
<div class="electure-next" data-nextid="10-3" title="Go to the next slide 10-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-10-3" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="10-2" title="Go to the previous slide 10-2">&larr;</div>
<div class="electure-next" data-nextid="11" title="Go to the next slide 11">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-11" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>You have reached the end of the basic stuffs of this Hash Table data structure and we encourage you to explore further in the <b>Exploration Mode</b>.</p><br><p>However, we still have a few more interesting Hash Table challenges for you that are outlined in this section.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="10-3" title="Go to the previous slide 10-3">&larr;</div>
<div class="electure-next" data-nextid="11-1" title="Go to the next slide 11-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-11-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>The performance of Hash Table degrades when the load factor α gets higher. For (standard) Quadratic Probing collision resolution technique, insertions might fail when the Hash Table has α &gt; 0.5.</p><br><p>If that happens, we can <b>rehash</b>. We build another Hash Table about twice as big with a new hash function. We go through all keys in the original Hash Table, recompute the new hash values, and re-insert the keys (with their satellite-data) into the new, bigger Hash Table, before finally we delete the older, smaller Hash Table.</p><br><p>A rule of thumb is to rehash when α &ge; 0.5 if using Open Addressing and when α &gt; small constant (close to 1.0, as per requirement) if using Separate Chaining.</p><br><p>If we know the maximum number of total possible keys, we can always influence &alpha; to be a low number.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="11" title="Go to the previous slide 11">&larr;</div>
<div class="electure-next" data-nextid="11-2" title="Go to the next slide 11-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-11-2" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>However, if you ever need to implement a Hash Table in C++, Python, or Java, and your keys are either Integers or Strings, you can use the built-in C++ STL, Python standard library, or Java API, respectively. They already have good built-in implementation of default hash functions for Integers or Strings.</p><br><p>See C++ STL <a href="http://en.cppreference.com/w/cpp/container/unordered_map" target="_blank"><u>std::unordered_map</u></a>, <a href="http://en.cppreference.com/w/cpp/container/unordered_set" target="_blank"><u>std::unordered_set</u></a>, Python <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" target="_blank"><u>dict</u></a>, <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" target="_blank"><u>set</u></a>, or Java <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html" target="_blank"><u>HashMap</u></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html" target="_blank"><u>HashSet</u></a>.</p><br><p>For C++, note that the std::multimap/std::multiset implementations are also exist where duplicate keys are allowed.</p><br><p>For OCaml, we can use <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Hashtbl.html" target="_blank"><u>Hashtbl</u></a>.</p><br><p>However, here is our take of a simple Separate Chaining implementation: <a href="http://www.comp.nus.edu.sg/~stevenha/cs2040c/demos/HashTableDemo.cpp" target="_blank"><u>HashTableDemo.cpp</u></a> | <a href="http://www.comp.nus.edu.sg/~stevenha/cs2040c/demos/HashTableDemo.py" target="_blank"><u>py</u></a> | <a href="http://www.comp.nus.edu.sg/~stevenha/cs2040c/demos/HashTableDemo.java" target="_blank"><u>java</u></a>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="11-1" title="Go to the previous slide 11-1">&larr;</div>
<div class="electure-next" data-nextid="11-3" title="Go to the next slide 11-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-11-3" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="11-2" title="Go to the previous slide 11-2">&larr;</div>
<div class="electure-next" data-nextid="11-4" title="Go to the next slide 11-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-11-4" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Hash Table is an extremely good data structure to implement Table ADT if the (Integer or String) keys only need to be mapped to satellite-data, with O(<b>1</b>) performance for Search(v), Insert(v), and Remove(v) operations if the Hash Table is set up properly.</p><br><p>However, if we need to do <a href="bste090.html?slide=3-5"><u>much more with the keys</u></a>, we may need to use an alternative data structure.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="11-3" title="Go to the previous slide 11-3">&larr;</div>
<div class="electure-next" data-nextid="11-5" title="Go to the next slide 11-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-11-5" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>For a few more interesting questions about this data structure, please practice on <a href="https://visualgo.net/training?diff=Medium&amp;n=7&amp;tl=0&amp;module=hashtable"><u>Hash Table</u></a> training module (no login is required, but short and of medium difficulty setting only).</p><br><p>However, for registered users, you should login and then go to the <a href="https://visualgo.net/training"><u>Main Training Page</u></a> to officially clear this module and such achievement will be recorded in your user account.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="11-4" title="Go to the previous slide 11-4">&larr;</div>
<div class="electure-next" data-nextid="11-6" title="Go to the next slide 11-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-11-6" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Try to solve a few basic programming problems that somewhat requires the usage of Hash Table (especially if the input size is much larger):<ol><li><a href="https://open.kattis.com/problems/cd" target="_blank"><u>Kattis - cd</u></a> (the inputs are already sorted so alternative, non Hash Table solution exists; if the inputs are not sorted, this set intersection problem is best solved with help of a Hash Table),</li><li><a href="https://open.kattis.com/problems/oddmanout" target="_blank"><u>Kattis - oddmanout</u></a> (we can map large invitation codes into smaller range of integers; this is a practice of hashing (large range) of integers),</li><li><a href="https://open.kattis.com/problems/whatdoesthefoxsay" target="_blank"><u>Kattis - whatdoesthefoxsay</u></a> (we put sounds that are not fox into an unordered set; this is a practice of hashing strings).</li></ol>
<div class="electure-addition">
<hr>
<p>You have reached the last slide. Return to 'Exploration Mode' to start exploring!</p>
<p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
</div>
<div class="electure-prev" data-nextid="11-5" title="Go to the previous slide 11-5">&larr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>Close</u></span>
</div>
<div id="rotateDeviceOverlay" style="display: none;">
<div id="rotateDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please rotate your device to landscape mode for a better user experience</div>
<div id="widenDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please make the window wider for a better user experience</div>
</div>

<style>
        .create {
            bottom: 146px
        }
    </style>
<style>
        .search {
            bottom: 119px
        }
    </style>
<style>
        .insert {
            bottom: 92px
        }
    </style>
<style>
        .remove {
            bottom: 65px
        }
    </style>
<div id="actions" class="panel">
<p id="create">Create(M, N)</p>
<p id="search">Search(v)</p>
<p id="insert">Insert(v)</p>
<p id="remove">Remove(v)</p>
</div>
<div id="actions-hide" class="panel-hide"><span style="color:white; font-size: x-large; display: inline-block;">&gt;</span></div>
<div id="actions-extras">
<div class="create action-menu-pullout">
<p id="create-plaintext1" style="transform: translate(0%, 25%);" class="new-menu-option">
New HT of size
</p>
<div id="create-inputM" class="new-menu-option">
M = <input id="v-createM" type="number" title="Enter an Integer" autocomplete="off" min="5" max="90" value="23"> </div>
<p id="create-plaintext2" style="transform: translate(0%, 25%);" class="new-menu-option">
and
</p>
<div id="create-inputN" class="new-menu-option">
N = <input id="v-createN" type="number" title="Enter an Integer" autocomplete="off" min="0" max="90" value="11"> </div>
<p id="create-plaintext3" style="transform: translate(0%, 25%);" class="new-menu-option">
random integers (&alpha; = N/M = <span id="alpha">0.5</span>)
</p>
<div id="create-go" class="execAction new-menu-option coloured-menu-option" onClick="createTable()">
<p>Go</p>
</div>
<div id="create-err" class="err" style="float: left;"></div>
</div>
<div class="search action-menu-pullout">
<div id="search-input" class="new-menu-option">
v = <input id="v-search" type="number" title="Enter an Integer" autocomplete="off" min="0" max="99" value="7"> </div>
<div id="search-go" class="execAction new-menu-option coloured-menu-option" onClick="searchInteger()">
<p>Go</p>
</div>
<div id="search-err" class="err" style="float: left;"></div>
</div>
<div class="insert action-menu-pullout">
<div id="insert-input" class="new-menu-option">
v = <input id="v-insert" type="text" title="Enter an Integer or comma-separated array of Integers" autocomplete="off" value="35,77" style="width: 200px"> </div>
<div id="insert-go" class="execAction new-menu-option coloured-menu-option" onClick="insertInteger()">
<p>Go</p>
</div>
<div id="insert-err" class="err" style="float: left;"></div>
</div>
<div class="remove action-menu-pullout">
<div id="remove-input" class="new-menu-option">
v = <input id="v-remove" type="text" title="Enter an Integer or comma-separated array of Integers" autocomplete="off" value="35,77" style="width: 200px"> </div>
<div id="remove-go" class="execAction new-menu-option coloured-menu-option" onClick="removeInteger()">
<p>Go</p>
</div>
<div id="remove-err" class="err" style="float: left;"></div>
</div>
</div>

</div>

<div id="bottom-bar">
<a id="scale" style="display: none;">1.0x</a>
<a id="trigger-about">About</a>
<a id="trigger-team">Team</a>
<a id="trigger-terms">Terms of use</a>
<a id="trigger-privacy">Privacy Policy</a>
</div>
<div id="about" class="overlays">
<h4>About</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.</p><p>Featuring numerous advanced algorithms discussed in Dr. Steven Halim&#39;s book, &#39;Competitive Programming&#39; — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.</p><p>While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.</p><p>Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.</p><p>VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.</p><p>Equipped with a built-in question generator and answer verifier, VisuAlgo&#39;s "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students&#39; answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students&#39; mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.</p><p>VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:</p>
<a href="https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689" target="_blank"><u>id</u></a>,
<a href="http://blog.naver.com/visualgo_nus" target="_blank"><u>kr</u></a>,
<a href="https://www.facebook.com/groups/163215593699283/permalink/824003417620494/" target="_blank"><u>vn</u></a>,
<a href="http://pantip.com/topic/32736343" target="_blank"><u>th</u></a>.
</div>
</div>
<div id="team" class="overlays">
<h4>Team</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>
<strong><span style="line-height: 150%;">Project Leader &amp; Advisor (Jul 2011-present)</span></strong><br>
<a href="https://www.comp.nus.edu.sg/~stevenha/" target="_blank">Associate Professor Steven Halim</a>, School of Computing (SoC), National University of Singapore (NUS)<br>
<a href="https://www.linkedin.com/in/felixhalim/" target="_blank">Dr Felix Halim</a>, Senior Software Engineer, Google (Mountain View)
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 1</span></strong><br>
<b>CDTL TEG 1: Jul 2011-Apr 2012</b>: Koh Zi Chun, Victor Loh Bo Huai
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 1</span></strong><br>
<b>Jul 2012-Dec 2013</b>: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang Duy<br>
<b>Jun 2013-Apr 2014</b> <a href="https://www.rosemarietan.com/" target="_blank">Rose Marie Tan Zhao Yun</a>, Ivan Reinaldo
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 2</span></strong><br>
<b>CDTL TEG 2: May 2014-Jul 2014</b>: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 2</span></strong><br>
<b>Jun 2014-Apr 2015</b>: Erin Teo Yi Ling, Wang Zi<br>
<b>Jun 2016-Dec 2017</b>: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin Mudzakir<br>
<b>Aug 2021-Apr 2023</b>: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius<br>
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 3</span></strong><br>
<b>Optiver: Aug 2023-Oct 2023</b>: Bui Hong Duc, Oleh Naver, Tay Ngan Lin<br>
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 3</span></strong><br>
<b>Aug 2023-Apr 2024</b>: Xiong Jingya, Radian Krisno, Ng Wee Han<br>
</p>
<p>
List of translators who have contributed &ge; 100 translations can be found at <a href="https://visualgo.net/statistics">statistics</a> page.
</p>
<p>
<strong><span style="line-height: 150%;">Acknowledgements</span></strong><br>
NUS <a href="https://nus.edu.sg/cdtl" target="_blank"><u>CDTL</u></a> gave Teaching Enhancement Grant to kickstart this project.<div>For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.</div>
</p>
</div>
</div>
<div id="termsofuse" class="overlays">
<h4>Terms of use</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that you <b>spread the word about its existence to fellow Computer Science students and instructors</b>. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.</p><p>Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (<a href="https://visualgo.net/">https://visualgo.net</a>) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo&#39;s client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.</p><p>Please note that VisuAlgo&#39;s online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the &#39;training mode.&#39; The &#39;test mode&#39; offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.</p><p><strong><span style="line-height: 200%;">List of Publications</span></strong></p> <p>This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can click <a href="https://ioinformatics.org/journal/INFOL099.pdf" target="_blank">this link</a> to read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) and <a href="https://ioinformatics.org/journal/v9_2015_243_245.pdf" target="_blank">this link</a> for the short update in 2015 (to link VisuAlgo name with the previous project).</p><p><strong><span style="line-height: 200%;">Bug Reports or Request for New Features</span></strong></p> <p>VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.</p>
</div>
</div>
<div id="privacy-policy" class="overlays">
<h4>Privacy Policy</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p><b>Version 1.2 (Updated Fri, 18 Aug 2023).</b></p><p>Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.</p><p>Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).</p><p>Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.</p><p>For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.<br></p><p>For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.</p>
</div>
</div>
</div>


<script src="../../code.jquery.com/jquery-3.7.0.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
<script src="../../cdn.jsdelivr.net/npm/bootstrap%405.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<script src="../../unpkg.com/d3-force-boundary%400.0.1/dist/d3-force-boundary.min.js"></script>
<script>
  $(function () {
    // overlays stuffs
    $('#trigger-about').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#about').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-team').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#team').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-terms').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#termsofuse').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-privacy').click(function () {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#privacy-policy').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    })

    $('.close-overlay').click(function() {
      $('.overlays').fadeOut(function() {
        $('#dark-overlay').fadeOut();
      });
    });

    $('#dark-overlay').click(function() {
      $('.overlays').fadeOut();
      $('#dark-overlay').fadeOut();
      if (typeof GeometryWidget !== 'undefined') {
        GeometryWidget.stopLoop();
      }
    });
  })
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-1566631-4"></script>
<script>
      $.ajaxSetup({
        headers: {
          'X-CSRF-TOKEN': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H"
        }
      });

      // handles account dropdown menu
      $(function () {
        $('#language-dropdown-btn').click(function (e) {
          $('#language-dropdown-menu').css('display', 'block');
          $('#account-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function () {
          $('#language-dropdown-menu').css('display', 'none')
        })
      })

      $(function () {
        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        })
      })

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        if (retval) {
          $('#current-action').show();
          $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
          $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
          triggerRightPanels();
          isPlaying = true;
        }
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; ++i) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      const MOBILE_WIDTH = 1000;
      const matchMediaMobile = window.matchMedia(`only screen and (max-width: ${MOBILE_WIDTH}px)`);
      const matchMediaNarrow = window.matchMedia(`only screen and (max-width: 500px)`);
      function isMobile() {
        return matchMediaMobile.matches;
      }
      //To fix the issue of a narrow desktop window being asked to rotate, I am now checking for it based on the navigator.userAgent to see if its mobile or not.
      //This may change in the future if browsers decide to change the naming of userAgent for mobile browsers so may need to keep an eye on this.
      function isMobileOS() {
        return /Mobi/i.test(navigator.userAgent) && !/ipad/i.test(navigator.userAgent);
      }
      let portraitMatcher = window.matchMedia("(orientation:portrait)");
      function isPortrait() {
        return portraitMatcher.matches;
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.colour').css("color", surpriseColour);
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
        });
      });

/*
      // GA dropped 26 Jun 2023 and then made official on 18 Aug 2023
/*
      // the sunset-ed GA, commented on 26 Jun 2023, and Prof Halim doesn't bother to use anymore
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
*/

      // function setCookie(cname, cvalue, exdays) {
      //   const d = new Date();
      //   d.setTime(d.getTime() + (exdays*24*60*60*1000));
      //   let expires = "expires="+ d.toUTCString();
      //   document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
      // }

//       //         $(function() {
//           $('#gdpr-accept').click(function () {
// /*
//             // added on 26 Jun 2023
//             window.dataLayer = window.dataLayer || [];
//             function gtag(){dataLayer.push(arguments);}
//             gtag('js', new Date());

//             gtag('config', 'UA-1566631-4');
// */
// //            ga('create', 'UA-1566631-4', 'auto');
// //            ga('send', 'pageview');
//             setCookie('use_google_analytics', 'true', 365)
//             $('#gdpr-popup').hide()
//           });
//           $('#gdpr-reject').click(function () {
//             setCookie('use_google_analytics', 'false', 365)
//             $('#gdpr-popup').hide()
//           });
//         });
//       
      $('#gdpr-privacy-policy').click(function () {
        if ($(window).width() > 600) {
          $('#dark-overlay').fadeIn(function() {
            $('#privacy-policy').fadeIn();
          });
        }
        else
          alert('Sorry, this dialog is too big. Please load it on bigger screen');
      })
    </script>

<script src="../js/jquery-ui.min.js"></script>

<script src="../js/d3.min.js"></script>
<script src="../js/viz-1.0.10.js"></script>

<script src="../js/graph_library/constant.js"></script>
<script src="../js/graph_library/drawgraph.js"></script>
<script src="../js/graph_library/GraphEdgeWidget.js"></script>
<script src="../js/graph_library/GraphPolygonWidget.js"></script>
<script src="../js/graph_library/GraphVertexWidget.js"></script>
<script src="../js/graph_library/GraphWidget.js"></script>
<script src="../js/graph_library/helperObjects89db.js?refresh22aug9pm"></script> 
<script src="../js/graph_library/misc.js"></script>
<script src="../js/graph_library/properties.js"></script>
<script src="../js/graph_library/Widget.js"></script>
<script src="../js/graph_library/force_directed_library.js"></script>

<script>
      $(function () {
        let defaultPlaybackSpeed = 1;
                createPlaybackSpeedSlider(defaultPlaybackSpeed);

        $('#scale').show();

        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        });
        //Mobile Design Related DOM Manipulations
        if (isMobile()) {
          $("#status").css({
            "bottom": "10%",
            "height": "12%",
            "max-height": "54px"
          });
          $("#current-action").css("bottom", "22%");
          $('#status-hide').remove();
          $('#left-bar').remove();
          $('#right-bar').remove();
          $("#mode-menu").remove();
          $("#codetrace").css("z-index", 1);
          $("#bottom-bar a").hide();
          $("#bottom-bar").css("height", $("#topbar").css("height"));
          $(".speed-dropup-btn").show();
        $('#scale').show();
          $("#go-to-beginning").remove();
          $("#go-to-end").remove();
          $("#pause").remove();
          $("#play").remove();
          $("#previous").remove();
          $("#next").remove();

          //make progress bar longer
          $("#progress-bar").css({
            left: "30%",
            width: "60%",
            'margin-left': 0
          })
        }
      })

      let mobilePlaybackOverlayTimeout;
      $(function() {
        $("#viz").on("click", () => {
          if (isMobile()) {
            if ($("#mobile-playback-overlay").is(":hidden") && isPlaying) {
              $("#mobile-playback-overlay").fadeIn();
              hideMobilePlaybackOverlay(6000);
            } else {
              $("#mobile-playback-overlay").fadeOut();
            }
          }
        });
        $("#mobile-playback-overlay").on("click", (event) => {
          if (event.target === event.currentTarget) //to ensure clicks on the controls dont fade the overlay
            $("#mobile-playback-overlay").fadeOut();
          else
            hideMobilePlaybackOverlay(5000);
        })
      });
      function hideMobilePlaybackOverlay(timeOut) {
        if (mobilePlaybackOverlayTimeout)
          clearTimeout(mobilePlaybackOverlayTimeout);
        mobilePlaybackOverlayTimeout = setTimeout(() => {
            $("#mobile-playback-overlay").fadeOut();
        }, timeOut);
      }
      function mobilePlaybackPauseOrPlay() {
        if ($("#mobile-playback-overlay").hasClass("playing")) {
          pause();
          hideMobilePlaybackOverlay(5000);
        } else {
          play();
          hideMobilePlaybackOverlay(3000);
        }
      }
      let rewindLabelTimeout, forwardLabelTimeout;
      function mobilePlaybackRewind() {
        $("#mobile-playback-rewind-label").css("opacity", 1);
        if (rewindLabelTimeout)
          clearTimeout(rewindLabelTimeout);
        rewindLabelTimeout = setTimeout(() => {
          $("#mobile-playback-rewind-label").css("opacity", 0);
        }, 800);
        stepBackward(7);
      }
      function mobilePlaybackForward() {
        $("#mobile-playback-forward-label").css("opacity", 1);
        if (forwardLabelTimeout)
          clearTimeout(forwardLabelTimeout);
        forwardLabelTimeout = setTimeout(() => {
          $("#mobile-playback-forward-label").css("opacity", 0);
        }, 800);
        stepForward(7);
      }

      //let eLectureSessionHistory = {};
      const sectorColors = ['#05a4d0', '#f1c706', '#fa0202'];
      function setSlideTimelineColor(slideNo) {
        const sectionNo = slideNo.split('-')[0];
        $(`[slideNo="${slideNo}"]`).css('background', sectorColors[(parseInt(sectionNo) % 3)]);
      }

      let currSlideTimer = null; //global so that we can clear the timeout when required

      const lectureIds = [{"id":90,"category":"hashtable","order":1,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-02-19 11:06:56","updated_at":"2023-04-25 11:36:32","section":-1,"code":"$('#title-SC').click();\n$(\"#v-search\").val(8);\n$(\"#search\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"1","text":"<p>Hash Table is a data structure to map key to values (also called Table or Map Abstract Data Type\/ADT). It uses a <b>hash function<\/b> to map large or even non-Integer keys into a small range of Integer indices (typically [0..hash_table_size-1]).<\/p><br><p>The probability of two distinct keys colliding into the same index is <a href=\"?slide=3-5\"><u>relatively high<\/u><\/a> and each of this potential collision needs to be resolved to maintain data integrity.<\/p><br><p>There are several collision resolution strategies that will be highlighted in this visualization: Open Addressing (Linear Probing, Quadratic Probing, and Double Hashing) and Closed Addressing (Separate Chaining). Try clicking <span class=\"slide-actions\" onclick=\"doButtonAction82()\">Search(7)<\/span> for a sample animation of searching a specific value 7 in a randomly created Hash Table using Separate Chaining technique (duplicates are allowed).<\/p>","title":"Hash Table"},{"id":472,"category":"hashtable","order":2,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-26 08:13:34","updated_at":"2023-04-24 12:22:52","section":-1,"code":"","section_order":-1,"value":"2","text":"<p>Hashing is an algorithm (via a hash function) that maps large data sets of variable length, called keys, not necessarily Integers, into smaller Integer data sets of a fixed length.<\/p><br><p>A Hash Table is a data structure that uses a hash function to efficiently map keys to values (Table or Map ADT), for efficient search\/retrieval,  insertion, and\/or removals.<\/p><br><p>Hash Table is widely used in many kinds of computer software, particularly for <a href=\"https:\/\/en.wikipedia.org\/wiki\/Associative_array\" target=\"_blank\"><u>associative arrays<\/u><\/a>, database indexing, caches, and sets.<\/p><br><p>In this e-Lecture, we will digress to Table ADT, the basic ideas of <a href=\"?slide=3\"><u>Hashing<\/u><\/a>, the discussion of <a href=\"?slide=4\"><u>Hash Functions<\/u><\/a> before going into the details of <a href=\"?slide=5\"><u>Hash Table<\/u><\/a> data structure itself.<\/p>","title":"Motivation"},{"id":473,"category":"hashtable","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-26 08:15:11","updated_at":"2023-04-24 12:22:57","section":472,"code":"","section_order":2,"value":"2-1","text":"<p>A Table ADT must support <b>at least<\/b> the following three operations as efficient as possible:<\/p><ol><li>Search(v) \u2014 determine if <b>v<\/b> exists in the ADT or not,<\/li><li>Insert(v) \u2014 insert <b>v<\/b> into the ADT,<\/li><li>Remove(v) \u2014 remove <b>v<\/b> from the ADT.<\/li><\/ol><p>Hash Table is one possible good implementation for this Table ADT (the other one is <a href=\".\/bst?slide=13-1\"><u>this<\/u><\/a>).<\/p><hr><p>PS1: For two weaker implementations of Table ADT, you can click the respective link: <a href=\".\/bst?slide=3-2\"><u>unsorted array<\/u><\/a> or a <a href=\".\/bst?slide=3-3\"><u>sorted array<\/u><\/a> to read the detailed discussions.<\/p><hr><p>PS2: In live class, you may want to compare the requirements of Table ADT vs <a href=\".\/list?slide=2-1\" target=\"_blank\"><u>List ADT<\/u><\/a>.<\/p>","title":"Table ADT"},{"id":475,"category":"hashtable","order":2,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-26 08:32:45","updated_at":"2023-04-24 12:22:59","section":472,"code":"","section_order":2,"value":"2-2","text":"<p>When the range of the <b>Integer<\/b> keys is <b>small<\/b>, e.g., [0..<b>M<\/b>-1], we can use an initially empty (Boolean) array <b>A<\/b> of size <b>M<\/b> and implement the following Table ADT operations <b>directly<\/b>:<\/p><ol><li>Search(v): Check if <b>A[v]<\/b> is true (filled) or false (empty),<\/li><li>Insert(v): Set <b>A[v]<\/b> to be true (filled),<\/li><li>Remove(v): Set <b>A[v]<\/b> to be false (empty).<\/li><\/ol><p>That&#39;s it, we use the small Integer key itself to determine the address in array <b>A<\/b>, hence the name <b>Direct Addressing<\/b>. It is clear that all three major Table ADT operations are O(<b>1<\/b>).<\/p><br><p>PS: This idea is also used elsewhere, e.g., in <a href=\".\/sorting?slide=15\"><u>Counting Sort<\/u><\/a>.<\/p>","title":"Direct Addressing Table (DAT)"},{"id":476,"category":"hashtable","order":3,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-26 08:46:35","updated_at":"2023-04-24 12:27:36","section":472,"code":"","section_order":2,"value":"2-3","text":"<p>In Singapore (<a href=\"https:\/\/en.wikipedia.org\/wiki\/List_of_bus_routes_in_Singapore\" target=\"_blank\"><u>as of Apr 2023<\/u><\/a>), bus routes are numbered from [2..991].<\/p><br><p>Not all integers between [2..991] are currently used, e.g., there is no bus route 989 \u2014 Search(989) should return false. A new bus route <b>x<\/b> may be introduced, i.e., Insert(<b>x<\/b>) or an existing bus route <b>y<\/b> may be discontinued, i.e., Remove(<b>y<\/b>).<\/p><br><p>As the range of possible bus routes is <b>small<\/b>, to record the data whether a bus route number exists or not, we can use a DAT with a Boolean array of size 1000 (generally, it is useful to give a few extra buffer cells on top of the current largest bus number of 991).<\/p>","title":"Example of DAT"},{"id":509,"category":"hashtable","order":4,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 06:14:10","updated_at":"2023-04-24 12:23:04","section":472,"code":"","section_order":2,"value":"2-4","text":"<p>Notice that we can always add <a href=\"https:\/\/stackoverflow.com\/questions\/14551845\/what-is-satellite-information-in-data-structures\" target=\"_blank\"><u><b>satellite data<\/b><\/u><\/a> instead of just using a Boolean array to record the existence of the keys.<\/p><br><p>For example, we can use an <b>associative<\/b> String array <b>A<\/b> instead to map a bus route number to its operator name, e.g.,<br><\/p><pre>A[2] = \"Go-Ahead Singapore\",<br>A[10] = \"SBS Transit\",<br>A[183] = \"Tower Transit Singapore\",<br>A[188] = \"SMRT Buses\", etc.<\/pre><p>Discussion: Can you think of a few other real-life DAT examples?<\/p>","title":"Example of DAT with Satellite Data"},{"id":479,"category":"hashtable","order":5,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-26 09:18:48","updated_at":"2023-04-24 12:23:07","section":472,"code":"","section_order":2,"value":"2-5","text":"<ol><li>Counting the frequency of keypresses, we can use ASCII values (256 characters),<\/li><li>Counting the frequency of each (of the 26) alphabets of a string,<\/li><li>Postal code that maps an address to a number,<\/li><li>Mailbox in an apartment block with exactly one small box per unit in the block,<\/li><li>Etc<\/li><\/ol>","title":"The Answer"},{"id":477,"category":"hashtable","order":6,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-26 09:14:22","updated_at":"2023-04-24 12:23:10","section":472,"code":"","section_order":2,"value":"2-6","text":"<p>The keys must be (or can be easily mapped to) <b>non-negative Integer<\/b> values. Note that basic DAT has problem in the full version of the example in the previous few slides as there are actually variations of bus route numbers in Singapore, e.g., 96B, 151A, NR10, etc.<\/p><br><p>The range of keys must be <b>small<\/b>.<br>The memory usage will be (insanely) large if we have (insanely) large range.<\/p><br><p>The keys must be dense, i.e., not many gaps in the key values.<br>DAT will contain too many empty (and wasted) cells otherwise.<\/p><br><p>We will overcome these restrictions with hashing.<\/p>","title":"DAT Limitations"},{"id":482,"category":"hashtable","order":3,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-26 13:19:04","updated_at":"2023-04-24 12:28:38","section":-1,"code":"","section_order":-1,"value":"3","text":"<p>Using hashing, we can:<\/p><ol><li>Map (some) <b>non-Integer<\/b> keys (e.g., Strings) to Integers keys,<\/li><li>Map <b>large<\/b> Integers to <b>smaller<\/b> Integers.<\/li><\/ol>","title":"Hashing: Ideas"},{"id":483,"category":"hashtable","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-26 13:20:38","updated_at":"2023-04-24 12:28:40","section":482,"code":"","section_order":3,"value":"3-1","text":"<p>For example, we have <b>N<\/b> = 400 Singapore phone numbers (Singapore phone number has 8 digits, so there are up to 10^8 = 100M possible phone numbers in Singapore).<\/p><br><p>Instead of using a DAT and use a <b>gigantic<\/b> array up to size <b>M<\/b> = 100 Million, we can use the following simple hash function <b>h(v) = v%997<\/b>.<\/p><br><p>This way, we map 8 digits phone numbers <b>6675&thinsp;2378<\/b> and <b>6874&thinsp;4483<\/b> into up to 3 digits <b>h(6675&thinsp;2378) = 237<\/b> and <b>h(6874&thinsp;4483) = 336<\/b>, respectively. Therefore, we only need to prepare an array of size <b>M<\/b> = 997 (997 is a prime) instead of <b>M<\/b> = 100 Million.<\/p>","title":"Phone Numbers Example"},{"id":484,"category":"hashtable","order":2,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-26 13:24:21","updated_at":"2023-04-24 12:28:43","section":482,"code":"","section_order":3,"value":"3-2","text":"<p>With hashing, we can now implement the following Table ADT operations using Integer array (instead of Boolean array) as follows:<\/p><ol><li>Search(v): Check if <b>A[h(v)] != -1<\/b> (we use -1 for an empty cell assuming <b>v &ge; 0<\/b>),<\/li><li>Insert(v): Set <b>A[h(v)] = v<\/b> (we hash <b>v<\/b> into <b>h(v)<\/b> so we need to somehow record key <b>v<\/b>),<\/li><li>Remove(v): Set <b>A[h(v)] = -1<\/b> &mdash; to be elaborated further.<\/li><\/ol>","title":"Hash Table Preview"},{"id":508,"category":"hashtable","order":3,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 06:09:40","updated_at":"2023-04-24 12:28:45","section":482,"code":"","section_order":3,"value":"3-3","text":"<p>If we have keys that map to satellite data and we want to record the original keys too, we can implement the Hash Table using pair of (Integer, satellite-data-type) array as follows:<\/p><ol><li>Search(v): Return <b>A[h(v)]<\/b>, which is a <b>pair (v, satellite-data)<\/b>, possibly empty,<\/li><li>Insert(v, satellite-data): Set <b>A[h(v)] = pair(v, satellite-data)<\/b>,<\/li><li>Remove(v): Set <b>A[h(v)] = (empty pair)<\/b> &mdash; to be elaborated further.<\/li><\/ol><p>However, by now you should notice that something is incomplete...<\/p>","title":"Hash Table with Satellite Data"},{"id":485,"category":"hashtable","order":4,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-26 13:26:05","updated_at":"2023-04-24 12:28:47","section":482,"code":"","section_order":3,"value":"3-4","text":"<p>A hash function may, and quite likely, map <b>different keys (Integer or not)<\/b> into the <b>same Integer slot<\/b>, i.e., a <b>many-to-one<\/b> mapping instead of <b>one-to-one<\/b> mapping.<\/p><br><p>For example, <b>h(6675&thinsp;2378) = 237<\/b> from <a href=\"?slide=3-1\"><u>three slides earlier<\/u><\/a> and if we want to insert another phone number <b>6675&thinsp;4372<\/b>, we will have a problem as <b>h(6675&thinsp;4372) = 237<\/b> too.<\/p><br><p>This situation is called a <b>collision<\/b>, i.e., two (or more) keys have the <b>same hash value<\/b>.<\/p>","title":"Collision"},{"id":517,"category":"hashtable","order":5,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 06:39:32","updated_at":"2023-04-24 12:28:50","section":482,"code":"","section_order":3,"value":"3-5","text":"<p>The <a href=\"https:\/\/en.wikipedia.org\/wiki\/Birthday_problem\" target=\"_blank\"><u>Birthday (von Mises) Paradox<\/u><\/a> asks: &#39;How many people (number of keys) must be in a room (Hash Table) of size 365 seats (cells) before the probability that some person&nbsp;<b>share a birthday<\/b> (collision, two keys are hashed to the same cell), ignoring the leap years (i.e., all years have 365 days), becomes &gt; 50 percent (i.e., more likely than not)?&#39;<\/p><br><p>The answer, which maybe surprising for some of us, is <span id=\"vonmises\" style=\"color: red;\"><span class=\"slide-actions\" onclick=\"doButtonAction88()\">Reveal<\/span><\/span>.<\/p><br><p>Let&#39;s do some calculation.<\/p>","title":"Probability of Collision"},{"id":518,"category":"hashtable","order":6,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 06:42:00","updated_at":"2023-04-24 12:28:52","section":482,"code":"","section_order":3,"value":"3-6","text":"<p>Let <b>Q(n)<\/b> be the probability of <b>unique<\/b> birthday for <b>n<\/b> people in a room.<br><b>Q(n) = 365\/365 \u00d7 364\/365 \u00d7 363\/365 \u00d7 ... \u00d7 (365-n+1)\/365<\/b>,<br>i.e., the first person&#39;s birthday can be any of the 365 days, the second person&#39;s birthday can be any of the 365 days except the first person&#39;s birthday, and so on.<\/p><br><p>Let <b>P(n)<\/b> be the probability of <b>same birthday<\/b> (collision) for <b>n<\/b> people in a room.<br><b>P(n) = 1-Q(n)<\/b>.<\/p><br><p>We compute that&nbsp;<b><a href=\"https:\/\/www.wolframalpha.com\/input\/?i=1.00-(365%2F365*364%2F365*...*343%2F365)\" target=\"_blank\"><u>P(23) = 0.507<\/u><\/a> &gt; 0.5 (50%)<\/b>.<\/p><br><p>Thus, we only need <b>23 people<\/b> (a small amount of keys) in the room (Hash Table) of size 365 seats (cells) for a (more than) 50% chance collision to happen (the birthday of two different people in that room is one of 365 days\/slots).<\/p>","title":"The Calculation"},{"id":510,"category":"hashtable","order":7,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 06:21:25","updated_at":"2023-04-24 12:28:56","section":482,"code":"","section_order":3,"value":"3-7","text":"<p>Issue 1: We have seen a simple hash function like the <b>h(v) = v%997<\/b> used in <a href=\"?slide=3-1\"><u>Phone Numbers example<\/u><\/a> that maps large range of Integer keys into a smaller range of Integer keys, but how about non Integer keys? How to do such hashing efficiently?<\/p><br><p>Issue 2: We have seen that by hashing, or mapping, large range into smaller range, there will very likely be a collision. How to deal with them?<\/p>","title":"Two Important Issues"},{"id":486,"category":"hashtable","order":4,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-26 13:33:48","updated_at":"2023-04-24 12:30:39","section":-1,"code":"","section_order":-1,"value":"4","text":"<p>How to create a good hash function with these desirable properties?<\/p><ol><li>Fast to compute, i.e., in O(<b>1<\/b>),<\/li><li>Uses as minimum slots\/Hash Table size <b>M<\/b> as possible,<\/li><li>Scatter the keys into different base addresses as uniformly as possible &in; [0..<b>M<\/b>-1],<\/li><li>Experience as minimum collisions as possible.<\/li><\/ol>","title":"Hash Functions"},{"id":511,"category":"hashtable","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 06:25:05","updated_at":"2023-04-24 12:30:43","section":486,"code":"","section_order":4,"value":"4-1","text":"<p>Suppose we have a hash table of size <b>M<\/b> where keys are used to identify the satellite-data and a specific hash function is used to compute a hash value.<\/p><br><p>A <b>hash value\/hash code<\/b> of key <b>v<\/b> is computed from the key <b>v<\/b> with the use of a hash function to get an Integer in the range 0 to <b>M<\/b>-1. This hash value is used as the base\/home index\/address of the Hash Table entry for the satellite-data.<\/p>","title":"Preliminaries"},{"id":513,"category":"hashtable","order":2,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 06:34:23","updated_at":"2023-04-24 12:31:19","section":486,"code":"","section_order":4,"value":"4-2","text":"<p>Using the <a href=\"?slide=3-1\"><u>Phone Numbers<\/u><\/a> example, if we we define <b>h(v) = floor(v\/1&thinsp;000&thinsp;000)<\/b>,<br>i.e., we select the first two digits a phone number.<\/p><pre>h(<span style=\"color: red;\">66<\/span>&thinsp;75&thinsp;2378) = 66<br>h(<span style=\"color: red;\">68<\/span>&thinsp;74&thinsp;4483) = 68<\/pre><p>Discuss: What happen when you use that hash function? Hint: See <a href=\"https:\/\/en.wikipedia.org\/wiki\/Telephone_numbers_in_Singapore#Numbering_plan\" target=\"_blank\"><u>this<\/u><\/a>.<\/p>","title":"Example of a Bad Hash Function"},{"id":529,"category":"hashtable","order":3,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-30 03:46:49","updated_at":"2023-04-24 12:30:49","section":486,"code":"","section_order":4,"value":"4-3","text":"<p>It will cause a major collision problem as all fixed line starts with a six (6) (and rarely, a three (3)) and all mobile numbers starts with either an eight (8) or a nine (9) in Singapore.<\/p><br><p>Therefore the <b>N<\/b> = <a href=\"?slide=3-1\"><u>400 phone numbers<\/u><\/a> to be hashed, which can be either fixed or mobile numbers in Singapore, will only have 40 different possible hash values [30..39] + [60..69] + [80..99] instead of 100 [00..99].<\/p><br><p>In real life class, we may digress to discuss more example of other bad hash functions.<\/p>","title":"The Answer"},{"id":514,"category":"hashtable","order":4,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 06:34:42","updated_at":"2023-04-24 12:30:51","section":486,"code":"","section_order":4,"value":"4-4","text":"<p>Before discussing the reality, let&#39;s discuss the ideal case: <a href=\"https:\/\/en.wikipedia.org\/wiki\/Perfect_hash_function\" target=\"_blank\"><u><b>perfect hash functions<\/b><\/u><\/a>.<\/p><br><p>A perfect hash function is a <b>one-to-one<\/b> mapping between keys and hash values, i.e., no collision at all. It is possible if all keys are known beforehand. For example, a compiler\/interpreter search for reserved keywords. However, such cases are rare.<\/p><br><p>A minimal perfect hash function is achieved when the table size is the same as the number of keywords supplied. This case is even rarer.<\/p><br><p>If you are interested, you can explore <a href=\"https:\/\/www.gnu.org\/software\/gperf\/\"><u>GNU gperf<\/u><\/a>, a freely available perfect hash function generator written in C++ that automatically constructs perfect functions (a C++ program) from a user supplied list of keywords.<\/p>","title":"Perfect Hash Function"},{"id":515,"category":"hashtable","order":5,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 06:35:02","updated_at":"2023-04-24 12:30:53","section":486,"code":"","section_order":4,"value":"4-5","text":"<p>People has tried various ways to hash a large range of Integers into a smaller range of Integers as uniformly as possible. In this e-Lecture, we jump directly to one of the best and most popular version: <b>h(v) = v%M<\/b>, i.e., map <b>v<\/b> into Hash Table of size <b>M<\/b> slots. The (%) is a modulo operator that gives the remainder after division. This is clearly fast, i.e., O(<b>1<\/b>) assuming that <b>v<\/b> does not exceed the natural Integer data type limit.<\/p><br><p>The Hash Table size <b>M<\/b> is set to be a reasonably large prime not near a power of 2, about 2+ times larger than the expected number of keys <b>N<\/b> that will ever be used in the Hash Table. This way, the <a href=\"https:\/\/en.wikipedia.org\/wiki\/Hash_table#Key_statistics\" target=\"_blank\"><u>load factor<\/u><\/a> &alpha; = N\/M &lt; 0.5 &mdash; we shall see later that having low load factor, thereby sacrificing empty spaces, help improving Hash Table performance.<\/p><br><p>Discuss: What if we set <b>M<\/b> to be a power of 10 (decimal) or power of 2 (binary)?<\/p>","title":"Hashing Integer - Best Practice"},{"id":530,"category":"hashtable","order":6,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-30 04:44:08","updated_at":"2023-04-24 12:30:55","section":486,"code":"","section_order":4,"value":"4-6","text":"<p>If <b>M<\/b> is a power of 10, i.e., <b>10<sup>L<\/sup><\/b>, then <b>v%M<\/b> = <b>v%10<sup>L<\/sup><\/b> will yield the last <b>L<\/b> digits of the key <b>v<\/b>,<br>which is a bad hash function.<\/p><br><p>If <b>M<\/b> is a power of 2, i.e., <b>2<sup>K<\/sup><\/b>, then <b>v%M<\/b> = <b>v%2<sup>K<\/sup><\/b> will yield the last <b>k<\/b> bits of the key <b>v<\/b>,<br>which is also a bad hash function.<\/p><br><p>Actually, any other power of other base number is equally bad and there is a reason why we use <a href=\"https:\/\/en.wikipedia.org\/wiki\/Euler%27s_totient_function#Some_values_of_the_function\" target=\"_blank\"><u>prime<\/u><\/a>.<\/p>","title":"The Answer"},{"id":516,"category":"hashtable","order":7,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 06:35:29","updated_at":"2023-04-25 11:37:48","section":486,"code":"","section_order":4,"value":"4-7","text":"<p>People has also tried various ways to hash Strings into a small range of Integers as uniformly as possible. In this e-Lecture, we jump directly to one of the best and most popular version, shown below:<\/p><pre>int hash_function(string v) { \/\/ assumption 1: v uses [&#39;A&#39;..&#39;Z&#39;] only<br>  int sum = 0;                \/\/ assumption 2: v is a short string<br>  for (auto&amp; c : v) \/\/ for each character c in v<br>    sum = ((sum*26)%M + (c-&#39;A&#39;+1))%M; \/\/ M is table size<br>  return sum;<br>}<\/pre><p>Interactive (M = \u221e), i.e., the modulo operation has no effect<br>v = <input type=\"text\" id=\"strv\" placeholder=\"Enter string v\" maxlength=\"7\">, <span class=\"slide-actions\" onclick=\"doButtonAction145()\">hash_string(v)<\/span> = <span id=\"hv\">0<\/span>.<\/p><br><p>Discussion: In real life class, discuss the components of the hash function above, e.g., why loop through all characters?, will that be slower than O(<b>1<\/b>)?, why multiply with 26?, what if the string v uses more than just UPPERCASE chars?, etc.<\/p>","title":"Hashing String - Best Practice"},{"id":531,"category":"hashtable","order":8,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-30 04:57:03","updated_at":"2023-04-24 12:31:02","section":486,"code":"","section_order":4,"value":"4-8","text":"<p>If we do not &#39;shift&#39; the sum by multiplying it with 26 (there are 26 characters \u2208 [&#39;A&#39;..&#39;Z&#39;] \u2014 adjust this if the String\/key <b>v<\/b> can have more character range), we will have a situation where all |<b>v<\/b>|! anagrams of the String\/key <b>v<\/b> have the same hash value. When we &#39;shift&#39; the sum before adding the next character, we give weight to each character position that affects the hash code.<\/p><br><p>The easier way to explain the for-loop is to think of a base-26 number system.<\/p><br><p>We loop through all characters as taking (a small) subset of the characters may cause too many collision. Thus the time complexity is actually polynomial w.r.t the length of the String key. But if each String contains just a few characters, we can treat O(<b>|v|<\/b>) = O(<b>1<\/b>).<\/p>","title":"The Answer"},{"id":91,"category":"hashtable","order":5,"top":"70px","right":"","bottom":"","left":"200px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-02-19 11:21:05","updated_at":"2023-04-24 13:02:04","section":-1,"code":"","section_order":-1,"value":"5","text":"<p>There are two major ideas: <b>Open Addressing<\/b> versus <b>Closed Addressing<\/b> method.<\/p><br><p>In Open Addressing, all hashed keys are located in a single array. The hash code of a key gives its base address. Collision is resolved by checking\/probing multiple alternative addresses (hence the name <b>open<\/b>) in the table based on a certain rule.<\/p><br><p>In Closed Addressing, the Hash Table looks like an <a href=\".\/graphds\"><u>Adjacency List<\/u><\/a> (a graph data structure). The hash code of a key gives its fixed\/<b>closed<\/b> base address. Collision is resolved by appending the collided keys inside an auxiliary data structure (usually any form of List ADT) identified by the base address.<\/p>","title":"Collision Resolution"},{"id":534,"category":"hashtable","order":1,"top":"70px","right":"","bottom":"","left":"220px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-30 06:56:51","updated_at":"2023-04-25 12:28:30","section":91,"code":"$('#title-LP').click();","section_order":5,"value":"5-1","text":"<p>There are three Open Addressing (OA) collision resolution techniques discussed in this visualization: Linear Probing (LP), Quadratic Probing (QP), and Double Hashing (DH).<\/p><br><p>To switch between the three modes, please click on the respective header.<\/p><br><p>Let:<br><b>M<\/b> = HT.length = the current hash table size,<br>base = (key%HT.length),<br>step = the current probing step,<br>secondary = smaller_prime - key%smaller_prime (to avoid zero &mdash; elaborated soon)<br><br>We will soon see that the probing sequences of the three modes are:<br>Linear Probing: i=(base+step*1) % M,<br>Quadratic Probing: i=(base+step*step) % M, and<br>Double Hashing: i=(base+step*secondary) % M.<\/p><br><p>All three OA techniques require that the load factor &alpha; = <b>N\/M<\/b> < 1.0 (otherwise no more insertion is possible). If we can bound &alpha; to be a small constant (true if we know the expected largest <b>N<\/b> in our Hash Table application so that we can set up <b>M<\/b> accordingly, preferably < 0.5 for most OA variants), then all Search(v), Insert(v), and Remove(v) operations using Open Addressing will be O(<b>1<\/b>) &mdash; details omitted.<\/p>","title":"Open Addressing (OA)"},{"id":535,"category":"hashtable","order":2,"top":"70px","right":"","bottom":"","left":"250px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-30 07:02:29","updated_at":"2023-04-25 12:26:02","section":91,"code":"$('#title-SC').click();","section_order":5,"value":"5-2","text":"<p>Separate Chaining (SC) collision resolution technique is simple. We use <b>M<\/b> copies of auxiliary data structures, usually <a href=\".\/list?mode=DLL\"><u>Doubly Linked Lists<\/u><\/a>. If two keys <b>a<\/b> and <b>b<\/b> both have the same hash value <b>i<\/b>, both will be appended to the (front\/back) of Doubly Linked List <b>i<\/b> (in this visualization, we append to the back in O(<b>1<\/b>) with help of tail pointer). That&#39;s it, where the keys will be slotted in is completely dependent on the hash function itself, hence we also call Separate Chaining as Closed Addressing collision resolution technique.<\/p><br><p>If we use Separate Chaining, the load factor &alpha; = <b>N\/M<\/b> is the average length of the <b>M<\/b> lists (unlike in Open Addressing, &alpha; can be \"slightly over 1.0\") and it will determine the performance of Search(v) as we may have to explore &alpha; elements on average. As Remove(v) also requires Search(v), its performance is similar as Search(v). Insert(v) is clearly O(<b>1<\/b>).<\/p><br><p>If we can bound &alpha; to be a small constant (true if we know the expected largest <b>N<\/b> in our Hash Table application so that we can set up <b>M<\/b> accordingly), then all Search(v), Insert(v), and Remove(v) operations using Separate Chaining will be O(<b>1<\/b>).<\/p>","title":"Separate Chaining (SC)"},{"id":92,"category":"hashtable","order":6,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-02-19 11:34:44","updated_at":"2023-04-25 12:39:29","section":-1,"code":"","section_order":-1,"value":"6","text":"<p>View the visualization of Hash Table above.<\/p><br><p>In this visualization, we allow the insertion of duplicate keys (i.e., a <i>multi<\/i>set). Since a multiset is more general than a set, simply just insert distinct integers in this visualization if you want to see how Hash Table works on distict integer keys only.<\/p><br><p>Due to limited screen space, we switch from default (1.0x) scale to 0.5x scale whenever you want to visualize Hash Table size <b>M<\/b> &in; [46..90] for OA techniques. The limit is a bit lower, i.e., <b>M<\/b> &in; [20..31] for SC technique.<\/p><br><p>The Hash Table is visualized horizontally like an array where index 0 is placed at the leftmost of the first row and index <b>M<\/b>-1 is placed at the rightmost of the last row but the details are different when we are visualizing Open Addressing (usually spans multiple rows) versus Separate Chaining (only the top row) collision resolution techniques.<\/p>","title":"Visualization"},{"id":532,"category":"hashtable","order":1,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-30 06:42:55","updated_at":"2023-04-25 12:34:26","section":92,"code":"$('#title-LP').click();","section_order":6,"value":"6-1","text":"<p>There are three Open Addressing collision resolution techniques discussed in this visualization: Linear Probing (LP), Quadratic Probing (QP), and Double Hashing (DH).<\/p><br><p>For all three techniques, each Hash Table cell is displayed as a vertex with cell value of [0..99] displayed as the vertex label (in 0.5x scale, the vertex label is displayed on top of the smaller black dot). Without loss of generality, we do not show any satellite data in this visualization as we concentrate only on the arrangement of the keys. We reserve value -1 to indicate an &#39;EMPTY cell&#39; (visualized as a blank vertex) and -2 to indicate a &#39;DELETED cell&#39; (visualized as a vertex with abbreviated label \"DEL\"). The cell indices ranging from [0..<b>M<\/b>-1] are shown as <span style=\"color: red;\">red label<\/span> below each vertex (rows of 15 indices in 1.0x scale or rows of 25 indices in 0.5x scale).<\/p>","title":"Open Addressing Version"},{"id":533,"category":"hashtable","order":2,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-30 06:43:38","updated_at":"2023-04-25 12:35:52","section":92,"code":"$('#title-SC').click();","section_order":6,"value":"6-2","text":"<p>For Separate Chaining (SC) collision resolution technique, the first row contains the <b>M<\/b> \"H\" (Head) pointers of <b>M<\/b> <a href=\".\/list?mode=DLL\"><u>Doubly Linked Lists<\/u><\/a>.<\/p><br><p>Then, each Doubly Linked List <b>i<\/b> contains all keys that are hashed into <b>i<\/b> in arbitrary order (in 0.5x scale, the vertex label is displayed on top of the smaller black dot). Mathematically, all keys that can be expressed as <b>i<\/b> (mod <b>M<\/b>) &mdash; including all duplicates of <b>i<\/b> &mdash; are hashed into DLL <b>i<\/b>. Again, we do not store any satellite data in this visualization.<\/p>","title":"Separate Chaining Version"},{"id":471,"category":"hashtable","order":7,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-26 07:14:29","updated_at":"2023-04-25 12:43:14","section":-1,"code":"$('#title-LP').click();\ncreateTableSpecial([-1,-1,-1,-1,-1,-1,-1]);\n$(\"#v-createM\").val(7);\n$(\"#v-createN\").val(0);\n$(\"#alpha\").text('0.0');\n$(\"#create\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"7","text":"<p>In <b>Linear Probing<\/b> collision resolution technique, we scan forwards one index at a time for the <b>next empty\/deleted slot<\/b> (wrapping around when we have reached the last slot) whenever there is a collision.<\/p><br><p>For example, let&#39;s assume we start with an empty Hash Table <b>HT<\/b> with table size <b>M = HT.length = 7<\/b> as shown above that uses index 0 to <b>M<\/b>-1 = 7-1 = 6. Notice that 7 is a prime number. The (primary) hash function is simple, <b>h(v) = v%M<\/b>.<\/p><br><p>This walk-through will show you the steps taken by Insert(v), Search(v), and Remove(v) operations when using Linear Probing as collision resolution technique.<\/p>","title":"Linear Probing (LP)"},{"id":487,"category":"hashtable","order":1,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-26 13:59:09","updated_at":"2023-04-25 12:44:04","section":471,"code":"$('#title-LP').click();\n$(\"#v-createM\").val(7);\ncreateTableSpecial([14,21,-1,-1,18,-1,-1]);\n$(\"#v-insert\").val(\"18,14,21\");\n$(\"#insert\").click().addClass(\"menu-highlighted\");","section_order":7,"value":"7-1","text":"<p>Now click <span class=\"slide-actions\" onclick=\"doButtonAction79()\">Insert([18,14,21])<\/span> \u2014 three individual insertions in one command.<\/p><br><p><span id=\"recap1\">Recap (to be shown after you click the button above).<\/span><\/p><br><p>Formally, we describe <a href=\"?slide=5-1\"><u>Linear Probing index <b>i<\/b><\/u><\/a> as <b>i = (base+step*1) % M<\/b> where <b>base<\/b> is the (primary) hash value of key <b>v<\/b>, i.e., <b>h(v)<\/b> and <b>step<\/b> is the Linear Probing step starting from 1.<\/p><br><p>Tips: To do a quick mental calculation of a (small) Integer <b>V<\/b> modulo <b>M<\/b>, we simply subtract <b>V<\/b> with the largest multiple of <b>M<\/b> \u2264 <b>V<\/b>, e.g., 18%7 = 18-14 = 4, as 14 is the largest multiple of 7 that is \u2264 18.<\/p>","title":"Insert([18, 14, 21)"},{"id":488,"category":"hashtable","order":2,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-26 14:04:08","updated_at":"2017-05-30 09:14:48","section":471,"code":"$('#title-LP').click();\ncreateTableSpecial([14,21,-1,-1,18,-1,-1]);\n$(\"#v-insert\").val(\"1,35\");\n$(\"#insert\").click().addClass(\"menu-highlighted\");","section_order":7,"value":"7-2","text":"<p>Now click <span class=\"slide-actions\" onclick=\"doButtonAction80()\">Insert([1,35])<\/span> (on top of the first three values inserted in the previous slide).<\/p><br><p><span id=\"recap2\">Recap (to be shown after you click the button above)<\/span><\/p>","title":"Insert([1, 35])"},{"id":489,"category":"hashtable","order":3,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-27 06:41:09","updated_at":"2017-05-30 09:14:53","section":471,"code":"$('#title-LP').click();\ncreateTableSpecial([14,21,1,35,18,-1,-1]);\n$(\"#v-search\").val(35);\n$(\"#search\").click().addClass(\"menu-highlighted\");","section_order":7,"value":"7-3","text":"<p>Now we illustrate Search(v) operation while using Linear Probing as collision resolution technique. The steps taken are very similar as with Insert(v) operation, i.e., we start from the (primary) hash key value and check if we have found <b>v<\/b>, otherwise we move one index forward at a time (wrapping around if necessary) and recheck on whether we have found <b>v<\/b>. We stop when we encounter an empty cell which implies that <b>v<\/b> is not in Hash Table at all (as earlier Insert(v) operation would have placed <b>v<\/b> there otherwise).<\/p><br><p>Now click <span class=\"slide-actions\" onclick=\"doButtonAction81()\">Search(35)<\/span> &mdash; you should see probing sequence [0,1,2,3 (key 35 found)].<\/p><br><p>Now click <span class=\"slide-actions\" onclick=\"doButtonAction82()\">Search(7)<\/span> &mdash; [1,2,3,4, 5 (empty cell, so key 8 is not found in the Hash Table)].<\/p>","title":"Search(35) and Search(8)"},{"id":490,"category":"hashtable","order":4,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-27 06:52:36","updated_at":"2017-05-30 09:14:56","section":471,"code":"$('#title-LP').click();\ncreateTableSpecial([14,21,1,35,18,-1,-1]);\n$(\"#v-remove\").val(21);\n$(\"#remove\").click().addClass(\"menu-highlighted\");","section_order":7,"value":"7-4","text":"<p>Now let&#39;s discuss Remove(v) operation.<\/p><br><p>If we just set <b>HT[i] = EMPTY<\/b> cell straightaway where <b>i<\/b> is the index that contains <b>v<\/b> (after linear probing if necessary), do you realize that we will cause a problem? Why?<\/p><br><p>Hint: Review the past three slides on how Insert(v) and Search(v) behave.<\/p>","title":"Remove(v) - Preliminary"},{"id":491,"category":"hashtable","order":5,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-27 06:54:33","updated_at":"2017-05-30 09:15:02","section":471,"code":"$('#title-LP').click();\ncreateTableSpecial([14,21,1,35,18,-1,-1]);\n$(\"#v-remove\").val(21);\n$(\"#remove\").click().addClass(\"menu-highlighted\");","section_order":7,"value":"7-5","text":"<p>If we set <b>HT[i] = EMPTY<\/b> straightaway, we may cause problem as Search(v) operation will stop upon encountering an empty cell in its probing sequence.<\/p><br><p>Thus if the Linear Probing sequence used inside future Search(v) operation actually need to bypass through index <b>i<\/b> in order to reach the correct index <b>j<\/b> where <b>H[j] = v<\/b>, it will not be able to do so as <b>H[i] = EMPTY<\/b> and the Linear Probing stops there.<\/p>","title":"The Answer"},{"id":492,"category":"hashtable","order":6,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-27 06:56:37","updated_at":"2017-05-30 09:15:06","section":471,"code":"$('#title-LP').click();\ncreateTableSpecial([14,21,1,35,18,-1,-1]);\n$(\"#v-remove\").val(21);\n$(\"#remove\").click().addClass(\"menu-highlighted\");","section_order":7,"value":"7-6","text":"<p>Now let&#39;s see the complete Remove(v). If we find <b>v<\/b> at index <b>i<\/b> (after Linear Probing if necessary), we have to set <b>HT[i] = DELETED<\/b> (abbreviated as <b>DEL<\/b> in this visualization) where <b>DEL<\/b> is a special symbol (generally you should only use a symbol that is <b>not<\/b> used in your application) to indicate that cell can be by-passed if necessary by future Search(v), but can be overwritten by future Insert(w). This strategy is called <b>Lazy Deletion<\/b>.<\/p><br><p>Now click <span class=\"slide-actions\" onclick=\"doButtonAction83()\">Remove(21)<\/span> \u2014 [0,1 (key 21 found and we set <b>H[1] = DEL<\/b>)].<\/p><br><p>Afterwards, please continue the discussion in the next slide.<\/p>","title":"Remove(21)"},{"id":493,"category":"hashtable","order":7,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-27 07:07:28","updated_at":"2017-05-30 10:01:42","section":471,"code":"$('#title-LP').click();\ncreateTableSpecial([14,-2,1,35,18,-1,-1]);\n$(\"#v-search\").val(35);\n$(\"#search\").click().addClass(\"menu-highlighted\");","section_order":7,"value":"7-7","text":"<p>Now click <span class=\"slide-actions\" onclick=\"doButtonAction81()\">Search(35)<\/span> &mdash; [0,1 (bypassing that DELETED cell), 2,3 (found key 35)].<\/p><br><p>Imagine what would have happened if we <i>wrongly<\/i> set <b>H[1] = EMPTY<\/b>.<\/p>","title":"Search(35) Again"},{"id":494,"category":"hashtable","order":8,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-27 07:16:16","updated_at":"2017-05-30 10:02:08","section":471,"code":"$('#title-LP').click();\ncreateTableSpecial([14,-2,1,35,18,-1,-1]);\n$(\"#v-insert\").val(15);\n$(\"#insert\").click().addClass(\"menu-highlighted\");","section_order":7,"value":"7-8","text":"<p>Now click <span class=\"slide-actions\" onclick=\"doButtonAction84()\">Insert(28)<\/span> &mdash; you should see probing sequence [0,1 (found a cell with DEL symbol)], so it is actually can be overwritten with a new value without affecting the correctness of future Search(v). Therefore, we put 28 in index 1.<\/p>","title":"Insert(28) - Overwriting DEL"},{"id":495,"category":"hashtable","order":9,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-27 13:14:55","updated_at":"2023-04-25 12:47:38","section":471,"code":"$('#title-LP').click();\ncreateTableSpecial([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]);","section_order":7,"value":"7-9","text":"<p>Although we can resolve collision with Linear Probing, it is not the most effective way.<\/p><br><p>We define a <b>cluster<\/b> to be a collection of consecutive occupied slots. A cluster that covers the base address of a key is called the <b>primary cluster<\/b> of the key.<\/p><br><p>Now notice that Linear Probing can create large primary clusters that will increase the running time of Search(v)\/Insert(v)\/Remove(v) operations beyond the advertised O(<b>1<\/b>).<\/p><br><p>See an example above with <b>M<\/b> = 31 and we have inserted 15 keys [0..14] so that they occupy cells [0..14] (&alpha; = 15\/31 < 0.5). Now see how &#39;slow&#39; <span class=\"slide-actions\" onclick=\"doButtonAction92()\">Insert(31)<\/span> (the 16th key) is.<\/p>","title":"Primary Clustering, Part 1"},{"id":496,"category":"hashtable","order":10,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-27 13:30:07","updated_at":"2023-04-25 12:53:59","section":471,"code":"$('#title-LP').click();\ncreateTableSpecial([0,1,2,3,-2,-2,6,7,-2,-2,-2,11,-2,13,-2,31,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]);","section_order":7,"value":"7-10","text":"<p>The probe sequence of Linear Probing can be formally described as follows:<\/p><pre> h(v) \/\/ base address<br>(h(v) + 1*<span style=\"color: red;\">1<\/span>) % M \/\/ 1st probing step if there is a collision<br>(h(v) + 2*<span style=\"color: red;\">1<\/span>) % M \/\/ 2nd probing step if there is still a collision<br>(h(v) + 3*<span style=\"color: red;\">1<\/span>) % M \/\/ 3rd probing step if there is still a collision<br>...<br>(h(v) + k*<span style=\"color: red;\">1<\/span>) % M \/\/ k-th probing step, etc...<\/pre><p>During Insert(v), if there is a collision but there is an empty (or DEL) slot remains in the Hash Table, we are sure to find it after at most <b>M<\/b> Linear Probing steps, i.e., in O(<b>M<\/b>). And when we do, the collision will be resolved, but the primary cluster of the key <b>v<\/b> is expanded as a result and future Hash Table operations will get slower too. Try the slow <span class=\"slide-actions\" onclick=\"doButtonAction127()\">Search(31)<\/span> on the same Hash Table as in the previous slide but with many DEL markers (suppose {4, 5, 8, 9, 10, 12, 14} have just been deleted).<\/p>","title":"Linear Probing Sequence"},{"id":757,"category":"hashtable","order":11,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2021-09-29 04:49:04","updated_at":"2023-04-25 13:01:33","section":471,"code":"$('#title-LP').click();\ncreateTableSpecial([-1,94,-1,96,66,96,99,68,70,-1,72,73,-1,44,-1,-1,-1,-1,80,-1,-1,-1,22,85,-1,-1,-1,89,-1,91,-1]);","section_order":7,"value":"7-11","text":"<p>In the previous slide (Primary Clustering, Part 1), we break the assumption that the hash function should uniformly distribute keys around [0..<b>M<\/b>-1]. In the next example, we will show that the problem of primary clustering can still happen even if the hash function distribute the keys into several relatively short primary clusters around [0..<b>M<\/b>-1].<\/p><br><p>On screen, you see <b>M<\/b> = 31 with 15 random integers between [0..99] inserted (there are several random but short primary clusters). If we then insert these next 4 keys {2, 9, 12, 1}, the first three keys will \"plug\" the three empty cells and accidentally annex (or combine) those neighboring (but previously disjointed) clusters into a (very) long primary cluster. So the next insertion of a key 1 that lands at (the beginning of) this long primary cluster will end up performing almost O(M) probing steps just to find an empty cell. Try <span class=\"slide-actions\" onclick=\"doButtonAction128()\">Insert([2,9,12,1])<\/span>.<\/p>","title":"Primary Clustering, Part 2"},{"id":470,"category":"hashtable","order":8,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-26 07:13:55","updated_at":"2018-03-09 05:32:57","section":-1,"code":"$('#title-QP').click();","section_order":-1,"value":"8","text":"<p>To reduce primary clustering, we can modify the probe sequence to:<\/p><pre> h(v) \/\/ base address<br>(h(v) + 1*<span style=\"color: red;\">1<\/span>) % M \/\/ 1st probing step if there is a collision<br>(h(v) + 2*<span style=\"color: red;\">2<\/span>) % M \/\/ 2nd probing step if there is still a collision<br>(h(v) + 3*<span style=\"color: red;\">3<\/span>) % M \/\/ 3rd probing step if there is still a collision<br>...<br>(h(v) + k*<span style=\"color: red;\">k<\/span>) % M \/\/ k-th probing step, etc...<\/pre><p>That&#39;s it, the probe jumps quadratically, wrapping around the Hash Table as necessary.<\/p><br><p><font color=\"red\">A very common mistake<\/font> as this is a different kind of Quadratic Probing:<br>Doing h(v), (h(v)+1) % M, (h(v)+1+4) % M, (h(v)+1+4+9) % M, ... <\/p>","title":"Quadratic Probing (QP)"},{"id":497,"category":"hashtable","order":1,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-27 14:26:17","updated_at":"2017-05-30 09:15:33","section":470,"code":"$('#title-QP').click();\ncreateTableSpecial([-1,-1,-1,10,18,-1,-1]);\n$(\"#v-insert\").val(\"38\");\n$(\"#insert\").click().addClass(\"menu-highlighted\");","section_order":8,"value":"8-1","text":"<p>Assume that we have called Insert(18) and Insert(10) into an initially empty Hash Table of size <b>M = HT.length = 7<\/b>. As 18%7 = 4 and 10%7 = 3, 18 and 3 do not collide and both reside in index 4 and 3 respectively as shown above.<\/p><br><p>Now, let&#39;s click <span class=\"slide-actions\" onclick=\"doButtonAction85()\">Insert(38)<\/span>.<\/p><br><p><span id=\"recap3\">Recap (to be shown after you click the button above).<\/span><\/p>","title":"Insert(38)"},{"id":519,"category":"hashtable","order":2,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 08:35:26","updated_at":"2017-05-30 09:15:41","section":470,"code":"$('#title-QP').click();\ncreateTableSpecial([38,-1,-1,10,-2,-1,-1]);\n$(\"#v-search\").val(\"38\");\n$(\"#search\").click().addClass(\"menu-highlighted\");","section_order":8,"value":"8-2","text":"<p>Remove(x) and Search(y) operations are defined similarly. Just that this time we use Quadratic Probing instead of Linear Probing.<\/p><br><p>For example, assume that we have called Remove(18) after the previous slide and we mark <b>HT[4] = DEL<\/b>. If we then call <span class=\"slide-actions\" onclick=\"doButtonAction91()\">Search(38)<\/span>, we will use the same Quadratic Probing sequence as with previous slide, but passing through <b>HT[4]<\/b> which marked as DELETED.<\/p>","title":"Remove(18) and Search(38) Again"},{"id":498,"category":"hashtable","order":3,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-28 01:06:15","updated_at":"2017-05-30 09:15:48","section":470,"code":"$('#title-QP').click();\ncreateTableSpecial([38,-1,-1,10,18,-1,-1]);\n$(\"#v-insert\").val(\"12,17\");\n$(\"#insert\").click().addClass(\"menu-highlighted\");","section_order":8,"value":"8-3","text":"<p>In a glance, Quadratic Probing that jumps +1, +4, +9, +16, ... quadratically seems able to solve the primary clustering issue that we have with Linear Probing earlier, but is it the perfect collision resolution technique?<\/p><br><p>Try <span class=\"slide-actions\" onclick=\"doButtonAction86()\">Insert([12,17])<\/span>.<\/p><br><p>Do you realized what has just happened?<\/p>","title":"Better than Linear Probing?"},{"id":499,"category":"hashtable","order":4,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-28 01:40:18","updated_at":"2018-03-09 05:41:19","section":470,"code":"$('#title-QP').click();\ncreateTableSpecial([38,-1,-1,10,18,12,-1]);\n$(\"#v-insert\").val(\"17\");\n$(\"#insert\").click().addClass(\"menu-highlighted\");","section_order":8,"value":"8-4","text":"<p>We can insert 12 easily as h(12) = 12%7 = 5 was empty previously (see above).<\/p><br><p>However we have major problem inserting key 17 even if we still have 3 empty slots as:<br>h(17) = 17%7 = 3 is already occupied by key 10,<br>(3+1*1) % 7 = 4 is already occupied by key 18, <br>(3+2*2) % 7 = 0 is already occupied by key 38, <br>(3+3*3) % 7 = 5 is already occupied by key 12, <br>(3+4*4) % 7 = 5 again is already occupied by key 12,<br>(3+5*5) % 7 = 0 again is already occupied by key 38,<br>(3+6*6) % 7 = 4 again is already occupied by key 18,<br>(3+7*7) % 7 = 3 again is already occupied by key 10,<br>it will <b>cycle forever<\/b> if we continue the Quadratic Probing...<\/p><br><p>Although we still have a few (3) empty cells, we are unable to insert this new value 17 into the Hash Table...<\/p>","title":"The Details"},{"id":500,"category":"hashtable","order":5,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-28 01:50:29","updated_at":"2023-04-25 13:05:01","section":470,"code":"","section_order":8,"value":"8-5","text":"<p>If &alpha; &lt; 0.5 and <b>M<\/b> is a prime (&gt; 3), then we can always find an empty slot using (this form of) Quadratic Probing. Recall: &alpha; is the load factor and <b>M<\/b> is the Hash Table size (HT.length).<\/p><br><p>If the two requirements above are satisfied, we can prove that the first <b>M<\/b>\/2 Quadratic Probing indices, including the base address <samp>h(v)<\/samp> are all distinct and unique.<\/p><br><p>But there is no such guarantee beyond that. Hence if we want to use Quadratic Probing, we need to ensure that &alpha; &lt; 0.5 (not enforced in this visualization but we do break the loop after <b>M<\/b> steps to prevent infinite loop).<\/p>","title":"A Theorem"},{"id":501,"category":"hashtable","order":6,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-28 01:52:21","updated_at":"2018-03-09 05:44:22","section":470,"code":"","section_order":8,"value":"8-6","text":"<p>We will use proof by contradiction. We first assume that two Quadratic Probing steps:<br>x and y, x != y (let&#39;s say x &lt; y), can yield the same address modulo <b>M<\/b>.<\/p><pre>h(v) + x*x = h(v) + y*y (mod M)<br>x*x = y*y (mod M) \/\/ strike out h(v) from both sides<br>x*x - y*y = 0 (mod M) \/\/ move y*y to LHS<br>(x-y)*(x+y) = 0 (mod M) \/\/ rearrange the formula<\/pre><p>Now, either <samp>(x-y)<\/samp> or <samp>(x+y)<\/samp> has to be equal to zero.<br>As our assumption says <samp>x != y<\/samp>, then <samp>(x-y)<\/samp> cannot be 0.<br>As <samp>0 &le; x &lt; y &le; (M\/2)<\/samp> and <samp>M<\/samp> is a prime &gt; 3 (an odd Integer),<br>then <samp>(x+y)<\/samp> also cannot be 0 modulo <samp>M<\/samp>.<\/p><br><p>Contradiction!<\/p><br><p>So the first <samp>M\/2<\/samp> Quadratic Probing steps cannot yield the same address modulo <samp>M<\/samp><br>(if we set <b>M<\/b> to be a prime number greater than 3).<\/p><br><p>Discussion: Can we make Quadratic Probing able to use the other ~50% of the table cells?<\/p>","title":"A Proof"},{"id":536,"category":"hashtable","order":7,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-30 07:10:44","updated_at":"2018-03-09 05:44:54","section":470,"code":"","section_order":8,"value":"8-7","text":"<p>An even better Quadratic Probing is to alternate the sign and having <b>M<\/b> to be a prime number congruent to 3 modulo 4 (i.e., 3, 7, 11, 19, ...):<\/p><pre> h(v) \/\/ base address<br>(h(v) + 1*<span style=\"color: red;\">1<\/span>) % M \/\/ 1st probing step if there is a collision<br>(h(v) - 1*<span style=\"color: red;\">1<\/span>) % M \/\/ 2nd probing step if there is still a collision<br>(h(v) + 2*<span style=\"color: red;\">2<\/span>) % M \/\/ 3rd probing step if there is still a collision<br>(h(v) - 2*<span style=\"color: red;\">2<\/span>) % M \/\/ 4th probing step if there is still a collision<br>...<br>(h(v) + k*<span style=\"color: red;\">k<\/span>) % M \/\/ 2*k-th probing step<br>(h(v) - k*<span style=\"color: red;\">k<\/span>) % M \/\/ 2*k+1-th probing step, etc...<\/pre><p>Proof omitted... Just FYI<\/p>","title":"Better Quadratic Probing"},{"id":502,"category":"hashtable","order":8,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-28 02:36:13","updated_at":"2023-04-25 13:06:23","section":470,"code":"$('#title-QP').click();\ncreateTableSpecial([0,1,64,-1,4,36,-1,-1,-1,9,-1,-1,-1,-1,-1,-1,16,-1,49,81,-1,-1,-1,-1,-1,25,-1,-1,-1,-1,-1]);","section_order":8,"value":"8-8","text":"<p>In Quadratic Probing, clusters are formed along the path of probing, instead of around the base address like in Linear Probing. These clusters are called <b>Secondary Clusters<\/b> and it is &#39;less visible&#39; compared to the Primary Clusters that plagued the Linear Probing.<\/p><br><p>Secondary clusters are formed as a result of using the same pattern in probing by colliding keys, i.e., if two distinct keys have the same base address, their Quadratic Probing sequences are going to be the same.<\/p><br><p>To illustrate this, see the screen with <b>M<\/b> = 31. We have populated this Hash Table with only 10 keys (so load factor \u03b1 = 10\/31 \u2264 0.5) and the Hash Table looks &#39;sparse enough&#39; (no visibly big primary cluster). However, if we then insert <span class=\"slide-actions\" onclick=\"doButtonAction129()\">Insert(62,93)<\/span>, despite the fact that there are many (31-10 = 21) empty cells and 62 != 93 (different keys that ends up hashed into index 0), we end up doing 10 probing steps along this &#39;less visible&#39; secondary cluster (notice that both {62, 93} follow similar Quadratic Probing sequences).<\/p><br><p>Secondary clustering in Quadratic Probing is not as bad as primary clustering in Linear Probing as a good hash function should theoretically disperse the keys into different base addresses \u2208 [0..<b>M<\/b>-1] in the first place.<\/p>","title":"Secondary Clustering"},{"id":480,"category":"hashtable","order":9,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-26 09:20:35","updated_at":"2017-05-29 06:38:07","section":-1,"code":"$('#title-DH').click();","section_order":-1,"value":"9","text":"<p>To reduce primary and secondary clustering, we can modify the probe sequence to:<\/p><pre> h(v) \/\/ base address<br>(h(v) + 1*<span style=\"color: red;\">h2(v)<\/span>) % M \/\/ 1st probing step if there is a collision<br>(h(v) + 2*<span style=\"color: red;\">h2(v)<\/span>) % M \/\/ 2nd probing step if there is still a collision<br>(h(v) + 3*<span style=\"color: red;\">h2(v)<\/span>) % M \/\/ 3rd probing step if there is still a collision<br>...<br>(h(v) + k*<span style=\"color: red;\">h2(v)<\/span>) % M \/\/ k-th probing step, etc...<\/pre><p>That&#39;s it, the probe jumps according to the value of the <b>second hash function<\/b> <samp>h2(v)<\/samp>, wrapping around the Hash Table as necessary.<\/p>","title":"Double Hashing (DH)"},{"id":503,"category":"hashtable","order":1,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-28 02:42:46","updated_at":"2017-05-28 02:43:22","section":480,"code":"$('#title-DH').click();","section_order":9,"value":"9-1","text":"<p>If <samp>h2(v) = 1<\/samp>, then Double Hashing works exactly the same as Linear Probing.<br>So we generally wants <samp>h2(v) &gt; 1<\/samp> to avoid primary clustering.<\/p><br><p>If <samp>h2(v) = 0<\/samp>, then Double Hashing does not work for an obvious reason as any probing step multiplied by 0 remains 0, i.e. we stay at the base address forever during a collision. We need to avoid this.<\/p><br><p>Usually (for Integer keys), <samp>h2(v) = M&#39; - v%M&#39;<\/samp> where <samp>M&#39;<\/samp> is a smaller prime than <samp>M<\/samp>.<br>This makes <samp>h2(v)<\/samp> &in; [1..<b>M&#39;<\/b>], which is diverse enough to avoid secondary clustering.<\/p><br><p>The usage of the secondary hash function makes it theoretically hard to have either primary or secondary clustering issue.<\/p>","title":"Secondary Hash Function h2(v)"},{"id":504,"category":"hashtable","order":2,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-28 02:50:09","updated_at":"2017-05-30 09:16:05","section":480,"code":"$('#title-DH').click();\ncreateTableSpecial([14,-1,-1,17,-1,12,-1]);\n$(\"#v-insert\").val(\"35,42\");\n$(\"#insert\").click().addClass(\"menu-highlighted\");","section_order":9,"value":"9-2","text":"<p>Click <span class=\"slide-actions\" onclick=\"doButtonAction87()\">Insert([35,42])<\/span> to insert 35 and then 42 to the current Hash Table above.<\/p><br><p><span id=\"recap4\">Recap (to be shown after you click the button above).<\/span><\/p>","title":"Insert([35, 42])"},{"id":520,"category":"hashtable","order":3,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 08:56:12","updated_at":"2017-05-30 09:16:11","section":480,"code":"$('#title-DH').click();\ncreateTableSpecial([14,35,-1,-2,-1,12,42]);\n$(\"#v-search\").val(35);\n$(\"#search\").click().addClass(\"menu-highlighted\");","section_order":9,"value":"9-3","text":"<p>Remove(x) and Search(y) operations are defined similarly. Just that this time we use Double Hashing instead of Linear Probing or Quadratic Probing.<\/p><br><p>For example, assume that we have called Remove(17) after the previous slide and we mark <b>HT[3] = DEL<\/b>. If we then call <span class=\"slide-actions\" onclick=\"doButtonAction81()\">Search(35)<\/span>, we will use the same Double Hashing sequence as with previous slide, but passing through <b>HT[3]<\/b> which marked as DELETED.<\/p>","title":"Remove(17) and Search(35) Again"},{"id":528,"category":"hashtable","order":4,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 09:29:02","updated_at":"2023-04-25 13:07:49","section":480,"code":"$('#title-DH').click();\ncreateTableSpecial([0,1,64,-1,4,36,-1,-1,-1,9,-1,-1,-1,-1,-1,-1,16,-1,49,81,-1,-1,-1,-1,-1,25,-1,-1,-1,-1,-1]);","section_order":9,"value":"9-4","text":"<p>In summary, a good Open Addressing collision resolution technique needs to:<\/p><ol><li>Always find an empty slot if it exists,<\/li><li>Minimize clustering (of any kind),<\/li><li>Give different probe sequences when 2 different keys collide,<\/li><li>Fast, O(<b>1<\/b>).<\/li><\/ol><p>Now, let&#39;s see <a href=\".\/hashtable?slide=8-8\"><u>the same test case that plagues Quadratic Probing<\/u><\/a> earlier. Now try <span class=\"slide-actions\" onclick=\"doButtonAction129()\">Insert(62,93)<\/span> again. Although h(62) = h(93) = 0 and their collide with 31 that already occupy index 0, their probing steps are not the same: h2(62) = 29-62%29 = 25 is not the same as h2(93) = 29-93%29 = 23.<\/p><br><p>Discussion: Double Hashing seems to fit the bill. But... Is Double Hashing strategy flexible enough to be used as the default library implementation of a Hash Table? Let&#39;s see...<\/p>","title":"Good OA Collision Resolution Technique"},{"id":537,"category":"hashtable","order":10,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-30 07:14:37","updated_at":"2022-07-01 10:00:08","section":-1,"code":"$('#title-SC').click();\ncreateSCDefaultTC();\n$(\"#v-insert\").val(\"68,90\");\n$(\"#insert\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"10","text":"<p>Try <span class=\"slide-actions\" onclick=\"doButtonAction93()\">Insert([9,16,23,30,37,44])<\/span> to see how Insert(v) operation works if we use Separate Chaining as collision resolution technique. On such random insertions, the performance is good and each insertion is clearly O(<b>1<\/b>).<\/p><p><br><\/p><p>However if we try <span class=\"slide-actions\" onclick=\"doButtonAction126()\">Insert([68,90])<\/span>, notice that all Integers {68,90} are 2 (modulo 11) so all of them will be appended into the (back of) Doubly Linked List 2. We will have a long chain in that list. Note that due to the screen limitation, we limit the length of each Doubly Linked List to be at maximum 6.<\/p>","title":"Separate Chaining (SC)"},{"id":538,"category":"hashtable","order":1,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-30 10:10:20","updated_at":"2022-07-01 09:58:48","section":537,"code":"$('#title-SC').click();\ncreateSCDefaultTC();\n$(\"#v-search\").val(35);\n$(\"#search\").click().addClass(\"menu-highlighted\");","section_order":10,"value":"10-1","text":"<p>Try <span class=\"slide-actions\" onclick=\"doButtonAction81()\">Search(35)<\/span> to see that Search(v) can be made to run in O(<b>1+\u03b1<\/b>).<\/p><br><p>Try <span class=\"slide-actions\" onclick=\"doButtonAction94()\">Remove(35)<\/span> to see that Remove(v) can be made to run in O(<b>1+\u03b1<\/b>) too.<\/p><br><p>If <b>\u03b1<\/b> is large, Separate Chaining performance is not really O(<b>1<\/b>). However, if we roughly know the potential maximum number of keys <b>N<\/b> that our application will ever use, then we can set table size <b>M<\/b> accordingly such that <b>\u03b1 = N\/M<\/b> is a very low positive (floating-point) number, thereby making Separate Chaining performances to be expected O(<b>1<\/b>).<\/p>","title":"Search(35) and Remove(35)"},{"id":657,"category":"hashtable","order":2,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-10-06 03:32:01","updated_at":"2022-07-01 09:58:57","section":537,"code":"$('#title-SC').click();\ncreateSCDefaultTC();\n$(\"#v-search\").val(35);\n$(\"#search\").click().addClass(\"menu-highlighted\");","section_order":10,"value":"10-2","text":"Discussion: After all these explanations, which of the two collision resolution technique is the better one?","title":"Open Addressing vs Separate Chaining?"},{"id":658,"category":"hashtable","order":3,"top":"","right":"","bottom":"60px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-10-06 03:33:50","updated_at":"2022-07-01 09:59:00","section":537,"code":"$('#title-SC').click();\ncreateSCDefaultTC();\n$(\"#v-search\").val(35);\n$(\"#search\").click().addClass(\"menu-highlighted\");","section_order":10,"value":"10-3","text":"<p>We reckon that for Open Addressing techniques, Double Hashing is the best form as it avoids the problem of Primary Clustering of Linear Probing and Secondary Clustering of Quadratic Probing.<\/p><br><p>However, if we frequently insert and remove values from the Hash Table, we may leave a lot of DELETED markers if we use Double Hashing or any other Open Addressing techniques, making future Hash Table operations slower.<\/p><br><p>We reckon that C++ STL <samp>std::unordered_map\/std::unordered_set<\/samp> must have used a kind of Separate Chaining technique that are more robust and much easier to maintain, especially if there are many potential deletion of existing elements of Hash Table in our application, see this <a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2003\/n1456.html\" target=\"_blank\"><u>reference document<\/u><\/a>.<\/p>","title":"The (Current) Answer"},{"id":521,"category":"hashtable","order":11,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 09:07:38","updated_at":"2023-04-25 13:09:23","section":-1,"code":"","section_order":-1,"value":"11","text":"<p>You have reached the end of the basic stuffs of this Hash Table data structure and we encourage you to explore further in the <b>Exploration Mode<\/b>.<\/p><br><p>However, we still have a few more interesting Hash Table challenges for you that are outlined in this section.<\/p>","title":"Extras"},{"id":523,"category":"hashtable","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 09:08:04","updated_at":"2023-04-25 13:10:04","section":521,"code":"$('#title-SC').click();","section_order":11,"value":"11-1","text":"<p>The performance of Hash Table degrades when the load factor \u03b1 gets higher. For (standard) Quadratic Probing collision resolution technique, insertions might fail when the Hash Table has \u03b1 &gt; 0.5.<\/p><br><p>If that happens, we can <b>rehash<\/b>. We build another Hash Table about twice as big with a new hash function. We go through all keys in the original Hash Table, recompute the new hash values, and re-insert the keys (with their satellite-data) into the new, bigger Hash Table, before finally we delete the older, smaller Hash Table.<\/p><br><p>A rule of thumb is to rehash when \u03b1 &ge; 0.5 if using Open Addressing and when \u03b1 &gt; small constant (close to 1.0, as per requirement) if using Separate Chaining.<\/p><br><p>If we know the maximum number of total possible keys, we can always influence &alpha; to be a low number.<\/p>","title":"Rehash"},{"id":524,"category":"hashtable","order":2,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 09:13:41","updated_at":"2023-04-25 13:09:28","section":521,"code":"","section_order":11,"value":"11-2","text":"<p>However, if you ever need to implement a Hash Table in C++, Python, or Java, and your keys are either Integers or Strings, you can use the built-in C++ STL, Python standard library, or Java API, respectively. They already have good built-in implementation of default hash functions for Integers or Strings.<\/p><br><p>See C++ STL <a href=\"http:\/\/en.cppreference.com\/w\/cpp\/container\/unordered_map\" target=\"_blank\"><u>std::unordered_map<\/u><\/a>, <a href=\"http:\/\/en.cppreference.com\/w\/cpp\/container\/unordered_set\" target=\"_blank\"><u>std::unordered_set<\/u><\/a>, Python <a href=\"https:\/\/docs.python.org\/3\/tutorial\/datastructures.html#dictionaries\" target=\"_blank\"><u>dict<\/u><\/a>, <a href=\"https:\/\/docs.python.org\/3\/tutorial\/datastructures.html#sets\" target=\"_blank\"><u>set<\/u><\/a>, or Java <a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/util\/HashMap.html\" target=\"_blank\"><u>HashMap<\/u><\/a>, <a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/util\/HashSet.html\" target=\"_blank\"><u>HashSet<\/u><\/a>.<\/p><br><p>For C++, note that the std::multimap\/std::multiset implementations are also exist where duplicate keys are allowed.<\/p><br><p>For OCaml, we can use <a href=\"https:\/\/caml.inria.fr\/pub\/docs\/manual-ocaml\/libref\/Hashtbl.html\" target=\"_blank\"><u>Hashtbl<\/u><\/a>.<\/p><br><p>However, here is our take of a simple Separate Chaining implementation: <a href=\"http:\/\/www.comp.nus.edu.sg\/~stevenha\/cs2040c\/demos\/HashTableDemo.cpp\" target=\"_blank\"><u>HashTableDemo.cpp<\/u><\/a> | <a href=\"http:\/\/www.comp.nus.edu.sg\/~stevenha\/cs2040c\/demos\/HashTableDemo.py\" target=\"_blank\"><u>py<\/u><\/a> | <a href=\"http:\/\/www.comp.nus.edu.sg\/~stevenha\/cs2040c\/demos\/HashTableDemo.java\" target=\"_blank\"><u>java<\/u><\/a>.<\/p>","title":"Hash Table Implementation"},{"id":539,"category":"hashtable","order":3,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-30 10:14:59","updated_at":"2023-04-25 13:09:31","section":521,"code":"","section_order":11,"value":"11-3","text":"<p>Separate Chaining technique is actually more flexible than the one presented here.<\/p><br><p>Can you think of another, potentially better, data structure that can be used to replace the Doubly Linked Lists? Note: May be overkill though if <b>&alpha;<\/b> can be set to be a low number.<\/p>","title":"Data Structure Combo?"},{"id":527,"category":"hashtable","order":4,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 09:19:36","updated_at":"2023-04-25 13:09:37","section":521,"code":"","section_order":11,"value":"11-4","text":"<p>Hash Table is an extremely good data structure to implement Table ADT if the (Integer or String) keys only need to be mapped to satellite-data, with O(<b>1<\/b>) performance for Search(v), Insert(v), and Remove(v) operations if the Hash Table is set up properly.<\/p><br><p>However, if we need to do <a href=\".\/bst?slide=3-5\"><u>much more with the keys<\/u><\/a>, we may need to use an alternative data structure.<\/p>","title":"Alternative Data Structure for Table ADT"},{"id":525,"category":"hashtable","order":5,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 09:17:05","updated_at":"2023-04-25 13:09:34","section":521,"code":"","section_order":11,"value":"11-5","text":"<p>For a few more interesting questions about this data structure, please practice on <a href=\"https:\/\/visualgo.net\/training?diff=Medium&amp;n=7&amp;tl=0&amp;module=hashtable\"><u>Hash Table<\/u><\/a> training module (no login is required, but short and of medium difficulty setting only).<\/p><br><p>However, for registered users, you should login and then go to the <a href=\"https:\/\/visualgo.net\/training\"><u>Main Training Page<\/u><\/a> to officially clear this module and such achievement will be recorded in your user account.<\/p>","title":"Online Quiz"},{"id":526,"category":"hashtable","order":6,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-29 09:17:20","updated_at":"2023-04-25 13:09:39","section":521,"code":"","section_order":11,"value":"11-6","text":"<p>Try to solve a few basic programming problems that somewhat requires the usage of Hash Table (especially if the input size is much larger):<ol><li><a href=\"https:\/\/open.kattis.com\/problems\/cd\" target=\"_blank\"><u>Kattis - cd<\/u><\/a> (the inputs are already sorted so alternative, non Hash Table solution exists; if the inputs are not sorted, this set intersection problem is best solved with help of a Hash Table),<\/li><li><a href=\"https:\/\/open.kattis.com\/problems\/oddmanout\" target=\"_blank\"><u>Kattis - oddmanout<\/u><\/a> (we can map large invitation codes into smaller range of integers; this is a practice of hashing (large range) of integers),<\/li><li><a href=\"https:\/\/open.kattis.com\/problems\/whatdoesthefoxsay\" target=\"_blank\"><u>Kattis - whatdoesthefoxsay<\/u><\/a> (we put sounds that are not fox into an unordered set; this is a practice of hashing strings).<\/li><\/ol>","title":"Online Judge Exercises"}];
      const numSlides = lectureIds.length;
      var sectorJunction12Section = 0, sectorJunction12Slide = 0;
      var sectorJunction23Section = 0, sectorJunction23Slide = 0;
      var sector1Count = 0, sector2Count = 0, sector3Count = 0;
      const sectorLength = Math.floor(numSlides / 3);
      function createELectureTimelineDisplay() {
        for (let j = 0; j < numSlides; ++j) {
          const currLecture = lectureIds[j].value;
          if (currLecture.includes('-')) {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-slide" slideNo=${lectureIds[j].value}></div>`)
            );
          } else {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-checkpoint" slideNo=${lectureIds[j].value}></div>`)
            );
          }
        }
      }

      function setSectorJunctionInfo() {
          //setting the sector junction slide numbers
          const j12 = sectorLength !== 0 ? (sectorLength - 1): 0;
          const j23 = sectorLength !== 0 ? (2 * sectorLength - 1) : 0;

          const sectorJunction12 = lectureIds[j12].value.split('-');
          sectorJunction12Section = parseInt(sectorJunction12[0]);
          sectorJunction12Slide = sectorJunction12.length > 1 ? parseInt(sectorJunction12[1]) : sectorJunction12Slide;

          const sectorJunction23 = lectureIds[j23].value.split('-');
          sectorJunction23Section = parseInt(sectorJunction23[0]);
          sectorJunction23Slide = sectorJunction23.length > 1 ? parseInt(sectorJunction23[1]) : sectorJunction23Slide;
      }

      function runSlide(slide) { // Steven's patch on 28 Jan 2022: Properly remove slide 99, 99-1, 99-2, 99-3, integrate with the earlier slides
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 1 + "%)");
          $('#title-SC').click();
$("#v-search").val(8);
$("#search").click().addClass("menu-highlighted");
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 2 + "%)");
          
        }
        if (slide == '2-1') {
          $("#e-lecture").html("slide " + slide + " (" + 4 + "%)");
          
        }
        if (slide == '2-2') {
          $("#e-lecture").html("slide " + slide + " (" + 5 + "%)");
          
        }
        if (slide == '2-3') {
          $("#e-lecture").html("slide " + slide + " (" + 7 + "%)");
          
        }
        if (slide == '2-4') {
          $("#e-lecture").html("slide " + slide + " (" + 8 + "%)");
          
        }
        if (slide == '2-5') {
          $("#e-lecture").html("slide " + slide + " (" + 10 + "%)");
          
        }
        if (slide == '2-6') {
          $("#e-lecture").html("slide " + slide + " (" + 11 + "%)");
          
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 13 + "%)");
          
        }
        if (slide == '3-1') {
          $("#e-lecture").html("slide " + slide + " (" + 14 + "%)");
          
        }
        if (slide == '3-2') {
          $("#e-lecture").html("slide " + slide + " (" + 16 + "%)");
          
        }
        if (slide == '3-3') {
          $("#e-lecture").html("slide " + slide + " (" + 17 + "%)");
          
        }
        if (slide == '3-4') {
          $("#e-lecture").html("slide " + slide + " (" + 19 + "%)");
          
        }
        if (slide == '3-5') {
          $("#e-lecture").html("slide " + slide + " (" + 20 + "%)");
          
        }
        if (slide == '3-6') {
          $("#e-lecture").html("slide " + slide + " (" + 22 + "%)");
          
        }
        if (slide == '3-7') {
          $("#e-lecture").html("slide " + slide + " (" + 23 + "%)");
          
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 25 + "%)");
          
        }
        if (slide == '4-1') {
          $("#e-lecture").html("slide " + slide + " (" + 26 + "%)");
          
        }
        if (slide == '4-2') {
          $("#e-lecture").html("slide " + slide + " (" + 27 + "%)");
          
        }
        if (slide == '4-3') {
          $("#e-lecture").html("slide " + slide + " (" + 29 + "%)");
          
        }
        if (slide == '4-4') {
          $("#e-lecture").html("slide " + slide + " (" + 30 + "%)");
          
        }
        if (slide == '4-5') {
          $("#e-lecture").html("slide " + slide + " (" + 32 + "%)");
          
        }
        if (slide == '4-6') {
          $("#e-lecture").html("slide " + slide + " (" + 33 + "%)");
          
        }
        if (slide == '4-7') {
          $("#e-lecture").html("slide " + slide + " (" + 35 + "%)");
          
        }
        if (slide == '4-8') {
          $("#e-lecture").html("slide " + slide + " (" + 36 + "%)");
          
        }
        if (slide == '5') {
          $("#e-lecture").html("slide " + slide + " (" + 38 + "%)");
          
        }
        if (slide == '5-1') {
          $("#e-lecture").html("slide " + slide + " (" + 39 + "%)");
          $('#title-LP').click();
        }
        if (slide == '5-2') {
          $("#e-lecture").html("slide " + slide + " (" + 41 + "%)");
          $('#title-SC').click();
        }
        if (slide == '6') {
          $("#e-lecture").html("slide " + slide + " (" + 42 + "%)");
          
        }
        if (slide == '6-1') {
          $("#e-lecture").html("slide " + slide + " (" + 44 + "%)");
          $('#title-LP').click();
        }
        if (slide == '6-2') {
          $("#e-lecture").html("slide " + slide + " (" + 45 + "%)");
          $('#title-SC').click();
        }
        if (slide == '7') {
          $("#e-lecture").html("slide " + slide + " (" + 47 + "%)");
          $('#title-LP').click();
createTableSpecial([-1,-1,-1,-1,-1,-1,-1]);
$("#v-createM").val(7);
$("#v-createN").val(0);
$("#alpha").text('0.0');
$("#create").click().addClass("menu-highlighted");
        }
        if (slide == '7-1') {
          $("#e-lecture").html("slide " + slide + " (" + 48 + "%)");
          $('#title-LP').click();
$("#v-createM").val(7);
createTableSpecial([14,21,-1,-1,18,-1,-1]);
$("#v-insert").val("18,14,21");
$("#insert").click().addClass("menu-highlighted");
        }
        if (slide == '7-2') {
          $("#e-lecture").html("slide " + slide + " (" + 50 + "%)");
          $('#title-LP').click();
createTableSpecial([14,21,-1,-1,18,-1,-1]);
$("#v-insert").val("1,35");
$("#insert").click().addClass("menu-highlighted");
        }
        if (slide == '7-3') {
          $("#e-lecture").html("slide " + slide + " (" + 51 + "%)");
          $('#title-LP').click();
createTableSpecial([14,21,1,35,18,-1,-1]);
$("#v-search").val(35);
$("#search").click().addClass("menu-highlighted");
        }
        if (slide == '7-4') {
          $("#e-lecture").html("slide " + slide + " (" + 52 + "%)");
          $('#title-LP').click();
createTableSpecial([14,21,1,35,18,-1,-1]);
$("#v-remove").val(21);
$("#remove").click().addClass("menu-highlighted");
        }
        if (slide == '7-5') {
          $("#e-lecture").html("slide " + slide + " (" + 54 + "%)");
          $('#title-LP').click();
createTableSpecial([14,21,1,35,18,-1,-1]);
$("#v-remove").val(21);
$("#remove").click().addClass("menu-highlighted");
        }
        if (slide == '7-6') {
          $("#e-lecture").html("slide " + slide + " (" + 55 + "%)");
          $('#title-LP').click();
createTableSpecial([14,21,1,35,18,-1,-1]);
$("#v-remove").val(21);
$("#remove").click().addClass("menu-highlighted");
        }
        if (slide == '7-7') {
          $("#e-lecture").html("slide " + slide + " (" + 57 + "%)");
          $('#title-LP').click();
createTableSpecial([14,-2,1,35,18,-1,-1]);
$("#v-search").val(35);
$("#search").click().addClass("menu-highlighted");
        }
        if (slide == '7-8') {
          $("#e-lecture").html("slide " + slide + " (" + 58 + "%)");
          $('#title-LP').click();
createTableSpecial([14,-2,1,35,18,-1,-1]);
$("#v-insert").val(15);
$("#insert").click().addClass("menu-highlighted");
        }
        if (slide == '7-9') {
          $("#e-lecture").html("slide " + slide + " (" + 60 + "%)");
          $('#title-LP').click();
createTableSpecial([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]);
        }
        if (slide == '7-10') {
          $("#e-lecture").html("slide " + slide + " (" + 61 + "%)");
          $('#title-LP').click();
createTableSpecial([0,1,2,3,-2,-2,6,7,-2,-2,-2,11,-2,13,-2,31,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]);
        }
        if (slide == '7-11') {
          $("#e-lecture").html("slide " + slide + " (" + 63 + "%)");
          $('#title-LP').click();
createTableSpecial([-1,94,-1,96,66,96,99,68,70,-1,72,73,-1,44,-1,-1,-1,-1,80,-1,-1,-1,22,85,-1,-1,-1,89,-1,91,-1]);
        }
        if (slide == '8') {
          $("#e-lecture").html("slide " + slide + " (" + 64 + "%)");
          $('#title-QP').click();
        }
        if (slide == '8-1') {
          $("#e-lecture").html("slide " + slide + " (" + 66 + "%)");
          $('#title-QP').click();
createTableSpecial([-1,-1,-1,10,18,-1,-1]);
$("#v-insert").val("38");
$("#insert").click().addClass("menu-highlighted");
        }
        if (slide == '8-2') {
          $("#e-lecture").html("slide " + slide + " (" + 67 + "%)");
          $('#title-QP').click();
createTableSpecial([38,-1,-1,10,-2,-1,-1]);
$("#v-search").val("38");
$("#search").click().addClass("menu-highlighted");
        }
        if (slide == '8-3') {
          $("#e-lecture").html("slide " + slide + " (" + 69 + "%)");
          $('#title-QP').click();
createTableSpecial([38,-1,-1,10,18,-1,-1]);
$("#v-insert").val("12,17");
$("#insert").click().addClass("menu-highlighted");
        }
        if (slide == '8-4') {
          $("#e-lecture").html("slide " + slide + " (" + 70 + "%)");
          $('#title-QP').click();
createTableSpecial([38,-1,-1,10,18,12,-1]);
$("#v-insert").val("17");
$("#insert").click().addClass("menu-highlighted");
        }
        if (slide == '8-5') {
          $("#e-lecture").html("slide " + slide + " (" + 72 + "%)");
          
        }
        if (slide == '8-6') {
          $("#e-lecture").html("slide " + slide + " (" + 73 + "%)");
          
        }
        if (slide == '8-7') {
          $("#e-lecture").html("slide " + slide + " (" + 75 + "%)");
          
        }
        if (slide == '8-8') {
          $("#e-lecture").html("slide " + slide + " (" + 76 + "%)");
          $('#title-QP').click();
createTableSpecial([0,1,64,-1,4,36,-1,-1,-1,9,-1,-1,-1,-1,-1,-1,16,-1,49,81,-1,-1,-1,-1,-1,25,-1,-1,-1,-1,-1]);
        }
        if (slide == '9') {
          $("#e-lecture").html("slide " + slide + " (" + 77 + "%)");
          $('#title-DH').click();
        }
        if (slide == '9-1') {
          $("#e-lecture").html("slide " + slide + " (" + 79 + "%)");
          $('#title-DH').click();
        }
        if (slide == '9-2') {
          $("#e-lecture").html("slide " + slide + " (" + 80 + "%)");
          $('#title-DH').click();
createTableSpecial([14,-1,-1,17,-1,12,-1]);
$("#v-insert").val("35,42");
$("#insert").click().addClass("menu-highlighted");
        }
        if (slide == '9-3') {
          $("#e-lecture").html("slide " + slide + " (" + 82 + "%)");
          $('#title-DH').click();
createTableSpecial([14,35,-1,-2,-1,12,42]);
$("#v-search").val(35);
$("#search").click().addClass("menu-highlighted");
        }
        if (slide == '9-4') {
          $("#e-lecture").html("slide " + slide + " (" + 83 + "%)");
          $('#title-DH').click();
createTableSpecial([0,1,64,-1,4,36,-1,-1,-1,9,-1,-1,-1,-1,-1,-1,16,-1,49,81,-1,-1,-1,-1,-1,25,-1,-1,-1,-1,-1]);
        }
        if (slide == '10') {
          $("#e-lecture").html("slide " + slide + " (" + 85 + "%)");
          $('#title-SC').click();
createSCDefaultTC();
$("#v-insert").val("68,90");
$("#insert").click().addClass("menu-highlighted");
        }
        if (slide == '10-1') {
          $("#e-lecture").html("slide " + slide + " (" + 86 + "%)");
          $('#title-SC').click();
createSCDefaultTC();
$("#v-search").val(35);
$("#search").click().addClass("menu-highlighted");
        }
        if (slide == '10-2') {
          $("#e-lecture").html("slide " + slide + " (" + 88 + "%)");
          $('#title-SC').click();
createSCDefaultTC();
$("#v-search").val(35);
$("#search").click().addClass("menu-highlighted");
        }
        if (slide == '10-3') {
          $("#e-lecture").html("slide " + slide + " (" + 89 + "%)");
          $('#title-SC').click();
createSCDefaultTC();
$("#v-search").val(35);
$("#search").click().addClass("menu-highlighted");
        }
        if (slide == '11') {
          $("#e-lecture").html("slide " + slide + " (" + 91 + "%)");
          
        }
        if (slide == '11-1') {
          $("#e-lecture").html("slide " + slide + " (" + 92 + "%)");
          $('#title-SC').click();
        }
        if (slide == '11-2') {
          $("#e-lecture").html("slide " + slide + " (" + 94 + "%)");
          
        }
        if (slide == '11-3') {
          $("#e-lecture").html("slide " + slide + " (" + 95 + "%)");
          
        }
        if (slide == '11-4') {
          $("#e-lecture").html("slide " + slide + " (" + 97 + "%)");
          
        }
        if (slide == '11-5') {
          $("#e-lecture").html("slide " + slide + " (" + 98 + "%)");
          
        }
        if (slide == '11-6') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
        }
        clearTimeout(currSlideTimer);
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };
      var slideTimeline = {};

      //reads all visited slides in the slideTimeline and gives them their sector color
      function setVisitedSlideTimelineColors() {
        for(const [sectionNo, visitedSlides] of Object.entries(slideTimeline)) {
          const visitedSlides = slideTimeline[sectionNo];
          for(const visitedSlideNo of visitedSlides) {
            setSlideTimelineColor(visitedSlideNo);
          }
        }
      }

      //only called on load if there is nothing in session
      function setTimelineForCompletedSector(sectorNum) {
        let len = sectorLength;
        switch (sectorNum) {
          case 1 : len = sectorLength; break;
          case 2 : len = 2 * sectorLength; break;
          default: len = numSlides;
        }
        let i = 0;
        switch (sectorNum) {
          case 1 : i = 0; break;
          case 2 : i = sectorLength; break;
          default: i = 2 * sectorLength;
        }
        for (; i < len; i++) {
          saveELectureTimeline(lectureIds[i].value, true);
        }
      }

      function getUserSectorHistory(callback) {
        $.ajax({
          type: 'GET',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            topic: "/hashtable".substring(1)
          }
        }
        ).done(function (data) {
            if (data.data[0] === 1) {
              setF1SectorColor(1);
              setTimelineForCompletedSector(1);
            }
            if (data.data[1] === 1) {
              setF1SectorColor(2);
              setTimelineForCompletedSector(2);
            }
            if (data.data[2] === 1) {
              setF1SectorColor(3);
              setTimelineForCompletedSector(3);
            }
            callback();
        }).fail(function (data) {
            console.log('get user sector history failed!');
        });
      }

      function getELectureTimelineFromSession() {
        const page = "/hashtable".substring(1);
        const timelineKey = page + '-slide-timeline';
        const storedTimeline = window.sessionStorage.getItem(timelineKey);
        if (storedTimeline) {
          slideTimeline = JSON.parse(storedTimeline);
        } else {
          return false;
        }
        let slideInfo = [];
        for (const [sectionNum, slides] of Object.entries(slideTimeline)) {
          for (const slide of slides) {
            indicateSlideCompletedUI(slide);
            slideInfo = slide.split('-');
            incrementSectorVisits(parseInt(sectionNum), slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0);
          }
        }
        return true;
      }

      async function initializeELectureTimeline() {
        setSectorJunctionInfo();
        if (!getELectureTimelineFromSession())
          getUserSectorHistory(sectorBasedModeSelection);
        else
          sectorBasedModeSelection();

        createELectureTimelineDisplay();
        setVisitedSlideTimelineColors();
      }

      function setF1SectorColor(sectorNum) {
        $(`[sectorNo="${sectorNum}"]`).css('background', sectorColors[(parseInt(sectorNum) % 3)]);
      }

      function updateSectorInDB(sectorNum) {
        $.ajax({
          type: 'POST',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            section: (sectorNum - 1),
            topic: "/hashtable".substring(1)
          }
        }
        ).done(function (data) {
            //console.log("Saved the sector " + sectorNum + " as done " + JSON.stringify(data));
        }).fail(function (data) {
            console.log("Setting sector done failed new attempt! "+ JSON.stringify(data));
        });
      }

      //If 87.5% or more of the slides in sector are done
      function setF1SectorCompleted(sectorNum, isInitializationCall) {
        setF1SectorColor(sectorNum);
        //avoid api call on initialization
        if (!isInitializationCall) {
          updateSectorInDB(sectorNum);
          $(`[sectorNo="${sectorNum}"]`).css("animation", "green-pulse 2s 4");
          setTimeout(() => {
            $(`[sectorNo="${sectorNum}"]`).css("animation", "");
          }, 8000);
        }
      }

      function incrementSectorVisits(sectionNum, slideNumWithinSection, isInitializationCall) {
        //updating sector count
        if (sectionNum < sectorJunction12Section
          || (sectionNum === sectorJunction12Section && slideNumWithinSection <= sectorJunction12Slide)) {
          ++sector1Count;
          if (sector1Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(1, isInitializationCall);
        } else if (sectionNum < sectorJunction23Section
          || (sectionNum === sectorJunction23Section && slideNumWithinSection <= sectorJunction23Slide)) {
          ++sector2Count;
          if (sector2Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(2, isInitializationCall);
        } else {
          ++sector3Count;
          if (sector3Count >= Math.ceil(0.875 * (numSlides - 2 * sectorLength)))
            setF1SectorCompleted(3, isInitializationCall);
        }
      }

      function saveELectureTimeline(slideNo, isInitialization) {
        const slideInfo = slideNo.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        if (slideTimeline[sectionNo]) {
          if (!slideTimeline[sectionNo].includes(slideNo)) {
            slideTimeline[sectionNo].push(slideNo);
            const sectionNum = parseInt(sectionNo);
            incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
          }
        } else {
          slideTimeline[sectionNo] = [];
          slideTimeline[sectionNo].push(slideNo);
          const sectionNum = parseInt(sectionNo);
          incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
        }
        setSlideTimelineColor(slideNo);
        indicateSlideCompletedUI(slideNo);
      }

      function saveELectureTimelineToSession() {
        const page = "/hashtable".substring(1);
        const timelineKey = page + '-slide-timeline';
        window.sessionStorage.setItem(timelineKey, JSON.stringify(slideTimeline));
      }

      function handleTimelineOnRunSlide(slideValue) {
        const slideInfo = slideValue.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        //start timer only if the slide isnt already done
        if (!slideTimeline[sectionNo] || !slideTimeline[sectionNo].includes(slideValue)) {
          const slideTextLength = $('#electure-'+slideValue + " p").text().length + $('#electure-'+slideValue + " li").text().length;
          const CHARS_READ_PER_MS = 0.05; //when fast, 50 characters a second
          //setting max reading time as 10 seconds for around 500 character slide
          const minSlideReadingTime = Math.min(Math.max(2000, (slideTextLength / CHARS_READ_PER_MS) +  + (2000 * $('#electure-'+slideValue + " img").length)), 10000);
          currSlideTimer = setTimeout(() => {
            saveELectureTimeline(slideValue);
          }, minSlideReadingTime);
        }
      }

      function indicateSlideCompletedUI(slide) {
        $('#electure-'+slide).css("box-shadow", "3px 3px 8px green"); //set green shadow for completed slides
        $('#electure-'+slide + ' .electure-read-status').html("&#10004;");
        $('#electure-'+slide + ' .electure-read-status').attr("title", "Slide Completed!");
        $('#electure-'+slide + ' .electure-read-status').css("font-size", "17px");
      }

      function pushState(slideValue) {
        var url = '/en/hashtable';
        if (typeof slideValue != 'undefined' && slideValue != null) {
          url += '?slide=' + slideValue;
                  }
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5);
        $('#overlay').show();

        $("#e-lecture-timeline").show();
        $("#e-lecture-f1map").show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
        $("#e-lecture-timeline").hide();
        $("#e-lecture-f1map").hide();
        clearTimeout(currSlideTimer);
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      function sectorBasedModeSelection() {
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        //check params are empty and then that all sectors are completed or not
        if (!Object.keys(params).length
          && sector1Count === sectorLength && sector2Count === sectorLength && sector3Count === (numSlides - 2 * sectorLength)) {
            hideOverlay();
        }
        else
          $('#mode-menu a').click();
      }

      $(function() {
        if (isMobileOS() && portraitMatcher.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').show();
          $('#widenDeviceText').hide();
          $('#topbar').css("z-index", 10001);
        } else if (matchMediaNarrow.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').hide();
          $('#widenDeviceText').show();
          $('#topbar').css("z-index", 10001);
        } else {
          $('#rotateDeviceOverlay').hide();
          $('#topbar').css("z-index", "");
        }

        matchMediaNarrow.addEventListener('change', e => {
          //screws up for square device! NEED RESIZE EVENT
          if (e.matches) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').hide();
              $('#widenDeviceText').show();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        portraitMatcher.addEventListener('change', e => {
          if (e.matches && isMobileOS()) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').show();
              $('#widenDeviceText').hide();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        let slide = getUrlParameter('slide');
        if (typeof slide !== undefined && slide != null) {
          cur_slide = slide;
        }
        //do all timeline and slide stuff only if specific params not provided
        if (!Object.keys(params).length || params["slide"]) {
          if (!isMobile()) {
                            $('#mode-menu a').click();
                      }
        }
        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
        $('#electure-2-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2-2');
          pushState('2-2');
        });
        $('#electure-2-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-2-2 .electure-next').click(function() {
          hidePopup();
          runSlide('2-3');
          pushState('2-3');
        });
        $('#electure-2-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
        $('#electure-2-3 .electure-next').click(function() {
          hidePopup();
          runSlide('2-4');
          pushState('2-4');
        });
        $('#electure-2-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-2');
          pushState('2-2');
        });
        $('#electure-2-4 .electure-next').click(function() {
          hidePopup();
          runSlide('2-5');
          pushState('2-5');
        });
        $('#electure-2-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-3');
          pushState('2-3');
        });
        $('#electure-2-5 .electure-next').click(function() {
          hidePopup();
          runSlide('2-6');
          pushState('2-6');
        });
        $('#electure-2-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-4');
          pushState('2-4');
        });
        $('#electure-2-6 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-5');
          pushState('2-5');
        });
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-6');
          pushState('2-6');
        });
        $('#electure-3-1 .electure-next').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
        $('#electure-3-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-3-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
        $('#electure-3-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
        $('#electure-3-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
        $('#electure-3-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
        $('#electure-3-4 .electure-next').click(function() {
          hidePopup();
          runSlide('3-5');
          pushState('3-5');
        });
        $('#electure-3-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
        $('#electure-3-5 .electure-next').click(function() {
          hidePopup();
          runSlide('3-6');
          pushState('3-6');
        });
        $('#electure-3-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
        $('#electure-3-6 .electure-next').click(function() {
          hidePopup();
          runSlide('3-7');
          pushState('3-7');
        });
        $('#electure-3-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-5');
          pushState('3-5');
        });
        $('#electure-3-7 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-6');
          pushState('3-6');
        });
        $('#electure-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-7');
          pushState('3-7');
        });
        $('#electure-4-1 .electure-next').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-4-2 .electure-next').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
        $('#electure-4-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
        $('#electure-4-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
        $('#electure-4-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
        $('#electure-4-5 .electure-next').click(function() {
          hidePopup();
          runSlide('4-6');
          pushState('4-6');
        });
        $('#electure-4-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
        $('#electure-4-6 .electure-next').click(function() {
          hidePopup();
          runSlide('4-7');
          pushState('4-7');
        });
        $('#electure-4-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
        $('#electure-4-7 .electure-next').click(function() {
          hidePopup();
          runSlide('4-8');
          pushState('4-8');
        });
        $('#electure-4-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-6');
          pushState('4-6');
        });
        $('#electure-4-8 .electure-next').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-4-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-7');
          pushState('4-7');
        });
        $('#electure-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
        $('#electure-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-8');
          pushState('4-8');
        });
        $('#electure-5-1 .electure-next').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
        $('#electure-5-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-5-2 .electure-next').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-5-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
        $('#electure-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
        $('#electure-6-1 .electure-next').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-6-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-6-2 .electure-next').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-6-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-7 .electure-next').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-7-1 .electure-next').click(function() {
          hidePopup();
          runSlide('7-2');
          pushState('7-2');
        });
        $('#electure-7-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-7-2 .electure-next').click(function() {
          hidePopup();
          runSlide('7-3');
          pushState('7-3');
        });
        $('#electure-7-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-7-3 .electure-next').click(function() {
          hidePopup();
          runSlide('7-4');
          pushState('7-4');
        });
        $('#electure-7-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-2');
          pushState('7-2');
        });
        $('#electure-7-4 .electure-next').click(function() {
          hidePopup();
          runSlide('7-5');
          pushState('7-5');
        });
        $('#electure-7-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-3');
          pushState('7-3');
        });
        $('#electure-7-5 .electure-next').click(function() {
          hidePopup();
          runSlide('7-6');
          pushState('7-6');
        });
        $('#electure-7-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-4');
          pushState('7-4');
        });
        $('#electure-7-6 .electure-next').click(function() {
          hidePopup();
          runSlide('7-7');
          pushState('7-7');
        });
        $('#electure-7-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-5');
          pushState('7-5');
        });
        $('#electure-7-7 .electure-next').click(function() {
          hidePopup();
          runSlide('7-8');
          pushState('7-8');
        });
        $('#electure-7-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-6');
          pushState('7-6');
        });
        $('#electure-7-8 .electure-next').click(function() {
          hidePopup();
          runSlide('7-9');
          pushState('7-9');
        });
        $('#electure-7-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-7');
          pushState('7-7');
        });
        $('#electure-7-9 .electure-next').click(function() {
          hidePopup();
          runSlide('7-10');
          pushState('7-10');
        });
        $('#electure-7-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-8');
          pushState('7-8');
        });
        $('#electure-7-10 .electure-next').click(function() {
          hidePopup();
          runSlide('7-11');
          pushState('7-11');
        });
        $('#electure-7-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-9');
          pushState('7-9');
        });
        $('#electure-7-11 .electure-next').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
        $('#electure-7-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-10');
          pushState('7-10');
        });
        $('#electure-8 .electure-next').click(function() {
          hidePopup();
          runSlide('8-1');
          pushState('8-1');
        });
        $('#electure-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-11');
          pushState('7-11');
        });
        $('#electure-8-1 .electure-next').click(function() {
          hidePopup();
          runSlide('8-2');
          pushState('8-2');
        });
        $('#electure-8-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
        $('#electure-8-2 .electure-next').click(function() {
          hidePopup();
          runSlide('8-3');
          pushState('8-3');
        });
        $('#electure-8-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-1');
          pushState('8-1');
        });
        $('#electure-8-3 .electure-next').click(function() {
          hidePopup();
          runSlide('8-4');
          pushState('8-4');
        });
        $('#electure-8-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-2');
          pushState('8-2');
        });
        $('#electure-8-4 .electure-next').click(function() {
          hidePopup();
          runSlide('8-5');
          pushState('8-5');
        });
        $('#electure-8-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-3');
          pushState('8-3');
        });
        $('#electure-8-5 .electure-next').click(function() {
          hidePopup();
          runSlide('8-6');
          pushState('8-6');
        });
        $('#electure-8-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-4');
          pushState('8-4');
        });
        $('#electure-8-6 .electure-next').click(function() {
          hidePopup();
          runSlide('8-7');
          pushState('8-7');
        });
        $('#electure-8-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-5');
          pushState('8-5');
        });
        $('#electure-8-7 .electure-next').click(function() {
          hidePopup();
          runSlide('8-8');
          pushState('8-8');
        });
        $('#electure-8-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-6');
          pushState('8-6');
        });
        $('#electure-8-8 .electure-next').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
        $('#electure-8-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-7');
          pushState('8-7');
        });
        $('#electure-9 .electure-next').click(function() {
          hidePopup();
          runSlide('9-1');
          pushState('9-1');
        });
        $('#electure-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-8');
          pushState('8-8');
        });
        $('#electure-9-1 .electure-next').click(function() {
          hidePopup();
          runSlide('9-2');
          pushState('9-2');
        });
        $('#electure-9-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
        $('#electure-9-2 .electure-next').click(function() {
          hidePopup();
          runSlide('9-3');
          pushState('9-3');
        });
        $('#electure-9-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-1');
          pushState('9-1');
        });
        $('#electure-9-3 .electure-next').click(function() {
          hidePopup();
          runSlide('9-4');
          pushState('9-4');
        });
        $('#electure-9-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-2');
          pushState('9-2');
        });
        $('#electure-9-4 .electure-next').click(function() {
          hidePopup();
          runSlide('10');
          pushState('10');
        });
        $('#electure-9-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-3');
          pushState('9-3');
        });
        $('#electure-10 .electure-next').click(function() {
          hidePopup();
          runSlide('10-1');
          pushState('10-1');
        });
        $('#electure-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-4');
          pushState('9-4');
        });
        $('#electure-10-1 .electure-next').click(function() {
          hidePopup();
          runSlide('10-2');
          pushState('10-2');
        });
        $('#electure-10-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('10');
          pushState('10');
        });
        $('#electure-10-2 .electure-next').click(function() {
          hidePopup();
          runSlide('10-3');
          pushState('10-3');
        });
        $('#electure-10-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('10-1');
          pushState('10-1');
        });
        $('#electure-10-3 .electure-next').click(function() {
          hidePopup();
          runSlide('11');
          pushState('11');
        });
        $('#electure-10-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('10-2');
          pushState('10-2');
        });
        $('#electure-11 .electure-next').click(function() {
          hidePopup();
          runSlide('11-1');
          pushState('11-1');
        });
        $('#electure-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('10-3');
          pushState('10-3');
        });
        $('#electure-11-1 .electure-next').click(function() {
          hidePopup();
          runSlide('11-2');
          pushState('11-2');
        });
        $('#electure-11-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('11');
          pushState('11');
        });
        $('#electure-11-2 .electure-next').click(function() {
          hidePopup();
          runSlide('11-3');
          pushState('11-3');
        });
        $('#electure-11-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('11-1');
          pushState('11-1');
        });
        $('#electure-11-3 .electure-next').click(function() {
          hidePopup();
          runSlide('11-4');
          pushState('11-4');
        });
        $('#electure-11-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('11-2');
          pushState('11-2');
        });
        $('#electure-11-4 .electure-next').click(function() {
          hidePopup();
          runSlide('11-5');
          pushState('11-5');
        });
        $('#electure-11-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('11-3');
          pushState('11-3');
        });
        $('#electure-11-5 .electure-next').click(function() {
          hidePopup();
          runSlide('11-6');
          pushState('11-6');
        });
        $('#electure-11-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('11-4');
          pushState('11-4');
        });
        $('#electure-11-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('11-5');
          pushState('11-5');
        });
      });

      function doButtonAction79() {
        $("#v-create").val(7);
createTableSpecial([-1,-1,-1,-1,-1,-1,-1]);
CUSTOM_ACTION('insert','18,14,21');
$("#recap1").html("First, we Insert(18). h(18) = 18%7 = 4. As HT[4] is clearly empty, we put 18 there.<br>Second, we Insert(14). h(14) = 14%7 = 0. As HT[0] is clearly empty, we put 14 there.<br><br>Third, we Insert(21). h(21) = 21%7 = 0 too. As HT[0] is already occupied by key 14 above, we cannot put 21 there. Since we use linear probing as the collision resolution technique, we look for the next empty slot. HT[1] happens to be empty and we put 21 there.");
      }
      function doButtonAction80() {
        createTableSpecial([14,21,-1,-1,18,-1,-1]);
CUSTOM_ACTION('insert','1,35');
$("#recap2").html("Fourth, we Insert(1). h(1) = 1%7 = 1. As HT[1] is already occupied by key 21 from earlier slide, we cannot put 1 there. Using Linear Probing, we look for the next available slot. HT[2] happens to be empty and we put 1 there.<br><br>Fifth, we Insert(35). h(35) = 35%7 = 0 too. As HT[0] and the next two adjacent slots: HT[1] and HT[2] have been occupied from previous insertions, we cannot put 35 in those three slots. Linear Probing will continue and find HT[3] is empty and put 35 there.");
      }
      function doButtonAction81() {
        CUSTOM_ACTION('search','35');
      }
      function doButtonAction82() {
        CUSTOM_ACTION('search','7');
      }
      function doButtonAction83() {
        createTableSpecial([14,21,1,35,18,-1,-1]);
CUSTOM_ACTION('remove','21');
      }
      function doButtonAction84() {
        createTableSpecial([14,-2,1,35,18,-1,-1]);
CUSTOM_ACTION('insert','28');
      }
      function doButtonAction85() {
        createTableSpecial([-1,-1,-1,10,18,-1,-1]);
CUSTOM_ACTION('insert','38');
$("#recap3").html("We will first try to put 38 at base address index h(38) = 38%7 = 3, but we are unable to do so as key 10 is already there.<br><br>Then, we try to put 38 at base address 3 + 1*1 = 4, but again we are unable to do so as key 18 is already there.<br><br>So, we try to put 38 at base address 3 + 2*2 = 7. But index 7 exceeds the last index <b>M</b>-1 = 7-1 = 6 in this Hash Table. We need the modulo operation to help us wrap around and reach index (3+4) % 7 = 0. We put 38 in this empty cell.");
      }
      function doButtonAction86() {
        createTableSpecial([38,-1,-1,10,18,-1,-1]);
CUSTOM_ACTION('insert','12,17');
      }
      function doButtonAction87() {
        createTableSpecial([14,-1,-1,17,-1,12,-1]);
CUSTOM_ACTION('insert','35,42');
$("#recap4").html("As the Hash Table size <b>M = 7</b>, the smaller prime is <b>M' = 5</b>.<br>Then, <samp>h2(35) = 5 - 35%5 = 5</samp> and <samp>h2(42) = 5 - 42%5 = 3</samp>.<br><br>Thus, Insert(35) will check indices [0,5,3,1 (found empty slot)] and insert 35 at index 1.<br>Then, Insert(42) will check indices [0,3,6 (found empty slot)] and insert 42 at index 6.<br>While <samp>h(35) = h(42) = 0</samp>, their probing sequences are different as <samp>h2(35) &ne; h2(42)</samp>.");
      }
      function doButtonAction88() {
        $("#vonmises").html("after having just 23 people (keys) in the room (the hash table of size 365 cells), it is more likely (&gt; 50% chance) to have a collision than not... We do not need 365/2 ~= 180+ people");
      }
      function doButtonAction91() {
        CUSTOM_ACTION('search','38');
      }
      function doButtonAction92() {
        CUSTOM_ACTION('insert','31');
      }
      function doButtonAction93() {
        $('#title-SC').click();
CUSTOM_ACTION('insert','9,16,23,30,37,44');
      }
      function doButtonAction94() {
        CUSTOM_ACTION('remove','35');
      }
      function doButtonAction126() {
        $('#title-SC').click();
CUSTOM_ACTION('insert','68,90');
      }
      function doButtonAction127() {
        CUSTOM_ACTION('search','31');
      }
      function doButtonAction128() {
        CUSTOM_ACTION('insert','2,9,12,1');
      }
      function doButtonAction129() {
        createTableSpecial([0,1,64,-1,4,36,-1,-1,-1,9,-1,-1,-1,-1,-1,-1,16,-1,49,81,-1,-1,-1,-1,-1,25,-1,-1,-1,-1,-1]);
CUSTOM_ACTION('insert','62,93');
      }
      function doButtonAction145() {
        var str = $('#strv').val();
var sum = 0;
for (var i = 0; i < str.length; ++i) {
  console.log("'" + str[i] + "'");
  sum = ((sum*26) + (str.charCodeAt(i)-65+1));
}
$('#hv').text(sum.toString());
      }

      $('.electure-print').click(() => {
        window.open(`/en/hashtable/print`);
      });
      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url.html) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}

      // This function will be called everytime 1.0x is changed to 0.5x or vice versa
      function redraw() {}

      $(document).ready(function () {
        setTimeout(function () {
          $('#change-lang-popup').fadeOut('slow')
        }, 5000)
      })
    </script>
<script type="text/javascript">
    var extraCSS = {"remove":"65px","insert":"92px","search":"119px","create":"146px"};
    var actionsIds = {"create":{"p":"Create(M, N)"},"search":{"p":"Search(v)"},"insert":{"p":"Insert(v)"},"remove":{"p":"Remove(v)"}};
    var isOpens = {};
    var len = 4;
    var keys = ["create","search","insert","remove"]; 
    for (i = 0; i < len; i++) {
        var actionDetails = keys[i];
        isOpens[actionDetails] = false;
    }
    function openAction(id) {
        hideThirdTiers(id);
        $("." + id).css("bottom", extraCSS[id]);
        if (!isOpens[id]) {
            $('.' + id).fadeIn('fast');
            isOpens[id] = true;
        }
    }
    function closeAction(id) {
        hideThirdTiers(id);
        if (isOpens[id]) {
            $('.' + id).fadeOut('fast');
            $('#' + id + '-err').html("");
            isOpens[id] = false;
        }
    }

    function hideEntireActionsPanel() {
        //hideAllThirdTiers();
                    closeAction('create');
                    closeAction('search');
                    closeAction('insert');
                    closeAction('remove');
                hideActionsPanel();
    }

    function hideThirdTiers(tier1Action) {
        if ("parents" in actionsIds[tier1Action]) {
            for (const secondTierAction of actionsIds[tier1Action]["parents"]) {
                $('#' + secondTierAction + '-third-tier').fadeOut('fast');
            }
        }
    }

    function hideAllThirdTiers() {
        for (const tier1Action in actionsIds) {
            hideThirdTiers(tier1Action);
        }
    }

    function toggleChildExtras(tier1, selectedParentTier2) {
        hideThirdTiers(tier1);
        //this actionId must have childExtras
        var style = extraCSS[tier1];
        $("." + tier1).css("bottom", (parseInt(style.substring(0, style.length - 2)) - 27));
        //fade ins and outs are done on the ID whereas css class is set on the class
        //fade in the third tier of the selected 2nd tier parent
        $('#' + selectedParentTier2 + '-third-tier').fadeIn('fast');

        // //fade out all other third tiers of that 'action'
        // for (const parent of actions[tier1]["parents"]) {
        //     console.log("parent is " + parent + " for " + selectedParentTier2);
        //     if (parent != selectedParentTier2) {
        //         $('#' + parent + '-third-tier').fadeOut('fast');
        //     }
        // }
    }

    function setActionHeightOriginal(tier1Action) {
        $("." + tier1Action).css("bottom", extraCSS[tier1Action]);
    }

            $('#' + 'create').click(function() {
            openAction('create');
                                                                            closeAction('search');
                                                                closeAction('insert');
                                                                closeAction('remove');
                                    });
            $('#' + 'search').click(function() {
            openAction('search');
                                                closeAction('create');
                                                                                            closeAction('insert');
                                                                closeAction('remove');
                                    });
            $('#' + 'insert').click(function() {
            openAction('insert');
                                                closeAction('create');
                                                                closeAction('search');
                                                                                            closeAction('remove');
                                    });
            $('#' + 'remove').click(function() {
            openAction('remove');
                                                closeAction('create');
                                                                closeAction('search');
                                                                closeAction('insert');
                                                                });
    
    //important to have all the input fields in actions menu take an id containing '-input'
    $("[id*='-input']").on("keypress keydown keyup", (event) => {
        event.stopPropagation();
    });
</script>
<script type="text/javascript">
// HashTable Widget
// original author: Steven Halim
// Defines a HashTable object; keeps implementation of Hash Table internally and interact with GraphWidget to display Hash Table visualizations

var scale = false;
var HashTable = function() {
  var self = this;

  var gw = new GraphWidget(false, true);
  this.getGraphWidget = function() { return gw; }

  var maxHashTableSize = 90; // 24 Apr 2023, new frontier, with medium scale format
  var maxHashTableSCSize = 31; // 25 Apr 2023, try 31
  var maxChainLength = 7; // 26 Apr, try 7 (from 6)
  var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89]; // 24 primes within our range of allowed Hash Table sizes, we resize to medium scale beyond 48 (3 rows of 16)
  var EMPTY = -1; // use -1 to indicate EMPTY element
  var DELETED = -2; // use -2 to indicate DELETED element
  var HT;  // HT: the Array that represents the state of the Hash Table in Open Addressing
  var HT_SC; // HT_SC: Adjacency List like structure to represent the state of the Hash Table in Separate Chaining
  var N = 4; // number of elements actually present in the hash table
  this.getN = function() { return N; }

  var activeStatus = "-";
  this.getActiveStatus = function() { return activeStatus; }

  this.setActiveStatus = function(newActiveStatus) {
    if (activeStatus != newActiveStatus) {
      activeStatus = newActiveStatus;
      if (activeStatus == "SC") { // Separate Chaining
        rand_M = primes[3 + Math.floor(Math.random()*8)]; // [7, 11, 13, 17, 19, 23, 29, 31] only
        $('#v-createM').val(rand_M);
        $('#v-createN').val(Math.floor(rand_M/2) + Math.floor(Math.random()*(rand_M*2))); // alpha = [0.5 .. 2.5] for SC
      }
      else { // Open Addressing
        rand_M = primes[7 + Math.floor(Math.random()*(24-7))]; // [19..89]
        $('#v-createM').val(rand_M);
        $('#v-createN').val(Math.floor(rand_M/4) + Math.floor(Math.random()*(rand_M/4))); // alpha = [0.25 .. 0.5] for OA
      }
      createTable(rand_M, $('#v-createN').val());
    }
  }

  this.createTable = function(sz, rand_N) {
    $('#create-err').html(''); // clear this
    if (sz < 5) { // for either mode
      // Sorry, Hash Table size should be ≥
      $('#create-err').html('Sorry, Hash Table size should be &ge; ' + "5");
      return false;
    }

    if (activeStatus != "SC") {
      if (sz > maxHashTableSize) {
        // Sorry, maximum allowed Hash Table size is
        $('#create-err').html('Sorry, maximum allowed Hash Table is ' + maxHashTableSize);
        return false;
      }

      if (rand_N*2 > sz) {
        $('#create-err').html('Sorry, please lower initial N to &le; M/2');
        return false;
      }
    }
    else { // if (activeStatus == "SC") {
      if (sz > maxHashTableSCSize) {
        // Sorry, maximum allowed Hash Table size is
        $('#create-err').html('Sorry, maximum allowed Hash Table is ' + maxHashTableSCSize + " (smaller for SC)");
        return false;
      }

      // rand_N can be bigger... but hopefully doesn't create case when one chain is very long? (> 6)?
    }

    N = 0; // reset
    // var inserted = new Set()
    var to_insert = "";
    for (var i = 0; i < rand_N; ++i) {
      var v = Math.floor(1+Math.random()*99); // [1..99]
      // while (inserted.has(v))
      //   v = Math.floor(1+Math.random()*99);
      // inserted.add(v);
      to_insert += v + ",";
    }
    to_insert = to_insert.slice(0, -1); // remove last ','

    if (activeStatus == "SC") { // Separate Chaining, one row of chains
      HT_SC = new Array(sz);
      for (var i = 0; i < sz; ++i)
        HT_SC[i] = [];
      this.insertSC(to_insert, null, false); // insert these, but without animation
      init(true);
    }
    else if (activeStatus != "SC") { // NOT Separate Chaining means Open Addressing where we can have 3 rows of 15 cells
      HT = new Array(sz);
      for (var i = 0; i < sz; ++i)
        HT[i] = EMPTY;
      if (to_insert != "") // avoid N=0 case
        this.insert(to_insert, null, false); // insert these, but without animation
      init(false);
    }
  };

  this.createTableSpecial = function(_HT) {
    HT = _HT;
    N = 0;
    for (var i = 0; i < HT.length; ++i)
      if (HT[i] != EMPTY)
        ++N;
    init(false);
  }

  this.generate = function(arr, callback) {
    if (arr.length > maxHashTableSize) {
      // Sorry, maximum allowed Hash Table size is
      $('#create-err').html('Sorry, maximum allowed Hash Table is ' + maxHashTableSize);
      return;
    }
    if (arr.length < 5) {
      // Sorry, Hash Table size should be ≥
      $('#create-err').html('Sorry, Hash Table size should be &ge; ' + "5");
      return;
    }
    HT = new Array(arr.length);
    for (var i = 0; i < arr.length; ++i)
      HT[i] = parseInt(arr[i]);
    init(false, callback);
  };

  function init(SC_mode, callback) {
    // HT size only change during init like this
    if ((!SC_mode && (HT.length > 45)) || (SC_mode && (HT_SC.length > 19))) // condition for shrinking
      setMediumScale(true);
    else
      setDefaultScale(true);

    gw.removeAll();
    var stateList = [];
    var cs;
    if (!SC_mode)
      cs = createState({}, {});
    else
      cs = createStateSC({}, {});
    gw.updateGraph(cs, 500);
    stateList.push(cs);
    stateList.push(cs); // need to push twice to get the effect :O (something is not correct)
    gw.startAnimation(stateList, callback);
  }

  this.exampleSC = function() { // still used in one of the e-Lecture slide
    HT_SC = [[11], [1], [24,13,35,79], [14], [], [27], [28], [18,7], [8], [], [21,10]];
    N = 13;
    init(true);
  }

  this.search = function(key, callback) {
    var stateList = [];
    var vertexTraversed = {};
    var edgeTraversed = {};
    var cs;

    if (key < 0 || key > 99) {
      cs = createState(vertexTraversed, edgeTraversed);
      // key = {key}, it must be between [0..99] in this visualization.
      // -1 = empty cell (blank) and -2 = deleted item.
      cs["status"] = 'key = {key}, it must be between [0..99] in this visualization.<br>-1 = empty cell (blank) and -2 = deleted item.'.replace("{key}", key);
      stateList.push(cs);
    }
    else {
      var i = key%(HT.length), base = i;
      var i_next;
      var jump = 1;
      var step = 1;
      var k = 23, smallerPrime = primes[k];
      while (smallerPrime >= HT.length)
        smallerPrime = primes[--k];
      var secondary = smallerPrime - key%smallerPrime; // so it will always be positive
      var strategy = "linear probing";

      cs = createState(vertexTraversed, edgeTraversed);
      // key = {key} is hashed to i = base = {key}%{length} = {i}.
      cs["status"] = 'key = {key} is hashed to i = base = {key}%{length} = {i}.'.replace("{key}", key).replace("{key}", key).replace("{length}", HT.length).replace("{i}", i);
      cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
      cs["lineNo"] = 1;
      stateList.push(cs);
      vertexTraversed[i] = true; // this is traversed in future iteration

      while (true) {
        if (HT[i] == EMPTY) { // Not Found
          cs = createState(vertexTraversed, edgeTraversed);
          // HT[{i}] is empty.
          // Therefore key = {key} is not found in Hash Table HT.
          cs["status"] = 'HT[{i}] is empty.<br>Therefore key = {key} is not found in Hash Table HT.'.replace("{i}", i).replace("{key}", key);
          cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
          cs["lineNo"] = 3;
          stateList.push(cs);
          break;
        }
        else if (HT[i] == key) { // Found
          cs = createState(vertexTraversed, edgeTraversed);
          // HT[{i}] = {key}.
          // Therefore key = {key} is found in Hash Table HT at index {i}.
          cs["status"] = 'HT[{i}] = {key}.<br>Therefore key = {key} is found in Hash Table HT at index {i}.'.replace("{i}", i).replace("{key}", key).replace("{key}", key).replace("{i}", i);
          cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
          cs["lineNo"] = 4;
          stateList.push(cs);
          break;
        }
        else {
          if (step == HT.length) {
            cs = createState(vertexTraversed, edgeTraversed);
            // After probing all possibilities, key = {key} is not found in Hash Table HT.
            cs["status"] = 'After probing all possibilities, key = {key} is not found in Hash Table HT.'.replace("{key}", key);
            stateList.push(cs);
            break;
          }

          if (activeStatus == "LP") {
            jump = 1;
            strategy = "LP"; // "linear probing";
          }
          else if (activeStatus == "QP") {
            jump = step;
            strategy = "QP"; // "quadratic probing";
          }
          else if (activeStatus == "DH") {
            jump = secondary;
            strategy = "DH"; // "double hashing";
          }

          i_next = (base + step*jump) % HT.length;

          cs = createState(vertexTraversed, edgeTraversed);
          // HT[{i}] = {val} != key.
          // Use {strategy} to check the next index i_next = ({base}+{step}*{jump})%{length} = {i_next}.
          cs["status"] = 'HT[{i}] = {val} != key.<br>Use {strategy} to check the next index i_next = ({base}+{step}*{jump})%{length} = {i_next}.'
                            .replace("{i}", i).replace("{val}", HT[i]).replace("{strategy}", strategy)
                            .replace("{base}", base).replace("{step}", step).replace("{jump}", jump).replace("{length}", HT.length).replace("{i_next}", i_next);
          cs["vl"][i_next]["state"] = VERTEX_HIGHLIGHTED;
          cs["lineNo"] = 5;
          stateList.push(cs);
          vertexTraversed[i_next] = true; // this is traversed in future iteration
          i = i_next;
          ++step;
        }
      }
    }

    gw.startAnimation(stateList, callback);
    populatePseudocode(0);
    return true;
  }

  this.searchSC = function(key, callback) {
    var stateList = [];
    var vertexTraversed = {};
    var edgeTraversed = {};
    var cs;

    if (key < 0 || key > 99) {
      cs = createStateSC(vertexTraversed, edgeTraversed);
      // key = {key}, it must be between [0..99] in this visualization.
      // -1 = empty cell (blank) and -2 = deleted item.
      cs["status"] = 'key = {key}, it must be between [0..99] in this visualization.<br>-1 = empty cell (blank) and -2 = deleted item.'.replace("{key}", key);
      stateList.push(cs);
    }
    else {
      var M = HT_SC.length;
      var i = key%M;
      var j = 0;

      cs = createStateSC(vertexTraversed, edgeTraversed);
      // key = {key} is hashed to i = base = {key}%{length} = {i}.
      cs["status"] = 'key = {key} is hashed to i = base = {key}%{length} = {i}.'.replace("{key}", key).replace("{key}", key).replace("{length}", M).replace("{i}", i);
      cs["vl"][i*(maxChainLength+1)]["state"] = VERTEX_HIGHLIGHTED;
      cs["lineNo"] = 1;
      stateList.push(cs);
      vertexTraversed[i*(maxChainLength+1)] = true; // this is traversed in future iteration

      for (var j = 0; j < HT_SC[i].length; ++j) {
        cs = createStateSC(vertexTraversed, edgeTraversed);
        cs["status"] = 'Checking this vertex';
        cs["vl"][i*(maxChainLength+1)+(j+1)]["state"] = VERTEX_HIGHLIGHTED;
        cs["lineNo"] = [2, 3];
        stateList.push(cs);
        vertexTraversed[i*(maxChainLength+1)+(j+1)] = true; // this is traversed in future iteration
        if (HT_SC[i][j] == key) {
          cs = createStateSC(vertexTraversed, edgeTraversed);
          cs["status"] = '{key} is found in Hash Table'.replace("{key}", key);
          cs["vl"][i*(maxChainLength+1)+(j+1)]["state"] = VERTEX_HIGHLIGHTED;
          cs["lineNo"] = [4];
          stateList.push(cs);
          break;
        }
      }

      if (j == HT_SC[i].length) { // not found
        cs = createStateSC(vertexTraversed, edgeTraversed);
        cs["status"] = '{key} is not found in Hash Table'.replace("{key}", key);
        cs["lineNo"] = 5;
        stateList.push(cs);
      }
    }

    gw.startAnimation(stateList, callback);
    populatePseudocode(3);
    return true;
  }

  this.insert = function(keys, callback, animated = true) {
    var stateList = [];
    var cs;

    var the_keys = keys.split(",");
    for (idx in the_keys) {
      var vertexTraversed = {}; // reset per key inserted
      var edgeTraversed = {};
      key = parseInt(the_keys[idx]);

      if (key < 0 || key > 99) {
        if (animated) {
          cs = createState(vertexTraversed, edgeTraversed);
          // key = {key}, it must be between [0..99] in this visualization.
          // -1 = empty cell (blank) and -2 = deleted item.
          cs["status"] = 'key = {key}, it must be between [0..99] in this visualization.<br>-1 = empty cell (blank) and -2 = deleted item.'.replace("{key}", key);
          stateList.push(cs);
        }
      }
/*
      else if (HT.indexOf(key) != -1) {
        if (animated) {
          cs = createState(vertexTraversed, edgeTraversed);
          // key = {key} is already in the Hash Table.
          // We prevent insertion of duplicate keys.
          cs["status"] = 'key = {key} is already in the Hash Table.<br>We prevent insertion of duplicate keys.'.replace("{key}", key);
          stateList.push(cs);
        }
      }
*/
      else {
        if (N+1 == HT.length) { // one item before full (if we allow full, our search can get into infinite loop)
          if (animated) {
            cs = createState(vertexTraversed, edgeTraversed);
            // Sorry, the Hash Table HT is nearly full (load factor too high).
            // We cannot insert a new integer.
            cs["status"] = 'Sorry, the Hash Table HT is nearly full (load factor too high).<br>We cannot insert a new integer.';
            cs["lineNo"] = 1;
            stateList.push(cs);
          }
        }
        else { // not yet full, do the insertion
          var i = key%(HT.length), base = i;
          var i_next;
          var jump = 1;
          var step = 1;
          var k = 23, smallerPrime = primes[k];
          while (smallerPrime >= HT.length)
            smallerPrime = primes[--k];
          var secondary = smallerPrime - key%smallerPrime; // so it will always be positive
          var strategy = "linear probing";

          if (animated) {
            cs = createState(vertexTraversed, edgeTraversed);
            // The hash table is not yet full.
            // key = {key} is hashed to i = base = {key}%{length} = {i}.
            cs["status"] = 'Begin insertion.<br>key = {key} is hashed to i = base = {key}%{length} = {i}.'.replace("{key}", key).replace("{key}", key).replace("{length}", HT.length).replace("{i}", i);
            cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
            cs["lineNo"] = 2;
            stateList.push(cs);
            vertexTraversed[i] = true; // this is traversed in future iteration
          }

          while (HT[i] >= 0 && step < HT.length) {
            if (activeStatus == "LP") {
              jump = 1;
              strategy = "LP"; // linear probing";
            }
            else if (activeStatus == "QP") {
              jump = step;
              strategy = "QP"; // quadratic probing";
            }
            else if (activeStatus == "DH") {
              jump = secondary;
              strategy = "DH"; // double hashing";
            }

            i_next = (base + step*jump) % HT.length;

            if (animated) {
              var special = (HT[i] == key ? '&nbsp;(actually a duplicate key)' : ""); // ' (actually a duplicate key)'
              cs = createState(vertexTraversed, edgeTraversed);
              // HT[{i}] = {val} is occupied{special}.
              // Use {strategy} to check the next index i_next ({base}+{step}*{jump})%{length} = {i_next}.
              cs["status"] = 'HT[{i}] = {val} is occupied{special}.<br>Use {strategy} to check the next index i_next ({base}+{step}*{jump})%{length} = {i_next}.'
                                .replace("{i}", i).replace("{val}", HT[i]).replace("{special}", special)
                                .replace("{strategy}", strategy).replace("{base}", base).replace("{step}", step).replace("{jump}", jump).replace("{length}", HT.length).replace("{i_next}", i_next);
              cs["vl"][i_next]["state"] = VERTEX_HIGHLIGHTED;
              cs["lineNo"] = 3;
              stateList.push(cs);
              vertexTraversed[i_next] = true; // this is traversed in future iteration
            }
            i = i_next;
            ++step;
          }

          if (step == HT.length) {
            if (animated) {
              cs = createState(vertexTraversed, edgeTraversed);
              // After {step} probe steps, we still cannot find an insertion point.
              // Reporting failure...
              cs["status"] = 'After {step} probe steps, we still cannot find an insertion point.<br>Reporting failure...'.replace("{step}", step);
              stateList.push(cs);
            }
          }
          else {
            HT[i] = key;
            ++N;

            if (animated) {
              cs = createState(vertexTraversed, edgeTraversed);
              // Found insertion point: Insert {key} at HT[{i}].
              // There are now {N} items in the Hash Table.
              cs["status"] = 'Found insertion point: Insert {key} at HT[{i}].<br>There are now {N} items in the Hash Table and&nbsp;α = {alpha}.'.replace("{key}", key).replace("{i}", i).replace("{N}", N).replace("{alpha}", (N/HT.length).toFixed(1));
              cs["vl"][i]["state"] = VERTEX_TRAVERSED;
              cs["lineNo"] = 4;
              stateList.push(cs);
            }
          }
        }
      }
    }

    if (animated) {
      gw.startAnimation(stateList, callback);
      populatePseudocode(1);
    }
    return true;
  }

  this.insertSC = function(keys, callback, animated = true) {
    var stateList = [];
    var edgeTraversed = {};
    var cs;

    if (keys == "") return false;

    var the_keys = keys.split(",");
    for (idx in the_keys) {
      var vertexTraversed = {}; // reset after every insertion?
      key = parseInt(the_keys[idx]);

      if (key < 0 || key > 99) {
        if (animated) {
          cs = createStateSC(vertexTraversed, edgeTraversed);
          // key = {key}, it must be between [0..99] in this visualization.
          // -1 = empty cell (blank) and -2 = deleted item.
          cs["status"] = 'key = {key}, it must be between [0..99] in this visualization.<br>-1 = empty cell (blank) and -2 = deleted item.'.replace("{key}", key);
          stateList.push(cs);
        }
      }
      else {
        var already_inside = false;
        var M = HT_SC.length;
        for (var i = 0; i < M; ++i)
          if (HT_SC[i].indexOf(key) != -1)
            already_inside = true;

  /*
// we may want to change this to frequency table instead

      if (already_inside) {
          if (animated) {
            cs = createStateSC(vertexTraversed, edgeTraversed);
            // key = {key} is already in the Hash Table.
            // We prevent insertion of duplicate keys.
            cs["status"] = 'key = {key} is already in the Hash Table.<br>We prevent insertion of duplicate keys.'.replace("{key}", key);
            stateList.push(cs);
          }
        }
        else { // key [0..99] and not inside
*/
          var i = key%M;
          if (animated) {
            cs = createStateSC(vertexTraversed, edgeTraversed);
            // The hash table is not yet full.
            // key = {key} is hashed to i = base = {key}%{length} = {i}.
            cs["status"] = 'Begin insertion.<br>key = {key} is hashed to i = base = {key}%{length} = {i}.'.replace("{key}", key).replace("{key}", key).replace("{length}", M).replace("{i}", i);
            cs["vl"][i*(maxChainLength+1)]["state"] = VERTEX_HIGHLIGHTED;
            cs["lineNo"] = 1;
            stateList.push(cs);
            vertexTraversed[i*(maxChainLength+1)] = true; // this is traversed in future iteration
          }

          if (HT_SC[i].length == maxChainLength) {
            if (animated) { // hm... will this create an issue later?
              cs = createStateSC(vertexTraversed, edgeTraversed);
              cs["status"] = 'Sorry, due to the limitation of this visualization<br>We do not allow any more extension to linked list {i}'.replace("{i}", i);
              cs["vl"][i*(maxChainLength+1)]["state"] = VERTEX_HIGHLIGHTED;
              cs["lineNo"] = 2;
              stateList.push(cs);
            }
          }
          else {
            HT_SC[i].push(key); // put at the back of this doubly linked list (assume that we have access to tail pointer)
            ++N;
            if (animated) {
              cs = createStateSC(vertexTraversed, edgeTraversed);
              cs["status"] = 'We append {key} to the back of Doubly Linked List {i}<br>This is O(1) with tail pointer'.replace("{key}", key).replace("{i}", i);
              cs["vl"][i*(maxChainLength+1)+(HT_SC[i].length-1)]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][i*(maxChainLength+1)+(HT_SC[i].length)]["state"] = VERTEX_HIGHLIGHTED;
              cs["lineNo"] = 3;
              stateList.push(cs);
            }
          }
/*
        }
*/
      }
    }

    if (animated) {
      gw.startAnimation(stateList, callback);
      populatePseudocode(4);
    }
    return true;
  }

  this.remove = function(keys, callback) {
    var stateList = [];
    var cs;

    var the_keys = keys.split(",");
    for (idx in the_keys) {
      var vertexTraversed = {}; // reset per key inserted
      var edgeTraversed = {};
      key = parseInt(the_keys[idx]);

      if (key < 0 || key > 99) {
        cs = createState(vertexTraversed, edgeTraversed);
        // key = {key}, it must be between [0..99] in this visualization.
        // -1 = empty cell (blank) and -2 = deleted item.
        cs["status"] = 'key = {key}, it must be between [0..99] in this visualization.<br>-1 = empty cell (blank) and -2 = deleted item.'.replace("{key}", key);
        stateList.push(cs);
      }
      else {
        var i = key % (HT.length), base = i;
        var i_next;
        var jump = 1;
        var step = 1;
        var k = 23, smallerPrime = primes[k];
        while (smallerPrime >= HT.length)
          smallerPrime = primes[--k];
        var secondary = smallerPrime - key%smallerPrime; // so it will always be positive
        var strategy = "linear probing";

        cs = createState(vertexTraversed, edgeTraversed);
        // key = {key} is hashed to i = base = {key}%{length} = {i}.
        cs["status"] = 'key = {key} is hashed to i = base = {key}%{length} = {i}.'.replace("{key}", key).replace("{key}", key).replace("{length}", HT.length).replace("{i}", i);
        cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
        cs["lineNo"] = 1;
        stateList.push(cs);
        vertexTraversed[i] = true; // this is traversed in future iteration

        while (true) {
          if (HT[i] == EMPTY) { // Not Found
            cs = createState(vertexTraversed, edgeTraversed);
            // HT[{i}] is empty.
            // Therefore key = {key} is not found in Hash Table HT.
            cs["status"] = 'HT[{i}] is empty.<br>Therefore key = {key} is not found in Hash Table HT.'.replace("{i}", i).replace("{key}", key);
            cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
            cs["lineNo"] = 3;
            stateList.push(cs);
            break;
          }
          else if (HT[i] == key) { // Found
            cs = createState(vertexTraversed, edgeTraversed);
            // HT[{i}] = {key}.
            // Therefore key = {key} is found in Hash Table HT at index {i}.
            cs["status"] = 'HT[{i}] = {key}.<br>Therefore key = {key} is found in Hash Table HT at index {i}.'.replace("{i}", i).replace("{key}", key).replace("{key}", key).replace("{i}", i);
            cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
            cs["lineNo"] = 4;
            stateList.push(cs);

            HT[i] = DELETED;
            --N;
            cs = createState(vertexTraversed, edgeTraversed);
            // Now we mark HT[{i}] as deleted.
            // There are now {N} items in the Hash Table.
            cs["status"] = 'Now we mark HT[{i}] as deleted<br>There are now {N} items in the Hash Table and .'.replace("{i}", i).replace("{N}", N);
            cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
            cs["lineNo"] = 5;
            stateList.push(cs);
            break;
          }
          else {
            if (activeStatus == "LP") {
              jump = 1;
              strategy = "LP"; // "linear probing";
            }
            else if (activeStatus == "QP") {
              jump = step;
              strategy = "QP"; // "quadratic probing";
            }
            else if (activeStatus == "DH") {
              jump = secondary;
              strategy = "DH"; // "double hashing";
            }

            i_next = (base + step * jump) % HT.length;

            cs = createState(vertexTraversed, edgeTraversed);
            // HT[{i}] = {val} != key.
            // Use {strategy} to check the next index i_next = ({base}+{step}*{jump})%{length} = {i_next}.
            cs["status"] = 'HT[{i}] = {val} != key.<br>Use {strategy} to check the next index i_next = ({base}+{step}*{jump})%{length} = {i_next}.'
                           .replace("{i}", i).replace("{val}", HT[i])
                           .replace("{strategy}", strategy).replace("{base}", base).replace("{step}", step).replace("{jump}", jump).replace("{length}", HT.length).replace("{i_next}", i_next);
            cs["vl"][i_next]["state"] = VERTEX_HIGHLIGHTED;
            cs["lineNo"] = 6;
            stateList.push(cs);
            vertexTraversed[i_next] = true; // this is traversed in future iteration
            i = i_next;
            ++step;
          }
        }
      }
    }

    gw.startAnimation(stateList, callback);
    populatePseudocode(2);
    return true;
  }

  this.removeSC = function(keys, callback) {
    var stateList = [];
    var cs;

    var the_keys = keys.split(",");
    for (idx in the_keys) {
      var vertexTraversed = {}; // reset per key inserted
      var edgeTraversed = {};
      key = parseInt(the_keys[idx]);

      if (key < 0 || key > 99) {
        cs = createStateSC(vertexTraversed, edgeTraversed);
        // key = {key}, it must be between [0..99] in this visualization.
        // -1 = empty cell (blank) and -2 = deleted item.
        cs["status"] = 'key = {key}, it must be between [0..99] in this visualization.<br>-1 = empty cell (blank) and -2 = deleted item.'.replace("{key}", key);
        stateList.push(cs);
      }
      else {
        var M = HT_SC.length;
        var i = key%M;
        var j = 0;

        cs = createStateSC(vertexTraversed, edgeTraversed);
        // key = {key} is hashed to i = base = {key}%{length} = {i}.
        cs["status"] = 'key = {key} is hashed to i = base = {key}%{length} = {i}.'.replace("{key}", key).replace("{key}", key).replace("{length}", M).replace("{i}", i);
        cs["vl"][i*(maxChainLength+1)]["state"] = VERTEX_HIGHLIGHTED;
        cs["lineNo"] = 1;
        stateList.push(cs);
        vertexTraversed[i*(maxChainLength+1)] = true; // this is traversed in future iteration

        var found_and_deleted = false;
        for (var j = 0; j < HT_SC[i].length; ++j) {
          cs = createStateSC(vertexTraversed, edgeTraversed);
          cs["status"] = 'Checking this vertex';
          cs["vl"][i*(maxChainLength+1)+(j+1)]["state"] = VERTEX_HIGHLIGHTED;
          cs["lineNo"] = [2, 3];
          stateList.push(cs);
          vertexTraversed[i*(maxChainLength+1)+(j+1)] = true; // this is traversed in future iteration
          if (HT_SC[i][j] == key) {
            cs = createStateSC(vertexTraversed, edgeTraversed);
            cs["status"] = '{key} is found in Hash Table'.replace("{key}", key).replace("{i}", i);
            cs["vl"][i*(maxChainLength+1)+(j+1)]["state"] = VERTEX_HIGHLIGHTED;
            cs["lineNo"] = [4];
            stateList.push(cs);

            HT_SC[i].splice(j, 1);
            delete vertexTraversed[i*(maxChainLength+1)+(j+1)];
            cs = createStateSC(vertexTraversed, edgeTraversed);
            cs["status"] = 'It is removed from list {i} in O(1+&alpha;)<br>Deletion is fast if we use Doubly Linked List'.replace("{key}", key).replace("{i}", i);
            cs["lineNo"] = [4];
            stateList.push(cs);

            found_and_deleted = true;
            --N;
            break;
          }
        }

        if (!found_and_deleted) { // not found
          cs = createStateSC(vertexTraversed, edgeTraversed);
          cs["status"] = '{key} is not found in Hash Table'.replace("{key}", key);
          cs["lineNo"] = 5;
          stateList.push(cs);
        }
      }
    }

    gw.startAnimation(stateList, callback);
    populatePseudocode(5);
    return true;
  }

  /*
   * vertexTraversed: JS object with the vertexes of the List which are to be marked as traversed as the key
   * edgeTraversed: JS object with the edges of the List which are to be marked as traversed as the key
   */

  function createState(vertexTraversed, edgeTraversed) {
    if (vertexTraversed == null || vertexTraversed == undefined || !(vertexTraversed instanceof Object))
      vertexTraversed = {};
    if (edgeTraversed == null || edgeTraversed == undefined || !(edgeTraversed instanceof Object))
      edgeTraversed = {};

console.log("now create state, N = " + self.getN());

    var s = {
      "vl": {},
      "el": {},
      "info": "N="+self.getN()+", M="+HT.length+", &alpha;="+(self.getN()/HT.length).toFixed(1),
    };

    // new more-compact layout 24 Apr 2023
    var per_row = 15;
    var top_offset = 25;
    if (HT.length > 45) {
      per_row = 25;
      top_offset = 50;
    }

    var scale_x = (1000-100) / per_row;
    if (HT.length < per_row)
      scale_x = (1000-100) / HT.length;
    var scale_y = 60;
    for (var i = 0; i < HT.length; ++i) {
      s["vl"][i] = {};
      s["vl"][i]["cx"] = 70 + (i%per_row)*scale_x;
      s["vl"][i]["cy"] = top_offset + Math.floor(i/per_row)*scale_y;
      s["vl"][i]["text"] = (HT[i] == EMPTY ? '' : (HT[i] == DELETED ? 'DEL' : HT[i]));
      s["vl"][i]["extratext"] = i.toString();
      s["vl"][i]["state"] = VERTEX_DEFAULT;
    }

    for (var key in vertexTraversed)
      s["vl"][key]["state"] = VERTEX_TRAVERSED;

    return s;
  }

  function createStateSC(vertexTraversed, edgeTraversed) {
    if (vertexTraversed == null || vertexTraversed == undefined || !(vertexTraversed instanceof Object))
      vertexTraversed = {};
    if (edgeTraversed == null || edgeTraversed == undefined || !(edgeTraversed instanceof Object))
      edgeTraversed = {};

    var M = HT_SC.length;
    var scale = (1000-180) / (M-1); // smaller than OA as the last chain dangles to the right a bit

    var s = {
      "vl": {},
      "el": {},
      "info": "N="+self.getN()+", M="+M+", &alpha;="+(self.getN()/M).toFixed(1),
    };

    var offset = (maxChainLength+1);
    for (var i = 0; i < M; ++i) {
      s["vl"][i*offset] = {};
      s["vl"][i*offset]["cx"] = 50 + i*scale;
      s["vl"][i*offset]["cy"] = 25;
      s["vl"][i*offset]["text"] = "H";
      s["vl"][i*offset]["extratext"] = i.toString();
      s["vl"][i*offset]["state"] = VERTEX_DEFAULT;
    }

    for (var i = 0; i < M; ++i) {
      for (var j = 0; j < HT_SC[i].length; ++j) {
        s["vl"][i*offset+(j+1)] = {};
        s["vl"][i*offset+(j+1)]["cx"] = 80 + i*scale;
        s["vl"][i*offset+(j+1)]["cy"] = 25 + (j+1)*50;
        s["vl"][i*offset+(j+1)]["text"] = HT_SC[i][j];
        s["vl"][i*offset+(j+1)]["state"] = VERTEX_DEFAULT;

        s["el"][i*offset+(j+1)] = {};
        s["el"][i*offset+(j+1)]["vertexA"] = i*offset+j;
        s["el"][i*offset+(j+1)]["vertexB"] = i*offset+(j+1);
        s["el"][i*offset+(j+1)]["type"] = (j == 0) ? EDGE_TYPE_DE : EDGE_TYPE_UDE;
        s["el"][i*offset+(j+1)]["weight"] = 1;
        s["el"][i*offset+(j+1)]["state"] = EDGE_DEFAULT;
        s["el"][i*offset+(j+1)]["animateHighlighted"] = false;
      }
    }

    for (var key in vertexTraversed)
      s["vl"][key]["state"] = VERTEX_TRAVERSED;

    return s;
  }

  function populatePseudocode(act) {
    var jump = '1';
    if (activeStatus == "LP")
      jump = '1';
    else if (activeStatus == "QP")
      jump = 'step';
    else if (activeStatus == "DH")
      jump = 'sec';

    $('#code6').html('');
    $('#code7').html('');
    switch (act) {
      case 0: // search
        $('#code1').html('step = 0; i = base = key%HT.length;');
        $('#code2').html('while (true)');
        $('#code3').html('&nbsp&nbspif (HT[i] == EMPTY) return "not found"');
        $('#code4').html('&nbsp&nbspelse if (HT[i] == key) return "found at index i"');
        $('#code5').html('&nbsp;&nbsp;else ++step; i = (base+step*{jump})%HT.length'.replace('{jump}', jump));
        $('#code6').html((activeStatus == 'DH' ? '// sec = prime - key%prime' : ''));
        break;
      case 1: // insert
        $('#code1').html('if N+1 == M, prevent insertion');
        $('#code2').html('step = 0; i = base = key%HT.length;');
        $('#code3').html('while (HT[i] != EMPTY &amp;&amp; HT[i] != DELETED)');
        $('#code4').html('&nbsp;&nbsp;++step; i = (base+step*{jump})%HT.length'.replace('{jump}', jump));
        $('#code5').html('found insertion point, insert key at HT[i]');
        $('#code6').html((activeStatus == 'DH' ? '// sec = prime - key%prime' : ''));
        break;
      case 2: // remove
        $('#code1').html('step = 0; i = base = key%HT.length;');
        $('#code2').html('while (true)');
        $('#code3').html('&nbsp&nbspif (HT[i] == EMPTY) break // &nbsp&nbspif (HT[i] == EMPTY) break // key not found');
        $('#code4').html('&nbsp&nbspelse if (HT[i] == key) // &nbsp&nbspelse if (HT[i] == key)');
        $('#code5').html('&nbsp&nbsp&nbsp&nbspHT[i] = DELETED, break // &nbsp;&nbsp;&nbsp;&nbsp;HT[i] = DELETED');
        $('#code6').html('&nbsp&nbspelse ++step; i = (base+step*{jump})%HT.length'.replace('{jump}', jump));
        $('#code7').html((activeStatus == 'DH' ? '// sec = prime - key%prime' : ''));
        break;
      case 3: // search SC
        $('#code1').html('i = key%HT.length;');
        $('#code2').html('for j = 0 to HT_SC[i].length');
        $('#code3').html('&nbsp&nbspif (HT_SC[i][j] == key)');
        $('#code4').html('&nbsp&nbsp&nbsp&nbspreturn "found at index i"');
        $('#code5').html('return "not found"');
        break;
      case 4: // insert SC
        $('#code1').html('i = key%HT.length;');
        $('#code2').html('if HT_SC[i].length == 7, prevent insertion');
        $('#code3').html('insert key to the back of this list i');
        $('#code4').html('');
        $('#code5').html('');
        break;
      case 5: // remove SC
        $('#code1').html('i = key%HT.length;');
        $('#code2').html('for j = 0 to HT_SC[i].length');
        $('#code3').html('&nbsp&nbspif (HT_SC[i][j] == key)');
        $('#code4').html('&nbsp&nbsp&nbsp&nbspremove key from list i');
        $('#code5').html('// do nothing, not found');
        break;
    }
  }
}



// HashTable_action.js
// actions panel stuff
var actionsWidth = 150;
var statusCodetraceWidth = 420;

// title changing
function AbbreviateTitle() {
  $('#title-LP').text("LP");
  $('#title-QP').text("QP");
  $('#title-DH').text("DH");
  $('#title-SC').text("SC");
}

$('#title-LP').click(function() {
  if (isPlaying) stop();
  htw.setActiveStatus("LP");
  AbbreviateTitle();
  $('#title-LP').text('Linear Probing');
});

$('#title-QP').click(function() {
  if (isPlaying) stop();
  htw.setActiveStatus("QP");
  AbbreviateTitle();
  $('#title-QP').text('Quadratic Probing');
});

$('#title-DH').click(function() {
  if (isPlaying) stop();
  htw.setActiveStatus("DH");
  AbbreviateTitle();
  $('#title-DH').text('Double Hashing');
});

$('#title-SC').click(function() {
  if (isPlaying) stop();
  htw.setActiveStatus("SC");
  AbbreviateTitle();
  $('#title-SC').text('Separate Chaining');
});



// local
$('#play').hide();
var htw = new HashTable();
var gw = htw.getGraphWidget();
var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 27, 31, 37, 41, 43];

$(function() {
  gw.setAnimationDuration(700 / speedVal);

  var hashMode = getQueryVariable("mode");
  if (hashMode.length > 0)
    $('#title-'+hashMode).click();
  else {
    var four_modes = ["LP", "QP", "DH", "SC"];
    $('#title-'+four_modes[Math.floor(Math.random()*4)]).click(); // randomly open one of the four default example every time, with random M (table size) and random N (initial population)
  }

  var createHT = getQueryVariable("create");
  if (createHT.length > 0) {
    var newHT = createHT.split(",");
    if (newHT.length == 1)
      htw.createTable(createHT);
    else
      htw.generate(newHT);
  }
  var insert = getQueryVariable("insert");
  if (insert.length > 0) {
    $('#v-insert').val(insert);
    openAction("insert");
  }

  var remove = getQueryVariable("remove");
  if (remove.length > 0) {
    $('#v-remove').val(remove);
    openAction("remove");
  }

  $("#v-search").val(Math.floor(Math.random()*100)); // [0..99]
  $("#v-insert").val(Math.floor(Math.random()*100) + ',' + Math.floor(Math.random()*100)); // [0..99] + ','+ [0..99]
  $("#v-remove").val(Math.floor(Math.random()*100) + ',' + Math.floor(Math.random()*100)); // [0..99] + ','+ [0..99]

  $('#create-inputM').change(function() {
    M_in = parseInt($('#v-createM').val());
    N_in = parseInt($('#v-createN').val());
    $('#alpha').text((N_in/M_in).toFixed(1));
  });

  $('#create-inputN').change(function() {
    M_in = parseInt($('#v-createM').val());
    N_in = parseInt($('#v-createN').val());
    $('#alpha').text((N_in/M_in).toFixed(1));
  });

  M_in = parseInt($('#v-createM').val());
  N_in = parseInt($('#v-createN').val());
  $('#alpha').text((N_in/M_in).toFixed(1));
});

function createTableSpecial(_HT) {
  if (isPlaying) stop();
  htw.createTableSpecial(_HT);
  $('#progress-bar').slider("option", "max", 0);
  closeAction("create");
  isPlaying = false;
  hideStatusPanel();
  hideCodetracePanel();
}

function createSCDefaultTC() {
  if (isPlaying) stop();
  htw.exampleSC();
  hideStatusPanel();
  hideCodetracePanel();
}

function createTable() {
  if (isPlaying) stop();
  M_in = parseInt($('#v-createM').val());
  N_in = parseInt($('#v-createN').val());
  $('#alpha').text((N_in/M_in).toFixed(1));
  hideStatusPanel();
  hideCodetracePanel();
  if (htw.createTable(M_in, N_in)) { // not 100% the same as commonAction
    $('#progress-bar').slider("option", "max", 0);
    isPlaying = false;
  }
}

function searchInteger(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#v-search').val());
  commonAction(htw.getActiveStatus() == "SC" ? htw.searchSC(input, callback) : htw.search(input, callback), "Search " + input);
  setTimeout(function() {
    $("#v-search").val(Math.floor(Math.random()*100)); // [0..99]
  }, 500);
}

function insertInteger(callback) {
  if (isPlaying) stop();
  var input = $('#v-insert').val();
  commonAction(htw.getActiveStatus() == "SC" ? htw.insertSC(input, callback) : htw.insert(input, callback), "Insert " + input);
  setTimeout(function() {
    $("#v-insert").val(Math.floor(Math.random()*100) + ',' + Math.floor(Math.random()*100)); // [0..99] + ','+ [0..99]
  }, 500);
}

function removeInteger(callback) {
  if (isPlaying) stop();
  var input = $('#v-remove').val();
  commonAction(htw.getActiveStatus() == "SC" ? htw.removeSC(input, callback) : htw.remove(input, callback), "Remove " + input);
  setTimeout(function() {
    $("#v-remove").val(Math.floor(Math.random()*100) + ',' + Math.floor(Math.random()*100)); // [0..99] + ','+ [0..99]
  }, 500);
}

// Implement these functions in each visualisation
// var userGraph = {
//   'vl': {},
//   'el': {},
// };

// This function will be called before entering E-Lecture Mode
function ENTER_LECTURE_MODE() {
  //if (bw) userGraph = bw.getGraph();
}

// This function will be called before returning to Explore Mode
function ENTER_EXPLORE_MODE() {
  //loadGraph(userGraph);
}

// Lecture action functions
function CUSTOM_ACTION(action, data, mode) {
  if (action == 'create_special') {
    createTableSpecial(data);
  }
  else if (action == 'search') {
    hideSlide(function() {
      $('#v-search').val(data); // force
      searchInteger(showSlide);
    });
  }
  else if (action == 'insert') {
    hideSlide(function() {
      $('#v-insert').val(data); // force
      insertInteger(showSlide);
    });
  }
  else if (action == 'remove') {
    hideSlide(function() {
      $('#v-remove').val(data); // force
      removeInteger(showSlide);
    });
  }
}
</script>
</body>

<!-- Mirrored from visualgo.net/en/hashtable by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:17:35 GMT -->
</html>
