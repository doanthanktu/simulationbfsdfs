<!DOCTYPE html>
<html lang="en">

<!-- Mirrored from visualgo.net/en/dfsbfs/?slide=7-7 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:17:23 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="description" content="Given a graph, we can use the O(V+E) DFS (Depth-First Search) or BFS (Breadth-First Search) algorithm to traverse the graph and explore the features/properties of the graph. Each algorithm has its own characteristics, features, and side-effects that we will explore in this visualization.This visualization is rich with a lot of DFS and BFS variants (all run in O(V+E)) such as: Topological Sort algorithm (both DFS and BFS/Kahn&amp;#39;s algorithm version),Bipartite Graph Checker algorithm (both DFS and BFS version),Cut Vertex &amp;amp; Bridge finding algorithm,Strongly Connected Components (SCC) finding algorithms(both Kosaraju&amp;#39;s and Tarjan&amp;#39;s version), and2-SAT Checker algorithm.">
<meta name="keywords" content="Graph Traversal Depth Breadth First Search Directed Undirected DFS BFS Topological Sort Toposort Bipartite Check Tarjan Kosaraju 2-SAT">
 
<meta name="csrf-token" content="dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../../img/png/dfsbfs.png">
<title>Graph Traversal (Depth/Breadth First Search) - VisuAlgo</title>
<link rel="icon" href="../../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../img/favicon.png">
<link rel="stylesheet" href="../../css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="../../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../../css/common-1.0.2.css">
<link rel="stylesheet" href="../../css/viz-1.0.4.css">
<link rel="stylesheet" href="../../css/visual.css">
<link rel="stylesheet" href="../../css/drawgraph-1.0.2.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
        z-index: 8001;
      }
      #e-lecture-timeline {
        top: 80px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }
      .e-lecture-timeline-slide {
        height: 5px;
        width: 2px;
        background: black;
        float: left;
      }
      .e-lecture-timeline-checkpoint {
        height: 20px;
        width: 3px;
        margin-left: 2px;
        margin-top: -7.5px;
        background: black;
        float: left;
      }

      #e-lecture-f1map {
        top: 102.5px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }

      .e-lecture-f1map-sector {
        flex-grow: 1;
        background: black;
        float: left;
        height: 5px;
        margin-right: 1px;
      }

      .e-lecture-f1map-sector:last-child {
        margin-right: 0px;
      }

      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }

      .electure-read-status {
        position: absolute;
        bottom: 4px;
        right: 4px;
        font-size: 14px;
        cursor: default;
        color: #00FF7F;
        display: none;
      }

      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
      .electure-print, .electure-end {
        position: fixed;
        top: 45px;
        height: 20px;
        width: 17px;
        right: 80px;
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
        text-align: center;
      }
      .electure-end {
        right: 45px; /* beside the X */
      }

      #change-lang-popup {
        position: fixed;
        background: green;
        left: 40px;
        top: 50px;
        width: 250px;
        height: 125px;
        border: transparent;
        border-radius: 10px;
        padding: 10px 20px;
        z-index: 9000;
      }

      #change-lang-popup p {
        font-size: medium;
        color: white;
        line-height: 2;
        font-family: "PT Sans", sans-serif;
      }

      #change-lang-popup-btn {
        text-decoration: underline;
        margin-left: 50px;
      }

      #change-lang-popup-btn:hover {
        cursor: pointer;
      }

      #rotateDeviceOverlay {
        z-index: 10000;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        background-color: white;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        overflow: hidden;
      }

      #mobile-playback-overlay {
        z-index: 9600;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        gap: 100px;
        background-color: black;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        opacity: 0.3;
        overflow: hidden;
      }
      .mobile-playback-item {
        min-width: 2.5%;
        max-width: 35px;
      }
      .mobile-playback-item img {
        width: 100%
      }
      .mobile-playback-label {
        opacity: 0;
        color: white;
        font-size: 25px;
        font-weight: bold;
        min-width: 1.5%;
        max-width: 25px;
        transition: opacity 0.25s ease-out;
        -webkit-backface-visibility: hidden;
      }
      #mobile-playback-rewind-label {
        margin-right: -70px;
      }
      #mobile-playback-forward-label {
        margin-left: -70px;
      }
      #viz-speed-value {
          font-size: 15px;
          width: 10%;
      }

      #scale {
        position: fixed;
        left: 5px;
      }
    </style>
<style>
/*
.directedChange { bottom: 200px; }
#directedChange-err { padding: 5px 8px; }


.draw { bottom: 308px; }
.examples { bottom: 254px; }
.dfs { bottom: 227px; }
.bfs { bottom: 200px; }
.topo { bottom : 173px; }
.bipartite { bottom: 146px; }
.bridge { bottom: 119px; }
.scc { bottom: 92px;}
.twosat { bottom: 65px; }
*/

#twosat-board {
  height: 470px;
  width: 600px;
  margin-left: -300px;
  margin-top: -235px;
}
</style>
<style>
/* copied here from common.css (perhaps need to use version numbering) until caches worldwide settles */
#reload-mobile-popup, #message-popup { /* #gdpr-popup, */
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  min-width: 320px;
  bottom: 62px;
  height: 300px;
  background-color: #0275d8;
  border-radius: 15px;
  padding: 30px 40px;
  z-index: 9500;
}
#reload-mobile-popup {
  background-color: green;
  height: 200px;
}
#message-popup {
  z-index: 9000;
  width: 40%;
  height: 130px;
  background-color: #d9534f;
}

#reload-mobile-popup p, #message-popup p { /* #gdpr-popup p, */
  font-size: large;
  color: white;
  line-height: 2;
  font-family: "PT Sans", sans-serif;
}

#reload-mobile-popup .inner-button, #message-popup .inner-button { /* #gdpr-popup .gdpr-button, */
  border: white solid 2px;
  border-radius: 4px;
  font-weight: bold;
  font-size: x-large;
  padding: 2px 8px;
  color: white;
  width: 90px;
  text-align: center;
  position: absolute;
  letter-spacing: 1px;
  text-decoration: none;
  cursor: pointer;
}

#gdpr-accept, #reload-mobile-button, #dismiss-message-btn {
  bottom: 30px;
  right: 40px;
}

#gdpr-reject, #cancel-reload-mobile-button {
  bottom: 30px;
  right: 170px;
}
    </style>
</head>
<body>
<div id="body-container" style="display: flex; flex-direction: column; min-height: 100vh;">
<style>
  #topbar {
    background-color: rgb(0,0,0);
    font-family: "PT Sans", sans-serif;
    font-size: 13px;
    height: 40px;

    padding-left: 40px;
    padding-right: 40px;

    display: flex;
    flex-wrap: wrap;
    align-items: center;
    position: relative;
    justify-content: flex-start;
  }

  #topbar a:hover {
    text-decoration: none;
  }

  #account-dropdown-btn {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;
    height: 24px;
    line-height: 1.5;
  }

  #account-dropdown-btn:hover {
    color: #0a58ca!important;
    border-color: #198754;
    text-decoration: none;
  }

  #login-button {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;

    height: 24px;
    line-height: 1.5;
  }

  #login-button a:hover {
    color: #0a58ca!important;
    text-decoration: none;
  }

  #account-dropdown-menu {
    display: none;
    position: absolute;
    background-color: white;
    z-index: 1000;
    min-width: 10rem;
    padding: 0.5rem 0;
    margin: 0;
    font-size: 1rem;
    color: rgb(0,0,0);
    text-align: left;
    list-style: none;
    background-clip: padding-box;
    border: 1px solid rgba(0,0,0,.15);
    border-radius: 0.25rem;
    top: 45px;
    right: 40px;
    line-height: 1.5;
  }

  .account-dropdown-item {
    display: block;
    width: auto;
    padding: 0.25rem 1rem;
    clear: both;
    font-weight: 400;
    color: rgb(0,0,0);
    text-align: inherit;
    text-decoration: none;
    white-space: nowrap;
    background-color: transparent;
    border: 0;
    height: 24px;
    font-family: SilkscreenNormal, sans-serif;
  }

  .account-dropdown-item:hover {
    background-color: #e9ecef;
    color: #0a58ca;
    text-decoration: none;
  }
</style>
<nav id="topbar">
<span style="margin-right: 0.25rem">
<a href="https://www.comp.nus.edu.sg/~stevenha" style="text-decoration: none; color: white">
<span class="colour" style="border: 1px solid; border-color: #198754!important; border-radius: .25rem!important">7</span>
</a>
<a href="https://visualgo.net/" style="font-family: SilkscreenNormal,sans-serif; font-size: 20px; margin-left: 4px;">
<span style="color: white">Visu</span><span class="colour">Algo</span><span style="font-size: 40%; color: white">.net</span>
</a>
<span style="color: white">/</span>
<select id="Language" class="select2-dropdown" onchange="changeURL()">
<option value="en" selected>en</option>
<option value="zh">zh</option>
<option value="id">id</option>
</select>
<span style="color: white; font-family: monospace">/dfsbfs</span>
</span>
<span style="max-height: 30px">
<span id="title">
<a id="title-dfsbfs" class="selected-viz">Graph Traversal (DFS/BFS)</a>
</span>
</span>
<span style="max-height: 30px; background-color:rgb(0,0,0)!important; color: white; margin-left: auto">
<div id="mode-menu">
<div id="mode-button" style="background-color: rgb(0,0,0)!important;" title="exploration">Exploration Mode &#9663;</div>
<div id="other-modes" style="background-color: rgb(0,0,0)!important; padding-top: 11px">
<a title="e-Lecture" style="background-color: rgb(0,0,0)!important;">e-Lecture Mode</a>
</div>
</div>
</span>
<span id="login-button" style="font-family: SilkscreenNormal,sans-serif">
<a href="https://visualgo.net/login">Login</a>
</span>
</nav>
<ul id="account-dropdown-menu">
<li><a class="account-dropdown-item" href="https://visualgo.net/profile">Profile</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/training">Training</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/tests">Tests</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/logout">Log Out</a></li>
</ul>
<script>
  function changeURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    URL[3] = document.getElementById("Language").value;
    window.location.assign(URL.join('https://visualgo.net/'));
  }

  function changeDefaultLanguageAndURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    let val = document.getElementById("Language").value;
    URL[3] = val;

    let data = {
      '_token': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
      'lang'  : val
    }
    $.post('https://visualgo.net/changeLanguage', data, function (res, status) {
      if(res['status'] === 'success') {
        window.location.assign(URL.join('https://visualgo.net/'));
      } else if (res['status'] === 'failed') {
        alert(res['message']);
      } else {
        alert('An unknown error occurred');
      }
    })
  }
</script>
<div id="dark-overlay"></div>
<div id="main-content-container" style="flex: 1">

<div id="mobile-playback-overlay" class="playing" style="display: none;">
<span id="mobile-playback-rewind-label" class="mobile-playback-label">-7</span>
<span id="mobile-playback-rewind" class="mobile-playback-item" onclick="mobilePlaybackRewind()"><img src="../../img/prevFrame.png" alt="rewind 7 frames"></span>
<span id="mobile-playback-pause" class="mobile-playback-item" onclick="mobilePlaybackPauseOrPlay()"><img src="../../img/pause.png" alt="pause"></span>
<span id="mobile-playback-play" class="mobile-playback-item" style="display: none;" onclick="mobilePlaybackPauseOrPlay()"><img src="../../img/play.png" alt="play"></span>
<span id="mobile-playback-forward" class="mobile-playback-item" onclick="mobilePlaybackForward()"><img src="../../img/nextFrame.png" alt="forward 7 frames"></span>
<span id="mobile-playback-forward-label" class="mobile-playback-label">+7</span>
</div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id="speed-control"><div id="speed-input"></div><div id="viz-speed-value">1x</div></div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick="goToBeginning()"><img src="../../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick="stepBackward()"><img src="../../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick="pause()"><img src="../../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick="play()"><img src="../../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick="stepForward()"><img src="../../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick="goToEnd()"><img src="../../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id="viz">
<p id="info" "></p>
</div>
<div id="current-action" class="panel"></div>
<div id="e-lecture" class="panel"></div> 
<div id="e-lecture-timeline"></div>
<div id="e-lecture-f1map">
<div class="e-lecture-f1map-sector" sectorNo="1"></div>
<div class="e-lecture-f1map-sector" sectorNo="2"></div>
<div class="e-lecture-f1map-sector" sectorNo="3"></div>
</div>
<div id="overlay" hidden onclick="end_eLecture()"> 
<div id="electure-dropdown">
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. DFS & BFS</option>
<option value="2">2. Visualization</option>
<option value="3">3. Specifying an Input Graph</option>
<option value="4">4. Recap</option>
<option value="4-1">&nbsp;&nbsp;&nbsp;4-1. Binary Tree Traversal - Source = Root</option>
<option value="4-2">&nbsp;&nbsp;&nbsp;4-2. Binary Tree Traversal - Pre-/In-/Post-order</option>
<option value="4-3">&nbsp;&nbsp;&nbsp;4-3. The Answer</option>
<option value="4-4">&nbsp;&nbsp;&nbsp;4-4. Binary Tree Traversal - Acyclic</option>
<option value="4-5">&nbsp;&nbsp;&nbsp;4-5. Issues in General Graph</option>
<option value="5">5. DFS</option>
<option value="5-1">&nbsp;&nbsp;&nbsp;5-1. Analogy</option>
<option value="5-2">&nbsp;&nbsp;&nbsp;5-2. Trying All Options</option>
<option value="5-3">&nbsp;&nbsp;&nbsp;5-3. Avoiding Cycle</option>
<option value="5-4">&nbsp;&nbsp;&nbsp;5-4. Memorizing the Path</option>
<option value="5-5">&nbsp;&nbsp;&nbsp;5-5. Hands-on Example</option>
<option value="5-6">&nbsp;&nbsp;&nbsp;5-6. O(V+E) Time Complexity</option>
<option value="5-7">&nbsp;&nbsp;&nbsp;5-7. O(V+E) at all times?</option>
<option value="5-8">&nbsp;&nbsp;&nbsp;5-8. The Answer</option>
<option value="6">6. BFS</option>
<option value="6-1">&nbsp;&nbsp;&nbsp;6-1. Analogy</option>
<option value="6-2">&nbsp;&nbsp;&nbsp;6-2. Try All, Avoid Cycle, Memorize Path</option>
<option value="6-3">&nbsp;&nbsp;&nbsp;6-3. Hands-on Example</option>
<option value="6-4">&nbsp;&nbsp;&nbsp;6-4. O(V+E) Time Complexity</option>
<option value="7">7. Simple DFS/BFS Applications</option>
<option value="7-1">&nbsp;&nbsp;&nbsp;7-1. Reachability Test</option>
<option value="7-2">&nbsp;&nbsp;&nbsp;7-2. Print the Traversal Path</option>
<option value="7-3">&nbsp;&nbsp;&nbsp;7-3. Identifying a Connected Component (CC)</option>
<option value="7-4">&nbsp;&nbsp;&nbsp;7-4. Counting the Number of/Labeling the CCs</option>
<option value="7-5">&nbsp;&nbsp;&nbsp;7-5. Wait, What is the Time Complexity?</option>
<option value="7-6">&nbsp;&nbsp;&nbsp;7-6. The Answer</option>
<option value="7-7">&nbsp;&nbsp;&nbsp;7-7. Detecting Cycle - Part 1</option>
<option value="7-8">&nbsp;&nbsp;&nbsp;7-8. Detecting Cycle - Part 2</option>
<option value="7-9">&nbsp;&nbsp;&nbsp;7-9. Hands-on Example (Detailed)</option>
<option value="7-10">&nbsp;&nbsp;&nbsp;7-10. Topological Sort - Definition</option>
<option value="7-11">&nbsp;&nbsp;&nbsp;7-11. Topological Sort</option>
<option value="8">8. More Advanced DFS/BFS Applications</option>
<option value="9">9. Bipartite Graph Checker</option>
<option value="10">10. Find Cut Vertices & Bridges</option>
<option value="11">11. Find Strongly Connected Components</option>
<option value="12">12. 2-SAT Checker Algorithm</option>
<option value="13">13. Which One is Better?</option>
<option value="13-1">&nbsp;&nbsp;&nbsp;13-1. The Answer</option>
<option value="14">14. Extras</option>
<option value="14-1">&nbsp;&nbsp;&nbsp;14-1. Online Quiz</option>
<option value="14-2">&nbsp;&nbsp;&nbsp;14-2. Online Judge Exercises</option>
<option value="14-3">&nbsp;&nbsp;&nbsp;14-3. Discussion</option>
</select>
</div>
<div class="electure-print" title="Print the e-Lecture note" style="z-index=8001;">&#9997;</div>
<div class="electure-end" title="Close the e-Lecture mode" style="z-index=8001;">&#10008;</div>
</div>
<div id="dropdown-temp-holder" hidden></div>

<div id="electure-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Given a graph, we can use the O(<b>V</b>+<b>E</b>) DFS (Depth-First Search) or BFS (Breadth-First Search) algorithm to traverse the graph and explore the features/properties of the graph. Each algorithm has its own characteristics, features, and side-effects that we will explore in this visualization.</p><br><p>This visualization is rich with a lot of DFS and BFS variants (all run in O(<b>V</b>+<b>E</b>)) such as: </p><ol><li>Topological Sort algorithm (both DFS and BFS/Kahn&#39;s algorithm version),</li><li>Bipartite Graph Checker algorithm (both DFS and BFS version),</li><li>Cut Vertex &amp; Bridge finding algorithm,</li><li>Strongly Connected Components (SCC) finding algorithms<br>(both Kosaraju&#39;s and Tarjan&#39;s version), and</li><li>2-SAT Checker algorithm.</li></ol>
<div class="electure-addition">
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
If you are an NUS student and a repeat visitor, please <a href="https://visualgo.net/login"><u>login</u></a>.</p>
</div>
<div class="electure-next" data-nextid="2" title="Go to the next slide 2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>When the chosen graph traversal algorithm is running, the animation will be shown here.</p><br><p>We use vertex+edge color (the color scheme will be elaborated soon) and occasionally the extra text under the vertex (in <span style="color: red;">red font</span>) to highlight the changes.</p><br><p>All graph traversal algorithms work on directed graphs (this is the default setting, where each edge has an arrowtip to indicate its direction) but the <b>Bipartite Graph Check</b> algorithm and the <b>Cut Vertex &amp; Bridge</b> finding algorithm requires the undirected graphs (the conversion is done automatically by this visualization).</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 1: Since you are not <a href="https://visualgo.net/login"><u>logged-in</u></a>, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b>/<b>[PageUp]</b> to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use <b>[&rarr; or &darr;/&larr; or &uarr;]</b> to do the same),and <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
</div>
<div class="electure-prev" data-nextid="1" title="Go to the previous slide 1">&larr;</div>
<div class="electure-next" data-nextid="3" title="Go to the next slide 3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>There are two different sources for specifying an input graph:</p><ol><li><b>Edit Graph</b>: You can draw a new graph or edit an example unweighted directed graph as the input graph (to draw bidirectional edge (u, v), you can draw two directed edges u → v and v → u).</li><li><b>Example Graphs</b>: You can select from the list of our selected example graphs to get you started.</li></ol>
<div class="electure-addition">
<hr>
<p>Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
</div>
<div class="electure-prev" data-nextid="2" title="Go to the previous slide 2">&larr;</div>
<div class="electure-next" data-nextid="4" title="Go to the next slide 4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4" class="electure-dialog" style="top:140px;right:60px;width:500px;">
<p>If you arrive at this e-Lecture <b>without</b> having first explore/master the concept of <a href="heap.html"><u>Binary Heap</u></a> and especially <a href="bst.html"><u>Binary Search Tree</u></a>, we suggest that you explore them first, as traversing a (Binary) Tree structure is much simpler than traversing a general graph.</p><br><input class="msq-answer" id="msq-answer-14" value="60,63,64" hidden><p>Quiz: <b>Mini pre-requisite check. What are the Pre-/In-/Post-order traversal of the binary tree shown (root = vertex 0), left and right child are as drawn?</b></p><input type="checkbox" class="msq-choice" id="msq-14-choice-60"> Pre = 0, 1, 2, 3, 4<br><input type="checkbox" class="msq-choice" id="msq-14-choice-64"> Post = 1, 3, 4, 2, 0<br><input type="checkbox" class="msq-choice" id="msq-14-choice-61"> Pre = 0, 2, 4, 3, 1<br><input type="checkbox" class="msq-choice" id="msq-14-choice-65"> Post = 4, 3, 2, 1, 0<br><input type="checkbox" class="msq-choice" id="msq-14-choice-63"> In = 1, 0, 3, 2, 4<br><input type="checkbox" class="msq-choice" id="msq-14-choice-62"> In = 4, 2, 3, 0, 1<br><button class="msq-submit" id="submit-14">Submit</button> <span id="answer-status-14"></span>
<div class="electure-addition">
<hr>
<p>Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode): <b>Spacebar</b> to play/pause/replay the animation, <b>&larr;</b>/<b>&rarr;</b> to step the animation backwards/forwards, respectively, and <b>-</b>/<b>+</b> to decrease/increase the animation speed, respectively.</p>
</div>
<div class="electure-prev" data-nextid="3" title="Go to the previous slide 3">&larr;</div>
<div class="electure-next" data-nextid="4-1" title="Go to the next slide 4-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-1" class="electure-dialog" style="top:140px;right:60px;width:500px;">
<p>We normally start from the most important vertex of a (binary) tree: The <b>root</b> vertex.</p><br><p>If the given tree is not &#39;rooted&#39; (see the example picture), we can pick any one vertex (for example, vertex 0 in the example picture) and designate it as the root. If we imagine that all edges are strings of similar length, then after "virtually pulling the designated root upwards" and let gravity pulls the rest downwards, we have a rooted directed (downwards) tree &mdash; see the next slide.</p><br><p>PS: Technically, this transformation is done by running <code>DFS(0)</code> that we will explore soon.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4" title="Go to the previous slide 4">&larr;</div>
<div class="electure-next" data-nextid="4-2" title="Go to the next slide 4-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-2" class="electure-dialog" style="top:140px;right:60px;width:500px;">
<p>In a <b>binary</b> tree, we only have <b>up to two</b> neighboring choices: From the current vertex, we can go to the left subtree first or go to the right subtree first. We also have option to visit the current vertex before or after visiting one of the (or both) subtree(s).</p><br><p>This gives rise to the classics: pre-order (visit current vertex, visit its left subtree, visit its right subtree), in-order (left, current, right), and post-order (left, right, current) traversals.</p><br><p>Discussion: Do you notice that there are three other possible binary tree traversal combinations? What are they?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-1" title="Go to the previous slide 4-1">&larr;</div>
<div class="electure-next" data-nextid="4-3" title="Go to the next slide 4-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-3" class="electure-dialog" style="top:140px;right:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-2" title="Go to the previous slide 4-2">&larr;</div>
<div class="electure-next" data-nextid="4-4" title="Go to the next slide 4-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-4" class="electure-dialog" style="top:140px;right:60px;width:500px;">
<p>In a binary tree, or in a tree structure in general, there is no (non-trivial) cycle involving 3 or more distinct vertices to worry about (we do not consider the trivial cycle involving bi-directional edges which can be taken care of easily — see three slides earlier).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-3" title="Go to the previous slide 4-3">&larr;</div>
<div class="electure-next" data-nextid="4-5" title="Go to the next slide 4-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-5" class="electure-dialog" style="top:140px;right:60px;width:500px;">
<p>In general graph, we do not have the notion of root vertex. Instead, we need to pick one distinguished vertex to be the starting point of the traversal, i.e. the source vertex <b>s</b>.</p><br><p>We also have 0, 1, ..., <b>k</b> neighbors of a vertex instead of just &le; 2.</p> <br><p>We <b>may (or actually very likely)</b> have cycle(s) in our general graph instead of acyclic tree,<br> be it the trivial one like u &rarr; v &rarr; u or the non-trivial one like a &rarr; b &rarr; c &rarr; a.</p><br><p>But fret not, graph traversal is an easy problem with two classic algorithms: DFS and BFS.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-4" title="Go to the previous slide 4-4">&larr;</div>
<div class="electure-next" data-nextid="5" title="Go to the next slide 5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>One of the most basic graph traversal algorithm is the O(<b>V</b>+<b>E</b>) Depth-First Search (DFS).</p><br><p>DFS takes one input parameter: The source vertex <b>s</b>.</p><br><p>DFS is one of the most fundamental graph algorithm, so please spend time to understand the key steps of this algorithm.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-5" title="Go to the previous slide 4-5">&larr;</div>
<div class="electure-next" data-nextid="5-1" title="Go to the next slide 5-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-1" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p><img src="https://visualgo.net/img/maze.svg" width="100" height="100" style="background-color: white; float: right;" alt="maze">The closest analogy of the behavior of DFS is to imagine a maze with only one entrance and one exit. You are at the entrance and want to explore the maze to reach the exit. Obviously you cannot split yourself into more than one.</p><br><p>Ask these reflective questions before continuing: What will you do if there are branching options in front of you? How to avoid going in cycle? How to mark your own path? Hint: You need a chalk, stones (or any other marker) and a (long) string.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5" title="Go to the previous slide 5">&larr;</div>
<div class="electure-next" data-nextid="5-2" title="Go to the next slide 5-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-2" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>As it name implies, DFS starts from a distinguished source vertex <b>s</b> and uses recursion (an implicit stack) to order the visitation sequence as deep as possible before backtracking.</p><br><p>If DFS is at a vertex <b>u</b> and it has <b>X</b> neighbors, it will pick the first neighbor <b>V<sub>1</sub></b> (usually the vertex with the lowest vertex number), recursively explore all reachable vertices from vertex <b>V<sub>1</sub></b>, and eventually backtrack to vertex <b>u</b>. DFS will then do the same for the other neighbors until it finishes exploring the last neighbor <b>V<sub>X</sub></b> and its reachable vertices.</p><br><p>This wordy explanation will be clearer with DFS animation later.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-1" title="Go to the previous slide 5-1">&larr;</div>
<div class="electure-next" data-nextid="5-3" title="Go to the next slide 5-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-3" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>If the graph is <b>cyclic</b>, the previous &#39;try-all&#39; strategy may lead DFS to run in cycle.</p><br><p>So <i>the basic form of DFS</i> uses an array <b>status[u]</b> of size <b>V</b> vertices to decide between <i>binary conditions</i>: Whether vertex <b>u</b> has been visited or unvisited. Only if vertex <b>u</b> is still unvisited, then DFS can visit vertex <b>u</b>.</p><br><p>When DFS runs out of option, it <b>backtrack</b> to previous vertex (<b>p[u]</b>, see the next slide) as the recursion unwinds.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-2" title="Go to the previous slide 5-2">&larr;</div>
<div class="electure-next" data-nextid="5-4" title="Go to the next slide 5-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-4" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>DFS uses another array <b>p[u]</b> of size <b>V</b> vertices to remember the <b>parent/predecessor/previous</b> of each vertex <b>u</b> along the DFS traversal path.</p><br><p>The predecessor of the source vertex, i.e., <b>p[s]</b> is set to -1 to say that the source vertex has no predecessor (as the lowest vertex number is vertex 0).</p><br><p>The sequence of vertices from a vertex <b>u</b> that is reachable from the source vertex <b>s</b> back to <b>s</b> forms the <b>DFS spanning tree</b>. We color these <b>tree edges</b> with <span style="color: red;">red color</span>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-3" title="Go to the previous slide 5-3">&larr;</div>
<div class="electure-next" data-nextid="5-5" title="Go to the next slide 5-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-5" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>For now, ignore the extra <b>status[u] = explored</b> in the displayed pseudocode and the presence of <span style="color: lightblue;">blue</span> and <span style="color: grey;">grey</span> edges in the visualization (to be explained soon).</p><br><p>Without further ado, let&#39;s execute <span class="slide-actions" onclick="doButtonAction39()">DFS(0)</span> on the default example graph for this e-Lecture (CP3 Figure 4.1). <span id="dfsrecap"><span class="slide-actions" onclick="doButtonAction41()">Recap DFS Example</span></span></p><br><p>The <i>basic version</i> of DFS presented so far is already enough for most simple cases.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-4" title="Go to the previous slide 5-4">&larr;</div>
<div class="electure-next" data-nextid="5-6" title="Go to the next slide 5-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-6" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>The time complexity of DFS is O(<b>V</b>+<b>E</b>) because:</p><ol><li>Each vertex is only visited once due to the fact that DFS will only recursively explore a vertex <b>u</b> if <b>status[u] = unvisited</b> &mdash; O(<b>V</b>)</li><li>Every time a vertex is visited, all its <b>k</b> neighbors are explored and therefore after all vertices are visited, we have examined all <b>E</b> edges &mdash; (O(<b>E</b>) as the total number of neighbors of each vertex equals to <b>E</b>).</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-5" title="Go to the previous slide 5-5">&larr;</div>
<div class="electure-next" data-nextid="5-7" title="Go to the next slide 5-7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-7" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>The O(<b>V</b>+<b>E</b>) time complexity of DFS only achievable if we can visit all <b>k</b> neighboring vertices of a vertex in O(<b>k</b>) time.</p><br><input class="mcq-answer" id="mcq-answer-13" value="57" hidden><p>Quiz: <b>Which underlying graph data structure support that operation?</b></p><form><input type="radio" name="mcq-13-choice" value="58"> Edge List<br><input type="radio" name="mcq-13-choice" value="57"> Adjacency List<br><input type="radio" name="mcq-13-choice" value="56"> Adjacency Matrix<br></form><button class="mcq-submit" id="submit-13">Submit</button> <span id="answer-status-13"></span><br><br><p>Discussion: Why?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-6" title="Go to the previous slide 5-6">&larr;</div>
<div class="electure-next" data-nextid="5-8" title="Go to the next slide 5-8">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5-8" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-7" title="Go to the previous slide 5-7">&larr;</div>
<div class="electure-next" data-nextid="6" title="Go to the next slide 6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>Another basic graph traversal algorithm is the O(<b>V</b>+<b>E</b>) Breadth-First Search (BFS).</p><br><p>As with DFS, BFS also takes one input parameter: The source vertex <b>s</b>.</p><br><p>Both DFS and BFS have their own strengths and weaknesses. It is important to learn both and apply the correct graph traversal algorithm for the correct situation.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5-8" title="Go to the previous slide 5-8">&larr;</div>
<div class="electure-next" data-nextid="6-1" title="Go to the next slide 6-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6-1" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p><img src="../../img/ripple.jpg" width="100" height="100" style="float: right;" alt="ripple">Imagine a still body of water and then you throw a stone into it. The first location where the stone hits the water surface is the position of the source vertex and the subsequent <b>ripple effect</b> across the water surface is like the BFS traversal pattern.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6" title="Go to the previous slide 6">&larr;</div>
<div class="electure-next" data-nextid="6-2" title="Go to the next slide 6-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6-2" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>BFS is very similar with DFS that have been discussed earlier, but with some differences.</p><br><p>BFS starts from a source vertex <b>s</b> but it uses a <a href="listc97b.html?mode=Queue"><u>queue</u></a> to order the visitation sequence <i>as breadth as possible before going deeper</i>.</p><br><p>BFS also uses a Boolean array of size <b>V</b> vertices to distinguish between two states: visited and unvisited vertices (we will not use BFS to detect back edge(s) as with DFS).</p><br><p>In this visualization, we also show that starting from the same source vertex <b>s</b> in an <b>unweighted graph</b>, BFS spanning tree of the graph equals to its <a href="sssp.html"><u>SSSP spanning tree</u></a>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6-1" title="Go to the previous slide 6-1">&larr;</div>
<div class="electure-next" data-nextid="6-3" title="Go to the next slide 6-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6-3" class="electure-dialog" style="top:140px;right:60px;width:500px;">
<p>Without further ado, let&#39;s execute <span class="slide-actions" onclick="doButtonAction40()">BFS(5)</span> on the default example graph for this e-Lecture (CP3 Figure 4.3). <span id="bfsrecap"><span class="slide-actions" onclick="doButtonAction42()">Recap BFS Example</span></span>.</p><br><p>Notice the <i>Breadth-first</i>&nbsp;exploration due to the usage of FIFO data structure: Queue?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6-2" title="Go to the previous slide 6-2">&larr;</div>
<div class="electure-next" data-nextid="6-4" title="Go to the next slide 6-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6-4" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>The time complexity of BFS is O(<b>V</b>+<b>E</b>) because:</p><ol><li>Each vertex is only visited once as it can only enter the queue once — O(<b>V</b>)</li><li>Every time a vertex is dequeued from the queue, all its <b>k</b> neighbors are explored and therefore after all vertices are visited, we have examined all <b>E</b> edges — (O(<b>E</b>) as the total number of neighbors of each vertex equals to <b>E</b>).</li></ol><p>As with DFS, this O(<b>V</b>+<b>E</b>) time complexity is only possible if we use <a href="graphds.html"><u>Adjacency List</u></a> graph data structure — same reason as with DFS analysis.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6-3" title="Go to the previous slide 6-3">&larr;</div>
<div class="electure-next" data-nextid="7" title="Go to the next slide 7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>So far, we can use DFS/BFS to solve a few graph traversal problem variants:</p><ol><li>Reachability test,</li><li>Actually printing the traversal path,</li><li>Identifying/Counting/Labeling Connected Components (CCs) of undirected graphs,</li><li>Detecting if a graph is cyclic,</li><li>Topological Sort (only on DAGs),</li></ol><p>For most data structures and algorithms courses, the applications of DFS/BFS are up to these few basic ones only, although DFS/BFS can do much more...</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6-4" title="Go to the previous slide 6-4">&larr;</div>
<div class="electure-next" data-nextid="7-1" title="Go to the next slide 7-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-1" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>If you are asked to test whether a vertex <b>s</b> and a (different) vertex <b>t</b> in a graph are reachable, i.e., connected directly (via a direct edge) or indirectly (via a simple, non cyclic, path), you can call the O(<b>V</b>+<b>E</b>) <samp>DFS(s)</samp> (or <samp>BFS(s)</samp>) and check if <samp>status[t] = visited</samp>.</p><br><p>Example 1: <b>s = 0</b> and <b>t = 4</b>, run <span class="slide-actions" onclick="doButtonAction39()">DFS(0)</span> and notice that <samp>status[4] = visited</samp>.<br>Example 2: <b>s = 0</b> and <b>t = 7</b>, run <span class="slide-actions" onclick="doButtonAction39()">DFS(0)</span> and notice that <samp>status[7] = unvisited</samp>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7" title="Go to the previous slide 7">&larr;</div>
<div class="electure-next" data-nextid="7-2" title="Go to the next slide 7-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-2" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p><a href="dfsbfs/indexbf39.html?slide=5-4"><u>Remember</u></a> that we set <b>p[v] = u</b> every time we manage to extend DFS/BFS traversal from vertex <b>u</b> to vertex <b>v</b> &mdash; a tree edge in the DFS/BFS spanning tree. Thus, we can use following simple recursive function to print out the path stored in array <b>p</b>. Possible follow-up discussion: Can you write this in <b>iterative</b> form? (trivial)</p><pre>method backtrack(u)<br>  if (u == -1) stop<br>  backtrack(p[u]);<br>  output vertex u<br></pre><p>To print out the path from a source vertex <b>s</b> to a target vertex <b>t</b> in a graph, you can call O(<b>V</b>+<b>E</b>) <samp>DFS(s)</samp> (or <samp>BFS(s)</samp>) and then O(<b>V</b>) <samp>backtrack(t)</samp>. Example: <b>s = 0</b> and <b>t = 4</b>, you can call <span class="slide-actions" onclick="doButtonAction39()">DFS(0)</span> and then <samp>backtrack(4)</samp>. <span id="printexample"><span class="slide-actions" onclick="doButtonAction43()">Elaborate</span></span></p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-1" title="Go to the previous slide 7-1">&larr;</div>
<div class="electure-next" data-nextid="7-3" title="Go to the next slide 7-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-3" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>We can enumerate <b>all</b> vertices that are reachable from a vertex <b>s</b> in an <b>undirected graph</b> (as the example graph shown above) by simply calling O(<b>V</b>+<b>E</b>) <samp>DFS(s)</samp> (or <samp>BFS(s)</samp>) and enumerate all vertex <b>v</b> that has <samp>status[v] = visited</samp>.</p><br><p>Example: <b>s = 0</b>, run <span class="slide-actions" onclick="doButtonAction39()">DFS(0)</span> and notice that <samp>status[{0,1,2,3,4}] = visited</samp> so they are all reachable vertices from vertex 0, i.e., they form one <b>Connected Component (CC)</b>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-2" title="Go to the previous slide 7-2">&larr;</div>
<div class="electure-next" data-nextid="7-4" title="Go to the next slide 7-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-4" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>We can use the following pseudo-code to count the number of CCs:</p><pre>CC = 0<br>for all u in V, set status[u] = unvisited<br>for all u in V<br>  if (status[u] == unvisited)<br>    ++CC // we can use CC counter number as the CC label<br>    DFS(u) // or BFS(u), that will flag its members as visited<br>output CC // the answer is 3 for the example graph above, i.e.<br>// CC 0 = {0,1,2,3,4}, CC 1 = {5}, CC 2 = {6,7,8}</pre><p>You can modify the DFS(u)/BFS(u) code a bit if you want to use it to label each CC with the identifier of that CC.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-3" title="Go to the previous slide 7-3">&larr;</div>
<div class="electure-next" data-nextid="7-5" title="Go to the next slide 7-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-5" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<input class="mcq-answer" id="mcq-answer-15" value="67" hidden><p>Quiz: <b>What is the time complexity of Counting the Number of CCs algorithm?</b></p><form><input type="radio" name="mcq-15-choice" value="68"> Trick question, the answer is none of the above, it is O(_____)<br><input type="radio" name="mcq-15-choice" value="67"> It is still O(V+E)<br><input type="radio" name="mcq-15-choice" value="66"> Calling O(V+E) DFS/BFS V times, so O(V*(V+E)) = O(V^2 + VE)<br></form><button class="mcq-submit" id="submit-15">Submit</button> <span id="answer-status-15"></span><br><br><p>Discussion: Why?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-4" title="Go to the previous slide 7-4">&larr;</div>
<div class="electure-next" data-nextid="7-6" title="Go to the next slide 7-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-6" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-5" title="Go to the previous slide 7-5">&larr;</div>
<div class="electure-next" data-nextid="7-7" title="Go to the next slide 7-7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-7" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>We can actually <i>augment</i> the basic DFS further to give more insights about the underlying graph.</p><br><p>In this visualization, we use <span style="color: lightblue;">blue color</span> to highlight <b>back</b> edge(s) of the DFS spanning tree. The presence of at least one back edge shows that the traversed graph (component) is <b>cyclic</b> while its absence shows that at least the component connected to the source vertex of the traversed graph is <b>acyclic</b>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-6" title="Go to the previous slide 7-6">&larr;</div>
<div class="electure-next" data-nextid="7-8" title="Go to the next slide 7-8">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-8" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>Back edge can be detected by modifying array <b>status[u]</b> to record <b>three</b> different states:</p><ol><li><b>unvisited</b>: same as earlier, DFS has not reach vertex <b>u</b> before,</li><li><b>explored</b>: DFS has visited vertex <b>u</b>, but at least one neighbor of vertex <b>u</b> has not been visited yet (DFS will go depth-first to that neighbor first),</li><li><b>visited</b>: now stronger definition: all neighbors of vertex <b>u</b> have also been visited and DFS is about to backtrack from vertex <b>u</b> to vertex <b>p[u]</b>.</li></ol><p>If DFS is now at vertex <b>x</b> and explore edge <b>x &rarr; y</b> and encounter <b>status[y] = explored</b>, we can declare <b>x &rarr; y</b> is a <b>back edge</b> (a cycle is found as we were previously at vertex <b>y</b> (hence <b>status[y] = explored</b>), go deep to neighbor of <b>y</b> and so on, but we are now at vertex <b>x</b> that is reachable from <b>y</b> but vertex <b>x</b> leads back to vertex <b>y</b>).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-7" title="Go to the previous slide 7-7">&larr;</div>
<div class="electure-next" data-nextid="7-9" title="Go to the next slide 7-9">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-9" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>The edges in the graph that are not <span style="color: red;">tree edge(s)</span> nor <span style="color: lightblue;">back edge(s)</span> are colored <span style="color: grey;">grey</span>. They are called <b>forward or cross edge(s)</b> and currently have limited use (not elaborated).</p><br><p>Now try <span class="slide-actions" onclick="doButtonAction39()">DFS(0)</span> on the example graph above with this new understanding, especially about the 3 possible status of a vertex (unvisited/<span style="color: black; background-color: white;">normal black circle</span>, explored/<span style="color: lightblue;">blue circle</span>, <span style="color: orange;">visited/orange circle</span>) and <span style="color: lightblue;">back edge</span>. Edge 2 → 1 will be discovered as a back edge as it is part of cycle 1 → 3 → 2 → 1 (as vertex 2 is `explored&#39; to vertex 1 which is currently `explored&#39;) (similarly with Edge 6 → 4 as part of cycle 4 &rightarrow; 5 &rightarrow; 7 &rightarrow; 6 &rightarrow; 4).</p><br><p>Note that if edges 2 → 1 and 6 → 4 are reversed to 1 → 2 and 4 → 6, then the graph is correctly classified as acyclic as edge 3 → 2 and 4 → 6 go from `explored&#39; to `fully visited&#39;. If we only use binary states: `unvisited&#39; vs `visited&#39;, we cannot distinguish these two cases.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-8" title="Go to the previous slide 7-8">&larr;</div>
<div class="electure-next" data-nextid="7-10" title="Go to the next slide 7-10">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-10" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>There is another DFS (and also BFS) application that can be treated as &#39;simple&#39;: Performing Topological Sort(ing) of a Directed Acyclic Graph (DAG) &mdash; see example above.</p><br><p>Topological sort of a DAG is a linear ordering of the DAG&#39;s vertices in which each vertex comes before all vertices to which it has outbound edges.</p><br><p>Every DAG (can be checked with <a href="dfsbfs/indexaaed.html?slide=7-7"><u>DFS earlier</u></a>) has at least one but possibly more topological sorts/ordering.</p><br><p>One of the main purpose of (at least one) topological sort of a DAG is for <a href="recursion.html"><u>Dynamic Programming (DP)</u></a> technique. For example, this topological sorting process is used internally in <a href="sssp.html"><u>DP solution for SSSP on DAG</u></a>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-9" title="Go to the previous slide 7-9">&larr;</div>
<div class="electure-next" data-nextid="7-11" title="Go to the next slide 7-11">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-11" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>We can use either the O(<b>V</b>+<b>E</b>) DFS or BFS to perform Topological Sort of a Directed Acyclic Graph (DAG).</p><br><p>The DFS version requires just one additional line compared to the normal DFS and is basically the post-order traversal of the graph. Try <span class="slide-actions" onclick="doButtonAction44()">Toposort (DFS)</span> on the example DAG.</p><br><p>The BFS version is based on the idea of vertices without incoming edge and is also called as Kahn&#39;s algorithm. Try <span class="slide-actions" onclick="doButtonAction45()">Toposort (BFS/Kahn's)</span> on the example DAG.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-10" title="Go to the previous slide 7-10">&larr;</div>
<div class="electure-next" data-nextid="8" title="Go to the next slide 8">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>As of now, you have seen DFS/BFS and what it can solve (with just minor tweaks). There are a few more advanced applications that require more tweaks and we will let advanced students to explore them on their own:</p><ol><li>Bipartite Graph Checker (DFS and BFS variants),</li><li>Finding Articulation Points (Cut Vertices) and Bridges of an Undirected Graph (DFS only),</li><li>Finding Strongly Connected Components (SCCs) of a Directed Graph (Tarjan&#39;s and Kosaraju&#39;s algorithms), and</li><li>2-SAT(isfiability) Checker algorithms.</li></ol><hr><p>Advertisement: The details are written in <a href="https://cpbook.net/" target="_blank"><u>Competitive Programming book</u></a>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-11" title="Go to the previous slide 7-11">&larr;</div>
<div class="electure-next" data-nextid="9" title="Go to the next slide 9">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-9" class="electure-dialog" style="top:300px;left:50%;margin-left:-250px;width:500px;">
<p>We can use the O(<b>V</b>+<b>E</b>) DFS or BFS (they work similarly) to check if a given graph is a Bipartite Graph by giving alternating color (<span style="color: orange;">orange</span> versus <span style="color: lightblue;">blue</span> in this visualization) between neighboring vertices and report &#39;non bipartite&#39; if we ends up assigning same color to two adjacent vertices or &#39;bipartite&#39; if it is possible to do such &#39;2-coloring&#39; process. Try <span class="slide-actions" onclick="doButtonAction46()">DFS_Checker</span> or <span class="slide-actions" onclick="doButtonAction47()">BFS_Checker</span> on the example Bipartite Graph.</p><br><p>Bipartite Graphs have useful applications in <a href="matching.html"><u>(Bipartite) Graph Matching problem</u></a>.</p><br><p>Note that Bipartite Graphs are usually only defined for undirected graphs so this visualization will convert directed input graphs into its undirected version automatically before continuing. This action is irreversible and you may have to redraw the directed input graph again for other purposes.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="8" title="Go to the previous slide 8">&larr;</div>
<div class="electure-next" data-nextid="10" title="Go to the next slide 10">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-10" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>We can modify (but unfortunately, not trivially) the O(<b>V</b>+<b>E</b>) DFS algorithm into an algorithm to find Cut Vertices &amp; Bridges of an Undirected Graph.</p><br><p>A Cut Vertex, or an Articulation Point, is a vertex of an undirected graph which removal disconnects the graph. Similarly, a bridge is an edge of an undirected graph which removal disconnects the graph.</p><br><p>Note that this algorithm for finding Cut Vertices &amp; Bridges only works for undirected graphs so this visualization will convert directed input graphs into its undirected version automatically before continuing. This action is irreversible and you may have to redraw the directed input graph again for other purposes. You can try to <span class="slide-actions" onclick="doButtonAction48()">Find Cut Vertices &amp; Bridges</span> on the example graph above.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="9" title="Go to the previous slide 9">&larr;</div>
<div class="electure-next" data-nextid="11" title="Go to the next slide 11">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-11" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>We can modify (but unfortunately, not trivially) the O(<b>V</b>+<b>E</b>) DFS algorithm into an algorithm to find Strongly Connected Components (SCCs) of a Directed Graph G.</p><br><p>An SCC of a directed graph G a is defined as a subgraph S of G such that for any two vertices u and v in S, vertex u can reach vertex v directly or via a path, and vertex v can also reach vertex u back directly or via a path.</p><br><p>There are two known algorithms for finding SCCs of a Directed Graph: Kosaraju&#39;s and Tarjan&#39;s. Both of them are available in this visualization. Try <span class="slide-actions" onclick="doButtonAction49()">Kosaraju's Algorithm</span> and/or <span class="slide-actions" onclick="doButtonAction50()">Tarjan's Algorithm</span> on the example directed graph above.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="10" title="Go to the previous slide 10">&larr;</div>
<div class="electure-next" data-nextid="12" title="Go to the next slide 12">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-12" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>We also have the 2-SAT Checker algorithm. Given a 2-Satisfiability (2-SAT) instance in the form of conjuction of clauses: (clause<sub>1</sub>) ^ (clause<sub>2</sub>) ^ ... ^ (clause<sub>n</sub>) and each clause is in form of disjunction of up to two variables (var<sub>a</sub> v var<sub>b</sub>), determine if we can assign True/False values to these variables so that the entire 2-SAT instance is evaluated to be true, i.e. satisfiable.</p><br><p>It turns out that each clause (a v b) can be turned into four vertices a, not a, b, and not b with two edges: (not a &rarr; b) and (not b &rarr; a). Thus we have a Directed Graph. If there is at least one variable and its negation inside an SCC of such graph, we know that it is impossible to satisfy the 2-SAT instance.</p><br><p>After such directed graph modeling, we can run an SCC finding algorithm (Kosaraju&#39;s or Tarjan&#39;s algorithm) to determine the satisfiability of the 2-SAT instance.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="11" title="Go to the previous slide 11">&larr;</div>
<div class="electure-next" data-nextid="13" title="Go to the next slide 13">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-13" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<input class="mcq-answer" id="mcq-answer-22" value="95" hidden><p>Quiz: <b>Which Graph Traversal Algorithm is Better?</b></p><form><input type="radio" name="mcq-22-choice" value="95"> It Depends on the Situation<br><input type="radio" name="mcq-22-choice" value="96"> Both are Equally Good<br><input type="radio" name="mcq-22-choice" value="93"> Always DFS<br><input type="radio" name="mcq-22-choice" value="94"> Always BFS<br></form><button class="mcq-submit" id="submit-22">Submit</button> <span id="answer-status-22"></span><br><br><p>Discussion: Why?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="12" title="Go to the previous slide 12">&larr;</div>
<div class="electure-next" data-nextid="13-1" title="Go to the next slide 13-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-13-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="13" title="Go to the previous slide 13">&larr;</div>
<div class="electure-next" data-nextid="14" title="Go to the next slide 14">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-14" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>There are lots of things that we can still do with just DFS and/or BFS...<br></p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="13-1" title="Go to the previous slide 13-1">&larr;</div>
<div class="electure-next" data-nextid="14-1" title="Go to the next slide 14-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-14-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>There are interesting questions about these two graph traversal algorithms: DFS+BFS and variants of graph traversal problems, please practice on <a href="https://visualgo.net/training?diff=Medium&amp;n=7&amp;tl=0&amp;module=dfsbfs"><u>Graph Traversal</u></a> training module (no login is required, but short and of medium difficulty setting only).</p><br><p>However, for registered users, you should login and then go to the <a href="https://visualgo.net/training"><u>Main Training Page</u></a> to officially clear this module and such achievement will be recorded in your user account.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="14" title="Go to the previous slide 14">&larr;</div>
<div class="electure-next" data-nextid="14-2" title="Go to the next slide 14-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-14-2" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>We also have a few programming problems that somewhat requires the usage of DFS and/or BFS: <a href="https://open.kattis.com/problems/reachableroads" title target="_blank"><u>Kattis - reachableroads</u></a> and <a href="https://open.kattis.com/problems/breakingbad" title target="_blank"><u>Kattis - breakingbad</u></a>.</p><br><p>Try to solve them and then try the <b>many more</b> interesting twists/variants of this simple graph traversal problem and/or algorithm.</p><br><p>You are allowed to use/modify our implementation code for DFS/BFS Algorithms:<br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/traversal/dfs_cc.cpp" target="_blank"><u>dfs_cc.cpp</u></a>/<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/bfs.cpp" target="_blank"><u>bfs.cpp</u></a><br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/traversal/dfs_cc.java" target="_blank"><u>dfs_cc.java</u></a>/<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/bfs.java" target="_blank"><u>bfs.java</u></a><br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/traversal/dfs_cc.py" target="_blank"><u>dfs_cc.py</u></a>/<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/bfs.py" target="_blank"><u>bfs.py</u></a><br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/traversal/dfs_cc.ml" target="_blank"><u>dfs_cc.ml</u></a>/<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/bfs.ml" target="_blank"><u>bfs.ml</u></a><br></p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="14-1" title="Go to the previous slide 14-1">&larr;</div>
<div class="electure-next" data-nextid="14-3" title="Go to the next slide 14-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-14-3" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
<hr>
<p>You have reached the last slide. Return to 'Exploration Mode' to start exploring!</p>
<p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
</div>
<div class="electure-prev" data-nextid="14-2" title="Go to the previous slide 14-2">&larr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>Close</u></span>
</div>
<div id="rotateDeviceOverlay" style="display: none;">
<div id="rotateDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please rotate your device to landscape mode for a better user experience</div>
<div id="widenDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please make the window wider for a better user experience</div>
</div>

<style>
        .mediumscale {
            bottom: 335px
        }
    </style>
<style>
        .draw {
            bottom: 281px
        }
    </style>
<style>
        .examples {
            bottom: 254px
        }
    </style>
<style>
        .dfs {
            bottom: 227px
        }
    </style>
<style>
        .bfs {
            bottom: 200px
        }
    </style>
<style>
        .topo {
            bottom: 173px
        }
    </style>
<style>
        .bipartite {
            bottom: 146px
        }
    </style>
<style>
        .bridge {
            bottom: 119px
        }
    </style>
<style>
        .scc {
            bottom: 92px
        }
    </style>
<style>
        .twosat {
            bottom: 65px
        }
    </style>
<div id="actions" class="panel">
<p id="mediumscale">Visualisation Scale</p>
<p class="execAction" id="vertexnumber" onClick="toggleVertexNumber()">Toggle V. Number for 0.5x</p>
<p class="execAction" id="draw" onClick="drawGraph()">Edit Graph</p>
<p id="examples">Example Graphs</p>
<p id="dfs">Depth-First Search</p>
<p id="bfs">Breadth-First Search</p>
<p id="topo">Topological Sort</p>
<p id="bipartite">Bipartite Graph Check</p>
<p class="execAction" id="bridge" onClick="bridge()">Cut Vertex & Bridge</p>
<p id="scc">SCC Algorithms</p>
<p id="twosat">2-SAT Checker</p>
</div>
<div id="actions-hide" class="panel-hide"><span style="color:white; font-size: x-large; display: inline-block;">&gt;</span></div>
<div id="actions-extras">
<div class="mediumscale action-menu-pullout">
<div id="defaultScale" class="execAction new-menu-option coloured-menu-option" onClick="setDefaultScale()">
<p>1.0x (Default)</p>
</div>
<div id="mediumScale" class="execAction new-menu-option coloured-menu-option" onClick="setMediumScale()">
<p>0.5x (Minimal Details)</p>
</div>
<div id="mediumscale-err" class="err" style="float: left;"></div>
</div>
<div class="draw action-menu-pullout">
<div id="draw-err" class="err" style="float: left;"></div>
</div>
<div class="examples action-menu-pullout">
<div id="example1" class="execAction new-menu-option coloured-menu-option" onClick="example(CP3_4_1)">
<p>CP3 4.1</p>
</div>
<div id="example2" class="execAction new-menu-option coloured-menu-option" onClick="example(CP3_4_3)">
<p>CP3 4.3</p>
</div>
<div id="example3" class="execAction new-menu-option coloured-menu-option" onClick="example(CP3_4_4)">
<p>CP3 4.4 DAG</p>
</div>
<div id="example4" class="execAction new-menu-option coloured-menu-option" onClick="example(CP3_4_9)">
<p>CP3 4.9</p>
</div>
<div id="example5" class="execAction new-menu-option coloured-menu-option" onClick="example(CP3_4_17)">
<p>CP3 4.17 DAG</p>
</div>
<div id="example6" class="execAction new-menu-option coloured-menu-option" onClick="example(CP3_4_18)">
<p>CP3 4.18 DAG, Bipartite</p>
</div>
<div id="example7" class="execAction new-menu-option coloured-menu-option" onClick="example(CP3_4_19)">
<p>CP3 4.19 Bipartite</p>
</div>
<div id="example8" class="execAction new-menu-option coloured-menu-option" onClick="example(DFSBFSLARGE)">
<p>Large Graph</p>
</div>
<div id="example9" class="execAction new-menu-option coloured-menu-option" onClick="example(DFSBFSLARGECYCLES)">
<p>Large, Cycles</p>
</div>
<div id="examples-err" class="err" style="float: left;"></div>
</div>
<div class="dfs action-menu-pullout">
<div id="dfs-input" class="new-menu-option">
s = <input id="dfs-v" type="number" title="Enter the source vertex" autocomplete="off" min="0" max="99" value="0"> </div>
<div id="dfs-go" class="execAction new-menu-option coloured-menu-option" onClick="dfs()">
<p>Go</p>
</div>
<div id="dfs-err" class="err" style="float: left;"></div>
</div>
<div class="bfs action-menu-pullout">
<div id="bfs-input" class="new-menu-option">
s = <input id="bfs-v" type="number" title="Enter the source vertex" autocomplete="off" min="0" max="99" value="0"> </div>
<div id="bfs-go" class="execAction new-menu-option coloured-menu-option" onClick="bfs()">
<p>Go</p>
</div>
<div id="bfs-err" class="err" style="float: left;"></div>
</div>
<div class="topo action-menu-pullout">
<div id="toposortDfs" class="execAction new-menu-option coloured-menu-option" onClick="toposortDfs()">
<p>DFS version</p>
</div>
<div id="toposortBfs" class="execAction new-menu-option coloured-menu-option" onClick="toposortBfs()">
<p>BFS version (Kahn&#39;s algorithm)</p>
</div>
<div id="topo-err" class="err" style="float: left;"></div>
</div>
<div class="bipartite action-menu-pullout">
<div id="bipartiteDfs" class="execAction new-menu-option coloured-menu-option" onClick="bipartiteDfs()">
<p>DFS version</p>
</div>
<div id="bipartiteBfs" class="execAction new-menu-option coloured-menu-option" onClick="bipartiteBfs()">
<p>BFS version</p>
</div>
<div id="bipartite-err" class="err" style="float: left;"></div>
</div>
<div class="bridge action-menu-pullout">
<div id="bridge-err" class="err" style="float: left;"></div>
</div>
<div class="scc action-menu-pullout">
<div id="kosaraju" class="execAction new-menu-option coloured-menu-option" onClick="kosaraju()">
<p>Kosaraju&#39;s Algorithm</p>
</div>
<div id="tarjan" class="execAction new-menu-option coloured-menu-option" onClick="tarjan()">
<p>Tarjan&#39;s Algorithm</p>
</div>
<div id="scc-err" class="err" style="float: left;"></div>
</div>
<div class="twosat action-menu-pullout">
<div id="numclauses-input" class="new-menu-option">
Number of clauses = <input id="twosat-v1" type="number" title="Enter the number of clauses" autocomplete="off" min="1" max="10" value="2"> </div>
<div id="numvariabls-input" class="new-menu-option">
Number of variables = <input id="twosat-v2" type="number" title="Enter the number of variables" autocomplete="off" min="1" max="10" value="2"> </div>
<div id="twosat-go" class="execAction new-menu-option coloured-menu-option" onClick="twosat()">
<p>GO</p>
</div>
<div id="twosat-err" class="err" style="float: left;"></div>
</div>
</div>

<div id="drawgraph" class="overlays"></div>
<div id="twosat-board" class="overlays"></div>
</div>

<div id="bottom-bar">
<a id="scale" style="display: none;">1.0x</a>
<a id="trigger-about">About</a>
<a id="trigger-team">Team</a>
<a id="trigger-terms">Terms of use</a>
<a id="trigger-privacy">Privacy Policy</a>
</div>
<div id="about" class="overlays">
<h4>About</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.</p><p>Featuring numerous advanced algorithms discussed in Dr. Steven Halim&#39;s book, &#39;Competitive Programming&#39; — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.</p><p>While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.</p><p>Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.</p><p>VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.</p><p>Equipped with a built-in question generator and answer verifier, VisuAlgo&#39;s "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students&#39; answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students&#39; mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.</p><p>VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:</p>
<a href="https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689" target="_blank"><u>id</u></a>,
<a href="http://blog.naver.com/visualgo_nus" target="_blank"><u>kr</u></a>,
<a href="https://www.facebook.com/groups/163215593699283/permalink/824003417620494/" target="_blank"><u>vn</u></a>,
<a href="http://pantip.com/topic/32736343" target="_blank"><u>th</u></a>.
</div>
</div>
<div id="team" class="overlays">
<h4>Team</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>
<strong><span style="line-height: 150%;">Project Leader &amp; Advisor (Jul 2011-present)</span></strong><br>
<a href="https://www.comp.nus.edu.sg/~stevenha/" target="_blank">Associate Professor Steven Halim</a>, School of Computing (SoC), National University of Singapore (NUS)<br>
<a href="https://www.linkedin.com/in/felixhalim/" target="_blank">Dr Felix Halim</a>, Senior Software Engineer, Google (Mountain View)
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 1</span></strong><br>
<b>CDTL TEG 1: Jul 2011-Apr 2012</b>: Koh Zi Chun, Victor Loh Bo Huai
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 1</span></strong><br>
<b>Jul 2012-Dec 2013</b>: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang Duy<br>
<b>Jun 2013-Apr 2014</b> <a href="https://www.rosemarietan.com/" target="_blank">Rose Marie Tan Zhao Yun</a>, Ivan Reinaldo
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 2</span></strong><br>
<b>CDTL TEG 2: May 2014-Jul 2014</b>: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 2</span></strong><br>
<b>Jun 2014-Apr 2015</b>: Erin Teo Yi Ling, Wang Zi<br>
<b>Jun 2016-Dec 2017</b>: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin Mudzakir<br>
<b>Aug 2021-Apr 2023</b>: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius<br>
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 3</span></strong><br>
<b>Optiver: Aug 2023-Oct 2023</b>: Bui Hong Duc, Oleh Naver, Tay Ngan Lin<br>
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 3</span></strong><br>
<b>Aug 2023-Apr 2024</b>: Xiong Jingya, Radian Krisno, Ng Wee Han<br>
</p>
<p>
List of translators who have contributed &ge; 100 translations can be found at <a href="https://visualgo.net/statistics">statistics</a> page.
</p>
<p>
<strong><span style="line-height: 150%;">Acknowledgements</span></strong><br>
NUS <a href="https://nus.edu.sg/cdtl" target="_blank"><u>CDTL</u></a> gave Teaching Enhancement Grant to kickstart this project.<div>For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.</div>
</p>
</div>
</div>
<div id="termsofuse" class="overlays">
<h4>Terms of use</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that you <b>spread the word about its existence to fellow Computer Science students and instructors</b>. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.</p><p>Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (<a href="https://visualgo.net/">https://visualgo.net</a>) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo&#39;s client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.</p><p>Please note that VisuAlgo&#39;s online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the &#39;training mode.&#39; The &#39;test mode&#39; offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.</p><p><strong><span style="line-height: 200%;">List of Publications</span></strong></p> <p>This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can click <a href="https://ioinformatics.org/journal/INFOL099.pdf" target="_blank">this link</a> to read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) and <a href="https://ioinformatics.org/journal/v9_2015_243_245.pdf" target="_blank">this link</a> for the short update in 2015 (to link VisuAlgo name with the previous project).</p><p><strong><span style="line-height: 200%;">Bug Reports or Request for New Features</span></strong></p> <p>VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.</p>
</div>
</div>
<div id="privacy-policy" class="overlays">
<h4>Privacy Policy</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p><b>Version 1.2 (Updated Fri, 18 Aug 2023).</b></p><p>Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.</p><p>Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).</p><p>Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.</p><p>For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.<br></p><p>For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.</p>
</div>
</div>
</div>


<script src="../../../code.jquery.com/jquery-3.7.0.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
<script src="../../../cdn.jsdelivr.net/npm/bootstrap%405.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<script src="../../../unpkg.com/d3-force-boundary%400.0.1/dist/d3-force-boundary.min.js"></script>
<script>
  $(function () {
    // overlays stuffs
    $('#trigger-about').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#about').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-team').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#team').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-terms').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#termsofuse').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-privacy').click(function () {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#privacy-policy').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    })

    $('.close-overlay').click(function() {
      $('.overlays').fadeOut(function() {
        $('#dark-overlay').fadeOut();
      });
    });

    $('#dark-overlay').click(function() {
      $('.overlays').fadeOut();
      $('#dark-overlay').fadeOut();
      if (typeof GeometryWidget !== 'undefined') {
        GeometryWidget.stopLoop();
      }
    });
  })
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-1566631-4"></script>
<script>
      $.ajaxSetup({
        headers: {
          'X-CSRF-TOKEN': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H"
        }
      });

      // handles account dropdown menu
      $(function () {
        $('#language-dropdown-btn').click(function (e) {
          $('#language-dropdown-menu').css('display', 'block');
          $('#account-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function () {
          $('#language-dropdown-menu').css('display', 'none')
        })
      })

      $(function () {
        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        })
      })

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        if (retval) {
          $('#current-action').show();
          $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
          $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
          triggerRightPanels();
          isPlaying = true;
        }
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; ++i) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      const MOBILE_WIDTH = 1000;
      const matchMediaMobile = window.matchMedia(`only screen and (max-width: ${MOBILE_WIDTH}px)`);
      const matchMediaNarrow = window.matchMedia(`only screen and (max-width: 500px)`);
      function isMobile() {
        return matchMediaMobile.matches;
      }
      //To fix the issue of a narrow desktop window being asked to rotate, I am now checking for it based on the navigator.userAgent to see if its mobile or not.
      //This may change in the future if browsers decide to change the naming of userAgent for mobile browsers so may need to keep an eye on this.
      function isMobileOS() {
        return /Mobi/i.test(navigator.userAgent) && !/ipad/i.test(navigator.userAgent);
      }
      let portraitMatcher = window.matchMedia("(orientation:portrait)");
      function isPortrait() {
        return portraitMatcher.matches;
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.colour').css("color", surpriseColour);
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
        });
      });

/*
      // GA dropped 26 Jun 2023 and then made official on 18 Aug 2023
/*
      // the sunset-ed GA, commented on 26 Jun 2023, and Prof Halim doesn't bother to use anymore
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
*/

      // function setCookie(cname, cvalue, exdays) {
      //   const d = new Date();
      //   d.setTime(d.getTime() + (exdays*24*60*60*1000));
      //   let expires = "expires="+ d.toUTCString();
      //   document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
      // }

//       //         $(function() {
//           $('#gdpr-accept').click(function () {
// /*
//             // added on 26 Jun 2023
//             window.dataLayer = window.dataLayer || [];
//             function gtag(){dataLayer.push(arguments);}
//             gtag('js', new Date());

//             gtag('config', 'UA-1566631-4');
// */
// //            ga('create', 'UA-1566631-4', 'auto');
// //            ga('send', 'pageview');
//             setCookie('use_google_analytics', 'true', 365)
//             $('#gdpr-popup').hide()
//           });
//           $('#gdpr-reject').click(function () {
//             setCookie('use_google_analytics', 'false', 365)
//             $('#gdpr-popup').hide()
//           });
//         });
//       
      $('#gdpr-privacy-policy').click(function () {
        if ($(window).width() > 600) {
          $('#dark-overlay').fadeIn(function() {
            $('#privacy-policy').fadeIn();
          });
        }
        else
          alert('Sorry, this dialog is too big. Please load it on bigger screen');
      })
    </script>

<script src="../../js/jquery-ui.min.js"></script>

<script src="../../js/d3.min.js"></script>
<script src="../../js/viz-1.0.10.js"></script>

<script src="../../js/graph_library/constant.js"></script>
<script src="../../js/graph_library/drawgraph.js"></script>
<script src="../../js/graph_library/GraphEdgeWidget.js"></script>
<script src="../../js/graph_library/GraphPolygonWidget.js"></script>
<script src="../../js/graph_library/GraphVertexWidget.js"></script>
<script src="../../js/graph_library/GraphWidget.js"></script>
<script src="../../js/graph_library/helperObjects89db.js?refresh22aug9pm"></script> 
<script src="../../js/graph_library/misc.js"></script>
<script src="../../js/graph_library/properties.js"></script>
<script src="../../js/graph_library/Widget.js"></script>
<script src="../../js/graph_library/force_directed_library.js"></script>

<script>
      $(function () {
        let defaultPlaybackSpeed = 1;
                createPlaybackSpeedSlider(defaultPlaybackSpeed);


        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        });
        //Mobile Design Related DOM Manipulations
        if (isMobile()) {
          $("#status").css({
            "bottom": "10%",
            "height": "12%",
            "max-height": "54px"
          });
          $("#current-action").css("bottom", "22%");
          $('#status-hide').remove();
          $('#left-bar').remove();
          $('#right-bar').remove();
          $("#mode-menu").remove();
          $("#codetrace").css("z-index", 1);
          $("#bottom-bar a").hide();
          $("#bottom-bar").css("height", $("#topbar").css("height"));
          $(".speed-dropup-btn").show();
          $("#go-to-beginning").remove();
          $("#go-to-end").remove();
          $("#pause").remove();
          $("#play").remove();
          $("#previous").remove();
          $("#next").remove();

          //make progress bar longer
          $("#progress-bar").css({
            left: "30%",
            width: "60%",
            'margin-left': 0
          })
        }
      })

      let mobilePlaybackOverlayTimeout;
      $(function() {
        $("#viz").on("click", () => {
          if (isMobile()) {
            if ($("#mobile-playback-overlay").is(":hidden") && isPlaying) {
              $("#mobile-playback-overlay").fadeIn();
              hideMobilePlaybackOverlay(6000);
            } else {
              $("#mobile-playback-overlay").fadeOut();
            }
          }
        });
        $("#mobile-playback-overlay").on("click", (event) => {
          if (event.target === event.currentTarget) //to ensure clicks on the controls dont fade the overlay
            $("#mobile-playback-overlay").fadeOut();
          else
            hideMobilePlaybackOverlay(5000);
        })
      });
      function hideMobilePlaybackOverlay(timeOut) {
        if (mobilePlaybackOverlayTimeout)
          clearTimeout(mobilePlaybackOverlayTimeout);
        mobilePlaybackOverlayTimeout = setTimeout(() => {
            $("#mobile-playback-overlay").fadeOut();
        }, timeOut);
      }
      function mobilePlaybackPauseOrPlay() {
        if ($("#mobile-playback-overlay").hasClass("playing")) {
          pause();
          hideMobilePlaybackOverlay(5000);
        } else {
          play();
          hideMobilePlaybackOverlay(3000);
        }
      }
      let rewindLabelTimeout, forwardLabelTimeout;
      function mobilePlaybackRewind() {
        $("#mobile-playback-rewind-label").css("opacity", 1);
        if (rewindLabelTimeout)
          clearTimeout(rewindLabelTimeout);
        rewindLabelTimeout = setTimeout(() => {
          $("#mobile-playback-rewind-label").css("opacity", 0);
        }, 800);
        stepBackward(7);
      }
      function mobilePlaybackForward() {
        $("#mobile-playback-forward-label").css("opacity", 1);
        if (forwardLabelTimeout)
          clearTimeout(forwardLabelTimeout);
        forwardLabelTimeout = setTimeout(() => {
          $("#mobile-playback-forward-label").css("opacity", 0);
        }, 800);
        stepForward(7);
      }

      //let eLectureSessionHistory = {};
      const sectorColors = ['#05a4d0', '#f1c706', '#fa0202'];
      function setSlideTimelineColor(slideNo) {
        const sectionNo = slideNo.split('-')[0];
        $(`[slideNo="${slideNo}"]`).css('background', sectorColors[(parseInt(sectionNo) % 3)]);
      }

      let currSlideTimer = null; //global so that we can clear the timeout when required

      const lectureIds = [{"id":34,"category":"dfsbfs","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 13:51:35","updated_at":"2023-10-19 08:39:31","section":-1,"code":"","section_order":-1,"value":"1","text":"<p>Given a graph, we can use the O(<b>V<\/b>+<b>E<\/b>) DFS (Depth-First Search) or BFS (Breadth-First Search) algorithm to traverse the graph and explore the features\/properties of the graph. Each algorithm has its own characteristics, features, and side-effects that we will explore in this visualization.<\/p><br><p>This visualization is rich with a lot of DFS and BFS variants (all run in O(<b>V<\/b>+<b>E<\/b>)) such as: <\/p><ol><li>Topological Sort algorithm (both DFS and BFS\/Kahn&#39;s algorithm version),<\/li><li>Bipartite Graph Checker algorithm (both DFS and BFS version),<\/li><li>Cut Vertex &amp; Bridge finding algorithm,<\/li><li>Strongly Connected Components (SCC) finding algorithms<br>(both Kosaraju&#39;s and Tarjan&#39;s version), and<\/li><li>2-SAT Checker algorithm.<\/li><\/ol>","title":"DFS & BFS"},{"id":35,"category":"dfsbfs","order":2,"top":"270px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 13:53:02","updated_at":"2017-05-07 06:58:47","section":-1,"code":"example(CP3_4_1);","section_order":-1,"value":"2","text":"<p>When the chosen graph traversal algorithm is running, the animation will be shown here.<\/p><br><p>We use vertex+edge color (the color scheme will be elaborated soon) and occasionally the extra text under the vertex (in <span style=\"color: red;\">red font<\/span>) to highlight the changes.<\/p><br><p>All graph traversal algorithms work on directed graphs (this is the default setting, where each edge has an arrowtip to indicate its direction) but the <b>Bipartite Graph Check<\/b> algorithm and the <b>Cut Vertex &amp; Bridge<\/b> finding algorithm requires the undirected graphs (the conversion is done automatically by this visualization).<\/p>","title":"Visualization"},{"id":36,"category":"dfsbfs","order":3,"top":"","right":"","bottom":"320px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 13:54:01","updated_at":"2023-10-19 08:42:44","section":-1,"code":"$(\"#draw\").addClass(\"menu-highlighted\");\n$(\"#random\").addClass(\"menu-highlighted\");\n$(\"#examples\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"3","text":"<p>There are two different sources for specifying an input graph:<\/p><ol><li><b>Edit Graph<\/b>: You can draw a new graph or edit an example unweighted directed graph as the input graph (to draw bidirectional edge (u, v), you can draw two directed edges u \u2192 v and v \u2192 u).<\/li><li><b>Example Graphs<\/b>: You can select from the list of our selected example graphs to get you started.<\/li><\/ol>","title":"Specifying an Input Graph"},{"id":297,"category":"dfsbfs","order":4,"top":"140px","right":"60px","bottom":"","left":"","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-08 01:19:19","updated_at":"2023-10-19 08:43:12","section":-1,"code":"loadGraph({\n  'vl': {\n    0: { \"x\": 100, \"y\": 50  },\n    1: { \"x\":  50, \"y\": 150 },\n    2: { \"x\": 150, \"y\": 150 },\n    3: { \"x\": 125, \"y\": 250 },\n    4: { \"x\": 175, \"y\": 250 },\n  },\n  'el': {\n    0: { \"u\": 0, \"v\": 1, \"w\": 1 },\n    1: { \"u\": 0, \"v\": 2, \"w\": 1 },\n    2: { \"u\": 2, \"v\": 3, \"w\": 1 },\n    3: { \"u\": 2, \"v\": 4, \"w\": 1 },\n  }\n});","section_order":-1,"value":"4","text":"<p>If you arrive at this e-Lecture <b>without<\/b> having first explore\/master the concept of <a href=\".\/heap\"><u>Binary Heap<\/u><\/a> and especially <a href=\".\/bst\"><u>Binary Search Tree<\/u><\/a>, we suggest that you explore them first, as traversing a (Binary) Tree structure is much simpler than traversing a general graph.<\/p><br><input class=\"msq-answer\" id=\"msq-answer-14\" value=\"60,63,64\" hidden><p>Quiz: <b>Mini pre-requisite check. What are the Pre-\/In-\/Post-order traversal of the binary tree shown (root = vertex 0), left and right child are as drawn?<\/b><\/p><input type=\"checkbox\" class=\"msq-choice\" id=\"msq-14-choice-60\"> Pre  = 0, 1, 2, 3, 4<br><input type=\"checkbox\" class=\"msq-choice\" id=\"msq-14-choice-64\"> Post = 1, 3, 4, 2, 0<br><input type=\"checkbox\" class=\"msq-choice\" id=\"msq-14-choice-61\"> Pre = 0, 2, 4, 3, 1<br><input type=\"checkbox\" class=\"msq-choice\" id=\"msq-14-choice-65\"> Post = 4, 3, 2, 1, 0<br><input type=\"checkbox\" class=\"msq-choice\" id=\"msq-14-choice-63\"> In = 1, 0, 3, 2, 4<br><input type=\"checkbox\" class=\"msq-choice\" id=\"msq-14-choice-62\"> In = 4, 2, 3, 0, 1<br><button class=\"msq-submit\" id=\"submit-14\">Submit<\/button> <span id=\"answer-status-14\"><\/span>","title":"Recap"},{"id":298,"category":"dfsbfs","order":1,"top":"140px","right":"60px","bottom":"","left":"","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-08 01:30:09","updated_at":"2023-10-19 08:43:21","section":297,"code":"loadGraph({\n  'vl': {\n    0: { \"x\": 100, \"y\": 150 },\n    1: { \"x\":  50, \"y\": 50  },\n    2: { \"x\": 150, \"y\": 50  },\n    3: { \"x\": 175, \"y\": 150 },\n    4: { \"x\": 225, \"y\": 150 },\n  },\n  'el': {\n    0: { \"u\": 0, \"v\": 1, \"w\": 1 },\n    1: { \"u\": 0, \"v\": 2, \"w\": 1 },\n    2: { \"u\": 2, \"v\": 3, \"w\": 1 },\n    3: { \"u\": 2, \"v\": 4, \"w\": 1 },\n    4: { \"u\": 1, \"v\": 0, \"w\": 1 },\n    5: { \"u\": 2, \"v\": 0, \"w\": 1 },\n    6: { \"u\": 3, \"v\": 2, \"w\": 1 },\n    7: { \"u\": 4, \"v\": 2, \"w\": 1 },\n  }\n});","section_order":4,"value":"4-1","text":"<p>We normally start from the most important vertex of a (binary) tree: The <b>root<\/b> vertex.<\/p><br><p>If the given tree is not &#39;rooted&#39; (see the example picture), we can pick any one vertex (for example, vertex 0 in the example picture) and designate it as the root. If we imagine that all edges are strings of similar length, then after \"virtually pulling the designated root upwards\" and let gravity pulls the rest downwards, we have a rooted directed (downwards) tree &mdash; see the next slide.<\/p><br><p>PS: Technically, this transformation is done by running <code>DFS(0)<\/code> that we will explore soon.<\/p>","title":"Binary Tree Traversal - Source = Root"},{"id":299,"category":"dfsbfs","order":2,"top":"140px","right":"60px","bottom":"","left":"","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-08 01:38:48","updated_at":"2023-10-19 08:43:24","section":297,"code":"loadGraph({\n  'vl': {\n    0: { \"x\": 100, \"y\": 50  },\n    1: { \"x\":  50, \"y\": 150 },\n    2: { \"x\": 150, \"y\": 150 },\n    3: { \"x\": 125, \"y\": 250 },\n    4: { \"x\": 175, \"y\": 250 },\n  },\n  'el': {\n    0: { \"u\": 0, \"v\": 1, \"w\": 1 },\n    1: { \"u\": 0, \"v\": 2, \"w\": 1 },\n    2: { \"u\": 2, \"v\": 3, \"w\": 1 },\n    3: { \"u\": 2, \"v\": 4, \"w\": 1 },\n  }\n});","section_order":4,"value":"4-2","text":"<p>In a <b>binary<\/b> tree, we only have <b>up to two<\/b> neighboring choices: From the current vertex, we can go to the left subtree first or go to the right subtree first. We also have option to visit the current vertex before or after visiting one of the (or both) subtree(s).<\/p><br><p>This gives rise to the classics: pre-order (visit current vertex, visit its left subtree, visit its right subtree), in-order (left, current, right), and post-order (left, right, current) traversals.<\/p><br><p>Discussion: Do you notice that there are three other possible binary tree traversal combinations? What are they?<\/p>","title":"Binary Tree Traversal - Pre-\/In-\/Post-order"},{"id":426,"category":"dfsbfs","order":3,"top":"140px","right":"60px","bottom":"","left":"","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-18 10:02:36","updated_at":"2023-10-19 08:43:26","section":297,"code":"loadGraph({\n  'vl': {\n    0: { \"x\": 100, \"y\": 50  },\n    1: { \"x\":  50, \"y\": 150 },\n    2: { \"x\": 150, \"y\": 150 },\n    3: { \"x\": 125, \"y\": 250 },\n    4: { \"x\": 175, \"y\": 250 },\n  },\n  'el': {\n    0: { \"u\": 0, \"v\": 1, \"w\": 1 },\n    1: { \"u\": 0, \"v\": 2, \"w\": 1 },\n    2: { \"u\": 2, \"v\": 3, \"w\": 1 },\n    3: { \"u\": 2, \"v\": 4, \"w\": 1 },\n  }\n});","section_order":4,"value":"4-3","text":"<p>Reverse Traversals:<\/p><ol><li>Reverse Inorder (right, current, left),<\/li><li>Reverse Preorder (current, right, left),<\/li><li>Reverse Postorder (right, left, current).<\/li><\/ol>","title":"The Answer"},{"id":300,"category":"dfsbfs","order":4,"top":"140px","right":"60px","bottom":"","left":"","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-08 01:45:23","updated_at":"2023-10-19 08:43:28","section":297,"code":"loadGraph({\n  'vl': {\n    0: { \"x\": 100, \"y\": 50  },\n    1: { \"x\":  50, \"y\": 150 },\n    2: { \"x\": 150, \"y\": 150 },\n    3: { \"x\": 125, \"y\": 250 },\n    4: { \"x\": 175, \"y\": 250 },\n  },\n  'el': {\n    0: { \"u\": 0, \"v\": 1, \"w\": 1 },\n    1: { \"u\": 0, \"v\": 2, \"w\": 1 },\n    2: { \"u\": 2, \"v\": 3, \"w\": 1 },\n    3: { \"u\": 2, \"v\": 4, \"w\": 1 },\n  }\n});","section_order":4,"value":"4-4","text":"<p>In a binary tree, or in a tree structure in general, there is no (non-trivial) cycle involving 3 or more distinct vertices to worry about (we do not consider the trivial cycle involving bi-directional edges which can be taken care of easily \u2014 see three slides earlier).<\/p>","title":"Binary Tree Traversal - Acyclic"},{"id":301,"category":"dfsbfs","order":5,"top":"140px","right":"60px","bottom":"","left":"","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-08 01:58:39","updated_at":"2023-10-19 08:43:30","section":297,"code":"","section_order":4,"value":"4-5","text":"<p>In general graph, we do not have the notion of root vertex. Instead, we need to pick one distinguished vertex to be the starting point of the traversal, i.e. the source vertex <b>s<\/b>.<\/p><br><p>We also have 0, 1, ..., <b>k<\/b> neighbors of a vertex instead of just &le; 2.<\/p> <br><p>We <b>may (or actually very likely)<\/b> have cycle(s) in our general graph instead of acyclic tree,<br> be it the trivial one like u &rarr; v &rarr; u or the non-trivial one like a &rarr; b &rarr; c &rarr; a.<\/p><br><p>But fret not, graph traversal is an easy problem with two classic algorithms: DFS and BFS.<\/p>","title":"Issues in General Graph"},{"id":37,"category":"dfsbfs","order":5,"top":"","right":"","bottom":"320px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 13:54:51","updated_at":"2018-03-22 13:35:01","section":-1,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_1);","section_order":-1,"value":"5","text":"<p>One of the most basic graph traversal algorithm is the O(<b>V<\/b>+<b>E<\/b>) Depth-First Search (DFS).<\/p><br><p>DFS takes one input parameter: The source vertex <b>s<\/b>.<\/p><br><p>DFS is one of the most fundamental graph algorithm, so please spend time to understand the key steps of this algorithm.<\/p>","title":"DFS"},{"id":284,"category":"dfsbfs","order":1,"top":"","right":"","bottom":"320px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-06 01:50:17","updated_at":"2017-10-20 09:09:58","section":37,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");","section_order":5,"value":"5-1","text":"<p><img src=\"\/img\/maze.svg\" width=\"100\" height=\"100\" style=\"background-color: white; float: right;\" alt=\"maze\">The closest analogy of the behavior of DFS is to imagine a maze with only one entrance and one exit. You are at the entrance and want to explore the maze to reach the exit. Obviously you cannot split yourself into more than one.<\/p><br><p>Ask these reflective questions before continuing: What will you do if there are branching options in front of you? How to avoid going in cycle? How to mark your own path? Hint: You need a chalk, stones (or any other marker) and a (long) string.<\/p>","title":"Analogy"},{"id":286,"category":"dfsbfs","order":2,"top":"","right":"","bottom":"320px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-06 02:06:18","updated_at":"2017-10-20 09:10:01","section":37,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");","section_order":5,"value":"5-2","text":"<p>As it name implies, DFS starts from a distinguished source vertex <b>s<\/b> and uses recursion (an implicit stack) to order the visitation sequence as deep as possible before backtracking.<\/p><br><p>If DFS is at a vertex <b>u<\/b> and it has <b>X<\/b> neighbors, it will pick the first neighbor <b>V<sub>1<\/sub><\/b> (usually the vertex with the lowest vertex number), recursively explore all reachable vertices from vertex <b>V<sub>1<\/sub><\/b>, and eventually backtrack to vertex <b>u<\/b>. DFS will then do the same for the other neighbors until it finishes exploring the last neighbor <b>V<sub>X<\/sub><\/b> and its reachable vertices.<\/p><br><p>This wordy explanation will be clearer with DFS animation later.<\/p>","title":"Trying All Options"},{"id":283,"category":"dfsbfs","order":3,"top":"","right":"","bottom":"320px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-05 14:24:43","updated_at":"2017-10-20 09:12:10","section":37,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");","section_order":5,"value":"5-3","text":"<p>If the graph is <b>cyclic<\/b>, the previous &#39;try-all&#39; strategy may lead DFS to run in cycle.<\/p><br><p>So <i>the basic form of DFS<\/i> uses an array <b>status[u]<\/b> of size <b>V<\/b> vertices to decide between <i>binary conditions<\/i>: Whether vertex <b>u<\/b> has been visited or unvisited. Only if vertex <b>u<\/b> is still unvisited, then DFS can visit vertex <b>u<\/b>.<\/p><br><p>When DFS runs out of option, it <b>backtrack<\/b> to previous vertex (<b>p[u]<\/b>, see the next slide) as the recursion unwinds.<\/p>","title":"Avoiding Cycle"},{"id":285,"category":"dfsbfs","order":4,"top":"","right":"","bottom":"320px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-06 01:57:23","updated_at":"2017-10-20 09:12:13","section":37,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");","section_order":5,"value":"5-4","text":"<p>DFS uses another array <b>p[u]<\/b> of size <b>V<\/b> vertices to remember the <b>parent\/predecessor\/previous<\/b> of each vertex <b>u<\/b> along the DFS traversal path.<\/p><br><p>The predecessor of the source vertex, i.e., <b>p[s]<\/b> is set to -1 to say that the source vertex has no predecessor (as the lowest vertex number is vertex 0).<\/p><br><p>The sequence of vertices from a vertex <b>u<\/b> that is reachable from the source vertex <b>s<\/b> back to <b>s<\/b> forms the <b>DFS spanning tree<\/b>. We color these <b>tree edges<\/b> with <span style=\"color: red;\">red color<\/span>.<\/p>","title":"Memorizing the Path"},{"id":287,"category":"dfsbfs","order":5,"top":"270px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-06 02:15:04","updated_at":"2017-05-07 01:59:51","section":37,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_1);","section_order":5,"value":"5-5","text":"<p>For now, ignore the extra <b>status[u] = explored<\/b> in the displayed pseudocode and the presence of <span style=\"color: lightblue;\">blue<\/span> and <span style=\"color: grey;\">grey<\/span> edges in the visualization (to be explained soon).<\/p><br><p>Without further ado, let&#39;s execute <span class=\"slide-actions\" onclick=\"doButtonAction39()\">DFS(0)<\/span> on the default example graph for this e-Lecture (CP3 Figure 4.1). <span id=\"dfsrecap\"><span class=\"slide-actions\" onclick=\"doButtonAction41()\">Recap DFS Example<\/span><\/span><\/p><br><p>The <i>basic version<\/i> of DFS presented so far is already enough for most simple cases.<\/p>","title":"Hands-on Example"},{"id":291,"category":"dfsbfs","order":6,"top":"","right":"","bottom":"320px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-07 06:53:52","updated_at":"2017-10-20 09:12:17","section":37,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");","section_order":5,"value":"5-6","text":"<p>The time complexity of DFS is O(<b>V<\/b>+<b>E<\/b>) because:<\/p><ol><li>Each vertex is only visited once due to the fact that DFS will only recursively explore a vertex <b>u<\/b> if <b>status[u] = unvisited<\/b> &mdash; O(<b>V<\/b>)<\/li><li>Every time a vertex is visited, all its <b>k<\/b> neighbors are explored and therefore after all vertices are visited, we have examined all <b>E<\/b> edges &mdash; (O(<b>E<\/b>) as the total number of neighbors of each vertex equals to <b>E<\/b>).<\/li><\/ol>","title":"O(V+E) Time Complexity"},{"id":292,"category":"dfsbfs","order":7,"top":"","right":"","bottom":"320px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-07 07:12:56","updated_at":"2017-10-20 09:12:18","section":37,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");","section_order":5,"value":"5-7","text":"<p>The O(<b>V<\/b>+<b>E<\/b>) time complexity of DFS only achievable if we can visit all <b>k<\/b> neighboring vertices of a vertex in O(<b>k<\/b>) time.<\/p><br><input class=\"mcq-answer\" id=\"mcq-answer-13\" value=\"57\" hidden><p>Quiz: <b>Which underlying graph data structure support that operation?<\/b><\/p><form><input type=\"radio\" name=\"mcq-13-choice\" value=\"58\"> Edge List<br><input type=\"radio\" name=\"mcq-13-choice\" value=\"57\"> Adjacency List<br><input type=\"radio\" name=\"mcq-13-choice\" value=\"56\"> Adjacency Matrix<br><\/form><button class=\"mcq-submit\" id=\"submit-13\">Submit<\/button> <span id=\"answer-status-13\"><\/span><br><br><p>Discussion: Why?<\/p>","title":"O(V+E) at all times?"},{"id":427,"category":"dfsbfs","order":8,"top":"","right":"","bottom":"320px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-18 10:06:05","updated_at":"2017-10-20 09:16:35","section":37,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");","section_order":5,"value":"5-8","text":"<p>Please review the time complexity of enumerating edges using various <a href=\".\/graphds?slide=8-5\"><u>graph data structures<\/u><\/a>.<\/p>","title":"The Answer"},{"id":38,"category":"dfsbfs","order":6,"top":"","right":"","bottom":"320px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 13:55:27","updated_at":"2017-10-20 09:16:46","section":-1,"code":"$(\"#bfs\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"6","text":"<p>Another basic graph traversal algorithm is the O(<b>V<\/b>+<b>E<\/b>) Breadth-First Search (BFS).<\/p><br><p>As with DFS, BFS also takes one input parameter: The source vertex <b>s<\/b>.<\/p><br><p>Both DFS and BFS have their own strengths and weaknesses. It is important to learn both and apply the correct graph traversal algorithm for the correct situation.<\/p>","title":"BFS"},{"id":293,"category":"dfsbfs","order":1,"top":"","right":"","bottom":"320px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-07 12:34:47","updated_at":"2017-10-20 09:17:47","section":38,"code":"$(\"#bfs\").click().addClass(\"menu-highlighted\");","section_order":6,"value":"6-1","text":"<p><img src=\"\/img\/ripple.jpg\" width=\"100\" height=\"100\" style=\"float: right;\" alt=\"ripple\">Imagine a still body of water and then you throw a stone into it. The first location where the stone hits the water surface is the position of the source vertex and the subsequent <b>ripple effect<\/b> across the water surface is like the BFS traversal pattern.<\/p>","title":"Analogy"},{"id":294,"category":"dfsbfs","order":2,"top":"","right":"","bottom":"320px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-07 12:36:07","updated_at":"2017-10-20 09:17:50","section":38,"code":"$(\"#bfs\").click().addClass(\"menu-highlighted\");","section_order":6,"value":"6-2","text":"<p>BFS is very similar with DFS that have been discussed earlier, but with some differences.<\/p><br><p>BFS starts from a source vertex <b>s<\/b> but it uses a <a href=\".\/list?mode=Queue\"><u>queue<\/u><\/a> to order the visitation sequence <i>as breadth as possible before going deeper<\/i>.<\/p><br><p>BFS also uses a Boolean array of size <b>V<\/b> vertices to distinguish between two states: visited and unvisited vertices (we will not use BFS to detect back edge(s) as with DFS).<\/p><br><p>In this visualization, we also show that starting from the same source vertex <b>s<\/b> in an <b>unweighted graph<\/b>, BFS spanning tree of the graph equals to its <a href=\".\/sssp\"><u>SSSP spanning tree<\/u><\/a>.<\/p>","title":"Try All, Avoid Cycle, Memorize Path"},{"id":295,"category":"dfsbfs","order":3,"top":"140px","right":"60px","bottom":"","left":"","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-07 12:39:47","updated_at":"2023-10-19 08:45:47","section":38,"code":"$(\"#bfs\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_3);","section_order":6,"value":"6-3","text":"<p>Without further ado, let&#39;s execute <span class=\"slide-actions\" onclick=\"doButtonAction40()\">BFS(5)<\/span> on the default example graph for this e-Lecture (CP3 Figure 4.3). <span id=\"bfsrecap\"><span class=\"slide-actions\" onclick=\"doButtonAction42()\">Recap BFS Example<\/span><\/span>.<\/p><br><p>Notice the <i>Breadth-first<\/i>&nbsp;exploration due to the usage of FIFO data structure: Queue?<\/p>","title":"Hands-on Example"},{"id":296,"category":"dfsbfs","order":4,"top":"","right":"","bottom":"320px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-07 12:53:23","updated_at":"2017-10-20 09:17:54","section":38,"code":"$(\"#bfs\").click().addClass(\"menu-highlighted\");","section_order":6,"value":"6-4","text":"<p>The time complexity of BFS is O(<b>V<\/b>+<b>E<\/b>) because:<\/p><ol><li>Each vertex is only visited once as it can only enter the queue once \u2014 O(<b>V<\/b>)<\/li><li>Every time a vertex is dequeued from the queue, all its <b>k<\/b> neighbors are explored and therefore after all vertices are visited, we have examined all <b>E<\/b> edges \u2014 (O(<b>E<\/b>) as the total number of neighbors of each vertex equals to <b>E<\/b>).<\/li><\/ol><p>As with DFS, this O(<b>V<\/b>+<b>E<\/b>) time complexity is only possible if we use <a href=\".\/graphds\"><u>Adjacency List<\/u><\/a> graph data structure \u2014 same reason as with DFS analysis.<\/p>","title":"O(V+E) Time Complexity"},{"id":302,"category":"dfsbfs","order":7,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-08 02:13:59","updated_at":"2023-10-19 08:46:18","section":-1,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");\n$(\"#bfs\").addClass(\"menu-highlighted\");","section_order":-1,"value":"7","text":"<p>So far, we can use DFS\/BFS to solve a few graph traversal problem variants:<\/p><ol><li>Reachability test,<\/li><li>Actually printing the traversal path,<\/li><li>Identifying\/Counting\/Labeling Connected Components (CCs) of undirected graphs,<\/li><li>Detecting if a graph is cyclic,<\/li><li>Topological Sort (only on DAGs),<\/li><\/ol><p>For most data structures and algorithms courses, the applications of DFS\/BFS are up to these few basic ones only, although DFS\/BFS can do much more...<\/p>","title":"Simple DFS\/BFS Applications"},{"id":304,"category":"dfsbfs","order":1,"top":"270px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-08 02:33:24","updated_at":"2021-11-12 10:53:17","section":302,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");\n$(\"#bfs\").addClass(\"menu-highlighted\");\nexample(CP3_4_1);","section_order":7,"value":"7-1","text":"<p>If you are asked to test whether a vertex <b>s<\/b> and a (different) vertex <b>t<\/b> in a graph are reachable, i.e., connected directly (via a direct edge) or indirectly (via a simple, non cyclic, path), you can call the O(<b>V<\/b>+<b>E<\/b>) <samp>DFS(s)<\/samp> (or <samp>BFS(s)<\/samp>) and check if <samp>status[t] = visited<\/samp>.<\/p><br><p>Example 1: <b>s = 0<\/b> and <b>t = 4<\/b>, run <span class=\"slide-actions\" onclick=\"doButtonAction39()\">DFS(0)<\/span> and notice that <samp>status[4] = visited<\/samp>.<br>Example 2: <b>s = 0<\/b> and <b>t = 7<\/b>, run <span class=\"slide-actions\" onclick=\"doButtonAction39()\">DFS(0)<\/span> and notice that <samp>status[7] = unvisited<\/samp>.<\/p>","title":"Reachability Test"},{"id":303,"category":"dfsbfs","order":2,"top":"270px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-08 02:21:21","updated_at":"2021-11-12 10:53:37","section":302,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");\n$(\"#bfs\").addClass(\"menu-highlighted\");\nexample(CP3_4_1);","section_order":7,"value":"7-2","text":"<p><a href=\"dfsbfs\/?slide=5-4\"><u>Remember<\/u><\/a> that we set <b>p[v] = u<\/b> every time we manage to extend DFS\/BFS traversal from vertex <b>u<\/b> to vertex <b>v<\/b> &mdash; a tree edge in the DFS\/BFS spanning tree. Thus, we can use following simple recursive function to print out the path stored in array <b>p<\/b>. Possible follow-up discussion: Can you write this in <b>iterative<\/b> form? (trivial)<\/p><pre>method backtrack(u)<br>  if (u == -1) stop<br>  backtrack(p[u]);<br>  output vertex u<br><\/pre><p>To print out the path from a source vertex <b>s<\/b> to a target vertex <b>t<\/b> in a graph, you can call O(<b>V<\/b>+<b>E<\/b>) <samp>DFS(s)<\/samp> (or <samp>BFS(s)<\/samp>) and then O(<b>V<\/b>) <samp>backtrack(t)<\/samp>. Example: <b>s = 0<\/b> and <b>t = 4<\/b>, you can call <span class=\"slide-actions\" onclick=\"doButtonAction39()\">DFS(0)<\/span> and then <samp>backtrack(4)<\/samp>. <span id=\"printexample\"><span class=\"slide-actions\" onclick=\"doButtonAction43()\">Elaborate<\/span><\/span><\/p>","title":"Print the Traversal Path"},{"id":305,"category":"dfsbfs","order":3,"top":"270px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-08 02:38:50","updated_at":"2021-11-12 10:56:06","section":302,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");\n$(\"#bfs\").addClass(\"menu-highlighted\");\nexample(CP3_4_1);","section_order":7,"value":"7-3","text":"<p>We can enumerate <b>all<\/b> vertices that are reachable from a vertex <b>s<\/b> in an <b>undirected graph<\/b> (as the example graph shown above) by simply calling O(<b>V<\/b>+<b>E<\/b>) <samp>DFS(s)<\/samp> (or <samp>BFS(s)<\/samp>) and enumerate all vertex <b>v<\/b> that has <samp>status[v] = visited<\/samp>.<\/p><br><p>Example: <b>s = 0<\/b>, run <span class=\"slide-actions\" onclick=\"doButtonAction39()\">DFS(0)<\/span> and notice that <samp>status[{0,1,2,3,4}] = visited<\/samp> so they are all reachable vertices from vertex 0, i.e., they form one <b>Connected Component (CC)<\/b>.<\/p>","title":"Identifying a Connected Component (CC)"},{"id":306,"category":"dfsbfs","order":4,"top":"270px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-08 02:43:48","updated_at":"2021-11-12 10:56:06","section":302,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");\n$(\"#bfs\").addClass(\"menu-highlighted\");\nexample(CP3_4_1);","section_order":7,"value":"7-4","text":"<p>We can use the following pseudo-code to count the number of CCs:<\/p><pre>CC = 0<br>for all u in V, set status[u] = unvisited<br>for all u in V<br>  if (status[u] == unvisited)<br>    ++CC \/\/ we can use CC counter number as the CC label<br>    DFS(u) \/\/ or BFS(u), that will flag its members as visited<br>output CC \/\/ the answer is 3 for the example graph above, i.e.<br>\/\/ CC 0 = {0,1,2,3,4}, CC 1 = {5}, CC 2 = {6,7,8}<\/pre><p>You can modify the DFS(u)\/BFS(u) code a bit if you want to use it to label each CC with the identifier of that CC.<\/p>","title":"Counting the Number of\/Labeling the CCs"},{"id":307,"category":"dfsbfs","order":5,"top":"270px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-08 02:47:45","updated_at":"2021-11-12 10:56:04","section":302,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");\n$(\"#bfs\").addClass(\"menu-highlighted\");\nexample(CP3_4_1);","section_order":7,"value":"7-5","text":"<input class=\"mcq-answer\" id=\"mcq-answer-15\" value=\"67\" hidden><p>Quiz: <b>What is the time complexity of Counting the Number of CCs algorithm?<\/b><\/p><form><input type=\"radio\" name=\"mcq-15-choice\" value=\"68\"> Trick question, the answer is none of the above, it is O(_____)<br><input type=\"radio\" name=\"mcq-15-choice\" value=\"67\"> It is still O(V+E)<br><input type=\"radio\" name=\"mcq-15-choice\" value=\"66\"> Calling O(V+E) DFS\/BFS V times, so O(V*(V+E)) = O(V^2 + VE)<br><\/form><button class=\"mcq-submit\" id=\"submit-15\">Submit<\/button> <span id=\"answer-status-15\"><\/span><br><br><p>Discussion: Why?<\/p>","title":"Wait, What is the Time Complexity?"},{"id":428,"category":"dfsbfs","order":6,"top":"270px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-18 10:09:41","updated_at":"2021-11-12 10:56:04","section":302,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");\n$(\"#bfs\").addClass(\"menu-highlighted\");\nexample(CP3_4_1);","section_order":7,"value":"7-6","text":"<p>Notice that each vertex and each edge of the graph are only touched once, even if they are separated into various Connected Components. Hence, the overall time complexity remains O(<b>V<\/b>+<b>E<\/b>).<\/p>","title":"The Answer"},{"id":662,"category":"dfsbfs","order":7,"top":"270px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-10-20 09:20:44","updated_at":"2021-11-12 10:53:52","section":302,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_9);","section_order":7,"value":"7-7","text":"<p>We can actually <i>augment<\/i> the basic DFS further to give more insights about the underlying graph.<\/p><br><p>In this visualization, we use <span style=\"color: lightblue;\">blue color<\/span> to highlight <b>back<\/b> edge(s) of the DFS spanning tree. The presence of at least one back edge shows that the traversed graph (component) is <b>cyclic<\/b> while its absence shows that at least the component connected to the source vertex of the traversed graph is <b>acyclic<\/b>.<\/p>","title":"Detecting Cycle - Part 1"},{"id":663,"category":"dfsbfs","order":8,"top":"270px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-10-20 09:21:40","updated_at":"2021-11-12 10:53:51","section":302,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_9);","section_order":7,"value":"7-8","text":"<p>Back edge can be detected by modifying array <b>status[u]<\/b> to record <b>three<\/b> different states:<\/p><ol><li><b>unvisited<\/b>: same as earlier, DFS has not reach vertex <b>u<\/b> before,<\/li><li><b>explored<\/b>: DFS has visited vertex <b>u<\/b>, but at least one neighbor of vertex <b>u<\/b> has not been visited yet (DFS will go depth-first to that neighbor first),<\/li><li><b>visited<\/b>: now stronger definition: all neighbors of vertex <b>u<\/b> have also been visited and DFS is about to backtrack from vertex <b>u<\/b> to vertex <b>p[u]<\/b>.<\/li><\/ol><p>If DFS is now at vertex <b>x<\/b> and explore edge <b>x &rarr; y<\/b> and encounter <b>status[y] = explored<\/b>, we can declare <b>x &rarr; y<\/b> is a <b>back edge<\/b> (a cycle is found as we were previously at vertex <b>y<\/b> (hence <b>status[y] = explored<\/b>), go deep to neighbor of <b>y<\/b> and so on, but we are now at vertex <b>x<\/b> that is reachable from <b>y<\/b> but vertex <b>x<\/b> leads back to vertex <b>y<\/b>).<\/p>","title":"Detecting Cycle - Part 2"},{"id":664,"category":"dfsbfs","order":9,"top":"270px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-10-20 09:23:13","updated_at":"2021-11-12 10:53:51","section":302,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_9);","section_order":7,"value":"7-9","text":"<p>The edges in the graph that are not <span style=\"color: red;\">tree edge(s)<\/span> nor <span style=\"color: lightblue;\">back edge(s)<\/span> are colored <span style=\"color: grey;\">grey<\/span>. They are called <b>forward or cross edge(s)<\/b> and currently have limited use (not elaborated).<\/p><br><p>Now try <span class=\"slide-actions\" onclick=\"doButtonAction39()\">DFS(0)<\/span> on the example graph above with this new understanding, especially about the 3 possible status of a vertex (unvisited\/<span style=\"color: black; background-color: white;\">normal black circle<\/span>, explored\/<span style=\"color: lightblue;\">blue circle<\/span>, <span style=\"color: orange;\">visited\/orange circle<\/span>) and <span style=\"color: lightblue;\">back edge<\/span>. Edge 2 \u2192 1 will be discovered as a back edge as it is part of cycle 1 \u2192 3 \u2192 2 \u2192 1 (as vertex 2 is `explored&#39; to vertex 1 which is currently `explored&#39;) (similarly with Edge 6 \u2192 4 as part of cycle 4 &rightarrow; 5 &rightarrow; 7 &rightarrow; 6 &rightarrow; 4).<\/p><br><p>Note that if edges 2 \u2192 1 and 6 \u2192 4 are reversed to 1 \u2192 2 and 4 \u2192 6, then the graph is correctly classified as acyclic as edge 3 \u2192 2 and 4 \u2192 6 go from `explored&#39; to `fully visited&#39;. If we only use binary states: `unvisited&#39; vs `visited&#39;, we cannot distinguish these two cases.<\/p>","title":"Hands-on Example (Detailed)"},{"id":310,"category":"dfsbfs","order":10,"top":"270px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-08 03:02:16","updated_at":"2017-10-20 09:23:18","section":302,"code":"$(\"#topo\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_4);","section_order":7,"value":"7-10","text":"<p>There is another DFS (and also BFS) application that can be treated as &#39;simple&#39;: Performing Topological Sort(ing) of a Directed Acyclic Graph (DAG) &mdash; see example above.<\/p><br><p>Topological sort of a DAG is a linear ordering of the DAG&#39;s vertices in which each vertex comes before all vertices to which it has outbound edges.<\/p><br><p>Every DAG (can be checked with <a href=\"dfsbfs\/?slide=7-7\"><u>DFS earlier<\/u><\/a>) has at least one but possibly more topological sorts\/ordering.<\/p><br><p>One of the main purpose of (at least one) topological sort of a DAG is for <a href=\".\/recursion\"><u>Dynamic Programming (DP)<\/u><\/a> technique. For example, this topological sorting process is used internally in <a href=\".\/sssp\"><u>DP solution for SSSP on DAG<\/u><\/a>.<\/p>","title":"Topological Sort - Definition"},{"id":309,"category":"dfsbfs","order":11,"top":"270px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-08 03:00:52","updated_at":"2017-10-20 09:23:17","section":302,"code":"$(\"#topo\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_4);","section_order":7,"value":"7-11","text":"<p>We can use either the O(<b>V<\/b>+<b>E<\/b>) DFS or BFS to perform Topological Sort of a Directed Acyclic Graph (DAG).<\/p><br><p>The DFS version requires just one additional line compared to the normal DFS and is basically the post-order traversal of the graph. Try <span class=\"slide-actions\" onclick=\"doButtonAction44()\">Toposort (DFS)<\/span> on the example DAG.<\/p><br><p>The BFS version is based on the idea of vertices without incoming edge and is also called as Kahn&#39;s algorithm. Try <span class=\"slide-actions\" onclick=\"doButtonAction45()\">Toposort (BFS\/Kahn's)<\/span> on the example DAG.<\/p>","title":"Topological Sort"},{"id":308,"category":"dfsbfs","order":8,"top":"","right":"","bottom":"320px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-08 02:56:27","updated_at":"2017-10-20 09:29:06","section":-1,"code":"$(\"#bipartite\").click().addClass(\"menu-highlighted\");\n$(\"#bridge\").addClass(\"menu-highlighted\");\n$(\"#scc\").addClass(\"menu-highlighted\");\n$(\"#twosat\").addClass(\"menu-highlighted\");","section_order":-1,"value":"8","text":"<p>As of now, you have seen DFS\/BFS and what it can solve (with just minor tweaks). There are a few more advanced applications that require more tweaks and we will let advanced students to explore them on their own:<\/p><ol><li>Bipartite Graph Checker (DFS and BFS variants),<\/li><li>Finding Articulation Points (Cut Vertices) and Bridges of an Undirected Graph (DFS only),<\/li><li>Finding Strongly Connected Components (SCCs) of a Directed Graph (Tarjan&#39;s and Kosaraju&#39;s algorithms), and<\/li><li>2-SAT(isfiability) Checker algorithms.<\/li><\/ol><hr><p>Advertisement: The details are written in <a href=\"https:\/\/cpbook.net\" target=\"_blank\"><u>Competitive Programming book<\/u><\/a>.<\/p>","title":"More Advanced DFS\/BFS Applications"},{"id":40,"category":"dfsbfs","order":9,"top":"300px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 13:56:18","updated_at":"2017-05-08 03:37:55","section":-1,"code":"$(\"#bipartite\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_18);","section_order":-1,"value":"9","text":"<p>We can use the O(<b>V<\/b>+<b>E<\/b>) DFS or BFS (they work similarly) to check if a given graph is a Bipartite Graph by giving alternating color (<span style=\"color: orange;\">orange<\/span> versus <span style=\"color: lightblue;\">blue<\/span> in this visualization) between neighboring vertices and report &#39;non bipartite&#39; if we ends up assigning same color to two adjacent vertices or &#39;bipartite&#39; if it is possible to do such &#39;2-coloring&#39; process. Try <span class=\"slide-actions\" onclick=\"doButtonAction46()\">DFS_Checker<\/span> or <span class=\"slide-actions\" onclick=\"doButtonAction47()\">BFS_Checker<\/span> on the example Bipartite Graph.<\/p><br><p>Bipartite Graphs have useful applications in <a href=\".\/matching\"><u>(Bipartite) Graph Matching problem<\/u><\/a>.<\/p><br><p>Note that Bipartite Graphs are usually only defined for undirected graphs so this visualization will convert directed input graphs into its undirected version automatically before continuing. This action is irreversible and you may have to redraw the directed input graph again for other purposes.<\/p>","title":"Bipartite Graph Checker"},{"id":41,"category":"dfsbfs","order":10,"top":"270px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 13:56:49","updated_at":"2017-05-08 03:36:40","section":-1,"code":"$(\"#bridge\").addClass(\"menu-highlighted\");\nexample(CP3_4_9);","section_order":-1,"value":"10","text":"<p>We can modify (but unfortunately, not trivially) the O(<b>V<\/b>+<b>E<\/b>) DFS algorithm into an algorithm to find Cut Vertices &amp; Bridges of an Undirected Graph.<\/p><br><p>A Cut Vertex, or an Articulation Point, is a vertex of an undirected graph which removal disconnects the graph. Similarly, a bridge is an edge of an undirected graph which removal disconnects the graph.<\/p><br><p>Note that this algorithm for finding Cut Vertices &amp; Bridges only works for undirected graphs so this visualization will convert directed input graphs into its undirected version automatically before continuing. This action is irreversible and you may have to redraw the directed input graph again for other purposes. You can try to <span class=\"slide-actions\" onclick=\"doButtonAction48()\">Find Cut Vertices &amp; Bridges<\/span> on the example graph above.<\/p>","title":"Find Cut Vertices & Bridges"},{"id":42,"category":"dfsbfs","order":11,"top":"270px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 13:57:16","updated_at":"2017-05-08 03:36:21","section":-1,"code":"$(\"#scc\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_9);","section_order":-1,"value":"11","text":"<p>We can modify (but unfortunately, not trivially) the O(<b>V<\/b>+<b>E<\/b>) DFS algorithm into an algorithm to find Strongly Connected Components (SCCs) of a Directed Graph G.<\/p><br><p>An SCC of a directed graph G a is defined as a subgraph S of G such that for any two vertices u and v in S, vertex u can reach vertex v directly or via a path, and vertex v can also reach vertex u back directly or via a path.<\/p><br><p>There are two known algorithms for finding SCCs of a Directed Graph: Kosaraju&#39;s and Tarjan&#39;s. Both of them are available in this visualization. Try <span class=\"slide-actions\" onclick=\"doButtonAction49()\">Kosaraju's Algorithm<\/span> and\/or <span class=\"slide-actions\" onclick=\"doButtonAction50()\">Tarjan's Algorithm<\/span> on the example directed graph above.<\/p>","title":"Find Strongly Connected Components"},{"id":43,"category":"dfsbfs","order":12,"top":"","right":"","bottom":"320px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 13:57:48","updated_at":"2017-10-20 09:29:13","section":-1,"code":"$(\"#twosat\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"12","text":"<p>We also have the 2-SAT Checker algorithm. Given a 2-Satisfiability (2-SAT) instance in the form of conjuction of clauses: (clause<sub>1<\/sub>) ^ (clause<sub>2<\/sub>) ^ ... ^ (clause<sub>n<\/sub>) and each clause is in form of disjunction of up to two variables (var<sub>a<\/sub> v var<sub>b<\/sub>), determine if we can assign True\/False values to these variables so that the entire 2-SAT instance is evaluated to be true, i.e. satisfiable.<\/p><br><p>It turns out that each clause (a v b) can be turned into four vertices a, not a, b, and not b with two edges: (not a &rarr; b) and (not b &rarr; a). Thus we have a Directed Graph. If there is at least one variable and its negation inside an SCC of such graph, we know that it is impossible to satisfy the 2-SAT instance.<\/p><br><p>After such directed graph modeling, we can run an SCC finding algorithm (Kosaraju&#39;s or Tarjan&#39;s algorithm) to determine the satisfiability of the 2-SAT instance.<\/p>","title":"2-SAT Checker Algorithm"},{"id":429,"category":"dfsbfs","order":13,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-18 13:00:33","updated_at":"2023-10-19 08:47:04","section":-1,"code":"","section_order":-1,"value":"13","text":"<input class=\"mcq-answer\" id=\"mcq-answer-22\" value=\"95\" hidden><p>Quiz: <b>Which Graph Traversal Algorithm is Better?<\/b><\/p><form><input type=\"radio\" name=\"mcq-22-choice\" value=\"95\"> It Depends on the Situation<br><input type=\"radio\" name=\"mcq-22-choice\" value=\"96\"> Both are Equally Good<br><input type=\"radio\" name=\"mcq-22-choice\" value=\"93\"> Always DFS<br><input type=\"radio\" name=\"mcq-22-choice\" value=\"94\"> Always BFS<br><\/form><button class=\"mcq-submit\" id=\"submit-22\">Submit<\/button> <span id=\"answer-status-22\"><\/span><br><br><p>Discussion: Why?<\/p>","title":"Which One is Better?"},{"id":430,"category":"dfsbfs","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-18 13:01:23","updated_at":"2023-10-19 08:47:06","section":429,"code":"","section_order":13,"value":"13-1","text":"<p>DFS is easier to implement especially for people who like to think recursively. DFS uses less memory compared to BFS. Although DFS\/BFS can usually be interchanged, there are a few graph properties that can only be detected via DFS, e.g. finding cut vertex\/bridge, finding SCCs, etc.<\/p><br><p>BFS has an alternative usage for solving <a href=\".\/sssp\"><u>Shortest Paths<\/u><\/a> problem on unweighted graph. However, BFS generally uses more memory than DFS as it has to hold (possibly long) active vertices in BFS queue.<\/p>","title":"The Answer"},{"id":311,"category":"dfsbfs","order":14,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-08 03:38:47","updated_at":"2023-10-19 08:47:09","section":-1,"code":"","section_order":-1,"value":"14","text":"<p>There are lots of things that we can still do with just DFS and\/or BFS...<br><\/p>","title":"Extras"},{"id":312,"category":"dfsbfs","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-08 03:39:11","updated_at":"2023-10-19 08:47:11","section":311,"code":"","section_order":14,"value":"14-1","text":"<p>There are interesting questions about these two graph traversal algorithms: DFS+BFS and variants of graph traversal problems, please practice on <a href=\"https:\/\/visualgo.net\/training?diff=Medium&amp;n=7&amp;tl=0&amp;module=dfsbfs\"><u>Graph Traversal<\/u><\/a> training module (no login is required, but short and of medium difficulty setting only).<\/p><br><p>However, for registered users, you should login and then go to the <a href=\"https:\/\/visualgo.net\/training\"><u>Main Training Page<\/u><\/a> to officially clear this module and such achievement will be recorded in your user account.<\/p>","title":"Online Quiz"},{"id":313,"category":"dfsbfs","order":2,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-08 03:40:09","updated_at":"2023-10-19 08:47:14","section":311,"code":"","section_order":14,"value":"14-2","text":"<p>We also have a few programming problems that somewhat requires the usage of DFS and\/or BFS: <a href=\"https:\/\/open.kattis.com\/problems\/reachableroads\" title=\"\" target=\"_blank\"><u>Kattis - reachableroads<\/u><\/a> and <a href=\"https:\/\/open.kattis.com\/problems\/breakingbad\" title=\"\" target=\"_blank\"><u>Kattis - breakingbad<\/u><\/a>.<\/p><br><p>Try to solve them and then try the <b>many more<\/b> interesting twists\/variants of this simple graph traversal problem and\/or algorithm.<\/p><br><p>You are allowed to use\/modify our implementation code for DFS\/BFS Algorithms:<br><a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/traversal\/dfs_cc.cpp\" target=\"_blank\"><u>dfs_cc.cpp<\/u><\/a>\/<a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/sssp\/bfs.cpp\" target=\"_blank\"><u>bfs.cpp<\/u><\/a><br><a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/traversal\/dfs_cc.java\" target=\"_blank\"><u>dfs_cc.java<\/u><\/a>\/<a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/sssp\/bfs.java\" target=\"_blank\"><u>bfs.java<\/u><\/a><br><a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/traversal\/dfs_cc.py\" target=\"_blank\"><u>dfs_cc.py<\/u><\/a>\/<a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/sssp\/bfs.py\" target=\"_blank\"><u>bfs.py<\/u><\/a><br><a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/traversal\/dfs_cc.ml\" target=\"_blank\"><u>dfs_cc.ml<\/u><\/a>\/<a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/sssp\/bfs.ml\" target=\"_blank\"><u>bfs.ml<\/u><\/a><br><\/p>","title":"Online Judge Exercises"},{"id":314,"category":"dfsbfs","order":3,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-08 03:44:00","updated_at":"2023-10-19 08:47:16","section":311,"code":"","section_order":14,"value":"14-3","text":"<p>For <a href=\"https:\/\/uva.onlinejudge.org\/external\/110\/11094.pdf\" title=\"\" target=\"_blank\"><u>UVa 11094 - Continents<\/u><\/a>, notice that you can do minor tweak to DFS (or BFS) to deal with the scrolling requirement and <b>reduce<\/b> the problem to just a simple flood fill (finding connected components) problem again.<\/p><br><p>For <a href=\"https:\/\/open.kattis.com\/problems\/breakingbad\" title=\"\" target=\"_blank\"><u>Kattis - breakingbad<\/u><\/a>, think about bipartite...<\/p>","title":"Discussion"}];
      const numSlides = lectureIds.length;
      var sectorJunction12Section = 0, sectorJunction12Slide = 0;
      var sectorJunction23Section = 0, sectorJunction23Slide = 0;
      var sector1Count = 0, sector2Count = 0, sector3Count = 0;
      const sectorLength = Math.floor(numSlides / 3);
      function createELectureTimelineDisplay() {
        for (let j = 0; j < numSlides; ++j) {
          const currLecture = lectureIds[j].value;
          if (currLecture.includes('-')) {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-slide" slideNo=${lectureIds[j].value}></div>`)
            );
          } else {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-checkpoint" slideNo=${lectureIds[j].value}></div>`)
            );
          }
        }
      }

      function setSectorJunctionInfo() {
          //setting the sector junction slide numbers
          const j12 = sectorLength !== 0 ? (sectorLength - 1): 0;
          const j23 = sectorLength !== 0 ? (2 * sectorLength - 1) : 0;

          const sectorJunction12 = lectureIds[j12].value.split('-');
          sectorJunction12Section = parseInt(sectorJunction12[0]);
          sectorJunction12Slide = sectorJunction12.length > 1 ? parseInt(sectorJunction12[1]) : sectorJunction12Slide;

          const sectorJunction23 = lectureIds[j23].value.split('-');
          sectorJunction23Section = parseInt(sectorJunction23[0]);
          sectorJunction23Slide = sectorJunction23.length > 1 ? parseInt(sectorJunction23[1]) : sectorJunction23Slide;
      }

      function runSlide(slide) { // Steven's patch on 28 Jan 2022: Properly remove slide 99, 99-1, 99-2, 99-3, integrate with the earlier slides
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 2 + "%)");
          
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 4 + "%)");
          example(CP3_4_1);
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 6 + "%)");
          $("#draw").addClass("menu-highlighted");
$("#random").addClass("menu-highlighted");
$("#examples").click().addClass("menu-highlighted");
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 8 + "%)");
          loadGraph({
  'vl': {
    0: { "x": 100, "y": 50  },
    1: { "x":  50, "y": 150 },
    2: { "x": 150, "y": 150 },
    3: { "x": 125, "y": 250 },
    4: { "x": 175, "y": 250 },
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 1 },
    2: { "u": 2, "v": 3, "w": 1 },
    3: { "u": 2, "v": 4, "w": 1 },
  }
});
        }
        if (slide == '4-1') {
          $("#e-lecture").html("slide " + slide + " (" + 10 + "%)");
          loadGraph({
  'vl': {
    0: { "x": 100, "y": 150 },
    1: { "x":  50, "y": 50  },
    2: { "x": 150, "y": 50  },
    3: { "x": 175, "y": 150 },
    4: { "x": 225, "y": 150 },
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 1 },
    2: { "u": 2, "v": 3, "w": 1 },
    3: { "u": 2, "v": 4, "w": 1 },
    4: { "u": 1, "v": 0, "w": 1 },
    5: { "u": 2, "v": 0, "w": 1 },
    6: { "u": 3, "v": 2, "w": 1 },
    7: { "u": 4, "v": 2, "w": 1 },
  }
});
        }
        if (slide == '4-2') {
          $("#e-lecture").html("slide " + slide + " (" + 13 + "%)");
          loadGraph({
  'vl': {
    0: { "x": 100, "y": 50  },
    1: { "x":  50, "y": 150 },
    2: { "x": 150, "y": 150 },
    3: { "x": 125, "y": 250 },
    4: { "x": 175, "y": 250 },
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 1 },
    2: { "u": 2, "v": 3, "w": 1 },
    3: { "u": 2, "v": 4, "w": 1 },
  }
});
        }
        if (slide == '4-3') {
          $("#e-lecture").html("slide " + slide + " (" + 15 + "%)");
          loadGraph({
  'vl': {
    0: { "x": 100, "y": 50  },
    1: { "x":  50, "y": 150 },
    2: { "x": 150, "y": 150 },
    3: { "x": 125, "y": 250 },
    4: { "x": 175, "y": 250 },
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 1 },
    2: { "u": 2, "v": 3, "w": 1 },
    3: { "u": 2, "v": 4, "w": 1 },
  }
});
        }
        if (slide == '4-4') {
          $("#e-lecture").html("slide " + slide + " (" + 17 + "%)");
          loadGraph({
  'vl': {
    0: { "x": 100, "y": 50  },
    1: { "x":  50, "y": 150 },
    2: { "x": 150, "y": 150 },
    3: { "x": 125, "y": 250 },
    4: { "x": 175, "y": 250 },
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 1 },
    2: { "u": 2, "v": 3, "w": 1 },
    3: { "u": 2, "v": 4, "w": 1 },
  }
});
        }
        if (slide == '4-5') {
          $("#e-lecture").html("slide " + slide + " (" + 19 + "%)");
          
        }
        if (slide == '5') {
          $("#e-lecture").html("slide " + slide + " (" + 21 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
example(CP3_4_1);
        }
        if (slide == '5-1') {
          $("#e-lecture").html("slide " + slide + " (" + 23 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
        }
        if (slide == '5-2') {
          $("#e-lecture").html("slide " + slide + " (" + 26 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
        }
        if (slide == '5-3') {
          $("#e-lecture").html("slide " + slide + " (" + 28 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
        }
        if (slide == '5-4') {
          $("#e-lecture").html("slide " + slide + " (" + 30 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
        }
        if (slide == '5-5') {
          $("#e-lecture").html("slide " + slide + " (" + 32 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
example(CP3_4_1);
        }
        if (slide == '5-6') {
          $("#e-lecture").html("slide " + slide + " (" + 34 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
        }
        if (slide == '5-7') {
          $("#e-lecture").html("slide " + slide + " (" + 36 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
        }
        if (slide == '5-8') {
          $("#e-lecture").html("slide " + slide + " (" + 39 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
        }
        if (slide == '6') {
          $("#e-lecture").html("slide " + slide + " (" + 41 + "%)");
          $("#bfs").click().addClass("menu-highlighted");
        }
        if (slide == '6-1') {
          $("#e-lecture").html("slide " + slide + " (" + 43 + "%)");
          $("#bfs").click().addClass("menu-highlighted");
        }
        if (slide == '6-2') {
          $("#e-lecture").html("slide " + slide + " (" + 45 + "%)");
          $("#bfs").click().addClass("menu-highlighted");
        }
        if (slide == '6-3') {
          $("#e-lecture").html("slide " + slide + " (" + 47 + "%)");
          $("#bfs").click().addClass("menu-highlighted");
example(CP3_4_3);
        }
        if (slide == '6-4') {
          $("#e-lecture").html("slide " + slide + " (" + 50 + "%)");
          $("#bfs").click().addClass("menu-highlighted");
        }
        if (slide == '7') {
          $("#e-lecture").html("slide " + slide + " (" + 52 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
$("#bfs").addClass("menu-highlighted");
        }
        if (slide == '7-1') {
          $("#e-lecture").html("slide " + slide + " (" + 54 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
$("#bfs").addClass("menu-highlighted");
example(CP3_4_1);
        }
        if (slide == '7-2') {
          $("#e-lecture").html("slide " + slide + " (" + 56 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
$("#bfs").addClass("menu-highlighted");
example(CP3_4_1);
        }
        if (slide == '7-3') {
          $("#e-lecture").html("slide " + slide + " (" + 58 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
$("#bfs").addClass("menu-highlighted");
example(CP3_4_1);
        }
        if (slide == '7-4') {
          $("#e-lecture").html("slide " + slide + " (" + 60 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
$("#bfs").addClass("menu-highlighted");
example(CP3_4_1);
        }
        if (slide == '7-5') {
          $("#e-lecture").html("slide " + slide + " (" + 63 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
$("#bfs").addClass("menu-highlighted");
example(CP3_4_1);
        }
        if (slide == '7-6') {
          $("#e-lecture").html("slide " + slide + " (" + 65 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
$("#bfs").addClass("menu-highlighted");
example(CP3_4_1);
        }
        if (slide == '7-7') {
          $("#e-lecture").html("slide " + slide + " (" + 67 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
example(CP3_4_9);
        }
        if (slide == '7-8') {
          $("#e-lecture").html("slide " + slide + " (" + 69 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
example(CP3_4_9);
        }
        if (slide == '7-9') {
          $("#e-lecture").html("slide " + slide + " (" + 71 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
example(CP3_4_9);
        }
        if (slide == '7-10') {
          $("#e-lecture").html("slide " + slide + " (" + 73 + "%)");
          $("#topo").click().addClass("menu-highlighted");
example(CP3_4_4);
        }
        if (slide == '7-11') {
          $("#e-lecture").html("slide " + slide + " (" + 76 + "%)");
          $("#topo").click().addClass("menu-highlighted");
example(CP3_4_4);
        }
        if (slide == '8') {
          $("#e-lecture").html("slide " + slide + " (" + 78 + "%)");
          $("#bipartite").click().addClass("menu-highlighted");
$("#bridge").addClass("menu-highlighted");
$("#scc").addClass("menu-highlighted");
$("#twosat").addClass("menu-highlighted");
        }
        if (slide == '9') {
          $("#e-lecture").html("slide " + slide + " (" + 80 + "%)");
          $("#bipartite").click().addClass("menu-highlighted");
example(CP3_4_18);
        }
        if (slide == '10') {
          $("#e-lecture").html("slide " + slide + " (" + 82 + "%)");
          $("#bridge").addClass("menu-highlighted");
example(CP3_4_9);
        }
        if (slide == '11') {
          $("#e-lecture").html("slide " + slide + " (" + 84 + "%)");
          $("#scc").click().addClass("menu-highlighted");
example(CP3_4_9);
        }
        if (slide == '12') {
          $("#e-lecture").html("slide " + slide + " (" + 86 + "%)");
          $("#twosat").click().addClass("menu-highlighted");
        }
        if (slide == '13') {
          $("#e-lecture").html("slide " + slide + " (" + 89 + "%)");
          
        }
        if (slide == '13-1') {
          $("#e-lecture").html("slide " + slide + " (" + 91 + "%)");
          
        }
        if (slide == '14') {
          $("#e-lecture").html("slide " + slide + " (" + 93 + "%)");
          
        }
        if (slide == '14-1') {
          $("#e-lecture").html("slide " + slide + " (" + 95 + "%)");
          
        }
        if (slide == '14-2') {
          $("#e-lecture").html("slide " + slide + " (" + 97 + "%)");
          
        }
        if (slide == '14-3') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
        }
        clearTimeout(currSlideTimer);
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };
      var slideTimeline = {};

      //reads all visited slides in the slideTimeline and gives them their sector color
      function setVisitedSlideTimelineColors() {
        for(const [sectionNo, visitedSlides] of Object.entries(slideTimeline)) {
          const visitedSlides = slideTimeline[sectionNo];
          for(const visitedSlideNo of visitedSlides) {
            setSlideTimelineColor(visitedSlideNo);
          }
        }
      }

      //only called on load if there is nothing in session
      function setTimelineForCompletedSector(sectorNum) {
        let len = sectorLength;
        switch (sectorNum) {
          case 1 : len = sectorLength; break;
          case 2 : len = 2 * sectorLength; break;
          default: len = numSlides;
        }
        let i = 0;
        switch (sectorNum) {
          case 1 : i = 0; break;
          case 2 : i = sectorLength; break;
          default: i = 2 * sectorLength;
        }
        for (; i < len; i++) {
          saveELectureTimeline(lectureIds[i].value, true);
        }
      }

      function getUserSectorHistory(callback) {
        $.ajax({
          type: 'GET',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            topic: "/dfsbfs".substring(1)
          }
        }
        ).done(function (data) {
            if (data.data[0] === 1) {
              setF1SectorColor(1);
              setTimelineForCompletedSector(1);
            }
            if (data.data[1] === 1) {
              setF1SectorColor(2);
              setTimelineForCompletedSector(2);
            }
            if (data.data[2] === 1) {
              setF1SectorColor(3);
              setTimelineForCompletedSector(3);
            }
            callback();
        }).fail(function (data) {
            console.log('get user sector history failed!');
        });
      }

      function getELectureTimelineFromSession() {
        const page = "/dfsbfs".substring(1);
        const timelineKey = page + '-slide-timeline';
        const storedTimeline = window.sessionStorage.getItem(timelineKey);
        if (storedTimeline) {
          slideTimeline = JSON.parse(storedTimeline);
        } else {
          return false;
        }
        let slideInfo = [];
        for (const [sectionNum, slides] of Object.entries(slideTimeline)) {
          for (const slide of slides) {
            indicateSlideCompletedUI(slide);
            slideInfo = slide.split('-');
            incrementSectorVisits(parseInt(sectionNum), slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0);
          }
        }
        return true;
      }

      async function initializeELectureTimeline() {
        setSectorJunctionInfo();
        if (!getELectureTimelineFromSession())
          getUserSectorHistory(sectorBasedModeSelection);
        else
          sectorBasedModeSelection();

        createELectureTimelineDisplay();
        setVisitedSlideTimelineColors();
      }

      function setF1SectorColor(sectorNum) {
        $(`[sectorNo="${sectorNum}"]`).css('background', sectorColors[(parseInt(sectorNum) % 3)]);
      }

      function updateSectorInDB(sectorNum) {
        $.ajax({
          type: 'POST',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            section: (sectorNum - 1),
            topic: "/dfsbfs".substring(1)
          }
        }
        ).done(function (data) {
            //console.log("Saved the sector " + sectorNum + " as done " + JSON.stringify(data));
        }).fail(function (data) {
            console.log("Setting sector done failed new attempt! "+ JSON.stringify(data));
        });
      }

      //If 87.5% or more of the slides in sector are done
      function setF1SectorCompleted(sectorNum, isInitializationCall) {
        setF1SectorColor(sectorNum);
        //avoid api call on initialization
        if (!isInitializationCall) {
          updateSectorInDB(sectorNum);
          $(`[sectorNo="${sectorNum}"]`).css("animation", "green-pulse 2s 4");
          setTimeout(() => {
            $(`[sectorNo="${sectorNum}"]`).css("animation", "");
          }, 8000);
        }
      }

      function incrementSectorVisits(sectionNum, slideNumWithinSection, isInitializationCall) {
        //updating sector count
        if (sectionNum < sectorJunction12Section
          || (sectionNum === sectorJunction12Section && slideNumWithinSection <= sectorJunction12Slide)) {
          ++sector1Count;
          if (sector1Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(1, isInitializationCall);
        } else if (sectionNum < sectorJunction23Section
          || (sectionNum === sectorJunction23Section && slideNumWithinSection <= sectorJunction23Slide)) {
          ++sector2Count;
          if (sector2Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(2, isInitializationCall);
        } else {
          ++sector3Count;
          if (sector3Count >= Math.ceil(0.875 * (numSlides - 2 * sectorLength)))
            setF1SectorCompleted(3, isInitializationCall);
        }
      }

      function saveELectureTimeline(slideNo, isInitialization) {
        const slideInfo = slideNo.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        if (slideTimeline[sectionNo]) {
          if (!slideTimeline[sectionNo].includes(slideNo)) {
            slideTimeline[sectionNo].push(slideNo);
            const sectionNum = parseInt(sectionNo);
            incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
          }
        } else {
          slideTimeline[sectionNo] = [];
          slideTimeline[sectionNo].push(slideNo);
          const sectionNum = parseInt(sectionNo);
          incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
        }
        setSlideTimelineColor(slideNo);
        indicateSlideCompletedUI(slideNo);
      }

      function saveELectureTimelineToSession() {
        const page = "/dfsbfs".substring(1);
        const timelineKey = page + '-slide-timeline';
        window.sessionStorage.setItem(timelineKey, JSON.stringify(slideTimeline));
      }

      function handleTimelineOnRunSlide(slideValue) {
        const slideInfo = slideValue.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        //start timer only if the slide isnt already done
        if (!slideTimeline[sectionNo] || !slideTimeline[sectionNo].includes(slideValue)) {
          const slideTextLength = $('#electure-'+slideValue + " p").text().length + $('#electure-'+slideValue + " li").text().length;
          const CHARS_READ_PER_MS = 0.05; //when fast, 50 characters a second
          //setting max reading time as 10 seconds for around 500 character slide
          const minSlideReadingTime = Math.min(Math.max(2000, (slideTextLength / CHARS_READ_PER_MS) +  + (2000 * $('#electure-'+slideValue + " img").length)), 10000);
          currSlideTimer = setTimeout(() => {
            saveELectureTimeline(slideValue);
          }, minSlideReadingTime);
        }
      }

      function indicateSlideCompletedUI(slide) {
        $('#electure-'+slide).css("box-shadow", "3px 3px 8px green"); //set green shadow for completed slides
        $('#electure-'+slide + ' .electure-read-status').html("&#10004;");
        $('#electure-'+slide + ' .electure-read-status').attr("title", "Slide Completed!");
        $('#electure-'+slide + ' .electure-read-status').css("font-size", "17px");
      }

      function pushState(slideValue) {
        var url = '/en/dfsbfs';
        if (typeof slideValue != 'undefined' && slideValue != null) {
          url += '?slide=' + slideValue;
                  }
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5);
        $('#overlay').show();

        $("#e-lecture-timeline").show();
        $("#e-lecture-f1map").show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
        $("#e-lecture-timeline").hide();
        $("#e-lecture-f1map").hide();
        clearTimeout(currSlideTimer);
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      function sectorBasedModeSelection() {
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        //check params are empty and then that all sectors are completed or not
        if (!Object.keys(params).length
          && sector1Count === sectorLength && sector2Count === sectorLength && sector3Count === (numSlides - 2 * sectorLength)) {
            hideOverlay();
        }
        else
          $('#mode-menu a').click();
      }

      $(function() {
        if (isMobileOS() && portraitMatcher.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').show();
          $('#widenDeviceText').hide();
          $('#topbar').css("z-index", 10001);
        } else if (matchMediaNarrow.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').hide();
          $('#widenDeviceText').show();
          $('#topbar').css("z-index", 10001);
        } else {
          $('#rotateDeviceOverlay').hide();
          $('#topbar').css("z-index", "");
        }

        matchMediaNarrow.addEventListener('change', e => {
          //screws up for square device! NEED RESIZE EVENT
          if (e.matches) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').hide();
              $('#widenDeviceText').show();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        portraitMatcher.addEventListener('change', e => {
          if (e.matches && isMobileOS()) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').show();
              $('#widenDeviceText').hide();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        let slide = getUrlParameter('slide');
        if (typeof slide !== undefined && slide != null) {
          cur_slide = slide;
        }
        //do all timeline and slide stuff only if specific params not provided
        if (!Object.keys(params).length || params["slide"]) {
          if (!isMobile()) {
                            $('#mode-menu a').click();
                      }
        }
        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-4-1 .electure-next').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-4-2 .electure-next').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
        $('#electure-4-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
        $('#electure-4-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
        $('#electure-4-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
        $('#electure-4-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-4-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
        $('#electure-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
        $('#electure-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
        $('#electure-5-1 .electure-next').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
        $('#electure-5-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-5-2 .electure-next').click(function() {
          hidePopup();
          runSlide('5-3');
          pushState('5-3');
        });
        $('#electure-5-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
        $('#electure-5-3 .electure-next').click(function() {
          hidePopup();
          runSlide('5-4');
          pushState('5-4');
        });
        $('#electure-5-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
        $('#electure-5-4 .electure-next').click(function() {
          hidePopup();
          runSlide('5-5');
          pushState('5-5');
        });
        $('#electure-5-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-3');
          pushState('5-3');
        });
        $('#electure-5-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-6');
          pushState('5-6');
        });
        $('#electure-5-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-4');
          pushState('5-4');
        });
        $('#electure-5-6 .electure-next').click(function() {
          hidePopup();
          runSlide('5-7');
          pushState('5-7');
        });
        $('#electure-5-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-5');
          pushState('5-5');
        });
        $('#electure-5-7 .electure-next').click(function() {
          hidePopup();
          runSlide('5-8');
          pushState('5-8');
        });
        $('#electure-5-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-6');
          pushState('5-6');
        });
        $('#electure-5-8 .electure-next').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-5-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-7');
          pushState('5-7');
        });
        $('#electure-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-8');
          pushState('5-8');
        });
        $('#electure-6-1 .electure-next').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-6-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-6-2 .electure-next').click(function() {
          hidePopup();
          runSlide('6-3');
          pushState('6-3');
        });
        $('#electure-6-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6-3 .electure-next').click(function() {
          hidePopup();
          runSlide('6-4');
          pushState('6-4');
        });
        $('#electure-6-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-6-4 .electure-next').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-6-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-3');
          pushState('6-3');
        });
        $('#electure-7 .electure-next').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-4');
          pushState('6-4');
        });
        $('#electure-7-1 .electure-next').click(function() {
          hidePopup();
          runSlide('7-2');
          pushState('7-2');
        });
        $('#electure-7-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-7-2 .electure-next').click(function() {
          hidePopup();
          runSlide('7-3');
          pushState('7-3');
        });
        $('#electure-7-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-7-3 .electure-next').click(function() {
          hidePopup();
          runSlide('7-4');
          pushState('7-4');
        });
        $('#electure-7-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-2');
          pushState('7-2');
        });
        $('#electure-7-4 .electure-next').click(function() {
          hidePopup();
          runSlide('7-5');
          pushState('7-5');
        });
        $('#electure-7-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-3');
          pushState('7-3');
        });
        $('#electure-7-5 .electure-next').click(function() {
          hidePopup();
          runSlide('7-6');
          pushState('7-6');
        });
        $('#electure-7-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-4');
          pushState('7-4');
        });
        $('#electure-7-6 .electure-next').click(function() {
          hidePopup();
          runSlide('7-7');
          pushState('7-7');
        });
        $('#electure-7-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-5');
          pushState('7-5');
        });
        $('#electure-7-7 .electure-next').click(function() {
          hidePopup();
          runSlide('7-8');
          pushState('7-8');
        });
        $('#electure-7-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-6');
          pushState('7-6');
        });
        $('#electure-7-8 .electure-next').click(function() {
          hidePopup();
          runSlide('7-9');
          pushState('7-9');
        });
        $('#electure-7-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-7');
          pushState('7-7');
        });
        $('#electure-7-9 .electure-next').click(function() {
          hidePopup();
          runSlide('7-10');
          pushState('7-10');
        });
        $('#electure-7-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-8');
          pushState('7-8');
        });
        $('#electure-7-10 .electure-next').click(function() {
          hidePopup();
          runSlide('7-11');
          pushState('7-11');
        });
        $('#electure-7-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-9');
          pushState('7-9');
        });
        $('#electure-7-11 .electure-next').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
        $('#electure-7-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-10');
          pushState('7-10');
        });
        $('#electure-8 .electure-next').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
        $('#electure-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-11');
          pushState('7-11');
        });
        $('#electure-9 .electure-next').click(function() {
          hidePopup();
          runSlide('10');
          pushState('10');
        });
        $('#electure-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
        $('#electure-10 .electure-next').click(function() {
          hidePopup();
          runSlide('11');
          pushState('11');
        });
        $('#electure-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
        $('#electure-11 .electure-next').click(function() {
          hidePopup();
          runSlide('12');
          pushState('12');
        });
        $('#electure-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('10');
          pushState('10');
        });
        $('#electure-12 .electure-next').click(function() {
          hidePopup();
          runSlide('13');
          pushState('13');
        });
        $('#electure-12 .electure-prev').click(function() {
          hidePopup();
          runSlide('11');
          pushState('11');
        });
        $('#electure-13 .electure-next').click(function() {
          hidePopup();
          runSlide('13-1');
          pushState('13-1');
        });
        $('#electure-13 .electure-prev').click(function() {
          hidePopup();
          runSlide('12');
          pushState('12');
        });
        $('#electure-13-1 .electure-next').click(function() {
          hidePopup();
          runSlide('14');
          pushState('14');
        });
        $('#electure-13-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('13');
          pushState('13');
        });
        $('#electure-14 .electure-next').click(function() {
          hidePopup();
          runSlide('14-1');
          pushState('14-1');
        });
        $('#electure-14 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-1');
          pushState('13-1');
        });
        $('#electure-14-1 .electure-next').click(function() {
          hidePopup();
          runSlide('14-2');
          pushState('14-2');
        });
        $('#electure-14-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('14');
          pushState('14');
        });
        $('#electure-14-2 .electure-next').click(function() {
          hidePopup();
          runSlide('14-3');
          pushState('14-3');
        });
        $('#electure-14-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-1');
          pushState('14-1');
        });
        $('#electure-14-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-2');
          pushState('14-2');
        });
      });

      function doButtonAction39() {
        CUSTOM_ACTION('dfs');
      }
      function doButtonAction40() {
        CUSTOM_ACTION('bfs');
      }
      function doButtonAction41() {
        $("#dfsrecap").html("We start from source vertex <b>s = 0</b> and DFS will explore vertices: 0 &rarr; 1 (cannot go back to 0) &rarr; 2 (cannot go back to 1) &rarr; 3 (cannot go back to 1 or to 2) &rarr; 4 (cannot go back to 3, backtrack to 3 &rarr; 2 &rarr; 1, cannot go to 3, backtrack to 0, done).");
      }
      function doButtonAction42() {
        $("#bfsrecap").html("We start from source vertex <b>s = 5</b> and BFS will explore vertices: {5} (the source vertex), {1, 6, 10} (one edge away from the source vertex), {0, 2, 11, 9} (two edges away), {4, 3, 12, 8} (three edges away), and finally {7} (four edges away).");
      }
      function doButtonAction43() {
        $("#printexample").html(" When we call <samp>backtrack(4)</samp> after executing <samp>DFS(0)</samp> on the sample graph, we go back from 4 &rarr; p[4] = 3 &rarr; p[3] = 2 &rarr; p[2] = 1 &rarr; p[1] = 0 &rarr; p[0] = -1 (so 0 is the source) and print the path in reversed order (due to recursion) i.e.,: 0 &rarr; 1 &rarr; 2 &rarr; 3 &rarr; 4.");
      }
      function doButtonAction44() {
        CUSTOM_ACTION('toposort_dfs');
      }
      function doButtonAction45() {
        CUSTOM_ACTION('toposort_bfs');
      }
      function doButtonAction46() {
        CUSTOM_ACTION('bipartite_dfs');
      }
      function doButtonAction47() {
        CUSTOM_ACTION('bipartite_bfs');
      }
      function doButtonAction48() {
        CUSTOM_ACTION('bridge');
      }
      function doButtonAction49() {
        CUSTOM_ACTION('kosaraju');
      }
      function doButtonAction50() {
        CUSTOM_ACTION('tarjan');
      }

      $('.electure-print').click(() => {
        window.open(`/en/dfsbfs/print`);
      });
      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url.html) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}

      // This function will be called everytime 1.0x is changed to 0.5x or vice versa
      function redraw() {}

      $(document).ready(function () {
        setTimeout(function () {
          $('#change-lang-popup').fadeOut('slow')
        }, 5000)
      })
    </script>
<script type="text/javascript">
    var extraCSS = {"twosat":"65px","scc":"92px","bridge":"119px","bipartite":"146px","topo":"173px","bfs":"200px","dfs":"227px","examples":"254px","draw":"281px","vertexnumber":"308px","mediumscale":"335px"};
    var actionsIds = {"mediumscale":{"p":"Visualisation Scale"},"vertexnumber":{"p":"Toggle V. Number for 0.5x","onClick":"toggleVertexNumber()"},"draw":{"p":"Edit Graph","onClick":"drawGraph()"},"examples":{"p":"Example Graphs"},"dfs":{"p":"Depth-First Search"},"bfs":{"p":"Breadth-First Search"},"topo":{"p":"Topological Sort"},"bipartite":{"p":"Bipartite Graph Check"},"bridge":{"p":"Cut Vertex & Bridge","onClick":"bridge()"},"scc":{"p":"SCC Algorithms"},"twosat":{"p":"2-SAT Checker"}};
    var isOpens = {};
    var len = 11;
    var keys = ["mediumscale","vertexnumber","draw","examples","dfs","bfs","topo","bipartite","bridge","scc","twosat"]; 
    for (i = 0; i < len; i++) {
        var actionDetails = keys[i];
        isOpens[actionDetails] = false;
    }
    function openAction(id) {
        hideThirdTiers(id);
        $("." + id).css("bottom", extraCSS[id]);
        if (!isOpens[id]) {
            $('.' + id).fadeIn('fast');
            isOpens[id] = true;
        }
    }
    function closeAction(id) {
        hideThirdTiers(id);
        if (isOpens[id]) {
            $('.' + id).fadeOut('fast');
            $('#' + id + '-err').html("");
            isOpens[id] = false;
        }
    }

    function hideEntireActionsPanel() {
        //hideAllThirdTiers();
                    closeAction('mediumscale');
                    closeAction('vertexnumber');
                    closeAction('draw');
                    closeAction('examples');
                    closeAction('dfs');
                    closeAction('bfs');
                    closeAction('topo');
                    closeAction('bipartite');
                    closeAction('bridge');
                    closeAction('scc');
                    closeAction('twosat');
                hideActionsPanel();
    }

    function hideThirdTiers(tier1Action) {
        if ("parents" in actionsIds[tier1Action]) {
            for (const secondTierAction of actionsIds[tier1Action]["parents"]) {
                $('#' + secondTierAction + '-third-tier').fadeOut('fast');
            }
        }
    }

    function hideAllThirdTiers() {
        for (const tier1Action in actionsIds) {
            hideThirdTiers(tier1Action);
        }
    }

    function toggleChildExtras(tier1, selectedParentTier2) {
        hideThirdTiers(tier1);
        //this actionId must have childExtras
        var style = extraCSS[tier1];
        $("." + tier1).css("bottom", (parseInt(style.substring(0, style.length - 2)) - 27));
        //fade ins and outs are done on the ID whereas css class is set on the class
        //fade in the third tier of the selected 2nd tier parent
        $('#' + selectedParentTier2 + '-third-tier').fadeIn('fast');

        // //fade out all other third tiers of that 'action'
        // for (const parent of actions[tier1]["parents"]) {
        //     console.log("parent is " + parent + " for " + selectedParentTier2);
        //     if (parent != selectedParentTier2) {
        //         $('#' + parent + '-third-tier').fadeOut('fast');
        //     }
        // }
    }

    function setActionHeightOriginal(tier1Action) {
        $("." + tier1Action).css("bottom", extraCSS[tier1Action]);
    }

            $('#' + 'mediumscale').click(function() {
            openAction('mediumscale');
                                                                            closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('dfs');
                                                                closeAction('bfs');
                                                                closeAction('topo');
                                                                closeAction('bipartite');
                                                                closeAction('bridge');
                                                                closeAction('scc');
                                                                closeAction('twosat');
                                    });
            $('#' + 'vertexnumber').click(function() {
            openAction('vertexnumber');
                                                closeAction('mediumscale');
                                                                                            closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('dfs');
                                                                closeAction('bfs');
                                                                closeAction('topo');
                                                                closeAction('bipartite');
                                                                closeAction('bridge');
                                                                closeAction('scc');
                                                                closeAction('twosat');
                                    });
            $('#' + 'draw').click(function() {
            openAction('draw');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                                            closeAction('examples');
                                                                closeAction('dfs');
                                                                closeAction('bfs');
                                                                closeAction('topo');
                                                                closeAction('bipartite');
                                                                closeAction('bridge');
                                                                closeAction('scc');
                                                                closeAction('twosat');
                                    });
            $('#' + 'examples').click(function() {
            openAction('examples');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                                            closeAction('dfs');
                                                                closeAction('bfs');
                                                                closeAction('topo');
                                                                closeAction('bipartite');
                                                                closeAction('bridge');
                                                                closeAction('scc');
                                                                closeAction('twosat');
                                    });
            $('#' + 'dfs').click(function() {
            openAction('dfs');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('examples');
                                                                                            closeAction('bfs');
                                                                closeAction('topo');
                                                                closeAction('bipartite');
                                                                closeAction('bridge');
                                                                closeAction('scc');
                                                                closeAction('twosat');
                                    });
            $('#' + 'bfs').click(function() {
            openAction('bfs');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('dfs');
                                                                                            closeAction('topo');
                                                                closeAction('bipartite');
                                                                closeAction('bridge');
                                                                closeAction('scc');
                                                                closeAction('twosat');
                                    });
            $('#' + 'topo').click(function() {
            openAction('topo');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('dfs');
                                                                closeAction('bfs');
                                                                                            closeAction('bipartite');
                                                                closeAction('bridge');
                                                                closeAction('scc');
                                                                closeAction('twosat');
                                    });
            $('#' + 'bipartite').click(function() {
            openAction('bipartite');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('dfs');
                                                                closeAction('bfs');
                                                                closeAction('topo');
                                                                                            closeAction('bridge');
                                                                closeAction('scc');
                                                                closeAction('twosat');
                                    });
            $('#' + 'bridge').click(function() {
            openAction('bridge');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('dfs');
                                                                closeAction('bfs');
                                                                closeAction('topo');
                                                                closeAction('bipartite');
                                                                                            closeAction('scc');
                                                                closeAction('twosat');
                                    });
            $('#' + 'scc').click(function() {
            openAction('scc');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('dfs');
                                                                closeAction('bfs');
                                                                closeAction('topo');
                                                                closeAction('bipartite');
                                                                closeAction('bridge');
                                                                                            closeAction('twosat');
                                    });
            $('#' + 'twosat').click(function() {
            openAction('twosat');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('dfs');
                                                                closeAction('bfs');
                                                                closeAction('topo');
                                                                closeAction('bipartite');
                                                                closeAction('bridge');
                                                                closeAction('scc');
                                                                });
    
    //important to have all the input fields in actions menu take an id containing '-input'
    $("[id*='-input']").on("keypress keydown keyup", (event) => {
        event.stopPropagation();
    });
</script>
<script type="text/javascript">

// Graph Traversal Widget
// original author: Koh Zi Chun, improved by Nguyen Viet Dung, then maintained by Steven Halim
var scale = false;
var GraphTraversal = function(isMediumScale = false) {

  var self = this;
  var gw = new GraphWidget(isMediumScale);

  var iVL = {};
  var iEL = {};
  var amountVertex = 0;
  var amountEdge = 0;
  this.getiVL = function() { return iVL; }
  this.getiEL = function() { return iEL; }
  this.getGraphWidget = function() { return gw; }

  fixJSON = function() {
    amountVertex = 0;
    amountEdge = 0;
    for (var key in iVL) ++amountVertex;
    for (var key in iEL) ++amountEdge;

    // for (var key in iEL) {
    //   delete iEL[key]["type"];
    //   delete iEL[key]["displayWeight"];
    // }
    // for (var key in iVL) {
    //   iVL[key]["x"] = iVL[key]["cx"];
    //   delete iVL[key]["cx"];
    //   iVL[key]["y"] = iVL[key]["cy"];
    //   delete iVL[key]["cy"];
    //   delete iVL[key]["text"];
    //   delete iVL[key]["state"];
    // }
    // for (var key in iEL) {
    //   iEL[key]["u"] = +iEL[key]["vertexA"];
    //   delete iEL[key]["vertexA"];
    //   iEL[key]["v"] = +iEL[key]["vertexB"];
    //   delete iEL[key]["vertexB"];
    //   iEL[key]["w"] = +iEL[key]["weight"];
    //   delete iEL[key]["weight"];
    // }
  }

  takeJSON = function(graph) {
    if (graph == null) return;
    graph = JSON.parse(graph);
    iVL = graph["vl"];
    iEL = graph["el"];
    fixJSON();
  }

  statusChecking = function() {
    $("#draw-status p").html('Draw graph with varying properties then try to run various graph traversal algorithms on it.<br>The default drawing mode is directed graph (each edge has one or at most two arrows).');
  }

  warnChecking = function() {
    var warn = "";
    if (currentGraphVisu.amountVertex() >= 10) warn += 'Too much vertex on screen, consider drawing smaller graph. ';
    if (warn == "") $("#draw-warn p").html('No Warning.');
    else            $("#draw-warn p").html(warn);
  }

  errorChecking = function() {
    var error = "";
    if (currentGraphVisu.amountVertex() == 0) {
      $("#draw-err p").html('Graph cannot be empty. ');
      return;
    }

    if (error == "") $("#draw-err p").html('No Error');
    else             $("#draw-err p").html(error);
  }

  var intervalID;

  this.startLoop = function() {
    intervalID = setInterval(function() {
      if (currentGraphVisu == undefined) return;
      //takeJSON(JSONresult);
      warnChecking();
      errorChecking();
      statusChecking();
    }, 100);
  }

  this.stopLoop = function() {
    clearInterval(intervalID);
  }

  this.draw = function() {
    if ($("#draw-err p").html() != 'No Error')
      return false;
    takeJSON(JSONresult);
    if ($("#submit").is(':checked'))
      this.submit(JSONresult);
    if ($("#copy").is(':checked'))
      window.prompt('Copy to clipboard:', JSONresult);

    DIRECTED_GR = true;
    OLD_POSITION = amountEdge;

    gw.removeAll(); // prevent "phantom" vertices and edges from appearing when using medium scale mode.
    graph = createState(iVL, iEL);
    gw.updateGraph(graph, 500);
    return true;
  }

  // this.submit = function(graph) {
  //   $.ajax({
  //     url: PHP_DOMAIN + "php/Graph.php?mode=" + MODE_SUBMIT_GRAPH,
  //     type: "POST",
  //     data: {canvasWidth: 1000, canvasHeight: 500, graphTopics: 'Graph Traversal', graphState: graph, fbAccessToken: fbAccessToken},
  //     error: function(xhr, errorType, exception) { //Triggered if an error communicating with server
  //         var errorMessage = exception || xhr.statusText; //If exception null, then default to xhr.statusText
  //         alert("There was an error submitting your graph " + errorMessage);
  //     }
  //   }).done(function(data) {
  //   });
  // }

  this.importjson = function(text) {
    takeJSON(text);
    statusChecking();

    DIRECTED_GR = true;
    OLD_POSITION = amountEdge;

    graph = createState(iVL, iEL);
    gw.updateGraph(graph, 500);
  }

  // this.initRandom = function(graph) {
  //   iVL = graph.iVL;
  //   iEL = graph.iEL;
  //   amountVertex = iVL.length;
  //   amountEdge = iEL.length;
  //   fixJSON();
  //   statusChecking();

  //   DIRECTED_GR = true;
  //   OLD_POSITION = amountEdge;

  //   var newState = createState(iVL, iEL);
  //   gw.updateGraph(newState, 500);
  // }

  var DIRECTED_GR;
  var OLD_POSITION;

  this.directedChange = function() {
    for (var key in iVL) iVL[key]["extratext"] = "";
    if (DIRECTED_GR == true) {
      DIRECTED_GR = false;
      for (var i = 0; i < OLD_POSITION; ++i) {
        var ok = false;
        for (var j = 0; j < amountEdge; ++j)
          if (iEL[i]["u"] == iEL[j]["v"] && iEL[i]["v"] == iEL[j]["u"]) {
            ok = true;
            break;
          }
        if (ok == false)
          iEL[amountEdge++] = {
            "u": iEL[i]["v"],
            "v": iEL[i]["u"]
          }
      }
    }
    else {
      DIRECTED_GR = true;
      for (var i = OLD_POSITION; i < amountEdge; ++i)
        delete iEL[i];
      amountEdge = OLD_POSITION;
    }

    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
    // $('#directedChange-err').html("Successful")
    //   .delay(1000)
    //   .queue(function(n) {
    //     $(this).html("");
    //   });
    return true;
  }

  this.getGraph = function() {
    return {
      'vl': iVL,
      'el': iEL
    };
  }

  this.getV = function() {
    return amountVertex;
  }

  this.dfs = function(sourceVertex, callback) {
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {}, treeEdge = {}, backEdge = {}, forwardEdge = {}, crossEdge = {};
    var stateList = [];
    var cs;

    // error checks
    if (amountVertex == 0) { // no graph
      $('#dfs-err').html('There is no graph to run this on. Please select an example graph first');
      return false;
    }

    if (sourceVertex >= amountVertex || sourceVertex < 0) { // source vertex not in range
      $('#dfs-err').html('This vertex does not exist in the graph. Please select another source vertex');
      return false;
    }

    var UNVISITED = 0, EXPLORED = 1, VISITED = 2;
    var p = {}, num = {}, Count = 0; // low = {},
    for (var i = 0; i < amountVertex; ++i) {
      p[i] = -1;
      num[i] = UNVISITED;
    }
    p[sourceVertex] = -2;
    for (var key in iVL) iVL[key]["extratext"] = "";
    iVL[sourceVertex]["extratext"] = "source";

    function dfsRecur(u) {
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
      cs["status"] = "DFS(" + u + ")";
      cs["lineNo"] = 1;
      stateList.push(cs);

      delete vertexHighlighted[u];
      vertexTraversing[u] = true;
      num[u] = EXPLORED; // low[u] = ++Count;

      var neighbors = [];
      for (var j = 0; j < amountEdge; ++j) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var u = iEL[j]["u"], v = iEL[j]["v"];
        edgeHighlighted[j] = true;
        // on 18 Oct, after the bidirectional edges are given offset, do NOT do the reverse
        // for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) edgeHighlighted[key] = true;
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
        cs["status"] = 'Try edge {u} → {v}'.replace("{u}", u).replace("{v}", v);
        cs["lineNo"] = 2;
        cs["el"][j]["animateHighlighted"] = true;
        stateList.push(cs);

        for (var key in iVL) delete vertexHighlighted[key];
        for (var key in iEL) delete edgeHighlighted[key];

        if (num[v] == UNVISITED) {
          vertexTraversing[v] = true;
          treeEdge[j] = true;
          // on 18 Oct, after the bidirectional edges are given offset, do NOT do the reverse
          // for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) treeEdge[key] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
          cs["lineNo"] = [3];
          cs["status"] = 'Try edge {u} → {v}<br>Vertex {v} is unvisited, we have a <font color="red">tree edge</font>.'.replace("{u}", u).replace("{v}", v).replace("{v}", v);
          stateList.push(cs);

          p[v] = u;
          dfsRecur(v);

          vertexHighlighted[u] = true;
          delete vertexHighlighted[v];
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
          cs["status"] = 'Finish DFS({v}), backtrack to DFS({u}).'.replace("{u}", u).replace("{v}", v);
          cs["lineNo"] = 1;
          stateList.push(cs);
        }
        else if (num[v] == EXPLORED) {
          // if (p[u] != v) { // this check is no longer needed, trivial bidirectional edge cycles also can be counted
            backEdge[j] = true;
            // on 18 Oct, after the bidirectional edges are given offset, do NOT do the reverse
            // for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) backEdge[key] = true;
          // }
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
          var thisStatus = 'Try edge {u} → {v}<br>Vertex {v} is explored, we have a '.replace("{u}", u).replace("{v}", v).replace("{v}", v);
          if (p[u] == v)
            thisStatus = thisStatus + '<font color="blue">bidirectional edge</font> (a trivial cycle).';
          else
            thisStatus = thisStatus + '<font color="blue">back edge</font> (a true cycle).';
          cs["status"] = thisStatus;
          cs["lineNo"] = 4;
          stateList.push(cs);
        }
        else if (num[v] == VISITED) {
          forwardEdge[j] = true;
          // on 18 Oct, after the bidirectional edges are given offset, do NOT do the reverse
          // for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) forwardEdge[key] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
          cs["status"] = 'Try edge {u} → {v}<br>Vertex {v} is visited, we have a <font color="grey">forward/cross edge</font>.'.replace("{u}", u).replace("{v}", v).replace("{v}", v);
          cs["lineNo"] = 5;
          stateList.push(cs);
        }
      }
      num[u] = VISITED;
      vertexTraversed[u] = true;
      delete vertexTraversing[u];
    }
    dfsRecur(sourceVertex);

    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
    cs["status"] = 'DFS({sourceVertex}) is completed. <font color="red">Red</font>/<font color="grey">grey</font>/<font color="blue">blue</font> edge is <font color="red">tree</font>/<font color="grey">cross/forward</font>/<font color="blue">back</font> edge of the DFS spanning tree, respectively.'.replace("{sourceVertex}", sourceVertex);
    cs["lineNo"] = 0;
    stateList.push(cs);

    populatePseudocode(0);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.bfs = function(sourceVertex, callback) {
    var notVisited = {}, vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {}, treeEdge = {}, backEdge = {}, forwardEdge = {}, crossEdge = {};
    var stateList = [];
    var key, i, cs;

    // error checks
    if (amountVertex == 0) { // no graph
      $('#bfs-err').html('There is no graph to run this on. Please select an example graph first');
      return false;
    }

    if (sourceVertex >= amountVertex || sourceVertex < 0) { // source vertex not in range
      $('#bfs-err').html('This vertex does not exist in the graph. Please select another source vertex');
      return false;
    }

    var p = {}, d = {};
    for (var i = 0; i < amountVertex; ++i) {
      p[i] = -1;
      d[i] = 999;
    }
    d[sourceVertex] = 0;
    for (var key in iVL) iVL[key]["extratext"] = "";
    iVL[sourceVertex]["extratext"] = "source";

    var q = []; //, EdgeProcessed = 0;
    q.push(sourceVertex);
    p[sourceVertex] = -2;
    vertexHighlighted[sourceVertex] = true;
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
    cs["status"] = 'Start from source s = {sourceVertex}.<br>Set Q = {{sourceVertex}}.'.replace("{sourceVertex}", sourceVertex).replace("{sourceVertex}", sourceVertex); // d[" + sourceVertex + "] = 0, 
    cs["lineNo"] = 1;
    stateList.push(cs);
    delete vertexHighlighted[sourceVertex];

    while (q.length > 0) {
      delete vertexTraversing[q[0]];
      vertexHighlighted[q[0]] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
      cs["status"] = 'The queue is now {{queue}}.<br>Exploring neighbors of vertex u = {Lis}.'.replace("{queue}", q).replace("{Lis}", q[0]);
      cs["lineNo"] = [2, 3];
      stateList.push(cs);

      var f = q.shift();
      vertexTraversed[f] = true;

      var neighbors = [];
      for (var j = 0; j < amountEdge; ++j) if (iEL[j]["u"] == f) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var u = iEL[j]["u"], v = iEL[j]["v"];
        // for (var key in iVL) delete vertexHighlighted[key];
        for (var key in iEL) delete edgeHighlighted[key];
        if (u == f) { // outgoing edge from vertex u
          //EdgeProcessed++;
          //var thisStatus = 'relax(' + u + ', ' + v + ', 1), #edge_processed = ' + EdgeProcessed + '.';
          edgeHighlighted[j] = true;
          // on 18 Oct, after the bidirectional edges are given offset, do NOT do the reverse
          // for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) edgeHighlighted[key] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
          cs["status"] = 'Try edge {u} → {v}'.replace("{u}", u).replace("{v}", v).replace("{v}", v);
          cs["lineNo"] = 3;
          cs["el"][j]["animateHighlighted"] = true;
          stateList.push(cs);

          for (var key in iEL) delete edgeHighlighted[key]; // clear all again :O
          if (d[v] == 999) {
            d[v] = d[u]+1;
            p[v] = u;
            treeEdge[j] = true;
            // on 18 Oct, after the bidirectional edges are given offset, do NOT do the reverse
            // for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) treeEdge[key] = false;
            q.push(v);
            vertexTraversing[v] = true;
            iVL[v]["extratext"] = d[v];
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
            cs["status"] = 'Try edge {u} → {v}<br>Vertex {v} is unvisited, we have a <font color="red">tree edge</font>.'.replace("{u}", u).replace("{v}", v).replace("{v}", v);
            cs["lineNo"] = 4;
          }
          else {
            // var grey_it = true;
            // on 18 Oct, after the bidirectional edges are given offset, do NOT do the reverse
            // for (var key in iEL) if ((iEL[key]["u"] == v && iEL[key]["v"] == u) && treeEdge[key]) grey_it = false;
            // if (grey_it) {
              forwardEdge[j] = true; // use grey to signify non-tree edge
              // on 18 Oct, after the bidirectional edges are given offset, do NOT do the reverse
              // for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) forwardEdge[key] = true;
            // }
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
            cs["status"] = 'Try edge {u} → {v}<br>Vertex {v} is explored, we ignore this <font color="grey">non-tree edge</font>.'.replace("{u}", u).replace("{v}", v).replace("{v}", v);
            cs["lineNo"] = 5;
          }
          stateList.push(cs);
        }
      }
      // delete vertexHighlighted[u];
      for (var key in iVL) delete vertexHighlighted[key];
      for (var key in iEL) delete edgeHighlighted[key];
    }

    for (var key in iVL) delete vertexHighlighted[key];
    for (var key in iEL) delete edgeHighlighted[key];
    vertexHighlighted[sourceVertex] = true;
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
    cs["status"] = 'BFS({sourceVertex}) is completed. <font color="red">Red</font>/<font color="grey">grey</font> edge is <font color="red">tree</font>/<font color="grey">non-tree</font> edge of the BFS & SSSP spanning tree (for unweighted graph).'.replace("{sourceVertex}", sourceVertex);
    stateList.push(cs);

    populatePseudocode(1);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.toposortDfs = function(callback) {
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {}, treeEdge = {}, backEdge = {}, forwardEdge = {}, crossEdge = {}, hiddenEdge = {};
    var stateList = [];
    var cs, flag = true;

    // check error
    if (!DIRECTED_GR) {
      // cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      // cs["status"] = "The input graph is not set as 'directed' graph yet.<br>This algorithm only works with directed graphs.";
      // cs["lineNo"] = 0;
      // stateList.push(cs);

      this.directedChange(); // force change

      // cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      // cs["status"] = "We turn on the directed graph mode.<br>This action is irreversible.";
      // cs["lineNo"] = 0;
      // stateList.push(cs);

      // $('#topo-err').html("Undirected graph clearly has no topological sort. Give a directed input graph.");
      // return false;
    }

    if (amountVertex == 0) { // no graph
      $('#topo-err').html('There is no graph to run this on. Please select an example graph first');
      return false;
    }

    // main code
    var p = {}, stack = [], stackNum = -1;
    for (var i = 0; i < amountVertex; ++i) p[i] = -1
    for (var key in iVL) iVL[key]["extratext"] = "";

    for (var i = 0; i < amountVertex; ++i)
      if (p[i] == -1) {
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
        cs["status"] = 'Vertex {i} has not been visited.'.replace("{i}", i);
        cs["lineNo"] = 1;
        stateList.push(cs);
        --p[i];
        Tdfs(i);
      }

    function Tdfs(u) {
      if (flag == false) return;
      vertexTraversing[u] = true;
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
      cs["status"] = "DFS(" + u + ").";
      cs["lineNo"] = 2;
      stateList.push(cs);
      delete vertexHighlighted[u];

      var neighbors = [];
      for (var j = 0; j < amountEdge; ++j) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
        if (u == vertexA) {
          edgeHighlighted[j] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
          cs["status"] = 'Try edge {vertexA} → {vertexB}.<br>List = [{stack}].'.replace("{vertexA}", vertexA).replace("{vertexB}", vertexB).replace("{stack}", stack);
          cs["lineNo"] = 3;
          cs["el"][j]["animateHighlighted"] = true;
          stateList.push(cs);

          if (p[vertexB] == -1) {
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
            cs["status"] = 'Vertex {vertexB} has not been visited, continue.<br>List = [{stack}].'.replace("{vertexB}", vertexB).replace("{stack}", stack);
            cs["lineNo"] = 4;
            stateList.push(cs);

            p[vertexB] = u;
            Tdfs(vertexB);
          }
          else {
            var k = u;
            while (k != -2) {
              k = p[k];
              if (k == vertexB) flag = false;
            }
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
            cs["status"] = 'Vertex {vertexB} has been visited, ignore this edge.<br>List = [{stack}].'.replace("{vertexB}", vertexB).replace("{stack}", stack);
            cs["lineNo"] = 5;
            stateList.push(cs);
          }
        }
      }
      stack.push(u);
      delete vertexTraversing[u];
      vertexTraversed[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
      cs["status"] = 'DFS({u}) is completed, add {u} to the back of the list.<br>List = [{stack}].'.replace("{u}", u).replace("{stack}", stack);
      cs["lineNo"] = 7;
      stateList.push(cs);
    }
    if (flag == false) { // not DAG
      $('#topo-err').html('This graph is not a DAG, unable to perform Topological Sort.');
      return false;
    }
    vertexHighlighted = {}, edgeHighlighted = {};
    vertexTraversed = {}, vertexTraversing = {}, treeEdge = {}, backEdge = {}, forwardEdge = {}, crossEdge = {}, hiddenEdge = {};
    stack.reverse();
    for (var key in stack) iVL[stack[key]]["extratext"] = key;
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
    cs["status"] = 'Topological Sort is completed after reversing the list.<br>List = [{stack}], also see the <font color="red">red</font> indices above.'.replace("{stack}", stack);
    cs["lineNo"] = 0;
    stateList.push(cs);

    populatePseudocode(2);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.toposortBfs = function(callback) {
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {}, treeEdge = {}, backEdge = {}, forwardEdge = {}, crossEdge = {}, hiddenEdge = {};
    var stateList = [];
    var cs, key;

    // error checks
    if (amountVertex == 0) { // no graph
      $('#topo-err').html('There is no graph to run this on. Please select an example graph first');
      return false;
    }

    if (!DIRECTED_GR) {
      this.directedChange(); // force change
      // $('#topo-err').html("Undirected graph clearly has no topological sort. Give a directed input graph.");
      // return false;
    }

    var fr = {}, cc = {};
    for (var i = 0; i < amountVertex; ++i)
      fr[i] = true, cc[i] = 0;
    for (var j = 0; j < amountEdge; ++j)
      ++cc[iEL[j]["v"]];

    for (key in iVL)
      iVL[key]["state"] = VERTEX_DEFAULT, iVL[key]["extratext"] = "";

    var q = [], EdgeProcessed = 0, Lis = [];
    for (var i = 0; i < amountVertex; ++i)
      if (cc[i] == 0)
        q.push(i), vertexHighlighted[i] = vertexTraversing[i] = true;
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
    cs["status"] = 'Queue = [{queue}].'.replace("{queue}", q);
    cs["lineNo"] = 1;
    stateList.push(cs);
    for (var i = 0; i < amountVertex; ++i)
      if (cc[i] == 0)
        delete vertexHighlighted[i];

    while (q.length > 0) {
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
      cs["status"] = 'Queue = [{queue}].'.replace("{queue}", q);
      cs["lineNo"] = 2;
      stateList.push(cs);

      var u = q.shift(); // front most item
      Lis.push(u);
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
      cs["status"] = 'Pop vertex {u} from queue and add it to the back of the list.<br>List = [{Lis}].'.replace("{u}", u).replace("{Lis}", Lis);
      cs["lineNo"] = 3;
      stateList.push(cs);

      var neighbors = [];
      for (var j = 0; j < amountEdge; ++j) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
        cc[vertexB]--;

        hiddenEdge[j] = true;
        var thisStatus = 'Queue = [{queue}].<br>Delete edge {vertexA} → {vertexB}.'.replace("{queue}", q).replace("{vertexA}", vertexA).replace("{vertexB}", vertexB);
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
        cs["status"] = thisStatus;
        cs["lineNo"] = [4, 5];
        cs["el"][j]["animateHighlighted"] = true;
        stateList.push(cs);

        if (cc[vertexB] == 0) {
          q.push(vertexB);
          vertexTraversing[vertexB] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
          cs["status"] = 'Queue = [{queue}].<br>Vertex {vertexB} now has no incoming edge, add it to queue.'.replace("{queue}", q).replace("vertexB", vertexB);
          cs["lineNo"] = 6;
          stateList.push(cs);
        }
        else {
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
          cs["status"] ='Queue = [{queue}]<br>Vertex {vertexB} still has incoming edge, ignore it.'.replace("{queue}", q).replace("vertexB", vertexB);
          cs["lineNo"] = 6;
          stateList.push(cs);
        }
      }
      delete vertexHighlighted[u];
      delete vertexTraversing[u];
      vertexTraversed[u] = true;
    }

    var thisStatus = 'Kahn&#39;s algorithm is completed.<br>';
    var flag = true;
    for (var j = 0; j < amountEdge; ++j)
      if (hiddenEdge[j] == null) {
        flag = false;
        $('#topo-err').html('This graph is not a DAG, unable to perform Topological Sort.');
        return false;
        // thisStatus += "Edge " + iEL[j]["u"] + "->" + iEL[j]["v"] + " has not been visited, the graph has cycle."
        // break;
      }
    if (flag)
      thisStatus += 'Topological order = [{Lis}]'.replace("{Lis}", Lis);
    for (var key in Lis) iVL[Lis[key]]["extratext"] = key;
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
    cs["lineNo"] = 7;
    cs["status"] = thisStatus;
    stateList.push(cs);

    populatePseudocode(3);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.bipartiteDfs = function(callback) {
    var p = {}, vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {};
    var stateList = [];
    var key, cs, flag = false;

    // error checks   
    if (amountVertex == 0) { // no graph
      $('#bipartite-err').html('There is no graph to run this on. Please select an example graph first');
      return false;
    }

    if (DIRECTED_GR) {
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
      cs["status"] = "The input graph is not set as 'undirected' graph yet.<br>Bipartite Graph is usually only defined for undirected graphs.";
      cs["lineNo"] = 0;
      stateList.push(cs);

      this.directedChange(); // force change

      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
      cs["status"] = "We add bidirectional edges as necessary and hide the arrows.<br>This action is irreversible (you may have to redraw your graph again).";
      cs["lineNo"] = 0;
      stateList.push(cs);

      // $('#bipartite-err').html("Bipartite graph is only defined for undirected graph. Please make the graph undirected.");
      // return false;
    }

    for (var key in iVL) {
      p[key] = -1;
      iVL[key]["extratext"] = "";
    }
    for (var i = 0; i < amountVertex; ++i)
      if (p[i] == -1) {
        vertexTraversed[i] = true;
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
        cs["status"] = "Vertex " + i + " is unvisited.";
        cs["lineNo"] = 1;
        if (vertexTraversed[i] != null) cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
        else                            cs["vl"][i]["state"] = VERTEX_BLUE_FILL;
        stateList.push(cs);
        p[i] = -2;
        dfsRecur(i);
        if (flag) break;
      }

    function dfsRecur(u) {
      if (flag) return;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
      cs["status"] = "DFS(" + u + ").";
      cs["lineNo"] = 2;
      if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
      else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
      stateList.push(cs);

      var neighbors = [];
      for (var j = 0; j < amountEdge; ++j) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
        if (edgeHighlighted[j] == null) {
          if (u == vertexA) {
            edgeHighlighted[j] = true;
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
            cs["status"] = "Try edge " + u + " &rarr; " + vertexB + ".";
            cs["lineNo"] = 3;
            if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
            else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
            cs["el"][j]["animateHighlighted"] = true;
            stateList.push(cs);

            if (p[vertexB] == -1) {
              if (vertexTraversed[u] == null) vertexTraversed[vertexB] = true;
              else                            vertexTraversing[vertexB] = true;
              p[vertexB] = u;
              cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
              cs["status"] = "Try edge " + u + " &rarr; " + vertexB + ".<br>Give vertex " + vertexB + " different color from vertex " + u + ".";
              cs["lineNo"] = 4;
              if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
              else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
              stateList.push(cs);
              dfsRecur(vertexB);
            }
            else {
              var cu = 0, cv = 0;
              if (vertexTraversing[u] != null) cu = 1;
              if (vertexTraversing[vertexB] != null) cv = 1;
              if (cu == cv) {
                flag = true;
                cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
                cs["status"] = "Vertex " + u + " and vertex " + vertexB + " have the same color.";
                cs["lineNo"] = 5;
                if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
                else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
                if (vertexTraversed[vertexB] != null) cs["vl"][vertexB]["state"] = VERTEX_HIGHLIGHTED;
                else                                  cs["vl"][vertexB]["state"] = VERTEX_BLUE_FILL;
                stateList.push(cs);
                break;
              }
            }
            if (flag) break;
          }
          if (flag) break;
        }
        else {
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
          cs["status"] = "Try edge " + vertexA + " &rarr; " + vertexB + ".<br>Vertex " + vertexA + " and vertex " + vertexB + " (already visited) have different color, continue.";
          cs["lineNo"] = 5;
          stateList.push(cs);
        }
      }
      if (flag) return;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
      cs["status"] = "Finish DFS(" + u + ")<br>Back to the parent.";
      cs["lineNo"] = 2;
      if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
      else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
      stateList.push(cs);
    }

    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
    if (flag == false) cs["status"] = "This is a bipartite graph!";
    else               cs["status"] = "This is NOT a bipartite graph!";
    cs["lineNo"] = 0;
    if (flag == true) cs["lineNo"] = 6;
    stateList.push(cs);

    populatePseudocode(4);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.bipartiteBfs = function(callback) {
    var p = {}, vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {};
    var stateList = [];
    var key, cs, flag = true;

    // error checks
    if (amountVertex == 0) { // no graph
      $('#bipartite-err').html('There is no graph to run this on. Please select an example graph first');
      return false;
    }

    if (DIRECTED_GR) {
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
      cs["status"] = "The input graph is not set as 'undirected' graph yet.<br>Bipartite Graph is usually only defined for undirected graphs.";
      cs["lineNo"] = 0;
      stateList.push(cs);

      this.directedChange(); // force change

      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
      cs["status"] = "We add bidirectional edges as necessary and hide the arrows.<br>This action is irreversible (you may have to redraw your graph again).";
      cs["lineNo"] = 0;
      stateList.push(cs);

      // $('#bipartite-err').html("Bipartite graph is only defined for undirected graph. Please make the graph undirected.");
      // return false;
    }

    for (key in iVL) {
      p[key] = -1;
      iVL[key]["state"] = VERTEX_DEFAULT;
      iVL[key]["extratext"] = "";
    }

    for (var s = 0; s < amountVertex; ++s)
      if (p[s] == -1) {
        p[s] = -2;
        vertexTraversed[s] = true;
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
        cs["status"] = 'Vertex ' + s + ' is unvisited.';
        cs["lineNo"] = 1;
        if (vertexTraversed[s] != null) cs["vl"][s]["state"] = VERTEX_HIGHLIGHTED;
        else                            cs["vl"][s]["state"] = VERTEX_BLUE_FILL;
        stateList.push(cs);

        var q = [];
        q.push(s);
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
        cs["status"] = "Queue = [" + q + "].";
        cs["lineNo"] = 2;
        stateList.push(cs);

        while (q.length > 0) {
          var u = q.shift();

          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
          cs["status"] = "Extract " + u + " from queue.";
          cs["lineNo"] = 3;
          if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
          else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
          stateList.push(cs);

          var neighbors = [];
          for (var j = 0; j < amountEdge; ++j) if (iEL[j]["u"] == u) neighbors.push(j);
          neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

          while (neighbors.length > 0) {
            var j = neighbors.shift();
            var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
            if (edgeHighlighted[j] == null) {
              if (u == vertexA) {
                edgeHighlighted[j] = true;
                cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
                cs["status"] = "Queue = [" + q + "].<br>Try edge " + vertexA + " &rarr; " + vertexB + ".";
                cs["lineNo"] = 4;
                if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
                else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
                cs["el"][j]["animateHighlighted"] = true;
                stateList.push(cs);

                if (p[vertexB] == -1) {
                  p[vertexB] = vertexA;
                  q.push(vertexB);
                  if (vertexTraversed[u] != null) vertexTraversing[vertexB] = true;
                  else                            vertexTraversed[vertexB] = true;

                  cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
                  cs["status"] = "Queue = [" + q + "].<br>Vertex " + vertexB + " is free, assign another color and push it to queue.";
                  cs["lineNo"] = 6;
                  if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
                  else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
                  stateList.push(cs);
                }
                else {
                  var cu = 0, cv = 0;
                  if (vertexTraversing[u] != null) cu = 1;
                  if (vertexTraversing[vertexB] != null) cv = 1;
                  if (cu == cv) {
                    flag = false;
                    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
                    cs["status"] = "Vertex " + u + " and vertex " + vertexB + " have the same color.<br>This is NOT a bipartite graph!";
                    cs["lineNo"] = 5;
                    if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
                    else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
                    if (vertexTraversed[vertexB] != null) cs["vl"][vertexB]["state"] = VERTEX_HIGHLIGHTED;
                    else                                  cs["vl"][vertexB]["state"] = VERTEX_BLUE_FILL;
                    stateList.push(cs);
                    break;
                  }
                }
                if (flag == false) break;
              }
              if (flag == false) break;
            }
            else {
              cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
              cs["status"] = "Try edge " + vertexA + " &rarr; " + vertexB + ".<br>Vertex " + vertexA + " and vertex " + vertexB + " (already visited) have different color, continue.";
              cs["lineNo"] = 5;
              stateList.push(cs);
            }
            if (flag == false) break;
          }
          if (flag == false) break;
        }
        if (flag == false) break;
      }

    if (flag) {
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
      cs["status"] = "This is a bipartite graph!";
      cs["lineNo"] = 0;
      stateList.push(cs);
    }

    populatePseudocode(5);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.bridge = function(callback) {
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {}, bridge = {}, articulationPoint = {};
    var stateList = [];
    var cs;

    // check error
    if (amountVertex == 0) { // no graph
      $('#bridge-err').html('There is no graph to run this on. Please select an example graph first');
      return false;
    }

    if (DIRECTED_GR) {
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
      cs["status"] = "The input graph is not set as 'undirected' graph yet.<br>This algorithm only works with undirected graphs.";
      cs["lineNo"] = 0;
      stateList.push(cs);

      this.directedChange(); // force change

      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
      cs["status"] = "We add bidirectional edges as necessary and hide the arrows.<br>This action is irreversible (you may have to redraw your graph again).";
      cs["lineNo"] = 0;
      stateList.push(cs);
      //$('#bridge-err').html("This algorithm can only work for undirected graph.");
      //return false;
    }

    // main code
    var p = {}, stack = {}, stackNum = -1, Count = -1, low = {}, num = {}, lab = {}, labNum = 0;
    var ROOT, chilNum = {};
    for (var i = 0; i < amountVertex; ++i) {
      p[i] = lab[i] = -1, chilNum[i] = 0;
      iVL[i]["extratext"] = "N/A";
    }

    function highlightArticulationPointsAndBridges() {
      for (var key in bridge) {
        cs["el"][key]["state"] = EDGE_GREEN;
        for (var z = 0; z < amountEdge; ++z)
          if (iEL[z]["u"] == iEL[key]["v"] && iEL[z]["v"] == iEL[key]["u"])
            cs["el"][z]["state"] = EDGE_GREEN;
      }
      for (var key in articulationPoint) cs["vl"][key]["state"] = VERTEX_GREEN_OUTLINE;
    }

    for (var i = 0; i < amountVertex; ++i)
      if (p[i] == -1) {
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
        cs["status"] = "Vertex " + i + " has not been visited.<br>DFSCount = " + Count + ".";
        cs["lineNo"] = 1;
        highlightArticulationPointsAndBridges();
        stateList.push(cs);
        --p[i];
        ROOT = i;
        Tdfs(i);
      }

    function Tdfs(u) {
      stack[++stackNum] = u;
      num[u] = low[u] = ++Count;
      iVL[u]["extratext"] = "" + num[u] + "," + low[u];
      vertexTraversing[u] = true;
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
      cs["status"] = "DFS(" + u + ").<br>DFSCount = " + Count + ".";
      cs["lineNo"] = 2;
      highlightArticulationPointsAndBridges();
      stateList.push(cs);
      delete vertexHighlighted[u];

      var neighbors = [];
      for (var j = 0; j < amountEdge; j++) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
        if (lab[vertexB] == -1 && u == vertexA) {
          edgeHighlighted[j] = true;
          for (var z = 0; z < amountEdge; z ++)
            if (iEL[z]["u"] == vertexB && iEL[z]["v"] == vertexA)
              edgeHighlighted[z] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
          cs["status"] = "Try edge " + vertexA + " -> " + vertexB + "<br>DFSCount = " + Count + ".";
          cs["lineNo"] = 3;
          cs["el"][j]["animateHighlighted"] = true;
          highlightArticulationPointsAndBridges();
          stateList.push(cs);

          if (p[vertexB] == -1) {
            vertexTraversing[vertexB] = true;
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
            cs["status"] = "" + vertexB + " has not been visited<br>DFSCount = " + Count + ".";
            cs["lineNo"] = 4;
            highlightArticulationPointsAndBridges();
            stateList.push(cs);

            p[vertexB] = u;
            Tdfs(vertexB);
            chilNum[u]++;
            var thisStatus = "low[" + u + "] is unchanged.";
            if (low[u] > low[vertexB]) {
              low[u] = low[vertexB];
              thisStatus = "update low[" + u + "] from low[" + vertexB + "].<br>There is <b>another</b> path to go from vertex " + u + " to vertex with num " + low[u] + ".";
            }
            iVL[u]["extratext"] = "" + num[u] + "," + low[u];

            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
            cs["status"] = thisStatus;
            cs["lineNo"] = 5;
            highlightArticulationPointsAndBridges();
            stateList.push(cs);

            var thisStatus = "";
            if (low[vertexB] >= num[u] && u != ROOT) {
              thisStatus = thisStatus + "low[" + vertexB + "] >= num[" + u + "] and " + u + " is not the root, vertex " + u + " is a cut vertex.<br>";
              articulationPoint[u] = true;
            }
            else if (low[vertexB] >= num[u] && u == ROOT)
              thisStatus = thisStatus + "low[" + vertexB + "] >= num[" + u + "] but " + u + " is the root, so it is not a cut vertex.<br>";
            else
              thisStatus = thisStatus + "low[" + vertexB + "] < num[" + u + "], so " + u + " is not a cut vertex.<br>";

            if (low[vertexB] > num[u]) {
              thisStatus = thisStatus + "low[" + vertexB + "] > num[" + u + "], so edge (" + u + ", " + vertexB + ") is a bridge.";
              bridge[j] = true;
            }
            else
              thisStatus = thisStatus + "low[" + vertexB + "] <= num[" + u + "], so edge (" + u + ", " + vertexB + ") is not a bridge.";

            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
            cs["status"] = thisStatus;
            cs["lineNo"] = 6;
            highlightArticulationPointsAndBridges();
            stateList.push(cs);
          }
          else if (vertexB != p[u]) {
            var thisStatus = "low[" + u + "] is unchanged.";
            if (low[u] > num[vertexB]) {
              low[u] = num[vertexB];
              thisStatus = "update low[" + u + "] from num[" + vertexB + "].<br>There is <b>another</b> path to go from vertex " + u + " to vertex with num " + low[u] + ".";
            }
            iVL[u]["extratext"] = "" + num[u] + "," + low[u];
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
            cs["status"] = "" + vertexB + " is visited, " + thisStatus; // update low[" + u + "] from num[" + vertexB + "]<br>DFSCount = " + Count + ".";
            cs["lineNo"] = 7;
            highlightArticulationPointsAndBridges();
            stateList.push(cs);
          }
          else {
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
            cs["status"] = "" + vertexB + " is the parent of " + u + ", ignore!<br>DFSCount = " + Count + ".";
            cs["lineNo"] = 7;
            highlightArticulationPointsAndBridges();
            stateList.push(cs);
          }
        }
      }

      delete vertexTraversing[u];
      vertexHighlighted[u] = true;
      vertexTraversed[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
      cs["status"] = "Finish DFS(" + u + "), backtrack.<br>DFSCount = " + Count + ".";
      if (u == ROOT && chilNum[u] >= 2) {
        cs["status"] = "Finish DFS(" + u + "), " + u + " is the root and u has more than 1 childs<br>Hence " + u + " is an articulation point.";
        articulationPoint[u] = true;
      }
      cs["lineNo"] = 0;
      highlightArticulationPointsAndBridges();
      cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
      stateList.push(cs);
      delete vertexHighlighted[u];
    }

    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
    cs["status"] = "Finished.<br>Green vertices/edges are articulation points/bridges, respectively.";
    cs["lineNo"] = 0;
    highlightArticulationPointsAndBridges();
    stateList.push(cs);

    populatePseudocode(6);
    gw.startAnimation(stateList, callback);
    for (var key in iVL) iVL[key]["extratext"] = "";
    return true;
  }

  this.kosaraju = function(callback) {
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {}, hiddenEdge = {};
    var stateList = [];
    var cs;

    // check error
    if (amountVertex == 0) { // no graph
      $('#scc-err').html('There is no graph to run this on. Please select an example graph first');
      return false;
    }

    if (!DIRECTED_GR) {
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = "The input graph is not set as 'directed' graph yet.<br>This algorithm only works with directed graphs.";
      cs["lineNo"] = 0;
      stateList.push(cs);

      this.directedChange(); // force change

      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = "We turn on the directed graph mode.<br>This action is irreversible.";
      cs["lineNo"] = 0;
      stateList.push(cs);

      // $('#scc-err').html("Please make the graph directed");
      // return false;
    }

    // main code
    var p = {}, stack = {}, stackNum = -1, Count = 0, low = {}, num = {}, lab = {}, labNum = 0;
    for (var i = 0; i < amountVertex; ++i) {
      p[i] = lab[i] = -1;
      iVL[i]["extratext"] = "";
    }
    for (var i = 0; i < amountVertex; ++i)
      if (p[i] == -1) {
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
        cs["status"] = "Vertex " + i + " has not been visited.";
        cs["lineNo"] = 1;
        stateList.push(cs);
        p[i]--;
        Tdfs(i);
      }

    vertexHighlighted = {}, edgeHighlighted = {};
    vertexTraversed = {}, vertexTraversing = {};
    for (var j = 0; j < amountEdge; ++j) { // reverse edge directions
      var vertexA = iEL[j]["u"];
      var vertexB = iEL[j]["v"];
      iEL[j]["u"] = vertexB;
      iEL[j]["v"] = vertexA;
    }
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
    cs["status"] = "Then, we transpose the directed graph.";
    cs["lineNo"] = 4;
    stateList.push(cs);

    while (stackNum >= 0) {
      if (lab[stack[stackNum]] == -1) {
        ++labNum;
        DFS2(stack[stackNum]);
        for (var j = 0; j < amountEdge; ++j) {
          var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
          if (lab[vertexA] != lab[vertexB]) hiddenEdge[j] = true;
        }

        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
        cs["status"] = getStack() + ".<br>Finish DFS(" + stack[stackNum] + ") and we get 1 Strongly Connected Component.";
        cs["lineNo"] = 7;
        stateList.push(cs);
      }
      else {
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
        cs["status"] = getStack() + ".<br>" + stack[stackNum] + " is visited, ignore.";
        cs["lineNo"] = 5;
        stateList.push(cs);
      }
      stackNum--;
    }

    function getStack() {
      var status = "List = [";
      for (var i = stackNum; i > 0; i--) status = status + stack[i] + ",";
      if (stackNum >= 0) status += stack[0] + "]";
      else               status += "]";
      return status;
    }

    function Tdfs(u) {
      vertexTraversing[u] = true;
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = getStack() + ".<br>DFS(" + u + ").";
      cs["lineNo"] = 1;
      stateList.push(cs);
      delete vertexHighlighted[u];

      var neighbors = [];
      for (var j = 0; j < amountEdge; ++j) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
        if (lab[vertexB] == -1 && u == vertexA) {
          edgeHighlighted[j] = true;
          for (var key in iEL) if (iEL[key]["v"] == vertexA && iEL[key]["u"] == vertexB) edgeHighlighted[key] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
          cs["status"] = getStack() + ".<br>Try edge " + vertexA + " &rarr; " + vertexB + ".";
          cs["lineNo"] = 2;
          cs["el"][j]["animateHighlighted"] = true;
          stateList.push(cs);

          if (p[vertexB] == -1) {
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
            cs["status"] = getStack() + ".<br>Vertex " + vertexB + " has not been visited.";
            cs["lineNo"] = 2;
            stateList.push(cs);

            p[vertexB] = u;
            Tdfs(vertexB);
          }
        }
      }

      stack[++stackNum] = u;
      delete vertexTraversing[u];
      vertexTraversed[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = getStack() + ".<br>DFS(" + u + ") is completed, add " + u + " to the front of the list.";
      cs["lineNo"] = 3;
      stateList.push(cs);
    }

    function DFS2(u) {
      lab[u] = labNum;
      vertexTraversing[u] = true;
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = getStack() + "<br>DFS(" + u + ").";
      cs["lineNo"] = 5;
      stateList.push(cs);
      delete vertexHighlighted[u];

      var neighbors = [];
      for (var j = 0; j < amountEdge; ++j) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
        if (hiddenEdge[j] == null) {
          edgeHighlighted[j] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
          cs["status"] = getStack() + ".<br>Try edge " + vertexA + " &rarr; " + vertexB + ".";
          cs["lineNo"] = 6;
          cs["el"][j]["animateHighlighted"] = true;
          stateList.push(cs);

          if (lab[vertexB] == -1) {
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
            cs["status"] = getStack() + "<br>Vertex " + vertexB + " has not been visited.";
            cs["lineNo"] = 6;
            stateList.push(cs);

            DFS2(vertexB);
          }
          else {
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
            cs["status"] = getStack() + "<br>" + vertexB + " is visited";
            cs["lineNo"] = 6;
            stateList.push(cs);
          }
        }
      }

      delete vertexTraversing[u];
      vertexTraversed[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = getStack() + "<br>DFS from " + u + " is completed, back to the parent";
      cs["lineNo"] = 5;
      stateList.push(cs);
    }

    for (var i = 0; i < amountEdge; ++i) {
      var vertexA = iEL[i]["u"];
      var vertexB = iEL[i]["v"];
      iEL[i]["u"] = vertexB;
      iEL[i]["v"] = vertexA;
    }
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
    cs["status"] = "We transpose the directed graph again.<br>In total, we have " + labNum + " Strongly Connected Component(s) as seen above.";
    cs["lineNo"] = 0;
    stateList.push(cs);

    populatePseudocode(7);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.tarjan = function(callback) {
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {}, hiddenEdge = {};
    var stateList = [];
    var cs;

    //check error
    if (amountVertex == 0) { // no graph
      $('#scc-err').html('There is no graph to run this on. Please select an example graph first');
      return false;
    }

    if (!DIRECTED_GR) {
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = "The input graph is not set as 'directed' graph yet.<br>This algorithm only works with directed graphs.";
      cs["lineNo"] = 0;
      stateList.push(cs);

      this.directedChange(); // force change

      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = "We turn on the directed graph mode.<br>This action is irreversible.";
      cs["lineNo"] = 0;
      stateList.push(cs);

      // $('#scc-err').html("Please make the graph directed");
      // return false;
    }

    // main code
    var p = {}, stack = {}, stackNum = -1, Count = -1, low = {}, num = {}, lab = {}, labNum = 0;
    for (var i = 0; i < amountVertex; ++i) {
      p[i] = lab[i] = -1
      iVL[i]["extratext"] = "N/A";
    }
    for (var i = 0; i < amountVertex; ++i)
      if (p[i] == -1) {
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
        cs["status"] = "Vertex " + i + " has not been visited.";
        cs["lineNo"] = 1;
        stateList.push(cs);
        p[i]--;
        Tdfs(i);
      }

    function getStack() {
      var status = "Stack = [";
      for (var i = 0; i < stackNum; ++i) status = status + stack[i] + ",";
      if (stackNum >= 0) status += stack[stackNum] + "]";
      else               status += "]";
      return status;
    }

    function Tdfs(u) {
      stack[++stackNum] = u;
      num[u] = low[u] = ++Count;
      iVL[u]["extratext"] = "" + num[u] + "," + low[u];
      vertexTraversing[u] = true;
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = getStack() + ".<br>DFS(" + u + ").";
      cs["lineNo"] = 2;
      stateList.push(cs);
      delete vertexHighlighted[u];

      var neighbors = [];
      for (var j = 0; j < amountEdge; ++j) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
        if (lab[vertexB] == -1 && u == vertexA) {
          edgeHighlighted[j] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
          cs["status"] = getStack() + "<br>Try edge " + vertexA + " &rarr; " + vertexB + ".";
          cs["lineNo"] = 3;
          cs["el"][j]["animateHighlighted"] = true;
          stateList.push(cs);

          if (p[vertexB] == -1) {
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
            cs["status"] = getStack() + "<br>Vertex " + vertexB + " has not been visited.";
            cs["lineNo"] = 4;
            stateList.push(cs);

            p[vertexB] = u;
            Tdfs(vertexB);
            if (low[u] > low[vertexB]) low[u] = low[vertexB];
          }
          else {
            if (low[u] > num[vertexB]) low[u] = num[vertexB];
          }
          iVL[u]["extratext"] = "" + num[u] + "," + low[u];
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
          cs["status"] = getStack() + "<br>Update low[" + u + "]."; // ambiguous for now " = min(num[" + vertexB + "], low[" + vertexB + "]).";
          cs["lineNo"] = 5;
          stateList.push(cs);
        }
      }

      delete vertexTraversing[u];
      vertexTraversed[u] = true;
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = getStack() + "<br>DFS(" + u + ") is completed, check if vertex " + u + " is the root of this SCC.";
      cs["lineNo"] = 6;
      stateList.push(cs);
      if (low[u] == num[u]) {
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
        cs["status"] = getStack() + "<br>low[" + u + "] == num[" + u + "], that means this vertex " + u + " is the root of this SCC.";
        cs["lineNo"] = 6;
        stateList.push(cs);
        var oldPos = stackNum;
        ++labNum;
        while (stack[stackNum] != u)
          lab[stack[stackNum--]] = labNum;
        lab[stack[stackNum--]] = labNum;

        for (var i = stackNum+1; i <= oldPos; ++i)
          vertexHighlighted[stack[i]] = true;
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
        cs["status"] = getStack() + "<br>We pop the stack until we get vertex " + u + ".";
        cs["lineNo"] = 7;
        stateList.push(cs);
        for (var i = stackNum+1; i <= oldPos; ++i)
          delete vertexHighlighted[stack[i]];

        for (var j = 0; j < amountEdge; ++j) {
          var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
          if (lab[vertexA] != lab[vertexB]) hiddenEdge[j] = true;
        }
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
        cs["status"] = getStack() + "<br>We get 1 Strongly Connected Component.";
        cs["lineNo"] = 7;
        stateList.push(cs);
      }
      delete vertexHighlighted[u];
    }

    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
    cs["status"] = "In total, we have " + labNum + " Strongly Connected Component(s) as seen above.";
    cs["lineNo"] = 1;
    stateList.push(cs);
    for (var key in iVL) iVL[key]["extratext"] = "";

    populatePseudocode(8);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.twosat = function(numOfRows, numOfColumns) {
    var vertexHighlighted = {}, edgeHighlighted = {};
    var stateList = [];
    var cs;
    var currentX = 0, currentY = -170, centerX = 200, centerY = 200;

    DIRECTED_GR = true;
    numOfColumns *= 2;
    var blocked = new Array(numOfRows+1);
    for (var i = 0; i <= numOfRows; ++i) {
      blocked[i] = new Array(numOfColumns+1);
      for (var j = 0; j <= numOfColumns; ++j)
        blocked[i][j] = false;
    }

    if (numOfRows < 1 || numOfRows > 5) {
      $('#twosat-err').html("The number of clauses must be [1..5].");
      return false;
    }

    if (numOfColumns < 1 || numOfColumns > 10) {
      $('#twosat-err').html("The number of variables must be [1..5].");
      return false;
    }

    $('#twosat-err').html("");

    this.checkInputt = function(XX) {
      var cc = 0;
      for (var j = 1; j <= numOfColumns; ++j)
        if (blocked[XX][j])
          ++cc;
      return cc;
    }

    this.checkInput = function() { // each clause can only have two variables
      for (var i = 1; i <= numOfRows; ++i) {
        var cc = 0;
        for (var j = 1; j <= numOfColumns; ++j) if (blocked[i][j]) ++cc;
        if (cc != 2) return false;
      }
      return true;
    }

    this.changeState = function(rowIndex, columnIndex) {
      var temp = '#cell' + rowIndex + columnIndex;
      if (blocked[rowIndex][columnIndex]) {
        $(temp).attr("bgcolor", "white");
        blocked[rowIndex][columnIndex] = false;
      }
      else {
        $(temp).attr("bgcolor", "black");
        blocked[rowIndex][columnIndex] = true;
      }
      if (this.checkInputt(rowIndex) > 2) {
        $('#twosat-board-err').html("Row " + rowIndex + " has more than 2 black cells.")
          .delay(1000)
          .queue(function(n) {
            $(this).html("");
          });
      }
    }

    this.createGraph = function() {
      iVL = {};
      iEL = {};
      amountEdge = 0;
      amountVertex = numOfColumns;

      getvar = function(i) { return i%2 == 0 ? "-x" + (i/2+1) : "x" + (i+1)/2; }
      getOpp = function(i) { return i%2 == 0 ? i+1 : i-1; }

      for (var i = 1; i <= numOfColumns; ++i) {
        var angle = Math.acos(-1)*2/amountVertex;
        var x1 = currentX * Math.cos(angle) - currentY*Math.sin(angle);
        var y1 = currentX * Math.sin(angle) + currentY*Math.cos(angle);
        currentX = x1, currentY = y1;
        iVL[i-1] = {
          "x": currentX+centerX,
          "y": currentY+centerY,
          "extratext": i%2 == 0 ? "x" + i/2 : "-x" + (i+1)/2
        }
      }

      cs = createState(iVL, iEL);
      cs["status"] = "Create 2 vertices for each variable.<br>One for xi, the other for -xi.";
      cs["lineNo"] = 1;
      stateList.push(cs);

      for (var i = 1; i <= numOfRows; ++i) { // clauses
        var a, b;
        for (var j = 0; j < numOfColumns; ++j) if (blocked[i][j+1]) a = j; // a
        for (var j = numOfColumns-1; j >= 0; --j) if (blocked[i][j+1]) b = j; // b
        // clause = (a v b)
        var pos1 = -1, pos2 = -1;
        var flag = true;
        for (var j = 0; j < amountEdge; --j) {
console.log(iEL[j]); // not sure why doing this printout solves the bug
          if ((iEL[j]["u"] == getOpp(a)) && (iEL[j]["v"] == b))
            flag = false, pos1 = j;
        }
        if (flag && (getOpp(a) !== b)) {
          iEL[amountEdge++] = {
            "u": getOpp(a),
            "v": b,
            "w": 1
          }
          pos1 = amountEdge-1;
        }

        flag = true;
        for (var j = 0; j < amountEdge; ++j) {
console.log(iEL[j]); // not sure why doing this printout solves the bug
          if ((iEL[j]["u"] == getOpp(b)) && (iEL[j]["v"] == a))
            flag = false, pos2 = j;
        }
        if (flag && (getOpp(b) !== a)) {
          iEL[amountEdge++] = {
            "u": getOpp(b),
            "v": a,
            "w": 1
          }
          pos2 = amountEdge-1;
        }

        cs = createState(iVL, iEL);
        cs["status"] = "Clause = (" + getvar(a) + " or " + getvar(b) + ").<br>" +
                       "Create edge " + getvar(getOpp(a)) + " &rarr; " + getvar(b) + " (" + getOpp(a) + " &rarr; " + b + ") and " + getvar(getOpp(b)) + " &rarr; " + getvar(a) + " (" + getOpp(b) + " &rarr; " + a + ").";
        cs["lineNo"] = [2, 3];
        if (pos1 != -1) cs["el"][pos1]["animateHighlighted"] = true;
        if (pos2 != -1) cs["el"][pos2]["animateHighlighted"] = true;
        stateList.push(cs);
      }
      return true;
    }

    this.runAlgo = function() {
      var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {}, hiddenEdge = {};
      var cs;

      cs = createState(iVL, iEL);
      cs["status"] = "We run an SCC finding algorithm (either Kosaraju's or Tarjan's) to see if there is a conflict (a variable and its negation in the same SCC).";
      cs["lineNo"] = 4;
      stateList.push(cs);

      // main code
      var p = {}, stack = {}, stackNum = -1, Count = 0, low = {}, num = {}, lab = {}, labNum = 0;
      for (var i = 0; i < amountVertex; ++i)
        p[i] = lab[i] = -1;
      for (var i = 0; i < amountVertex; ++i)
        if (p[i] == -1) {
          p[i]--;
          Tdfs(i);
        }

      for (var j = 0; j < amountEdge; ++j) {
        var vertexA = iEL[j]["u"];
        var vertexB = iEL[j]["v"];
        iEL[j]["u"] = vertexB;
        iEL[j]["v"] = vertexA;
      }

      while (stackNum >= 0) {
        if (lab[stack[stackNum]] == -1) {
          ++labNum;
          DFS2(stack[stackNum]);
          var flag = -1;
          for (var z = 0; z < amountVertex; z += 2)
            if ((lab[z] == lab[z+1]) && (lab[z] == labNum))
              flag = z;

          if (flag != -1) {
            for (var key in iVL)
              if (lab[key] == lab[flag])
                vertexTraversed[key] = true;
            vertexHighlighted[flag] = vertexHighlighted[flag+1] = true;
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
            cs["status"] = "" + getvar(flag) + " (vertex " + flag + ") and " + getvar(flag+1) + " (vertex " + (flag+1) + ") are in the same SCC.<br>The 2-SAT instance is not satisfiable!";
            cs["lineNo"] = 7;
            stateList.push(cs);
            return true;
          }
        }
        stackNum--;
      }

      function Tdfs(u) {
        var neighbors = [];
        for (var j = 0; j < amountEdge; ++j) if (iEL[j]["u"] == u) neighbors.push(j);
        neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

        while (neighbors.length > 0) {
          var j = neighbors.shift();
          var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
          if (lab[vertexB] == -1 && u == vertexA)
            if (p[vertexB] == -1) {
              p[vertexB] = u;
              Tdfs(vertexB);
            }
        }

        stack[++stackNum] = u;
      }

      function DFS2(u) {
        lab[u] = labNum;

        var neighbors = [];
        for (var j = 0; j < amountEdge; ++j) if (iEL[j]["u"] == u) neighbors.push(j);
        neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

        while (neighbors.length > 0) {
          var j = neighbors.shift();
          var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
          if (hiddenEdge[j] == null)
            if (lab[vertexB] == -1)
              DFS2(vertexB);
        }
      }

      for (var i = 0; i < amountEdge; ++i) {
        var vertexA = iEL[i]["u"];
        var vertexB = iEL[i]["v"];
        iEL[i]["u"] = vertexB;
        iEL[i]["v"] = vertexA;
      }

      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = "SCC algorithm is completed without any conflict.<br>So the 2-SAT instance is satisfiable!";
      cs["lineNo"] = 5;
      stateList.push(cs);
    }

    this.CloseBox = function() {
      $('.overlays').hide("slow");
      $('#dark-overlay').hide("slow");
      $('#rookattack-board').hide("slow");
    }

    this.inputExample1 = function() {
      numOfRows = 2;
      numOfColumns = 4;
      blocked = new Array(numOfRows+1);
      for (var i = 0; i <= numOfRows; ++i) {
        blocked[i] = new Array(numOfColumns+1);
        for (var j = 0; j <= numOfColumns; ++j)
          blocked[i][j] = false;
      }
      var toWrite = '<html>\n';
      toWrite += '<br>Click on any cell to toggle between black/white cell</br>\n';
      toWrite += '<br>Each black cell presents a clause. Each row should have exactly 2 black cells.</br>\n';
      toWrite += '<table border="1" id="board">'
      for (var j = 0; j <= numOfColumns; ++j)
        toWrite += '<col width="50">';

      toWrite += '<tr><td height="50" bgcolor="white" id="cell00"></td>';
      for (var j = 1; j <= numOfColumns; j++)
        if (j % 2 == 1)
          toWrite += '<td height="50" bgcolor="white" id="cell' + 0 + j + '">-x' + (j + 1) / 2 + '</td>';
        else
          toWrite += '<td height="50" bgcolor="white" id="cell' + 0 + j + '">x' + j / 2 + '</td>';
      toWrite += "</tr>"

      for (var i = 1; i <= numOfRows; ++i) {
        toWrite += '<tr>';
        toWrite += '<td height="50" bgcolor="white" id="cell00">' + i + '</td>';
        for (var j = 1; j <= numOfColumns; ++j)
          toWrite += '<td height="50" bgcolor="white" id="cell' + i + j + '" onclick=gtw.changeState(' + i + ',' + j + ')></td>';
        toWrite += '</tr>';
      }

      toWrite += '</table>\n';
      toWrite += '<button onclick=gtw.inputRandomized()>Randomized</button>';
      toWrite += '<button onclick=gtw.inputFinished()>Done</button>';
      toWrite += '<button onclick=gtw.inputExample1()>Example 1</button>';
      toWrite += '<button onclick=gtw.inputExample2()>Example 2</button>';3
      toWrite += '<button onclick=gtw.CloseBox()>Close</button>';
      toWrite += '<div id="twosat-board-err" class="err"></div>';
      toWrite += '</html>\n';
      $('#twosat-board').html(toWrite);

      this.changeState(1, 1);
      this.changeState(1, 3);
      this.changeState(2, 2);
      this.changeState(2, 4);
    }

    this.inputExample2 = function() {
      numOfRows = 4;
      numOfColumns = 6;
      blocked = new Array(numOfRows+1);
      for (var i = 0; i <= numOfRows; i++) {
        blocked[i] = new Array(numOfColumns+1);
        for (var j = 0; j <= numOfColumns; j++)
          blocked[i][j] = false;
      }
      var toWrite = '<html>\n';
      toWrite += '<br>Click on any cell to toggle between black/white cell</br>\n';
      toWrite += '<br>Each black cell presents a clause. Each row should have exactly 2 black cells.</br>\n';
      toWrite += '<table border="1" id="board">'
      for (var j = 0; j <= numOfColumns; ++j)
        toWrite += '<col width="50">';

      toWrite += '<tr><td height="50" bgcolor="white" id="cell00"></td>';
      for (var j = 1; j <= numOfColumns; j++)
        if (j % 2 == 1)
          toWrite += '<td height="50" bgcolor="white" id="cell' + 0 + j + '">-x' + (j + 1) / 2 + '</td>';
        else
          toWrite += '<td height="50" bgcolor="white" id="cell' + 0 + j + '">x' + j / 2 + '</td>';
      toWrite += "</tr>"

      for (var i = 1; i <= numOfRows; ++i) {
        toWrite += '<tr>';
        toWrite += '<td height="50" bgcolor="white" id="cell00">' + i + '</td>';
        for (var j = 1; j <= numOfColumns; ++j)
          toWrite += '<td height="50" bgcolor="white" id="cell' + i + j + '" onclick=gtw.changeState(' + i + ',' + j + ')></td>';
        toWrite += '</tr>';
      }

      toWrite += '</table>\n';
      toWrite += '<button onclick=gtw.inputRandomized()>Randomized</button>';
      toWrite += '<button onclick=gtw.inputFinished()>Done</button>';
      toWrite += '<button onclick=gtw.inputExample1()>Example 1</button>';
      toWrite += '<button onclick=gtw.inputExample2()>Example 2</button>';
      toWrite += '<button onclick=gtw.CloseBox()>Close</button>';
      toWrite += '<div id="twosat-board-err" class="err"></div>';
      toWrite += '</html>\n';
      $('#twosat-board').html(toWrite);

      this.changeState(1, 2);
      this.changeState(1, 4);
      this.changeState(2, 1);
      this.changeState(2, 4);
      this.changeState(3, 3);
      this.changeState(3, 6);
      this.changeState(4, 3);
      this.changeState(4, 5);
    }

    this.inputFinished = function() {
      if (!this.checkInput()) {
        $('#twosat-board-err').html("Each row should have exactly 2 black cells.")
          .delay(1000)
          .queue(function(n) {
            $(this).html("");
          });
        return false;
      }

      $('.overlays').hide("slow");
      $('#dark-overlay').hide("slow");
      $('#rookattack-board').hide("slow");
      this.createGraph();
      this.runAlgo();
      gw.startAnimation(stateList);
      $('#current-action').show();
      $('#current-action p').html("2-SAT Modeling");
      $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
      triggerRightPanels();
      populatePseudocode(9);
      isPlaying = true;
      return true;
    }

    this.inputRandomized = function() {
      var randNumMin = 1;
      var randNumMax = numOfColumns;
      for (var i = 1; i <= numOfRows; i++) {
        for (var j = 1; j <= numOfColumns; j++)
          if (blocked[i][j])
            this.changeState(i, j);
        var a = (Math.floor(Math.random() * (randNumMax-randNumMin+1)) + randNumMin);
        var b = (Math.floor(Math.random() * (randNumMax-randNumMin+1)) + randNumMin);
        while (a == b)
          b = (Math.floor(Math.random() * (randNumMax-randNumMin+1)) + randNumMin);
        this.changeState(i, a);
        this.changeState(i, b);
      }
    }

    $('#dark-overlay').show("slow");
    var toWrite = '<html>\n';
    toWrite += '<br>Click on any cell to toggle between black/white cell</br>\n';
    toWrite += '<br>Each black cell presents a clause. Each row should have exactly 2 black cells.</br>\n';
    toWrite += '<table border="1" id="board">'
    for (var j = 0; j <= numOfColumns; ++j)
      toWrite += '<col width="50">';

    toWrite += '<tr><td height="50" bgcolor="white" id="cell00"></td>';
    for (var j = 1; j <= numOfColumns; j++)
      if (j % 2 == 1)
        toWrite += '<td height="50" bgcolor="white" id="cell' + 0 + j + '">-x' + (j+1)/2 + '</td>';
      else
        toWrite += '<td height="50" bgcolor="white" id="cell' + 0 + j + '">x' + j/2 + '</td>';
    toWrite += "</tr>"

    for (var i = 1; i <= numOfRows; ++i) {
      toWrite += '<tr>';
      toWrite += '<td height="50" bgcolor="white" id="cell00">' + i + '</td>';
      for (var j = 1; j <= numOfColumns; ++j)
        toWrite += '<td height="50" bgcolor="white" id="cell' + i + j + '" onclick=gtw.changeState(' + i + ',' + j + ')></td>';
      toWrite += '</tr>';
    }

    toWrite += '</table>\n';
    toWrite += '<button onclick=gtw.inputRandomized()>Randomized</button>';
    toWrite += '<button onclick=gtw.inputFinished()>Done</button>';
    toWrite += '<button onclick=gtw.inputExample1()>Example 1</button>';
    toWrite += '<button onclick=gtw.inputExample2()>Example 2</button>';
    toWrite += '<button onclick=gtw.CloseBox()>Close</button>';
    toWrite += '<div id="twosat-board-err" class="err"></div>';
    toWrite += '</html>\n';
    $('#twosat-board').html(toWrite);
    $('#twosat-board').show("slow");
  }

  this.examples = function(id) {
    iVL = getExampleGraph(id, VL);
    iEL = getExampleGraph(id, EL);
    amountVertex = 0;
    amountEdge = 0;
    for (var key in iVL) amountVertex++;
    for (var key in iEL) amountEdge++;

    DIRECTED_GR = true;
    OLD_POSITION = amountEdge;

    var newState = createState(iVL, iEL);
    gw.removeAll();
    gw.updateGraph(newState, 500);
    if (id == DFSBFSLARGE || id == DFSBFSLARGECYCLES) {
      setMediumScale();
    }
    return true;
  }

  this.loadGraph = function(vertexList, edgeList) {
    iVL = vertexList;
    iEL = edgeList;
    fixJSON();
    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
  }

  function createState(iVLObject, iELObject, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge) {
    if (vertexHighlighted == null) vertexHighlighted = {};
    if (edgeHighlighted == null) edgeHighlighted = {};
    if (vertexTraversed == null) vertexTraversed = {};
    if (vertexTraversing == null) vertexTraversing = {};
    if (treeEdge == null) treeEdge = {};
    if (backEdge == null) backEdge = {};
    if (crossEdge == null) crossEdge = {};
    if (forwardEdge == null) forwardEdge = {};
    if (hiddenEdge == null) hiddenEdge = {};

    var key, state = {
      "vl": {},
      "el": {}
    };

    for (key in iVLObject) {
      state["vl"][key] = {};
      state["vl"][key]["cx"] = iVLObject[key]["x"];
      state["vl"][key]["cy"] = iVLObject[key]["y"];
      state["vl"][key]["text"] = key;
      state["vl"][key]["extratext"] = iVLObject[key]["extratext"];
      if (iVLObject[key]["state"] == OBJ_HIDDEN)
        state["vl"][key]["state"] = OBJ_HIDDEN;
      else
        state["vl"][key]["state"] = VERTEX_DEFAULT;
    }

    for (key in iELObject) {
      state["el"][key] = {};
      state["el"][key]["vertexA"] = iELObject[key]["u"];
      state["el"][key]["vertexB"] = iELObject[key]["v"];
      if (DIRECTED_GR == false)
        state["el"][key]["type"] = EDGE_TYPE_UDE;
      else
        state["el"][key]["type"] = EDGE_TYPE_DE;
      state["el"][key]["weight"] = iELObject[key]["w"];
      if (iELObject[key]["state"] == OBJ_HIDDEN)
        state["el"][key]["state"] = OBJ_HIDDEN;
      else
        state["el"][key]["state"] = EDGE_DEFAULT;
      state["el"][key]["displayWeight"] = false;
      state["el"][key]["animateHighlighted"] = false;
    }

    for (key in vertexTraversed) state["vl"][key]["state"] = VERTEX_TRAVERSED;
    for (key in vertexTraversing) state["vl"][key]["state"] = VERTEX_BLUE_OUTLINE;
    for (key in treeEdge) state["el"][key]["state"] = EDGE_RED;
    for (key in backEdge) state["el"][key]["state"] = EDGE_BLUE;
    for (key in crossEdge) state["el"][key]["state"] = EDGE_GREEN; // apparently I haven't even use this yet
    for (key in forwardEdge) state["el"][key]["state"] = EDGE_GREY;

    for (key in vertexHighlighted) state["vl"][key]["state"] = VERTEX_BLUE_FILL; // HIGHLIGHTED;
    for (key in edgeHighlighted) {
      state["el"][key]["state"] = EDGE_HIGHLIGHTED;
      for (var keyR in iEL) if ((iEL[key]["u"] == iEL[keyR]["v"]) && (iEL[key]["v"] == iEL[keyR]["u"])) edgeHighlighted[keyR] = true;
    }

    for (key in hiddenEdge) state["el"][key]["state"] = EDGE_GREY;

    return state;
  }

  function populatePseudocode(act) {
    switch (act) {
      case 0: // DFS
        $('#code1').html('DFS(u)');
        $('#code2').html('for each neighbor v of u');
        $('#code3').html('&nbsp;&nbsp;if v is unvisited, tree edge, DFS(v)');
        $('#code4').html('&nbsp;&nbsp;else if v is explored, bidirectional/back edge');
        $('#code5').html('&nbsp;&nbsp;else if v is visited, forward/cross edge');
        $('#code6').html('// <b><a href="http://cpbook.net/#downloads" target="_blank">ch4_01_dfs.cpp/java, ch4, CP3</a></b>');
        $('#code7').html('');
        break
      case 1: // BFS
        $('#code1').html('BFS(u), Q = {u}');
        $('#code2').html('while !Q.empty // Q is a normal queue');
        $('#code3').html('&nbsp;&nbsp;for each neighbor v of u = Q.front, Q.pop');
        $('#code4').html('&nbsp;&nbsp;&nbsp;&nbsp;if v is unvisited, tree edge, Q.push(v)');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;else if v is visited, we ignore this edge'); // bidirectional/back edge
        $('#code6').html('// <b><a href="http://cpbook.net/#downloads" target="_blank">ch4_04_bfs.cpp/java, ch4, CP3</a></b>');
        $('#code7').html('');
        break;
      case 2: // Topological Sort using DFS
        $('#code1').html('for each unvisited vertex u');
        $('#code2').html('&nbsp;&nbsp;DFS(u)');
        $('#code3').html('&nbsp;&nbsp;&nbsp;&nbsp;for each neighbor v of u');
        $('#code4').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if v is unvisited, DFS(v)');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;else skip v;');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;finish DFS(u), add u to the back of list');
        $('#code7').html('reverse list // <b><a href="http://cpbook.net/#downloads" target="_blank">ch4_01_dfs.cpp/java, ch4, CP3</a></b>');
        break
      case 3: // Topological Sort using BFS
        $('#code1').html('add vertices with no incoming edge to queue Q');
        $('#code2').html('while !Q.empty // Q is a normal queue');
        $('#code3').html('&nbsp;&nbsp;u = Q.front, Q.pop, add u to the back of list');
        $('#code4').html('&nbsp;&nbsp;for each neighbor v of u');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;delete edge u &rarr; v');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;if v has no incoming edge, add v to queue');
        $('#code7').html('// done'); // not in CP3, only as exercise at the moment?
        break;
      case 4: // bipartite DFS
        $('#code1').html('for each unvisited vertex u');
        $('#code2').html('&nbsp;&nbsp;DFS(u)');
        $('#code3').html('&nbsp;&nbsp;&nbsp;&nbsp;for each neighbor v of u');
        $('#code4').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if v is unvisited, different color, DFS(v)');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if u and v have the same color');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not bipartite graph, exit.');
        $('#code7').html(''); // not in CP3, only as exercise at the moment? // <b><a href="http://cpbook.net/#downloads" target="_blank">ch4_01_dfs.cpp/java, ch4, CP3</a></b>');
        break
      case 5: // bipartite BFS
        $('#code1').html('for each unvisited vertex u');
        $('#code2').html('&nbsp;&nbsp;push u to the queue');
        $('#code3').html('&nbsp;&nbsp;while !Q.empty // Q is a normal queue');
        $('#code4').html('&nbsp;&nbsp;&nbsp;&nbsp;for each neighbor v of u = Q.front, Q.pop');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if u and v have the same color &rarr; exit');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assign another color to v, push v to queue');
        $('#code7').html('// <b><a href="http://cpbook.net/#downloads" target="_blank">ch4_01_dfs.cpp/java, ch4, CP3</a></b>');
        break
      case 6: // articulation points and bridges
        $('#code1').html('try all vertex u, if u hasnt been visited, DFS(u)');
        $('#code2').html('DFS(u), initiate num[u] = low[u] = DFSCount');
        $('#code3').html('&nbsp;&nbsp;try all neighbor v of u');
        $('#code4').html('&nbsp;&nbsp;&nbsp;&nbsp;if v is free, DFS(v)');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;low[u] = min(low[u], low[v])');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;check the condition');
        $('#code7').html('&nbsp;&nbsp;&nbsp;&nbsp;else low[u] = min(low[u], num[v])');
        break;
      case 7: // Kosaraju's algorithm
        $('#code1').html('for each unvisited vertex u, DFS(u)');
        $('#code2').html('&nbsp;&nbsp;try all free neighbor v of u, DFS(v)');
        $('#code3').html('&nbsp;&nbsp;finish DFS(u), add u to the front of list');
        $('#code4').html('transpose the graph');
        $('#code5').html('DFS in order of the list, DFS(u)');
        $('#code6').html('&nbsp;&nbsp;try all free neighbor v of u, DFS(v)');
        $('#code7').html('each time we complete a DFS, we get an SCC');
        break;
      case 8: // Tarjan's algorithm
        $('#code1').html('for each unvisited vertex u');
        $('#code2').html('&nbsp;&nbsp;DFS(u), s.push(u), num[u] = low[u] = DFSCount');
        $('#code3').html('&nbsp;&nbsp;&nbsp;&nbsp;for each neighbor v of u');
        $('#code4').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if v is unvisited, DFS(v)');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;low[u] = min(low[u], low[v])');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;if low[u] == num[u] // root of an SCC');
        $('#code7').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop from stack s until we get u');
        break;
      case 9: // two-sat
        $('#code1').html('create graph, each variable creates 2 vertices');
        $('#code2').html('for clause (a or b)');
        $('#code3').html('&nbsp;&nbsp;create edge -a &rarr; b and -b &rarr; a');
        $('#code4').html('run scc algorithm');
        $('#code5').html('if no conflict, the 2-SAT instance is satisfiable');
        $('#code6').html('if a variable and its negation are in the same SCC');
        $('#code7').html('&nbsp;&nbsp;the 2-SAT instance is not satisfiable');
        break;
    }
  }
}



// Graph Traversal action
var actionsWidth = 180;
var statusCodetraceWidth = 410;

/*
// turned off these manual menu stuff on 26 Feb, if all working as expected, remove this
var isExamplesOpen = false, isBFSOpen = false, isDFSOpen = false, isTopoOpen = false, isBipartiteOpen = false, isBridgeOpen = false, isSCCOpen = false, is2SATOpen = false;

function openExamples() {
  if (!isExamplesOpen) {
    $('.examples').fadeIn('fast');
    isExamplesOpen = true;
  }
}

function closeExamples() {
  if (isExamplesOpen) {
    $('.examples').fadeOut('fast');
    isExamplesOpen = false;
  }
}

function openDFS() {
  if (!isDFSOpen) {
    $('.dfs').fadeIn('fast');
    isDFSOpen = true;
  }
}

function closeDFS() {
  if (isDFSOpen) {
    $('.dfs').fadeOut('fast');
    $('#dfs-err').html("");
    isDFSOpen = false;
  }
}

function openBFS() {
  if (!isBFSOpen) {
    $('.bfs').fadeIn('fast');
    isBFSOpen = true;
  }
}

function closeBFS() {
  if (isBFSOpen) {
    $('.bfs').fadeOut('fast');
    $('#bfs-err').html("");
    isBFSOpen = false;
  }
}

function openTopo() {
  if (!isTopoOpen) {
    $('.topo').fadeIn('fast');
    isTopoOpen = true;
  }
}

function closeTopo() {
  if (isTopoOpen) {
    $('.topo').fadeOut('fast');
    $('#topo-err').html("");
    isTopoOpen = false;
  }
}

function openBipartite() {
  if (!isBipartiteOpen) {
    $('.bipartite').fadeIn('fast');
    isBipartiteOpen = true;
  }
}

function closeBipartite() {
  if (isBipartiteOpen) {
    $('.bipartite').fadeOut('fast');
    $('#bipartite-err').html("");
    isBipartiteOpen = false;
  }
}

function openBridge() {
  if (!isBridgeOpen) {
    $('.bridge').fadeIn('fast');
    isBridgeOpen = true;
  }
}

function closeBridge() {
  if (isBridgeOpen) {
    $('.bridge').fadeOut('fast');
    $('#bridge-err').html("");
    isBridgeOpen = false;
  }
}

function openScc() {
  if (!isSCCOpen) {
    $('.scc').fadeIn('fast');
    isSCCOpen = true;
  }
}

function closeScc() {
  if (isSCCOpen) {
    $('.scc').fadeOut('fast');
    $('#scc-err').html("");
    isSCCOpen = false;
  }
}

function open2sat() {
  $('#twosat-v1').val(3);
  $('#twosat-v2').val(3);
  if (!is2SATOpen) {
    $('.twosat').fadeIn('fast');
    is2SATOpen = true;
  }
}

function close2sat() {
  if (is2SATOpen) {
    $('.twosat').fadeOut('fast');
    $('#twosat-err').html("");
    is2SATOpen = false;
  }
}

function hideEntireActionsPanel() {
  closeExamples();
  closeDFS();
  closeBFS();
  closeTopo();
  closeBipartite();
  closeBridge();
  closeScc();
  close2sat();
  hideActionsPanel();
}
*/


// local
write(false, true);
var gtw, gw, randomGraphID;

$(function() {
  $('#play').hide();
  gtw = new GraphTraversal(scale);
  gw = gtw.getGraphWidget();
  gw.setAnimationDuration(700 / speedVal); // patch on 17 Apr 23 by Steven to make playback speed works as intended upon page load, need to do this only after gw is defined...

  var options = [CP3_4_1, CP3_4_3, CP3_4_4, CP3_4_9, CP3_4_17, CP3_4_18, CP3_4_19, DFSBFSLARGE, DFSBFSLARGECYCLES];
  gtw.examples(options[Math.floor(Math.random()*7)]);
  randomGraphID = -1;
  var directed = getQueryVariable("directed"); // ask for this first
  var graphJSON = getQueryVariable("create");
  if (graphJSON.length > 0) {
    importjson(graphJSON);
    window.history.pushState("object or string", "Title", window.location.href.split('?')[0]);
  }
  if (directed.length > 0) {
    directed = parseInt(directed);
    if (directed === 0)
      directedChange();
  }
  userGraph = gtw.getGraph(); // save the current graph

/*
  $('#examples').click(function() {
    openExamples();
    closeDFS();
    closeBFS();
    closeTopo();
    closeBipartite();
    closeBridge();
    closeScc();
    close2sat();
  });

  $('#directedChange').click(function() {
    closeExamples();
    closeDFS();
    closeBFS();
    closeTopo();
    closeBipartite();
    closeBridge();
    closeScc();
    close2sat();
  });

  $('#dfs').click(function() {
    closeExamples();
    openDFS();
    closeBFS();
    closeTopo();
    closeBipartite();
    closeBridge();
    closeScc();
    close2sat();
  });

  $('#bfs').click(function() {
    closeExamples();
    closeDFS();
    openBFS();
    closeTopo();
    closeBipartite();
    closeBridge();
    closeScc();
    close2sat();
  });

  $('#topo').click(function() {
    closeExamples();
    closeDFS();
    closeBFS();
    openTopo();
    closeBipartite();
    closeBridge();
    closeScc();
    close2sat();
  });

  $('#bipartite').click(function() {
    closeExamples();
    closeDFS();
    closeBFS();
    closeTopo();
    openBipartite();
    closeBridge();
    closeScc();
    close2sat();
  });

  $('#bridge').click(function() {
    closeExamples();
    closeDFS();
    closeBFS();
    closeTopo();
    closeBipartite();
    openBridge();
    closeScc();
    close2sat();
  });

  $('#scc').click(function() {
    closeExamples();
    closeDFS();
    closeBFS();
    closeTopo();
    closeBipartite();
    closeBridge();
    openScc();
    close2sat();
  });

  $('#twosat').click(function() {
    closeExamples();
    closeDFS();
    closeBFS();
    closeTopo();
    closeBipartite();
    closeBridge();
    closeScc();
    open2sat();
  });
*/
});

function importjson(text) {
  if (isPlaying) stop();
  if (mode == "exploration") {
    gtw.importjson(text);
    //closeExamples();
    isPlaying = false;
  }
}

function setDefaultScale() {
    if (isPlaying) stop();
    isPlaying = false;
    if (scale) {
        scale = !scale;
        gw.redrawAllForMediumScale();
        gw.setMediumScale(false);

        userGraph = gtw.getGraph();
    } 
}

function setMediumScale() {
    if (isPlaying) stop();
    isPlaying = false;
    if (!scale) {
        scale = !scale;
        gw.redrawAllForMediumScale();
        gw.setMediumScale(true);

        userGraph = gtw.getGraph();
    }
}

function toggleVertexNumber() {
    if (isPlaying) stop();
    isPlaying = false;
    if (scale) {
        gw.toggleVertexNumber();
    }
}

function drawGraph() {
  if (isPlaying) stop();
  if (mode == "exploration") {
    const [newiVL, newiEL] = representationConvert(gtw.getiVL(), gtw.getiEL())
    currentGraphVisu = new GraphVisu(false, true, true, newiVL, newiEL, true)
    $('#dark-overlay').fadeIn(function() {
      $('#drawgraph').fadeIn();
    });
    gtw.startLoop();
    isPlaying = false;
  }
}

function drawDone() {
  if (!gtw.draw()) return false;
  gtw.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

function drawCancel() {
  gtw.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

// function createRandom() {
//   if (isPlaying) stop();
//   if (mode == "exploration") {
//     var n = Math.floor(Math.random()*6 + 5);
//     $.ajax({
//       url: PHP_DOMAIN + "/php/Graph.php?mode=" + MODE_GET_RANDOM_SUBMITTED_GRAPH + "&directed=" + 1 + "&connected=" + 1
//     }).done(function(data) {
//       data = JSON.parse(data);
//       var graph = extractQnGraph(data.graph);
//       if (data.graphID == randomGraphID) // to ensure we get different graph per click (make sure #graph > 1 in the database)
//         createRandom();
//       randomGraphID = data.graphID;
//       gtw.initRandom(graph);
//       $('#rate-sample-graph').show();
//     })
//     $('#progress-bar').slider("option", "max", 0);
//     closeExamples();
//     isPlaying = false;
//   }
// }

function example(id) {
  if (isPlaying) stop();
  setTimeout(function() {
    if (gtw.examples(id)) { // (mode == "exploration") && 
      $('#progress-bar').slider("option", "max", 0);
      //closeExamples();
      isPlaying = false;
    }
  }, 500);
}

function directedChange() {
  if (isPlaying) stop();
  setTimeout(function() {
    if ((mode == "exploration") && gtw.directedChange()) {
      $('#progress-bar').slider("option", "max", 0);
      isPlaying = false;
    }
  }, 500);
}

function dfs(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#dfs-v').val());
  commonAction(gtw.dfs(input, callback), "DFS(" + input + ")");
  setTimeout(function() { $("#dfs-v").val(1 + Math.floor(Math.random()*gtw.getV())); }, 500); // randomized for next click between [0..V-1]
}

function bfs(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#bfs-v').val());
  commonAction(gtw.bfs(input, callback), "BFS(" + input + ")");
  setTimeout(function() { $("#bfs-v").val(1 + Math.floor(Math.random()*gtw.getV())); }, 500);
}

function toposortDfs(callback) {
  if (isPlaying) stop();
  commonAction(gtw.toposortDfs(callback), "Topological Sort (DFS)");
}

function toposortBfs(callback) {
  if (isPlaying) stop();
  commonAction(gtw.toposortBfs(callback), "Topological Sort (BFS)");
}

function bipartiteDfs(callback) {
  if (isPlaying) stop();
  commonAction(gtw.bipartiteDfs(callback), "Bipartite Graph Checker (DFS)");
}

function bipartiteBfs(callback) {
  if (isPlaying) stop();
  commonAction(gtw.bipartiteBfs(callback), "Bipartite Graph Checker (BFS)");
}

function bridge(callback) {
  if (isPlaying) stop();
  commonAction(gtw.bridge(callback), "Articulation Points and Bridges Checker");
}

function kosaraju(callback) {
  if (isPlaying) stop();
  commonAction(gtw.kosaraju(callback), "Kosaraju's Algorithm");
}

function tarjan(callback) {
  if (isPlaying) stop();
  commonAction(gtw.tarjan(callback), "Tarjan's Algorithm");
}

function twosat() {
  if (isPlaying) stop();
  var input1 = parseInt($('#twosat-v1').val()), input2 = parseInt($('#twosat-v2').val());
  commonAction(gtw.twosat(input1, input2), "2-SAT Checker");
}

function loadGraph(graph) {
  if (gtw) {
    gtw.loadGraph(graph['vl'], graph['el']);
  }
}

// Implement these functions in each visualisation
var userGraph = {
  'vl': {},
  'el': {},
};

// This function will be called before entering E-Lecture Mode
function ENTER_LECTURE_MODE() {
  if (gtw) userGraph = gtw.getGraph();
}

// This function will be called before returning to Explore Mode
function ENTER_EXPLORE_MODE() {
  loadGraph(userGraph);
}

// Lecture action functions
function CUSTOM_ACTION(action, data, mode) {
  if (action == 'dfs') {
    hideSlide(function() {
      $('#dfs-v').val(0); // force
      dfs(showSlide);
    });
  }
  else if (action == 'bfs') {
    hideSlide(function() {
      $('#bfs-v').val(5); // force
      bfs(showSlide);
    });
  }
  else if (action == 'toposort_dfs') {
    hideSlide(function() {
      toposortDfs(showSlide);
    });
  }
  else if (action == 'toposort_bfs') {
    hideSlide(function() {
      toposortBfs(showSlide);
    });
  }
  else if (action == 'bipartite_dfs') {
    hideSlide(function() {
      bipartiteDfs(showSlide);
    });
  }
  else if (action == 'bipartite_bfs') {
    hideSlide(function() {
      bipartiteBfs(showSlide);
    });
  }
  else if (action == 'bridge') {
    hideSlide(function() {
      bridge(showSlide);
    });
  }
  else if (action == 'kosaraju') {
    hideSlide(function() {
      kosaraju(showSlide);
    });
  }
  else if (action == 'tarjan') {
    hideSlide(function() {
      tarjan(showSlide);
    });
  }
}
</script>
</body>

<!-- Mirrored from visualgo.net/en/dfsbfs/?slide=7-7 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:17:23 GMT -->
</html>
