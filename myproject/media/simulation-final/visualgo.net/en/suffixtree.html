<!DOCTYPE html>
<html lang="en">

<!-- Mirrored from visualgo.net/en/suffixtree by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:18:15 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="description" content="A Suffix Tree is a compressed tree containing all the suffixes of the given (usually long) text string T of length n characters (n can be in order of hundred thousands characters).The positions of each suffix in the text string T are recorded as integer indices at the leaves of the Suffix Tree whereas the path labels (concatenation of edge labels starting from the root) of the leaves describe the suffixes.Suffix Tree provides a particularly fast implementation for many important (long) string operations.This data structure is very related to the Suffix Array data structure. Both data structures are usually studied together.">
<meta name="keywords" content="Suffix Tree Construction Common Prefix LCP String Matching Longest Repeated Substring">
 
<meta name="csrf-token" content="dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../img/png/suffixtree.png">
<title>Suffix Tree - VisuAlgo</title>
<link rel="icon" href="../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../img/favicon.png">
<link rel="stylesheet" href="../css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../css/common-1.0.2.css">
<link rel="stylesheet" href="../css/viz-1.0.4.css">
<link rel="stylesheet" href="../css/visual.css">
<link rel="stylesheet" href="../css/drawgraph-1.0.2.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
        z-index: 8001;
      }
      #e-lecture-timeline {
        top: 80px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }
      .e-lecture-timeline-slide {
        height: 5px;
        width: 2px;
        background: black;
        float: left;
      }
      .e-lecture-timeline-checkpoint {
        height: 20px;
        width: 3px;
        margin-left: 2px;
        margin-top: -7.5px;
        background: black;
        float: left;
      }

      #e-lecture-f1map {
        top: 102.5px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }

      .e-lecture-f1map-sector {
        flex-grow: 1;
        background: black;
        float: left;
        height: 5px;
        margin-right: 1px;
      }

      .e-lecture-f1map-sector:last-child {
        margin-right: 0px;
      }

      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }

      .electure-read-status {
        position: absolute;
        bottom: 4px;
        right: 4px;
        font-size: 14px;
        cursor: default;
        color: #00FF7F;
        display: none;
      }

      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
      .electure-print, .electure-end {
        position: fixed;
        top: 45px;
        height: 20px;
        width: 17px;
        right: 80px;
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
        text-align: center;
      }
      .electure-end {
        right: 45px; /* beside the X */
      }

      #change-lang-popup {
        position: fixed;
        background: green;
        left: 40px;
        top: 50px;
        width: 250px;
        height: 125px;
        border: transparent;
        border-radius: 10px;
        padding: 10px 20px;
        z-index: 9000;
      }

      #change-lang-popup p {
        font-size: medium;
        color: white;
        line-height: 2;
        font-family: "PT Sans", sans-serif;
      }

      #change-lang-popup-btn {
        text-decoration: underline;
        margin-left: 50px;
      }

      #change-lang-popup-btn:hover {
        cursor: pointer;
      }

      #rotateDeviceOverlay {
        z-index: 10000;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        background-color: white;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        overflow: hidden;
      }

      #mobile-playback-overlay {
        z-index: 9600;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        gap: 100px;
        background-color: black;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        opacity: 0.3;
        overflow: hidden;
      }
      .mobile-playback-item {
        min-width: 2.5%;
        max-width: 35px;
      }
      .mobile-playback-item img {
        width: 100%
      }
      .mobile-playback-label {
        opacity: 0;
        color: white;
        font-size: 25px;
        font-weight: bold;
        min-width: 1.5%;
        max-width: 25px;
        transition: opacity 0.25s ease-out;
        -webkit-backface-visibility: hidden;
      }
      #mobile-playback-rewind-label {
        margin-right: -70px;
      }
      #mobile-playback-forward-label {
        margin-left: -70px;
      }
      #viz-speed-value {
          font-size: 15px;
          width: 10%;
      }

      #scale {
        position: fixed;
        left: 5px;
      }
    </style>
<style>
/*others*/
.background {
  fill: none;
  pointer-events: all;
}

.lcs_first {
  fill: #2ebbd1;
}

.lcs_second {
  fill: #52bc69;
}

.lcs_internal {
  fill: #eeeeee;
}
</style>
<style>
/* copied here from common.css (perhaps need to use version numbering) until caches worldwide settles */
#reload-mobile-popup, #message-popup { /* #gdpr-popup, */
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  min-width: 320px;
  bottom: 62px;
  height: 300px;
  background-color: #0275d8;
  border-radius: 15px;
  padding: 30px 40px;
  z-index: 9500;
}
#reload-mobile-popup {
  background-color: green;
  height: 200px;
}
#message-popup {
  z-index: 9000;
  width: 40%;
  height: 130px;
  background-color: #d9534f;
}

#reload-mobile-popup p, #message-popup p { /* #gdpr-popup p, */
  font-size: large;
  color: white;
  line-height: 2;
  font-family: "PT Sans", sans-serif;
}

#reload-mobile-popup .inner-button, #message-popup .inner-button { /* #gdpr-popup .gdpr-button, */
  border: white solid 2px;
  border-radius: 4px;
  font-weight: bold;
  font-size: x-large;
  padding: 2px 8px;
  color: white;
  width: 90px;
  text-align: center;
  position: absolute;
  letter-spacing: 1px;
  text-decoration: none;
  cursor: pointer;
}

#gdpr-accept, #reload-mobile-button, #dismiss-message-btn {
  bottom: 30px;
  right: 40px;
}

#gdpr-reject, #cancel-reload-mobile-button {
  bottom: 30px;
  right: 170px;
}
    </style>
</head>
<body>
<div id="body-container" style="display: flex; flex-direction: column; min-height: 100vh;">
<style>
  #topbar {
    background-color: rgb(0,0,0);
    font-family: "PT Sans", sans-serif;
    font-size: 13px;
    height: 40px;

    padding-left: 40px;
    padding-right: 40px;

    display: flex;
    flex-wrap: wrap;
    align-items: center;
    position: relative;
    justify-content: flex-start;
  }

  #topbar a:hover {
    text-decoration: none;
  }

  #account-dropdown-btn {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;
    height: 24px;
    line-height: 1.5;
  }

  #account-dropdown-btn:hover {
    color: #0a58ca!important;
    border-color: #198754;
    text-decoration: none;
  }

  #login-button {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;

    height: 24px;
    line-height: 1.5;
  }

  #login-button a:hover {
    color: #0a58ca!important;
    text-decoration: none;
  }

  #account-dropdown-menu {
    display: none;
    position: absolute;
    background-color: white;
    z-index: 1000;
    min-width: 10rem;
    padding: 0.5rem 0;
    margin: 0;
    font-size: 1rem;
    color: rgb(0,0,0);
    text-align: left;
    list-style: none;
    background-clip: padding-box;
    border: 1px solid rgba(0,0,0,.15);
    border-radius: 0.25rem;
    top: 45px;
    right: 40px;
    line-height: 1.5;
  }

  .account-dropdown-item {
    display: block;
    width: auto;
    padding: 0.25rem 1rem;
    clear: both;
    font-weight: 400;
    color: rgb(0,0,0);
    text-align: inherit;
    text-decoration: none;
    white-space: nowrap;
    background-color: transparent;
    border: 0;
    height: 24px;
    font-family: SilkscreenNormal, sans-serif;
  }

  .account-dropdown-item:hover {
    background-color: #e9ecef;
    color: #0a58ca;
    text-decoration: none;
  }
</style>
<nav id="topbar">
<span style="margin-right: 0.25rem">
<a href="https://www.comp.nus.edu.sg/~stevenha" style="text-decoration: none; color: white">
<span class="colour" style="border: 1px solid; border-color: #198754!important; border-radius: .25rem!important">7</span>
</a>
<a href="https://visualgo.net/" style="font-family: SilkscreenNormal,sans-serif; font-size: 20px; margin-left: 4px;">
<span style="color: white">Visu</span><span class="colour">Algo</span><span style="font-size: 40%; color: white">.net</span>
</a>
<span style="color: white">/</span>
<select id="Language" class="select2-dropdown" onchange="changeURL()">
<option value="en" selected>en</option>
<option value="zh">zh</option>
<option value="id">id</option>
</select>
<span style="color: white; font-family: monospace">/suffixtree</span>
</span>
<span style="max-height: 30px">
<span id="title">
<a id="title-suffixtree" class="selected-viz">Suffix Tree</a>
</span>
</span>
<span style="max-height: 30px; background-color:rgb(0,0,0)!important; color: white; margin-left: auto">
<div id="mode-menu">
<div id="mode-button" style="background-color: rgb(0,0,0)!important;" title="exploration">Exploration Mode &#9663;</div>
<div id="other-modes" style="background-color: rgb(0,0,0)!important; padding-top: 11px">
<a title="e-Lecture" style="background-color: rgb(0,0,0)!important;">e-Lecture Mode</a>
</div>
</div>
</span>
<span id="login-button" style="font-family: SilkscreenNormal,sans-serif">
<a href="https://visualgo.net/login">Login</a>
</span>
</nav>
<ul id="account-dropdown-menu">
<li><a class="account-dropdown-item" href="https://visualgo.net/profile">Profile</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/training">Training</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/tests">Tests</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/logout">Log Out</a></li>
</ul>
<script>
  function changeURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    URL[3] = document.getElementById("Language").value;
    window.location.assign(URL.join('https://visualgo.net/'));
  }

  function changeDefaultLanguageAndURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    let val = document.getElementById("Language").value;
    URL[3] = val;

    let data = {
      '_token': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
      'lang'  : val
    }
    $.post('https://visualgo.net/changeLanguage', data, function (res, status) {
      if(res['status'] === 'success') {
        window.location.assign(URL.join('https://visualgo.net/'));
      } else if (res['status'] === 'failed') {
        alert(res['message']);
      } else {
        alert('An unknown error occurred');
      }
    })
  }
</script>
<div id="dark-overlay"></div>
<div id="main-content-container" style="flex: 1">

<div id="mobile-playback-overlay" class="playing" style="display: none;">
<span id="mobile-playback-rewind-label" class="mobile-playback-label">-7</span>
<span id="mobile-playback-rewind" class="mobile-playback-item" onclick="mobilePlaybackRewind()"><img src="../img/prevFrame.png" alt="rewind 7 frames"></span>
<span id="mobile-playback-pause" class="mobile-playback-item" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/pause.png" alt="pause"></span>
<span id="mobile-playback-play" class="mobile-playback-item" style="display: none;" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/play.png" alt="play"></span>
<span id="mobile-playback-forward" class="mobile-playback-item" onclick="mobilePlaybackForward()"><img src="../img/nextFrame.png" alt="forward 7 frames"></span>
<span id="mobile-playback-forward-label" class="mobile-playback-label">+7</span>
</div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id="speed-control"><div id="speed-input"></div><div id="viz-speed-value">1x</div></div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick="goToBeginning()"><img src="../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick="stepBackward()"><img src="../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick="pause()"><img src="../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick="play()"><img src="../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick="stepForward()"><img src="../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick="goToEnd()"><img src="../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id="viz">
<p id="info" "></p>
</div>
<div id="current-action" class="panel"></div>
<div id="e-lecture" class="panel"></div> 
<div id="e-lecture-timeline"></div>
<div id="e-lecture-f1map">
<div class="e-lecture-f1map-sector" sectorNo="1"></div>
<div class="e-lecture-f1map-sector" sectorNo="2"></div>
<div class="e-lecture-f1map-sector" sectorNo="3"></div>
</div>
<div id="overlay" hidden onclick="end_eLecture()"> 
<div id="electure-dropdown">
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. Suffix Tree</option>
<option value="1-1">&nbsp;&nbsp;&nbsp;1-1. Suffix of a String T</option>
<option value="2">2. Suffix Tree Visualization</option>
<option value="2-1">&nbsp;&nbsp;&nbsp;2-1. Example with T = "GATAGACA$"</option>
<option value="2-2">&nbsp;&nbsp;&nbsp;2-2. Terminating Symbol $</option>
<option value="2-3">&nbsp;&nbsp;&nbsp;2-3. Suffix Tree has O(n) Vertices</option>
<option value="2-4">&nbsp;&nbsp;&nbsp;2-4. Much Shorter Suffix Tree</option>
<option value="3">3. Available Operations</option>
<option value="3-1">&nbsp;&nbsp;&nbsp;3-1. Build Suffix Tree (instant)</option>
<option value="3-2">&nbsp;&nbsp;&nbsp;3-2. Search</option>
<option value="3-3">&nbsp;&nbsp;&nbsp;3-3. Longest Repeated Substring (LRS)</option>
<option value="3-4">&nbsp;&nbsp;&nbsp;3-4. Longest Common Substring (LCS)</option>
<option value="4">4. Extras</option>
</select>
</div>
<div class="electure-print" title="Print the e-Lecture note" style="z-index=8001;">&#9997;</div>
<div class="electure-end" title="Close the e-Lecture mode" style="z-index=8001;">&#10008;</div>
</div>
<div id="dropdown-temp-holder" hidden></div>

<div id="electure-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>A <b>Suffix Tree</b> is a compressed tree containing all the suffixes of the given (usually long) text string <b>T</b> of length <b>n</b> characters (<b>n</b> can be in order of hundred thousands characters).</p><br><p>The positions of each suffix in the text string <b>T</b> are recorded as integer indices at the leaves of the Suffix Tree whereas the path labels (concatenation of edge labels starting from the root) of the leaves describe the suffixes.</p><br><p>Suffix Tree provides a particularly fast implementation for many important (long) string operations.</p><br><p>This data structure is very related to the <a href="suffixarray.html"><u>Suffix Array</u></a> data structure. Both data structures are usually studied together.</p>
<div class="electure-addition">
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
If you are an NUS student and a repeat visitor, please <a href="https://visualgo.net/login"><u>login</u></a>.</p>
</div>
<div class="electure-next" data-nextid="1-1" title="Go to the next slide 1-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-1-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>The suffix <b>i</b> (or the <b>i</b>-th suffix) of a (usually long) text string <b>T</b> is a &#39;special case&#39; of substring that goes from the <b>i</b>-th character of the string up to its <i>last</i> character.</p><br><p>For example, if <b>T</b> = "STEVEN$", then suffix 0 of <b>T</b> is "STEVEN$" (0-based indexing), suffix 2 of <b>T</b> is "EVEN$", suffix 4 of <b>T</b> is "EN$", etc.</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 1: Since you are not <a href="https://visualgo.net/login"><u>logged-in</u></a>, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b>/<b>[PageUp]</b> to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use <b>[&rarr; or &darr;/&larr; or &uarr;]</b> to do the same),and <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
</div>
<div class="electure-prev" data-nextid="1" title="Go to the previous slide 1">&larr;</div>
<div class="electure-next" data-nextid="2" title="Go to the next slide 2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>The visualization of Suffix Tree of a string <b>T</b> is basically a rooted tree where path label (concatenation of edge label(s)) from root to each leaf describes a suffix of <b>T</b>. Each leaf vertex is a suffix and the integer value written inside the leaf vertex (we ensure this property with terminating symbol $) is the suffix number.</p><br><p>An internal vertex will branch to more than one child vertex, therefore there are more than one suffix from the root to the leaves via this internal vertex. The path label of an internal vertex is a common prefix among those suffix(es).</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
</div>
<div class="electure-prev" data-nextid="1-1" title="Go to the previous slide 1-1">&larr;</div>
<div class="electure-next" data-nextid="2-1" title="Go to the next slide 2-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>The Suffix Tree above is built from string <b>T</b> = "GATAGACA$" that have these 9 suffixes:</p><table><tr><th><b>i</b></th><th><b>Suffix</b></th></tr><tr><td>0</td><td>GATAGACA$</td></tr><tr><td>1</td><td>ATAGACA$</td></tr><tr><td>2</td><td>TAGACA$</td></tr><tr><td>3</td><td>AGACA$</td></tr><tr><td>4</td><td>GACA$</td></tr><tr><td>5</td><td>ACA$</td></tr><tr><td>6</td><td>CA$</td></tr><tr><td>7</td><td>A$</td></tr><tr><td>8</td><td>$</td></tr></table><p>Now verify that the path labels of suffix 7/6/2 are "A$"/"CA$"/"TAGACA$", respectively (there are 6 other suffixes). The internal vertices with path label "A"/"GA" branch out to 4 suffixes {7, 5, 3, 1}/2 suffixes {4, 0}, respectively (we ignore the trivial internal vertex = root vertex that branches out to all 9 suffixes).</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode): <b>Spacebar</b> to play/pause/replay the animation, <b>&larr;</b>/<b>&rarr;</b> to step the animation backwards/forwards, respectively, and <b>-</b>/<b>+</b> to decrease/increase the animation speed, respectively.</p>
</div>
<div class="electure-prev" data-nextid="2" title="Go to the previous slide 2">&larr;</div>
<div class="electure-next" data-nextid="2-2" title="Go to the next slide 2-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>In order to ensure that every suffix of the input string <b>T</b> ends in a leaf vertex, we enforce that string <b>T</b> ends with a special terminating symbol &#39;$&#39; that is not used in the original string <b>T</b> and has ASCII value lower than the lowest allowable character in <b>T</b> (which is character &#39;A&#39; in this visualization). This way, edge label &#39;$&#39; always appear at the leftmost edge of the root vertex of this Suffix Tree visualization.</p><br><p>For the Suffix Tree example above (for <b>T</b> = "GATAGACA$"), if we do not have terminating symbol &#39;$&#39;, notice that suffix 7 "A" (without the &#39;$&#39;) does NOT end in a leaf vertex and can complicate some operations later.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-1" title="Go to the previous slide 2-1">&larr;</div>
<div class="electure-next" data-nextid="2-3" title="Go to the next slide 2-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-3" class="electure-dialog" style="top:300px;left:60px;width:500px;">
<p>As we have ensured that all suffixes end at a leaf vertex, there are <i>at most</i> <b>n</b> leaves/suffixes in a Suffix Tree. All internal vertices (including the root vertex if it is an internal vertex) are always branching thus there can be at most <b>n</b>-1 such vertices, as shown with one of the extreme test case on the right.</p><br><p>The maximum number of vertices in a Suffix Tree is thus = <b>n</b> (leaves) + (<b>n</b>-1) internal vertices = <b>2n</b>-1 = O(<b>n</b>) vertices. As Suffix Tree is a tree, the maximum number of edges in a Suffix Tree is also (<b>2n</b>-1)-1 = O(<b>n</b>) edges.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-2" title="Go to the previous slide 2-2">&larr;</div>
<div class="electure-next" data-nextid="2-4" title="Go to the next slide 2-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2-4" class="electure-dialog" style="top:210px;left:50%;margin-left:-250px;width:500px;">
<p>When all the characters in string <b>T</b> is all distinct (e.g., <b>T</b> = "ABCDE$"), we can have the following very short Suffix Tree with exactly <b>n</b>+1 vertices (+1 due to root vertex).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-3" title="Go to the previous slide 2-3">&larr;</div>
<div class="electure-next" data-nextid="3" title="Go to the next slide 3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3" class="electure-dialog" style="bottom:200px;left:60px;width:500px;">
<p>All available operations on the Suffix Tree in this visualization are listed below:</p><ol><li><b>Build Suffix Tree (instant/details omitted)</b> &mdash; instant-build the Suffix Tree from string <b>T</b>.</li><li><b>Search</b> — Find the vertex in Suffix Tree of a (usually longer) string <b>T</b> that has path label containing the (usually shorter) pattern/search string <b>P</b>.</li><li><b>Longest Repeated Substring (LRS)</b> — Find the deepest (the one that has the longest path label) internal vertex (as that vertex shares common prefix between two (or more) suffixes of <b>T</b>).</li><li><b>Longest Common Substring (LCS)</b> — Find the deepest internal vertex that contains suffixes from two different original strings.</li></ol><p>There are a few other possible operations of Suffix Tree that are not included in this visualization.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2-4" title="Go to the previous slide 2-4">&larr;</div>
<div class="electure-next" data-nextid="3-1" title="Go to the next slide 3-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-1" class="electure-dialog" style="bottom:200px;left:60px;width:500px;">
<p>In this visualization, we only show the fully constructed Suffix Tree <i>without describing the details of the O(<b>n</b>) Suffix Tree construction algorithm</i> — it is a bit too complicated. Interested readers can explore <a href="https://en.wikipedia.org/wiki/Ukkonen%27s_algorithm" target="_blank"><u>this</u></a> instead.</p><br><p>We limit the input to only accept 25 (cannot be too long due to the available drawing space — but in the real application of Suffix Tree, <b>n</b> can be in order of hundred thousand to million characters) ASCII (or even Unicode) characters. If you do not write a terminating symbol &#39;$&#39; at the back of your input string, we will automatically do so. If you place a &#39;$&#39; in the middle of the input string, they will be ignored. And if you enter an empty input string, we will resort to the default "GATAGACA$".</p><br><p>For convenience, we provide a few classic test case input strings usually found in Suffix Tree/Array lectures, but to showcase the strength of this visualization tool, you are encouraged to enter any 25-characters string of your choice (ending with character &#39;$&#39;). You can use Chinese characters (in Unicode), e.g., "四是四十是十十四不是四十四十不是十四$".</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3" title="Go to the previous slide 3">&larr;</div>
<div class="electure-next" data-nextid="3-2" title="Go to the next slide 3-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-2" class="electure-dialog" style="bottom:200px;left:60px;width:500px;">
<p>Assuming that the Suffix Tree of a (usually longer) string <b>T</b> (of length <b>n</b>) has been built, we want to find all occurrences of pattern/search string <b>P</b> (of length <b>m</b>).</p><br><p>To do this, we search for the vertex <b>x</b> in the suffix Tree of <b>T</b> which has path label (concatenation of edge label(s) from the root to <b>x</b>) where <b>P</b> is the prefix of that path label. Once we find this vertex <b>x</b>, all the leaves in the subtree rooted at <b>x</b> are the occurrences.</p><br><p>Time complexity: O(<b>m+k</b>) where <b>k</b> is the total number of occurrences.</p><br><p>For example, on the Suffix Tree of <b>T</b> = "GATAGACA$" above, try these scenarios:</p><ol><li><b>P</b> is a full match with the path label of vertex <b>x</b>:<br><span class="slide-actions" onclick="doButtonAction115()">Search("A")</span>, occurrences = {7, 5, 3, 1} or <span class="slide-actions" onclick="doButtonAction116()">Search("GA")</span>, occurrences = {4, 0}</li><li><b>P</b> is a partial match with the path label of vertex <b>x</b>:<br><span class="slide-actions" onclick="doButtonAction131()">Search("T")</span>, occurrences = {2} or <span class="slide-actions" onclick="doButtonAction132()">Search("GAT")</span>, occurrences = {0}</li><li><b>P</b> is not found in <b>T</b>:<br><span class="slide-actions" onclick="doButtonAction133()">Search("WALDO")</span>, occurrences = {NIL}</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-1" title="Go to the previous slide 3-1">&larr;</div>
<div class="electure-next" data-nextid="3-3" title="Go to the next slide 3-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-3" class="electure-dialog" style="bottom:200px;left:60px;width:500px;">
<p>Assuming that the Suffix Tree of a (usually longer) string <b>T</b> (of length <b>n</b>) has been built, we can find the Longest Repeated Substring (LRS) in <b>T</b> by simply finding the deepest (the one that has the longest path label) internal vertex of the Suffix Tree of <b>T</b>.</p><br><p>This is because each internal vertex of the Suffix Tree of <b>T</b> branches out to at least two (or more) suffixes, i.e., the path label (common prefix of these suffixes) are <b>repeated</b>.</p><br><p>The deepest (the one that has the longest path label) internal vertex is the required answer, which can be found in O(<b>n</b>) with a simple tree traversal.</p><br><p>Without further ado, try <span class="slide-actions" onclick="doButtonAction117()">LRS("GATAGACA$")</span>. We have LRS = "GA".</p><br><p>It is possible that <b>T</b> contains more than one LRS, e.g., try <span class="slide-actions" onclick="doButtonAction134()">LRS("BANANABAN$")</span>.<br>We have LRS = "ANA" (actually overlap) or "BAN" (without overlap).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-2" title="Go to the previous slide 3-2">&larr;</div>
<div class="electure-next" data-nextid="3-4" title="Go to the next slide 3-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-4" class="electure-dialog" style="bottom:200px;left:60px;width:500px;">
<p>This time, we need two input strings <b>T1</b> and <b>T2</b> that terminate with symbol &#39;$&#39;/&#39;#&#39;, respectively. We then create the <b>generalized</b> Suffix Tree of these two strings <b>T1+T2</b> in O(<b>n</b>) where <b>n = n1+n2</b> (sum of the length of the two strings). We can find the Longest Common Substring (LCS) of those two strings <b>T1</b> and <b>T2</b> by simply finding the deepest <b>and valid</b> internal vertex of the generalized Suffix Tree of <b>T1+T2</b>.</p><br><p>To be a valid internal vertex for consideration as an LCS candidate, an internal vertex must represents suffixes from <b>both strings</b>, i.e., a <b>common</b> substring found in both <b>T1</b> and <b>T2</b>.</p><br><p>Then, since an internal vertex of the Suffix Tree of <b>T</b> branches out to at least two (or more) suffixes, i.e., the path label (common prefix of these suffixes) are <b>repeated</b>. If that internal vertex is also a valid internal vertex, then it is a <b>common</b> substring that is <b>repeated</b>.</p><br><p>The valid and deepest (the one that has the longest path label) internal vertex is the required answer, which can be found in O(<b>n</b>) with a simple tree traversal.</p><br><p>Without further ado, try <span class="slide-actions" onclick="doButtonAction118()">LCS(T1,T2)</span> on the generalized Suffix Tree of string <b>T1</b> = "GATAGACA$" and <b>T2</b> = "CATA#" (notice that the UI will change to generalized Suffix Tree version). We have LCS = "ATA".</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-3" title="Go to the previous slide 3-3">&larr;</div>
<div class="electure-next" data-nextid="4" title="Go to the next slide 4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>There are a few other things that we can do with Suffix Tree like "Finding Longest Repeated Substring without overlap", "Finding Longest Common Substring of &ge; 2 strings", etc, but we will keep that for later.</p><br><p>We will continue the discussion of this String-specific data structure with the more versatile to <a href="suffixarray.html"><u>Suffix Array</u></a> data structure.</p>
<div class="electure-addition">
<hr>
<p>You have reached the last slide. Return to 'Exploration Mode' to start exploring!</p>
<p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
</div>
<div class="electure-prev" data-nextid="3-4" title="Go to the previous slide 3-4">&larr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>Close</u></span>
</div>
<div id="rotateDeviceOverlay" style="display: none;">
<div id="rotateDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please rotate your device to landscape mode for a better user experience</div>
<div id="widenDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please make the window wider for a better user experience</div>
</div>

<style>
        .build {
            bottom: 146px
        }
    </style>
<style>
        .search {
            bottom: 119px
        }
    </style>
<style>
        .lrs {
            bottom: 92px
        }
    </style>
<style>
        .lcs {
            bottom: 65px
        }
    </style>
<div id="actions" class="panel">
<p id="build">Build Suffix Tree</p>
<p id="search">Search</p>
<p class="execAction" id="lrs" onClick="doLRS()">Longest Repeated Substring</p>
<p id="lcs">Longest Common Substring</p>
</div>
<div id="actions-hide" class="panel-hide"><span style="color:white; font-size: x-large; display: inline-block;">&gt;</span></div>
<div id="actions-extras">
<div class="build action-menu-pullout">
<div id="build-example1" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#arrv1&#039;).val(&#039;GATAGACA$&#039;); buildSuffixTree();">
<p>GATAGACA$</p>
</div>
<div id="build-example2" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#arrv1&#039;).val(&#039;BANANABAN$&#039;); buildSuffixTree();">
<p>BANANABAN$</p>
</div>
<div id="build-example3" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#arrv1&#039;).val(&#039;MISSISSIPPI$&#039;); buildSuffixTree();">
<p>MISSISSIPPI$</p>
</div>
<div id="build-example4" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#arrv1&#039;).val(&#039;ABRACADABRA$&#039;); buildSuffixTree();">
<p>ABRACADABRA$</p>
</div>
<div id="build-example5" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#arrv1&#039;).val(&#039;RATATAT$&#039;); buildSuffixTree();">
<p>RATATAT$</p>
</div>
<div id="build-example6" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#arrv1&#039;).val(&#039;AAAAAAA$&#039;); buildSuffixTree();">
<p>AAAAAAA$</p>
</div>
<div id="build-example7" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#arrv1&#039;).val(&#039;ABCDE$&#039;); buildSuffixTree();">
<p>ABCDE$</p>
</div>
<div id="build-example8" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#arrv1&#039;).val(&#039;AABBCC$&#039;); buildSuffixTree();">
<p>AABBCC$</p>
</div>
<div id="build-example9" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#arrv1&#039;).val(&#039;你問我愛你有多深我愛你有幾分$&#039;); buildSuffixTree();">
<p>你問我愛你有多深 我愛你有幾分$</p>
</div>
<div id="build-example10" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#arrv1&#039;).val(&#039;四是四十是十十四不是四十四十不是十四$&#039;); buildSuffixTree();">
<p>四是四 Tongue Twister</p>
</div>
<div id="build-input" class="new-menu-option">
T = <input id="arrv1" type="text" autocomplete="off" value="CUSTOMSTR$" maxlength="25" style="width: 120px"> </div>
<div id="build-go" class="execAction new-menu-option coloured-menu-option" onClick="buildSuffixTree()">
<p>Go</p>
</div>
<div id="build-err" class="err" style="float: left;"></div>
</div>
<div class="search action-menu-pullout">
<div id="search-input" class="new-menu-option">
P = <input id="search_inp" type="text" autocomplete="off" value="GA" maxlength="12" style="width: 120px"> </div>
<div id="search-go" class="execAction new-menu-option coloured-menu-option" onClick="doSearch()">
<p>Go</p>
</div>
<div id="search-err" class="err" style="float: left;"></div>
</div>
<div class="lrs action-menu-pullout">
<div id="lrs-err" class="err" style="float: left;"></div>
</div>
<div class="lcs action-menu-pullout">
<div id="lcs-input1" class="new-menu-option">
T1 = <input id="s1" type="text" autocomplete="off" value="GATAGACA$" maxlength="12" style="width: 120px"> </div>
<div id="lcs-input2" class="new-menu-option">
T2 = <input id="s2" type="text" autocomplete="off" value="CATA#" maxlength="12" style="width: 120px"> </div>
<div id="lcs-go" class="execAction new-menu-option coloured-menu-option" onClick="doLCS()">
<p>Go</p>
</div>
<div id="lcs-err" class="err" style="float: left;"></div>
</div>
</div>

</div>

<div id="bottom-bar">
<a id="scale" style="display: none;">1.0x</a>
<a id="trigger-about">About</a>
<a id="trigger-team">Team</a>
<a id="trigger-terms">Terms of use</a>
<a id="trigger-privacy">Privacy Policy</a>
</div>
<div id="about" class="overlays">
<h4>About</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.</p><p>Featuring numerous advanced algorithms discussed in Dr. Steven Halim&#39;s book, &#39;Competitive Programming&#39; — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.</p><p>While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.</p><p>Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.</p><p>VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.</p><p>Equipped with a built-in question generator and answer verifier, VisuAlgo&#39;s "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students&#39; answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students&#39; mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.</p><p>VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:</p>
<a href="https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689" target="_blank"><u>id</u></a>,
<a href="http://blog.naver.com/visualgo_nus" target="_blank"><u>kr</u></a>,
<a href="https://www.facebook.com/groups/163215593699283/permalink/824003417620494/" target="_blank"><u>vn</u></a>,
<a href="http://pantip.com/topic/32736343" target="_blank"><u>th</u></a>.
</div>
</div>
<div id="team" class="overlays">
<h4>Team</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>
<strong><span style="line-height: 150%;">Project Leader &amp; Advisor (Jul 2011-present)</span></strong><br>
<a href="https://www.comp.nus.edu.sg/~stevenha/" target="_blank">Associate Professor Steven Halim</a>, School of Computing (SoC), National University of Singapore (NUS)<br>
<a href="https://www.linkedin.com/in/felixhalim/" target="_blank">Dr Felix Halim</a>, Senior Software Engineer, Google (Mountain View)
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 1</span></strong><br>
<b>CDTL TEG 1: Jul 2011-Apr 2012</b>: Koh Zi Chun, Victor Loh Bo Huai
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 1</span></strong><br>
<b>Jul 2012-Dec 2013</b>: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang Duy<br>
<b>Jun 2013-Apr 2014</b> <a href="https://www.rosemarietan.com/" target="_blank">Rose Marie Tan Zhao Yun</a>, Ivan Reinaldo
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 2</span></strong><br>
<b>CDTL TEG 2: May 2014-Jul 2014</b>: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 2</span></strong><br>
<b>Jun 2014-Apr 2015</b>: Erin Teo Yi Ling, Wang Zi<br>
<b>Jun 2016-Dec 2017</b>: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin Mudzakir<br>
<b>Aug 2021-Apr 2023</b>: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius<br>
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 3</span></strong><br>
<b>Optiver: Aug 2023-Oct 2023</b>: Bui Hong Duc, Oleh Naver, Tay Ngan Lin<br>
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 3</span></strong><br>
<b>Aug 2023-Apr 2024</b>: Xiong Jingya, Radian Krisno, Ng Wee Han<br>
</p>
<p>
List of translators who have contributed &ge; 100 translations can be found at <a href="https://visualgo.net/statistics">statistics</a> page.
</p>
<p>
<strong><span style="line-height: 150%;">Acknowledgements</span></strong><br>
NUS <a href="https://nus.edu.sg/cdtl" target="_blank"><u>CDTL</u></a> gave Teaching Enhancement Grant to kickstart this project.<div>For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.</div>
</p>
</div>
</div>
<div id="termsofuse" class="overlays">
<h4>Terms of use</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that you <b>spread the word about its existence to fellow Computer Science students and instructors</b>. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.</p><p>Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (<a href="https://visualgo.net/">https://visualgo.net</a>) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo&#39;s client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.</p><p>Please note that VisuAlgo&#39;s online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the &#39;training mode.&#39; The &#39;test mode&#39; offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.</p><p><strong><span style="line-height: 200%;">List of Publications</span></strong></p> <p>This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can click <a href="https://ioinformatics.org/journal/INFOL099.pdf" target="_blank">this link</a> to read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) and <a href="https://ioinformatics.org/journal/v9_2015_243_245.pdf" target="_blank">this link</a> for the short update in 2015 (to link VisuAlgo name with the previous project).</p><p><strong><span style="line-height: 200%;">Bug Reports or Request for New Features</span></strong></p> <p>VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.</p>
</div>
</div>
<div id="privacy-policy" class="overlays">
<h4>Privacy Policy</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p><b>Version 1.2 (Updated Fri, 18 Aug 2023).</b></p><p>Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.</p><p>Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).</p><p>Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.</p><p>For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.<br></p><p>For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.</p>
</div>
</div>
</div>


<script src="../../code.jquery.com/jquery-3.7.0.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
<script src="../../cdn.jsdelivr.net/npm/bootstrap%405.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<script src="../../unpkg.com/d3-force-boundary%400.0.1/dist/d3-force-boundary.min.js"></script>
<script>
  $(function () {
    // overlays stuffs
    $('#trigger-about').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#about').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-team').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#team').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-terms').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#termsofuse').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-privacy').click(function () {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#privacy-policy').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    })

    $('.close-overlay').click(function() {
      $('.overlays').fadeOut(function() {
        $('#dark-overlay').fadeOut();
      });
    });

    $('#dark-overlay').click(function() {
      $('.overlays').fadeOut();
      $('#dark-overlay').fadeOut();
      if (typeof GeometryWidget !== 'undefined') {
        GeometryWidget.stopLoop();
      }
    });
  })
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-1566631-4"></script>
<script>
      $.ajaxSetup({
        headers: {
          'X-CSRF-TOKEN': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H"
        }
      });

      // handles account dropdown menu
      $(function () {
        $('#language-dropdown-btn').click(function (e) {
          $('#language-dropdown-menu').css('display', 'block');
          $('#account-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function () {
          $('#language-dropdown-menu').css('display', 'none')
        })
      })

      $(function () {
        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        })
      })

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        if (retval) {
          $('#current-action').show();
          $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
          $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
          triggerRightPanels();
          isPlaying = true;
        }
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; ++i) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      const MOBILE_WIDTH = 1000;
      const matchMediaMobile = window.matchMedia(`only screen and (max-width: ${MOBILE_WIDTH}px)`);
      const matchMediaNarrow = window.matchMedia(`only screen and (max-width: 500px)`);
      function isMobile() {
        return matchMediaMobile.matches;
      }
      //To fix the issue of a narrow desktop window being asked to rotate, I am now checking for it based on the navigator.userAgent to see if its mobile or not.
      //This may change in the future if browsers decide to change the naming of userAgent for mobile browsers so may need to keep an eye on this.
      function isMobileOS() {
        return /Mobi/i.test(navigator.userAgent) && !/ipad/i.test(navigator.userAgent);
      }
      let portraitMatcher = window.matchMedia("(orientation:portrait)");
      function isPortrait() {
        return portraitMatcher.matches;
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.colour').css("color", surpriseColour);
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
        });
      });

/*
      // GA dropped 26 Jun 2023 and then made official on 18 Aug 2023
/*
      // the sunset-ed GA, commented on 26 Jun 2023, and Prof Halim doesn't bother to use anymore
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
*/

      // function setCookie(cname, cvalue, exdays) {
      //   const d = new Date();
      //   d.setTime(d.getTime() + (exdays*24*60*60*1000));
      //   let expires = "expires="+ d.toUTCString();
      //   document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
      // }

//       //         $(function() {
//           $('#gdpr-accept').click(function () {
// /*
//             // added on 26 Jun 2023
//             window.dataLayer = window.dataLayer || [];
//             function gtag(){dataLayer.push(arguments);}
//             gtag('js', new Date());

//             gtag('config', 'UA-1566631-4');
// */
// //            ga('create', 'UA-1566631-4', 'auto');
// //            ga('send', 'pageview');
//             setCookie('use_google_analytics', 'true', 365)
//             $('#gdpr-popup').hide()
//           });
//           $('#gdpr-reject').click(function () {
//             setCookie('use_google_analytics', 'false', 365)
//             $('#gdpr-popup').hide()
//           });
//         });
//       
      $('#gdpr-privacy-policy').click(function () {
        if ($(window).width() > 600) {
          $('#dark-overlay').fadeIn(function() {
            $('#privacy-policy').fadeIn();
          });
        }
        else
          alert('Sorry, this dialog is too big. Please load it on bigger screen');
      })
    </script>

<script src="../js/jquery-ui.min.js"></script>

<script src="../js/d3.min.js"></script>
<script src="../js/viz-1.0.10.js"></script>

<script src="../js/graph_library/constant.js"></script>
<script src="../js/graph_library/drawgraph.js"></script>
<script src="../js/graph_library/GraphEdgeWidget.js"></script>
<script src="../js/graph_library/GraphPolygonWidget.js"></script>
<script src="../js/graph_library/GraphVertexWidget.js"></script>
<script src="../js/graph_library/GraphWidget.js"></script>
<script src="../js/graph_library/helperObjects89db.js?refresh22aug9pm"></script> 
<script src="../js/graph_library/misc.js"></script>
<script src="../js/graph_library/properties.js"></script>
<script src="../js/graph_library/Widget.js"></script>
<script src="../js/graph_library/force_directed_library.js"></script>

<script>
      $(function () {
        let defaultPlaybackSpeed = 1;
                createPlaybackSpeedSlider(defaultPlaybackSpeed);


        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        });
        //Mobile Design Related DOM Manipulations
        if (isMobile()) {
          $("#status").css({
            "bottom": "10%",
            "height": "12%",
            "max-height": "54px"
          });
          $("#current-action").css("bottom", "22%");
          $('#status-hide').remove();
          $('#left-bar').remove();
          $('#right-bar').remove();
          $("#mode-menu").remove();
          $("#codetrace").css("z-index", 1);
          $("#bottom-bar a").hide();
          $("#bottom-bar").css("height", $("#topbar").css("height"));
          $(".speed-dropup-btn").show();
          $("#go-to-beginning").remove();
          $("#go-to-end").remove();
          $("#pause").remove();
          $("#play").remove();
          $("#previous").remove();
          $("#next").remove();

          //make progress bar longer
          $("#progress-bar").css({
            left: "30%",
            width: "60%",
            'margin-left': 0
          })
        }
      })

      let mobilePlaybackOverlayTimeout;
      $(function() {
        $("#viz").on("click", () => {
          if (isMobile()) {
            if ($("#mobile-playback-overlay").is(":hidden") && isPlaying) {
              $("#mobile-playback-overlay").fadeIn();
              hideMobilePlaybackOverlay(6000);
            } else {
              $("#mobile-playback-overlay").fadeOut();
            }
          }
        });
        $("#mobile-playback-overlay").on("click", (event) => {
          if (event.target === event.currentTarget) //to ensure clicks on the controls dont fade the overlay
            $("#mobile-playback-overlay").fadeOut();
          else
            hideMobilePlaybackOverlay(5000);
        })
      });
      function hideMobilePlaybackOverlay(timeOut) {
        if (mobilePlaybackOverlayTimeout)
          clearTimeout(mobilePlaybackOverlayTimeout);
        mobilePlaybackOverlayTimeout = setTimeout(() => {
            $("#mobile-playback-overlay").fadeOut();
        }, timeOut);
      }
      function mobilePlaybackPauseOrPlay() {
        if ($("#mobile-playback-overlay").hasClass("playing")) {
          pause();
          hideMobilePlaybackOverlay(5000);
        } else {
          play();
          hideMobilePlaybackOverlay(3000);
        }
      }
      let rewindLabelTimeout, forwardLabelTimeout;
      function mobilePlaybackRewind() {
        $("#mobile-playback-rewind-label").css("opacity", 1);
        if (rewindLabelTimeout)
          clearTimeout(rewindLabelTimeout);
        rewindLabelTimeout = setTimeout(() => {
          $("#mobile-playback-rewind-label").css("opacity", 0);
        }, 800);
        stepBackward(7);
      }
      function mobilePlaybackForward() {
        $("#mobile-playback-forward-label").css("opacity", 1);
        if (forwardLabelTimeout)
          clearTimeout(forwardLabelTimeout);
        forwardLabelTimeout = setTimeout(() => {
          $("#mobile-playback-forward-label").css("opacity", 0);
        }, 800);
        stepForward(7);
      }

      //let eLectureSessionHistory = {};
      const sectorColors = ['#05a4d0', '#f1c706', '#fa0202'];
      function setSlideTimelineColor(slideNo) {
        const sectionNo = slideNo.split('-')[0];
        $(`[slideNo="${slideNo}"]`).css('background', sectorColors[(parseInt(sectionNo) % 3)]);
      }

      let currSlideTimer = null; //global so that we can clear the timeout when required

      const lectureIds = [{"id":68,"category":"suffixtree","order":1,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:29:41","updated_at":"2022-03-27 10:11:01","section":-1,"code":"","section_order":-1,"value":"1","text":"<p>A <b>Suffix Tree<\/b> is a compressed tree containing all the suffixes of the given (usually long) text string <b>T<\/b> of length <b>n<\/b> characters (<b>n<\/b> can be in order of hundred thousands characters).<\/p><br><p>The positions of each suffix in the text string <b>T<\/b> are recorded as integer indices at the leaves of the Suffix Tree whereas the path labels (concatenation of edge labels starting from the root) of the leaves describe the suffixes.<\/p><br><p>Suffix Tree provides a particularly fast implementation for many important (long) string operations.<\/p><br><p>This data structure is very related to the <a href=\".\/suffixarray\"><u>Suffix Array<\/u><\/a> data structure. Both data structures are usually studied together.<\/p>","title":"Suffix Tree"},{"id":706,"category":"suffixtree","order":1,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-28 07:28:05","updated_at":"2022-03-27 08:22:05","section":68,"code":"","section_order":1,"value":"1-1","text":"<p>The suffix <b>i<\/b> (or the <b>i<\/b>-th suffix) of a (usually long) text string <b>T<\/b> is a &#39;special case&#39; of substring that goes from the <b>i<\/b>-th character of the string up to its <i>last<\/i> character.<\/p><br><p>For example, if <b>T<\/b> = \"STEVEN$\", then suffix 0 of <b>T<\/b> is \"STEVEN$\" (0-based indexing), suffix 2 of <b>T<\/b> is \"EVEN$\", suffix 4 of <b>T<\/b> is \"EN$\", etc.<\/p>","title":"Suffix of a String T"},{"id":69,"category":"suffixtree","order":2,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:30:24","updated_at":"2022-03-27 08:24:08","section":-1,"code":"$(\"#arrv1\").val(\"GATAGACA$\");\nbuildSuffixTree();","section_order":-1,"value":"2","text":"<p>The visualization of Suffix Tree of a string <b>T<\/b> is basically a rooted tree where path label (concatenation of edge label(s)) from root to each leaf describes a suffix of <b>T<\/b>. Each leaf vertex is a suffix and the integer value written inside the leaf vertex (we ensure this property with terminating symbol $) is the suffix number.<\/p><br><p>An internal vertex will branch to more than one child vertex, therefore there are more than one suffix from the root to the leaves via this internal vertex. The path label of an internal vertex is a common prefix among those suffix(es).<\/p>","title":"Suffix Tree Visualization"},{"id":705,"category":"suffixtree","order":1,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-28 07:27:00","updated_at":"2018-03-28 07:27:23","section":69,"code":"$(\"#arrv1\").val(\"GATAGACA$\");\nbuildSuffixTree();","section_order":2,"value":"2-1","text":"<p>The Suffix Tree above is built from string <b>T<\/b> = \"GATAGACA$\" that have these 9 suffixes:<\/p><table><tr><th><b>i<\/b><\/th><th><b>Suffix<\/b><\/th><\/tr><tr><td>0<\/td><td>GATAGACA$<\/td><\/tr><tr><td>1<\/td><td>ATAGACA$<\/td><\/tr><tr><td>2<\/td><td>TAGACA$<\/td><\/tr><tr><td>3<\/td><td>AGACA$<\/td><\/tr><tr><td>4<\/td><td>GACA$<\/td><\/tr><tr><td>5<\/td><td>ACA$<\/td><\/tr><tr><td>6<\/td><td>CA$<\/td><\/tr><tr><td>7<\/td><td>A$<\/td><\/tr><tr><td>8<\/td><td>$<\/td><\/tr><\/table><p>Now verify that the path labels of suffix 7\/6\/2 are \"A$\"\/\"CA$\"\/\"TAGACA$\", respectively (there are 6 other suffixes). The internal vertices with path label \"A\"\/\"GA\" branch out to 4 suffixes {7, 5, 3, 1}\/2 suffixes {4, 0}, respectively (we ignore the trivial internal vertex = root vertex that branches out to all 9 suffixes).<\/p>","title":"Example with T = \"GATAGACA$\""},{"id":704,"category":"suffixtree","order":2,"top":"310px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-28 06:55:47","updated_at":"2022-03-27 08:25:18","section":69,"code":"$(\"#arrv1\").val(\"GATAGACA$\");\nbuildSuffixTree();","section_order":2,"value":"2-2","text":"<p>In order to ensure that every suffix of the input string <b>T<\/b> ends in a leaf vertex, we enforce that string <b>T<\/b> ends with a special terminating symbol &#39;$&#39; that is not used in the original string <b>T<\/b> and has ASCII value lower than the lowest allowable character in <b>T<\/b> (which is character &#39;A&#39; in this visualization). This way, edge label &#39;$&#39; always appear at the leftmost edge of the root vertex of this Suffix Tree visualization.<\/p><br><p>For the Suffix Tree example above (for <b>T<\/b> = \"GATAGACA$\"), if we do not have terminating symbol &#39;$&#39;, notice that suffix 7 \"A\" (without the &#39;$&#39;) does NOT end in a leaf vertex and can complicate some operations later.<\/p>","title":"Terminating Symbol $"},{"id":707,"category":"suffixtree","order":3,"top":"300px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-28 07:41:34","updated_at":"2018-03-28 07:43:59","section":69,"code":"$(\"#arrv1\").val(\"AAAAAAA$\");\nbuildSuffixTree();","section_order":2,"value":"2-3","text":"<p>As we have ensured that all suffixes end at a leaf vertex, there are <i>at most<\/i> <b>n<\/b> leaves\/suffixes in a Suffix Tree. All internal vertices (including the root vertex if it is an internal vertex) are always branching thus there can be at most <b>n<\/b>-1 such vertices, as shown with one of the extreme test case on the right.<\/p><br><p>The maximum number of vertices in a Suffix Tree is thus = <b>n<\/b> (leaves) + (<b>n<\/b>-1) internal vertices = <b>2n<\/b>-1 = O(<b>n<\/b>) vertices. As Suffix Tree is a tree, the maximum number of edges in a Suffix Tree is also (<b>2n<\/b>-1)-1 = O(<b>n<\/b>) edges.<\/p>","title":"Suffix Tree has O(n) Vertices"},{"id":708,"category":"suffixtree","order":4,"top":"210px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-28 07:48:52","updated_at":"2022-03-27 08:26:16","section":69,"code":"$(\"#arrv1\").val(\"ABCDE$\");\nbuildSuffixTree();","section_order":2,"value":"2-4","text":"<p>When all the characters in string <b>T<\/b> is all distinct (e.g., <b>T<\/b> = \"ABCDE$\"), we can have the following very short Suffix Tree with exactly <b>n<\/b>+1 vertices (+1 due to root vertex).<\/p>","title":"Much Shorter Suffix Tree"},{"id":70,"category":"suffixtree","order":3,"top":"","right":"","bottom":"200px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:30:59","updated_at":"2022-03-27 08:27:41","section":-1,"code":"","section_order":-1,"value":"3","text":"<p>All available operations on the Suffix Tree in this visualization are listed below:<\/p><ol><li><b>Build Suffix Tree (instant\/details omitted)<\/b> &mdash; instant-build the Suffix Tree from string <b>T<\/b>.<\/li><li><b>Search<\/b> \u2014 Find the vertex in Suffix Tree of a (usually longer) string <b>T<\/b> that has path label containing the (usually shorter) pattern\/search string <b>P<\/b>.<\/li><li><b>Longest Repeated Substring (LRS)<\/b> \u2014 Find the deepest (the one that has the longest path label) internal vertex (as that vertex shares common prefix between two (or more) suffixes of <b>T<\/b>).<\/li><li><b>Longest Common Substring (LCS)<\/b> \u2014 Find the deepest internal vertex that contains suffixes from two different original strings.<\/li><\/ol><p>There are a few other possible operations of Suffix Tree that are not included in this visualization.<\/p>","title":"Available Operations"},{"id":710,"category":"suffixtree","order":1,"top":"","right":"","bottom":"200px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-28 07:53:55","updated_at":"2023-03-27 05:22:16","section":70,"code":"$(\"#build\").click().addClass(\"menu-highlighted\");","section_order":3,"value":"3-1","text":"<p>In this visualization, we only show the fully constructed Suffix Tree <i>without describing the details of the O(<b>n<\/b>) Suffix Tree construction algorithm<\/i> \u2014 it is a bit too complicated. Interested readers can explore <a href=\"https:\/\/en.wikipedia.org\/wiki\/Ukkonen%27s_algorithm\" target=\"_blank\"><u>this<\/u><\/a> instead.<\/p><br><p>We limit the input to only accept 25 (cannot be too long due to the available drawing space \u2014 but in the real application of Suffix Tree, <b>n<\/b> can be in order of hundred thousand to million characters) ASCII (or even Unicode) characters. If you do not write a terminating symbol &#39;$&#39; at the back of your input string, we will automatically do so. If you place a &#39;$&#39; in the middle of the input string, they will be ignored. And if you enter an empty input string, we will resort to the default \"GATAGACA$\".<\/p><br><p>For convenience, we provide a few classic test case input strings usually found in Suffix Tree\/Array lectures, but to showcase the strength of this visualization tool, you are encouraged to enter any 25-characters string of your choice (ending with character &#39;$&#39;). You can use Chinese characters (in Unicode), e.g., \"\u56db\u662f\u56db\u5341\u662f\u5341\u5341\u56db\u4e0d\u662f\u56db\u5341\u56db\u5341\u4e0d\u662f\u5341\u56db$\".<\/p>","title":"Build Suffix Tree (instant)"},{"id":711,"category":"suffixtree","order":2,"top":"","right":"","bottom":"200px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-28 08:04:50","updated_at":"2022-03-27 09:03:08","section":70,"code":"$(\"#search\").click().addClass(\"menu-highlighted\");\n$(\"#arrv1\").val(\"GATAGACA$\");\nbuildSuffixTree();","section_order":3,"value":"3-2","text":"<p>Assuming that the Suffix Tree of a (usually longer) string <b>T<\/b> (of length <b>n<\/b>) has been built, we want to find all occurrences of pattern\/search string <b>P<\/b> (of length <b>m<\/b>).<\/p><br><p>To do this, we search for the vertex <b>x<\/b> in the suffix Tree of <b>T<\/b> which has path label (concatenation of edge label(s) from the root to <b>x<\/b>) where <b>P<\/b> is the prefix of that path label. Once we find this vertex <b>x<\/b>, all the leaves in the subtree rooted at <b>x<\/b> are the occurrences.<\/p><br><p>Time complexity: O(<b>m+k<\/b>) where <b>k<\/b> is the total number of occurrences.<\/p><br><p>For example, on the Suffix Tree of <b>T<\/b> = \"GATAGACA$\" above, try these scenarios:<\/p><ol><li><b>P<\/b> is a full match with the path label of vertex <b>x<\/b>:<br><span class=\"slide-actions\" onclick=\"doButtonAction115()\">Search(\"A\")<\/span>, occurrences = {7, 5, 3, 1} or <span class=\"slide-actions\" onclick=\"doButtonAction116()\">Search(\"GA\")<\/span>, occurrences = {4, 0}<\/li><li><b>P<\/b> is a partial match with the path label of vertex <b>x<\/b>:<br><span class=\"slide-actions\" onclick=\"doButtonAction131()\">Search(\"T\")<\/span>, occurrences = {2} or <span class=\"slide-actions\" onclick=\"doButtonAction132()\">Search(\"GAT\")<\/span>, occurrences = {0}<\/li><li><b>P<\/b> is not found in <b>T<\/b>:<br><span class=\"slide-actions\" onclick=\"doButtonAction133()\">Search(\"WALDO\")<\/span>, occurrences = {NIL}<\/li><\/ol>","title":"Search"},{"id":712,"category":"suffixtree","order":3,"top":"","right":"","bottom":"200px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-28 08:18:18","updated_at":"2023-03-27 05:23:24","section":70,"code":"$(\"#lrs\").addClass(\"menu-highlighted\");\n$(\"#arrv1\").val(\"GATAGACA$\");\nbuildSuffixTree();","section_order":3,"value":"3-3","text":"<p>Assuming that the Suffix Tree of a (usually longer) string <b>T<\/b> (of length <b>n<\/b>) has been built, we can find the Longest Repeated Substring (LRS) in <b>T<\/b> by simply finding the deepest (the one that has the longest path label) internal vertex of the Suffix Tree of <b>T<\/b>.<\/p><br><p>This is because each internal vertex of the Suffix Tree of <b>T<\/b> branches out to at least two (or more) suffixes, i.e., the path label (common prefix of these suffixes) are <b>repeated<\/b>.<\/p><br><p>The deepest (the one that has the longest path label) internal vertex is the required answer, which can be found in O(<b>n<\/b>) with a simple tree traversal.<\/p><br><p>Without further ado, try <span class=\"slide-actions\" onclick=\"doButtonAction117()\">LRS(\"GATAGACA$\")<\/span>. We have LRS = \"GA\".<\/p><br><p>It is possible that <b>T<\/b> contains more than one LRS, e.g., try <span class=\"slide-actions\" onclick=\"doButtonAction134()\">LRS(\"BANANABAN$\")<\/span>.<br>We have LRS = \"ANA\" (actually overlap) or \"BAN\" (without overlap).<\/p>","title":"Longest Repeated Substring (LRS)"},{"id":713,"category":"suffixtree","order":4,"top":"","right":"","bottom":"200px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-28 08:25:15","updated_at":"2023-03-27 05:24:00","section":70,"code":"$(\"#lcs\").addClass(\"menu-highlighted\");\n$(\"#arrv1\").val(\"GATAGACA$\");\n$(\"#arrv2\").val(\"TACA#\");\nbuildSuffixTree();","section_order":3,"value":"3-4","text":"<p>This time, we need two input strings <b>T1<\/b> and <b>T2<\/b> that terminate with symbol &#39;$&#39;\/&#39;#&#39;, respectively. We then create the <b>generalized<\/b> Suffix Tree of these two strings <b>T1+T2<\/b> in O(<b>n<\/b>) where <b>n = n1+n2<\/b> (sum of the length of the two strings). We can find the Longest Common Substring (LCS) of those two strings <b>T1<\/b> and <b>T2<\/b> by simply finding the deepest <b>and valid<\/b> internal vertex of the generalized Suffix Tree of <b>T1+T2<\/b>.<\/p><br><p>To be a valid internal vertex for consideration as an LCS candidate, an internal vertex must represents suffixes from <b>both strings<\/b>, i.e., a <b>common<\/b> substring found in both <b>T1<\/b> and <b>T2<\/b>.<\/p><br><p>Then, since an internal vertex of the Suffix Tree of <b>T<\/b> branches out to at least two (or more) suffixes, i.e., the path label (common prefix of these suffixes) are <b>repeated<\/b>. If that internal vertex is also a valid internal vertex, then it is a <b>common<\/b> substring that is <b>repeated<\/b>.<\/p><br><p>The valid and deepest (the one that has the longest path label) internal vertex is the required answer, which can be found in O(<b>n<\/b>) with a simple tree traversal.<\/p><br><p>Without further ado, try <span class=\"slide-actions\" onclick=\"doButtonAction118()\">LCS(T1,T2)<\/span> on the generalized Suffix Tree of string <b>T1<\/b> = \"GATAGACA$\" and <b>T2<\/b> = \"CATA#\" (notice that the UI will change to generalized Suffix Tree version). We have LCS = \"ATA\".<\/p>","title":"Longest Common Substring (LCS)"},{"id":714,"category":"suffixtree","order":4,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-28 08:35:18","updated_at":"2018-03-28 08:35:18","section":-1,"code":"","section_order":-1,"value":"4","text":"<p>There are a few other things that we can do with Suffix Tree like \"Finding Longest Repeated Substring without overlap\", \"Finding Longest Common Substring of &ge; 2 strings\", etc, but we will keep that for later.<\/p><br><p>We will continue the discussion of this String-specific data structure with the more versatile to <a href=\".\/suffixarray\"><u>Suffix Array<\/u><\/a> data structure.<\/p>","title":"Extras"}];
      const numSlides = lectureIds.length;
      var sectorJunction12Section = 0, sectorJunction12Slide = 0;
      var sectorJunction23Section = 0, sectorJunction23Slide = 0;
      var sector1Count = 0, sector2Count = 0, sector3Count = 0;
      const sectorLength = Math.floor(numSlides / 3);
      function createELectureTimelineDisplay() {
        for (let j = 0; j < numSlides; ++j) {
          const currLecture = lectureIds[j].value;
          if (currLecture.includes('-')) {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-slide" slideNo=${lectureIds[j].value}></div>`)
            );
          } else {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-checkpoint" slideNo=${lectureIds[j].value}></div>`)
            );
          }
        }
      }

      function setSectorJunctionInfo() {
          //setting the sector junction slide numbers
          const j12 = sectorLength !== 0 ? (sectorLength - 1): 0;
          const j23 = sectorLength !== 0 ? (2 * sectorLength - 1) : 0;

          const sectorJunction12 = lectureIds[j12].value.split('-');
          sectorJunction12Section = parseInt(sectorJunction12[0]);
          sectorJunction12Slide = sectorJunction12.length > 1 ? parseInt(sectorJunction12[1]) : sectorJunction12Slide;

          const sectorJunction23 = lectureIds[j23].value.split('-');
          sectorJunction23Section = parseInt(sectorJunction23[0]);
          sectorJunction23Slide = sectorJunction23.length > 1 ? parseInt(sectorJunction23[1]) : sectorJunction23Slide;
      }

      function runSlide(slide) { // Steven's patch on 28 Jan 2022: Properly remove slide 99, 99-1, 99-2, 99-3, integrate with the earlier slides
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 7 + "%)");
          
        }
        if (slide == '1-1') {
          $("#e-lecture").html("slide " + slide + " (" + 15 + "%)");
          
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 23 + "%)");
          $("#arrv1").val("GATAGACA$");
buildSuffixTree();
        }
        if (slide == '2-1') {
          $("#e-lecture").html("slide " + slide + " (" + 30 + "%)");
          $("#arrv1").val("GATAGACA$");
buildSuffixTree();
        }
        if (slide == '2-2') {
          $("#e-lecture").html("slide " + slide + " (" + 38 + "%)");
          $("#arrv1").val("GATAGACA$");
buildSuffixTree();
        }
        if (slide == '2-3') {
          $("#e-lecture").html("slide " + slide + " (" + 46 + "%)");
          $("#arrv1").val("AAAAAAA$");
buildSuffixTree();
        }
        if (slide == '2-4') {
          $("#e-lecture").html("slide " + slide + " (" + 53 + "%)");
          $("#arrv1").val("ABCDE$");
buildSuffixTree();
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 61 + "%)");
          
        }
        if (slide == '3-1') {
          $("#e-lecture").html("slide " + slide + " (" + 69 + "%)");
          $("#build").click().addClass("menu-highlighted");
        }
        if (slide == '3-2') {
          $("#e-lecture").html("slide " + slide + " (" + 76 + "%)");
          $("#search").click().addClass("menu-highlighted");
$("#arrv1").val("GATAGACA$");
buildSuffixTree();
        }
        if (slide == '3-3') {
          $("#e-lecture").html("slide " + slide + " (" + 84 + "%)");
          $("#lrs").addClass("menu-highlighted");
$("#arrv1").val("GATAGACA$");
buildSuffixTree();
        }
        if (slide == '3-4') {
          $("#e-lecture").html("slide " + slide + " (" + 92 + "%)");
          $("#lcs").addClass("menu-highlighted");
$("#arrv1").val("GATAGACA$");
$("#arrv2").val("TACA#");
buildSuffixTree();
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
        }
        clearTimeout(currSlideTimer);
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };
      var slideTimeline = {};

      //reads all visited slides in the slideTimeline and gives them their sector color
      function setVisitedSlideTimelineColors() {
        for(const [sectionNo, visitedSlides] of Object.entries(slideTimeline)) {
          const visitedSlides = slideTimeline[sectionNo];
          for(const visitedSlideNo of visitedSlides) {
            setSlideTimelineColor(visitedSlideNo);
          }
        }
      }

      //only called on load if there is nothing in session
      function setTimelineForCompletedSector(sectorNum) {
        let len = sectorLength;
        switch (sectorNum) {
          case 1 : len = sectorLength; break;
          case 2 : len = 2 * sectorLength; break;
          default: len = numSlides;
        }
        let i = 0;
        switch (sectorNum) {
          case 1 : i = 0; break;
          case 2 : i = sectorLength; break;
          default: i = 2 * sectorLength;
        }
        for (; i < len; i++) {
          saveELectureTimeline(lectureIds[i].value, true);
        }
      }

      function getUserSectorHistory(callback) {
        $.ajax({
          type: 'GET',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            topic: "/suffixtree".substring(1)
          }
        }
        ).done(function (data) {
            if (data.data[0] === 1) {
              setF1SectorColor(1);
              setTimelineForCompletedSector(1);
            }
            if (data.data[1] === 1) {
              setF1SectorColor(2);
              setTimelineForCompletedSector(2);
            }
            if (data.data[2] === 1) {
              setF1SectorColor(3);
              setTimelineForCompletedSector(3);
            }
            callback();
        }).fail(function (data) {
            console.log('get user sector history failed!');
        });
      }

      function getELectureTimelineFromSession() {
        const page = "/suffixtree".substring(1);
        const timelineKey = page + '-slide-timeline';
        const storedTimeline = window.sessionStorage.getItem(timelineKey);
        if (storedTimeline) {
          slideTimeline = JSON.parse(storedTimeline);
        } else {
          return false;
        }
        let slideInfo = [];
        for (const [sectionNum, slides] of Object.entries(slideTimeline)) {
          for (const slide of slides) {
            indicateSlideCompletedUI(slide);
            slideInfo = slide.split('-');
            incrementSectorVisits(parseInt(sectionNum), slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0);
          }
        }
        return true;
      }

      async function initializeELectureTimeline() {
        setSectorJunctionInfo();
        if (!getELectureTimelineFromSession())
          getUserSectorHistory(sectorBasedModeSelection);
        else
          sectorBasedModeSelection();

        createELectureTimelineDisplay();
        setVisitedSlideTimelineColors();
      }

      function setF1SectorColor(sectorNum) {
        $(`[sectorNo="${sectorNum}"]`).css('background', sectorColors[(parseInt(sectorNum) % 3)]);
      }

      function updateSectorInDB(sectorNum) {
        $.ajax({
          type: 'POST',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            section: (sectorNum - 1),
            topic: "/suffixtree".substring(1)
          }
        }
        ).done(function (data) {
            //console.log("Saved the sector " + sectorNum + " as done " + JSON.stringify(data));
        }).fail(function (data) {
            console.log("Setting sector done failed new attempt! "+ JSON.stringify(data));
        });
      }

      //If 87.5% or more of the slides in sector are done
      function setF1SectorCompleted(sectorNum, isInitializationCall) {
        setF1SectorColor(sectorNum);
        //avoid api call on initialization
        if (!isInitializationCall) {
          updateSectorInDB(sectorNum);
          $(`[sectorNo="${sectorNum}"]`).css("animation", "green-pulse 2s 4");
          setTimeout(() => {
            $(`[sectorNo="${sectorNum}"]`).css("animation", "");
          }, 8000);
        }
      }

      function incrementSectorVisits(sectionNum, slideNumWithinSection, isInitializationCall) {
        //updating sector count
        if (sectionNum < sectorJunction12Section
          || (sectionNum === sectorJunction12Section && slideNumWithinSection <= sectorJunction12Slide)) {
          ++sector1Count;
          if (sector1Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(1, isInitializationCall);
        } else if (sectionNum < sectorJunction23Section
          || (sectionNum === sectorJunction23Section && slideNumWithinSection <= sectorJunction23Slide)) {
          ++sector2Count;
          if (sector2Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(2, isInitializationCall);
        } else {
          ++sector3Count;
          if (sector3Count >= Math.ceil(0.875 * (numSlides - 2 * sectorLength)))
            setF1SectorCompleted(3, isInitializationCall);
        }
      }

      function saveELectureTimeline(slideNo, isInitialization) {
        const slideInfo = slideNo.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        if (slideTimeline[sectionNo]) {
          if (!slideTimeline[sectionNo].includes(slideNo)) {
            slideTimeline[sectionNo].push(slideNo);
            const sectionNum = parseInt(sectionNo);
            incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
          }
        } else {
          slideTimeline[sectionNo] = [];
          slideTimeline[sectionNo].push(slideNo);
          const sectionNum = parseInt(sectionNo);
          incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
        }
        setSlideTimelineColor(slideNo);
        indicateSlideCompletedUI(slideNo);
      }

      function saveELectureTimelineToSession() {
        const page = "/suffixtree".substring(1);
        const timelineKey = page + '-slide-timeline';
        window.sessionStorage.setItem(timelineKey, JSON.stringify(slideTimeline));
      }

      function handleTimelineOnRunSlide(slideValue) {
        const slideInfo = slideValue.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        //start timer only if the slide isnt already done
        if (!slideTimeline[sectionNo] || !slideTimeline[sectionNo].includes(slideValue)) {
          const slideTextLength = $('#electure-'+slideValue + " p").text().length + $('#electure-'+slideValue + " li").text().length;
          const CHARS_READ_PER_MS = 0.05; //when fast, 50 characters a second
          //setting max reading time as 10 seconds for around 500 character slide
          const minSlideReadingTime = Math.min(Math.max(2000, (slideTextLength / CHARS_READ_PER_MS) +  + (2000 * $('#electure-'+slideValue + " img").length)), 10000);
          currSlideTimer = setTimeout(() => {
            saveELectureTimeline(slideValue);
          }, minSlideReadingTime);
        }
      }

      function indicateSlideCompletedUI(slide) {
        $('#electure-'+slide).css("box-shadow", "3px 3px 8px green"); //set green shadow for completed slides
        $('#electure-'+slide + ' .electure-read-status').html("&#10004;");
        $('#electure-'+slide + ' .electure-read-status').attr("title", "Slide Completed!");
        $('#electure-'+slide + ' .electure-read-status').css("font-size", "17px");
      }

      function pushState(slideValue) {
        var url = '/en/suffixtree';
        if (typeof slideValue != 'undefined' && slideValue != null) {
          url += '?slide=' + slideValue;
                  }
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5);
        $('#overlay').show();

        $("#e-lecture-timeline").show();
        $("#e-lecture-f1map").show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
        $("#e-lecture-timeline").hide();
        $("#e-lecture-f1map").hide();
        clearTimeout(currSlideTimer);
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      function sectorBasedModeSelection() {
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        //check params are empty and then that all sectors are completed or not
        if (!Object.keys(params).length
          && sector1Count === sectorLength && sector2Count === sectorLength && sector3Count === (numSlides - 2 * sectorLength)) {
            hideOverlay();
        }
        else
          $('#mode-menu a').click();
      }

      $(function() {
        if (isMobileOS() && portraitMatcher.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').show();
          $('#widenDeviceText').hide();
          $('#topbar').css("z-index", 10001);
        } else if (matchMediaNarrow.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').hide();
          $('#widenDeviceText').show();
          $('#topbar').css("z-index", 10001);
        } else {
          $('#rotateDeviceOverlay').hide();
          $('#topbar').css("z-index", "");
        }

        matchMediaNarrow.addEventListener('change', e => {
          //screws up for square device! NEED RESIZE EVENT
          if (e.matches) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').hide();
              $('#widenDeviceText').show();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        portraitMatcher.addEventListener('change', e => {
          if (e.matches && isMobileOS()) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').show();
              $('#widenDeviceText').hide();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        let slide = getUrlParameter('slide');
        if (typeof slide !== undefined && slide != null) {
          cur_slide = slide;
        }
        //do all timeline and slide stuff only if specific params not provided
        if (!Object.keys(params).length || params["slide"]) {
          if (!isMobile()) {
                            $('#mode-menu a').click();
                      }
        }
        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
        $('#electure-1-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-1-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
        $('#electure-2-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2-2');
          pushState('2-2');
        });
        $('#electure-2-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-2-2 .electure-next').click(function() {
          hidePopup();
          runSlide('2-3');
          pushState('2-3');
        });
        $('#electure-2-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
        $('#electure-2-3 .electure-next').click(function() {
          hidePopup();
          runSlide('2-4');
          pushState('2-4');
        });
        $('#electure-2-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-2');
          pushState('2-2');
        });
        $('#electure-2-4 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-3');
          pushState('2-3');
        });
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-4');
          pushState('2-4');
        });
        $('#electure-3-1 .electure-next').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
        $('#electure-3-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-3-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
        $('#electure-3-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
        $('#electure-3-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
        $('#electure-3-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
        $('#electure-3-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
      });

      function doButtonAction115() {
        $("#search_inp").val("A");
doSearch();
      }
      function doButtonAction116() {
        $("#search_inp").val("GA");
doSearch();
      }
      function doButtonAction117() {
        $("#arrv1").val("GATAGACA$");
buildSuffixTree();
doLRS();
      }
      function doButtonAction118() {
        doLCS();
      }
      function doButtonAction131() {
        $("#search_inp").val("T");
doSearch();
      }
      function doButtonAction132() {
        $("#search_inp").val("GAT");
doSearch();
      }
      function doButtonAction133() {
        $("#search_inp").val("WALDO");
doSearch();
      }
      function doButtonAction134() {
        $("#arrv1").val("BANANABAN$");
buildSuffixTree();
doLRS();
      }

      $('.electure-print').click(() => {
        window.open(`/en/suffixtree/print`);
      });
      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url.html) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}

      // This function will be called everytime 1.0x is changed to 0.5x or vice versa
      function redraw() {}

      $(document).ready(function () {
        setTimeout(function () {
          $('#change-lang-popup').fadeOut('slow')
        }, 5000)
      })
    </script>
<script type="text/javascript">
    var extraCSS = {"lcs":"65px","lrs":"92px","search":"119px","build":"146px"};
    var actionsIds = {"build":{"p":"Build Suffix Tree"},"search":{"p":"Search"},"lrs":{"p":"Longest Repeated Substring","onClick":"doLRS()"},"lcs":{"p":"Longest Common Substring"}};
    var isOpens = {};
    var len = 4;
    var keys = ["build","search","lrs","lcs"]; 
    for (i = 0; i < len; i++) {
        var actionDetails = keys[i];
        isOpens[actionDetails] = false;
    }
    function openAction(id) {
        hideThirdTiers(id);
        $("." + id).css("bottom", extraCSS[id]);
        if (!isOpens[id]) {
            $('.' + id).fadeIn('fast');
            isOpens[id] = true;
        }
    }
    function closeAction(id) {
        hideThirdTiers(id);
        if (isOpens[id]) {
            $('.' + id).fadeOut('fast');
            $('#' + id + '-err').html("");
            isOpens[id] = false;
        }
    }

    function hideEntireActionsPanel() {
        //hideAllThirdTiers();
                    closeAction('build');
                    closeAction('search');
                    closeAction('lrs');
                    closeAction('lcs');
                hideActionsPanel();
    }

    function hideThirdTiers(tier1Action) {
        if ("parents" in actionsIds[tier1Action]) {
            for (const secondTierAction of actionsIds[tier1Action]["parents"]) {
                $('#' + secondTierAction + '-third-tier').fadeOut('fast');
            }
        }
    }

    function hideAllThirdTiers() {
        for (const tier1Action in actionsIds) {
            hideThirdTiers(tier1Action);
        }
    }

    function toggleChildExtras(tier1, selectedParentTier2) {
        hideThirdTiers(tier1);
        //this actionId must have childExtras
        var style = extraCSS[tier1];
        $("." + tier1).css("bottom", (parseInt(style.substring(0, style.length - 2)) - 27));
        //fade ins and outs are done on the ID whereas css class is set on the class
        //fade in the third tier of the selected 2nd tier parent
        $('#' + selectedParentTier2 + '-third-tier').fadeIn('fast');

        // //fade out all other third tiers of that 'action'
        // for (const parent of actions[tier1]["parents"]) {
        //     console.log("parent is " + parent + " for " + selectedParentTier2);
        //     if (parent != selectedParentTier2) {
        //         $('#' + parent + '-third-tier').fadeOut('fast');
        //     }
        // }
    }

    function setActionHeightOriginal(tier1Action) {
        $("." + tier1Action).css("bottom", extraCSS[tier1Action]);
    }

            $('#' + 'build').click(function() {
            openAction('build');
                                                                            closeAction('search');
                                                                closeAction('lrs');
                                                                closeAction('lcs');
                                    });
            $('#' + 'search').click(function() {
            openAction('search');
                                                closeAction('build');
                                                                                            closeAction('lrs');
                                                                closeAction('lcs');
                                    });
            $('#' + 'lrs').click(function() {
            openAction('lrs');
                                                closeAction('build');
                                                                closeAction('search');
                                                                                            closeAction('lcs');
                                    });
            $('#' + 'lcs').click(function() {
            openAction('lcs');
                                                closeAction('build');
                                                                closeAction('search');
                                                                closeAction('lrs');
                                                                });
    
    //important to have all the input fields in actions menu take an id containing '-input'
    $("[id*='-input']").on("keypress keydown keyup", (event) => {
        event.stopPropagation();
    });
</script>
<script>
// Suffix Tree Widget
// original author: Nguyen Hoang Duy, then maintained by Steven Halim

var SuffixTreeWidget = function() {
  var self = this;
  var graphWidget = new GraphWidget();

  var coord = new Array();
  var A = new Array();
  var amountVertex = 0;
  var amountEdge = 0;

  var stateList = [];
  var edgeGenerator = d3.svg.line()
  .x(function(d){return d.x;})
  .y(function(d){return d.y;})
  .interpolate("linear");
  var mousedown_node = null;
  var mousemove_coor = null;
  var edgeList = [];
  var mousedown_in_progress = false, mousemove_in_progress = false, mouseup_in_progress = false;
  var mousedown_event = null, mousemove_event = null, mouseup_event = null;
  var deleted_vertex_list = [];
  var used_alt = -1;
  var adjMatrix = [], adjList = [];
  var edgeId = 0;

  var Txt='',    // the input text string
    root=null, // root of the suffix tree
    infinity;  // quite a big number
    nForks=0;  // number of branching nodes in the suffix tree
    width = 50;
    height = 30;
    height_offset = 18;
  var suffix_table = new Array(), reverse_suffix_table = new Array();
  var height_level = new Array();
  var draw_data = new Array();
  var processQueue = new Array();
  var fromResultNode = null, toResultNode = null;
  var foundResult = false;
  var cur_LRS_max = '', old_LRS_max ='';
  var LRSMax;
  var LRSMaxEqual = new Array();
  var currentColorNode = -1, currentColorElem = -1;
  var saveEdge = 0;
  var isCanvasClear = true;
  var maxX = 0, maxY = 0;

  mainSvg.style("class", "unselectable");
  mainSvg.attr("height", window.innerHeight-80);
  mainSvg.attr("width", window.innerWidth);

  $( window ).resize(function() {
  mainSvg.attr("height", window.innerHeight-80);
  mainSvg.attr("width", window.innerWidth);
  });

  var projection = d3.geo.albersUsa()
    .scale(1070)
    .translate([MAIN_SVG_WIDTH / 2, MAIN_SVG_HEIGHT / 2]);

  var path = d3.geo.path()
      .projection(projection);

  mainSvg.append("rect")
    .attr("class", "background")
    .attr("width", MAIN_SVG_WIDTH)
    .attr("height", MAIN_SVG_HEIGHT)
    .on("click", clicked);

  var g = mainSvg.append("g");

  function getCircleLineIntersectionPoint(x1, y1, x2, y2, r, cx, cy) {
    var baX = x2 - x1; //pointB.x - pointA.x;
    var baY = y2 - y1; //pointB.y - pointA.y;
    var caX = cx - x1; //center.x - pointA.x;
    var caY = cy - y1; //center.y - pointA.y;

    var a = baX * baX + baY * baY;
    var bBy2 = baX * caX + baY * caY;
    var c = caX * caX + caY * caY - r * r;

    var pBy2 = bBy2 / a;
    var q = c / a;

    var disc = pBy2 * pBy2 - q;
    var tmpSqrt = Math.sqrt(disc);
    var abScalingFactor1 = -pBy2 + tmpSqrt;
    var abScalingFactor2 = -pBy2 - tmpSqrt;

    var r_x1 = x1 - baX * abScalingFactor1;
    var r_y1 = y1 - baY * abScalingFactor1
    //Point p1 = new Point(pointA.x - baX * abScalingFactor1, pointA.y
    //      - baY * abScalingFactor1);
    var r_x2 = x1 - baX * abScalingFactor2;
    var r_y2 = y1 - baY * abScalingFactor2

    //Point p2 = new Point(pointA.x - baX * abScalingFactor2, pointA.y
    //       - baY * abScalingFactor2);
    var res = new Array();
    res[0] = r_x1; 
    res[1] = r_y1;
    res[2] = r_x2;
    res[3] = r_y2 ;
    return res;
  }

  function moveCircle(x, y, class_id) {
    mainSvg.selectAll(".v" + class_id)
    .attr("cx", x)
    .attr("cy", y);

    var b = mainSvg.selectAll(".v" + class_id);
    b[0] = b[0].splice(2,1);
    b.attr("y", y + 3);
    b.attr("x", x);

    for (var i=1; i <= Object.size(edgeList); i++) {
      var e = edgeList["#e" + i.toString()];
      if (typeof(e) == "undefined") continue;
      if (e[0] == class_id || e[1] == class_id)
        moveWeightedText(i);
    }
  }

  function calculateEdge(x1, y1, x2, y2) {
    var pts = getCircleLineIntersectionPoint(x1, y1, x2, y2, 15, x1, y1);
    var pts2 = getCircleLineIntersectionPoint(x1, y1, x2, y2, 15, x2, y2);
    var min = 5000;
    var save1 = 0, save2 = 0;
    for (var i=1; i<=3; i+=2)
      for (var j=1; j<=3; j+=2)
      {
        var d = Math.sqrt((pts[i-1]-pts2[j-1])*(pts[i-1]-pts2[j-1]) + (pts[i] - pts2[j])*(pts[i] - pts2[j]));
        if (d < min) {
          min = d;
          save1 = i; save2 = j;
        }
      }

      var beginPoint = {"x": pts[save1-1], "y": pts[save1]};
      var endPoint = {"x": pts2[save2-1], "y": pts2[save2]};

      return [beginPoint, endPoint];
    }

  // ax + by = c
  // return coordinate of intersection point
  // if parallel, return [-1,-1]
  function getLinesIntersection(a1, b1, c1, a2, b2, c2) {
    if (a1*b2 - a2*b1 == 0) return [-1, 1];
    return [(c1*b2 - b1*c2)/(a1*b2 - b1*a2), (a1*c2 - c1*a2)/(a1*b2 - b1*a2)];
  }

  // return distance from (x, y) to ax + by + c = 0
  function getDistancePointToLine(x, y, a, b, c) {
    return (Math.abs(a*x + y*b + c))/Math.sqrt(a*a + b*b);
  }

  // x1 is the origin
  function getStraightLineCoordinate(x1, y1, x2, y2) {
    // intersection with x - y - x1 + y1 = 0
    var intersection = getLinesIntersection(1, 1, x2 + y2, 1, -1, x1 - y1);
    var min = getDistancePointToLine(x2, y2, 1, -1, -x1 + y1);
    var save = intersection;
    // intersection with x + y - x1 - y1 = 0
    intersection = getLinesIntersection(-1, 1, -x2 + y2, 1, 1, x1 + y1);
    var dist = getDistancePointToLine(x2, y2, 1, 1, -x1 - y1);
    if (min > dist) {
      min = dist;
      save = intersection;
    }
    // intersection with x - x1 = 0
    intersection = getLinesIntersection(0, 1, y2, 1, 0, x1);
    dist = getDistancePointToLine(x2, y2, 1, 0, -x1);
    if (min > dist) {
      min = dist;
      save = intersection;
    }
    // intersection with y - y1 = 0
    intersection = getLinesIntersection(-1, 0, -x2, 0, 1, y1);
    dist = getDistancePointToLine(x2, y2, 0, 1, -y1);
    if (min > dist) {
      min = dist;
      save = intersection;
    }
    return save;
  }

  this.getGraphWidget = function() {
    return graphWidget;
  }

  this.getAmountVertex = function() {
    return amountVertex;
  }

  this.getAmountEdge = function() {
    return amountEdge;
  }

  function dist2P(x1, y1, x2, y2) {
    return Math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
  }

  // return the circle class id if is inside the circle
  // return -1 if free
  function isUsed(x,y) {
    var i,j;
    for (i=1; i<amountVertex; i++) {
      if (dist2P(x, y, coord[i][0], coord[i][1]) <= 35)
       return i;
   }
   return -1;
  }

  function resetEverything() {
    coord = new Array();
    A = new Array();
    amountVertex = 0;
    amountEdge = 0;

    stateList = [];
    edgeGenerator = d3.svg.line()
    .x(function(d){return d.x;})
    .y(function(d){return d.y;})
    .interpolate("linear");
    mousedown_node = null;
    mousemove_coor = null;
    edgeList = [];
    mousedown_in_progress = false, mousemove_in_progress = false, mouseup_in_progress = false;
    mousedown_event = null, mousemove_event = null, mouseup_event = null;
    deleted_vertex_list = [];
    used_alt = -1;
    adjMatrix = [], adjList = [];
    edgeId = 0;

    Txt='',    // the input text string
    root=null, // root of the suffix tree
    infinity;  // quite a big number
    nForks=0;  // number of branching nodes in the suffix tree
    width = 50;
    height = 30;
    height_offset = 18;
    suffix_table = new Array(), reverse_suffix_table = new Array();
    height_level = new Array();
    draw_data = new Array();
    processQueue = new Array();
    fromResultNode = null, toResultNode = null;
    foundResult = false;
    cur_LRS_max = '', old_LRS_max ='';
    LRSMax;
    LRSMaxEqual = new Array();
    currentColorNode = -1, currentColorElem = -1;
    saveEdge = 0;
    isCanvasClear = true;
    maxX = 0, maxY = 0;
  }

  function clearScreen() {
    var i;

    // remove edges first
    for (i = 1; i <= amountEdge; i++){
      graphWidget.removeEdge(i);
    }

    // remove vertices after removing edges
    for (i = 1; i < amountVertex; i++){
      graphWidget.removeVertex(A[i].getSecond());
    }
    try {
      graphWidget.removeVertex(0);
    } catch (err) {}

    mainSvg.selectAll(".edgelabel").remove();
    mainSvg.selectAll("text").remove();
    amountVertex = 0;
    resetEverything();
  }

  // Javascript addon: get size of an object
  Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
      if (obj.hasOwnProperty(key)) size++;
    }
    return size;
  };

  function addIndirectedEdge(vertexClassA, vertexClassB, edgeIdNumber, type, weight, show) {
    graphWidget.addEdge(vertexClassA, vertexClassB, edgeIdNumber, type, weight, show);
    var edgeId = "#e" + edgeIdNumber.toString();
    edgeList[edgeId.toString()] = [vertexClassA, vertexClassB];
  }

  function createAdjMatrix() {
    var vertex_count = getNextVertexId() - 1;
    adjMatrix = new Array(vertex_count);
    for (var i = 0; i < vertex_count; i++) {
      adjMatrix[i] = new Array(vertex_count);
      for (var j=0; j < vertex_count; j++)
        adjMatrix[i][j] = 0;
    }

    var tmp = "#e";
    for (var i=1; i <= Object.size(edgeList); i++) {
      var edge_id = tmp + i.toString();
      if (mainSvg.select(edge_id).attr("style"))
        if (mainSvg.select(edge_id).attr("style").indexOf("hidden") != -1) continue;
      var from_vertex_id = edgeList[edge_id][0];
      var target = mainSvg.selectAll(".v" + from_vertex_id.toString());
      var from_vertex_content = target[0][2].textContent;

      var to_vertex_id = edgeList[edge_id][1];
      if (from_vertex_id == to_vertex_id) continue;

      target = mainSvg.selectAll(".v" + to_vertex_id.toString());
      var to_vertex_content = target[0][2].textContent;

      if (document.getElementById("weighted_checkbox").checked) {
        var weight = document.getElementById("w_e"+ i.toString());
        adjMatrix[parseInt(from_vertex_content)][parseInt(to_vertex_content)] = (weight == null) ? 1 : weight.textContent;
        if (!document.getElementById("direct_checkbox").checked)
          adjMatrix[parseInt(to_vertex_content)][parseInt(from_vertex_content)] = (weight == null) ? 1 : weight.textContent;
      } else {
        adjMatrix[parseInt(from_vertex_content)][parseInt(to_vertex_content)] = 1;
        if (!document.getElementById("direct_checkbox").checked)
          adjMatrix[parseInt(to_vertex_content)][parseInt(from_vertex_content)] = 1;
      }
    }
    var xv = 1;
    drawAdjMatrix();
  }

  function pair(a, b) { this.fst = a; this.snd = b; } // i.e. <fst, snd>
// NB. most of Ukkonen's functions return a pair (s,w)


  function isEmptyStrng() { return this.right < this.left; }

  function Strng(left, right) // represents Txt[left..right]
  { this.left=left; this.right=right;
   this.isEmpty = isEmptyStrng;
  }//constructor


  function addTrnstn(left, right, s) // this['a'] >---(left..right)---> s
  // add a transition to `this' state
  { this[Txt.charAt(left)] = new pair(new Strng(left,right), s);
   this.isLeaf = false;
  }

  function State() // i.e. a new leaf node in the suffix tree
  { this.addTransition = addTrnstn; this.isLeaf = true; }

  function Node(word, x, y) {
    this.word = word;
    this.x = x;
    this.y = y;
  }

  function stringCmp(a, b) {
    for (var i=0; i<Math.min(a.length, b.length); i++) {
      if (a[i] < b[i]) return 1;
      else if (a[i] > b[i]) return -1;
    }
    if (a.length == b.length) return 0;
    else if (a.length > b.length) return -1;
    return 1;
  }

  function Node2(word, index) {
    this.word = word;
    this.index = index;
  }

  function Node3(word, suffix_index, parent_index, x, y, path_label, class_id, color)  {
    this.word = word;
    this.suffix_index = suffix_index;
    this.parent_index = parent_index;
    this.x = x;
    this.y = y;
    this.path_label = path_label;
    this.class_id = class_id;
    if (typeof(color)=='undefined') this.color = 'black';
    else this.color = color;
  }

  function Node4(path_label, node_label,  x, y, match_flag) {
    this.path_label = path_label;
    this.node_label = node_label;
    this.x = x;
    this.y = y;
    this.match_flag = match_flag;
  }

  function NodeLRS(path_label, x, y, is_leaf) {
    this.path_label = path_label;
    this.x = x;
    this.y = y;
    this.is_leaf = is_leaf;
  }

  function NodeG(prev_x, isString1, isString2) {
    this.prev_x = prev_x;
    this.isString1 = isString1;
    this.isString2 = isString2;
  }

  function upDate(s, k, i)
  // (s, (k, i-1)) is the canonical reference pair for the active point
  {
    var oldr = root;                                                        
    var endAndr = test_and_split(s, k, i-1, Txt.charAt(i))                  
    var endPoint = endAndr.fst; var r = endAndr.snd                         

    while (!endPoint)                                                       
    { r.addTransition(i, infinity, new State());                           
      if (oldr != root) oldr.sLink = r;                                    

      oldr = r;
      var sAndk = canonize(s.sLink, k, i-1)                                
      s = sAndk.fst; k = sAndk.snd;                                        
      endAndr = test_and_split(s, k, i-1, Txt.charAt(i))                   
      endPoint = endAndr.fst; r = endAndr.snd;                             
    }                                                                      

    if(oldr != root) oldr.sLink = s;                                       

    return new pair(s, k);
  }//upDate


  function test_and_split(s, k, p, t) { 
    if(k<=p)                                                                
    { // find the t_k transition g'(s,(k',p'))=s' from s                  
      // k1 is k'  p1 is p'                                                
      var w1ands1 = s[Txt.charAt(k)];          // s --(w1)--> s1            
      var s1 = w1ands1.snd;                                               
      var k1 = w1ands1.fst.left;  var p1 = w1ands1.fst.right;

      if (t == Txt.charAt(k1 + p - k + 1))
         return new pair(true, s);
      else
       { var r = new State()
         s.addTransition(k1, k1+p-k,   r);     // s ----> r ----> s1
         r.addTransition(    k1+p-k+1, p1, s1);
         return new pair(false, r)
       }
    }
    else // k > p;  ? is there a t-transition from s ?
    return new pair(s[t] != null, s);
  }//test_and_split


  function canonize(s, k, p) {
    if(p < k) return new pair (s, k);

     // find the t_k transition g'(s,(k',p'))=s' from s
     // k1 is k',  p1 is p'
     var w1ands1 = s[Txt.charAt(k)];                            // s --(w1)--> s1
     var s1 = w1ands1.snd;
     var k1 = w1ands1.fst.left;  var p1 = w1ands1.fst.right;

     while(p1-k1 <= p-k)                               // s --(w1)--> s1 ---> ...
      { k += p1 - k1 + 1;                    // remove |w1| chars from front of w
        s = s1;
        if(k <= p)
         { w1ands1 = s[Txt.charAt(k)];                          // s --(w1)--> s1
           s1 = w1ands1.snd;
           k1 = w1ands1.fst.left; p1 = w1ands1.fst.right;
         }
       }
      return new pair(s, k);
  }//canonize


  function insertionSort(Txt, second) // NB. O(n**2) or worse; unacceptable for long input strings!
  { //if(Txt.length > 11) return;//too long for sorting
    //var suffixW = document.getElementById('suffixW');
    //suffixW.value = '';
    var table = document.getElementById('myTable');
    var A = new Array(), len = Txt.length;
    //cleanup();
    var i;
    for(i = 0; i < Txt.length; i++) A[i] = i;
    for(i = 0; i < Txt.length-1; i++)
    { var j,  small = i;
      for(j = i+1; j < Txt.length; j++)
         if(Txt.substring(A[j],len) < Txt.substring(A[small], len))
            small = j;
      var temp = A[i]; A[i] = A[small]; A[small] = temp;
    }
    for(i = 0; i < len; i++)
    { var numbr = '    '+(A[i])+': ';
      numbr = numbr.substring(numbr.length-4, numbr.length);
      //document.theForm.opt.value += numbr+Txt.substring(A[i], len)+'\n';
      suffix_table[A[i]] = Txt.substring(A[i], len);
      reverse_suffix_table[Txt.substring(A[i], len)] = A[i];
    }
    for (i=0; i < suffix_table.length-1; i++) {
      for (var j=i+1; j< suffix_table.length; j++) {
        if (suffix_table[i] > suffix_table[j]) {
          var tmp = suffix_table[i];
          suffix_table[i] = suffix_table[j];
          suffix_table[j] = tmp;
        }
      }
    }
    /*
    for (i=0; i < suffix_table.length; ++i) {
      var $input = $('<tr><td height=20px>' + i + '</td>' +  ' <td>' + reverse_suffix_table[suffix_table[i]] + '</td> ' + '<td>' + suffix_table[i] + '</td> ' + ' </tr>').appendTo(suffixW.getWidget().find('.tb1'));
      //row_draw_data[suffix_table[i]] = i;
    } */
    //document.theForm.opt.value += '\n';
    /*
    var canvas = document.getElementById('canvas');  
    if (typeof(second)!== "undefined") {
    canvas.addEventListener('click', function(evt) {
          var mousePos = getMousePos(canvas, evt);
          //alert(mousePos.x + " " + mousePos.y);
          var message = 'Mouse position: ' + mousePos.x + ',' + mousePos.y;
          insertionSort(Txt);
          highlightFromTreeToArray(mousePos);
        }, false);

    $('.vertices').css('pointer-events','none');  
    $('.edges').css('pointer-events','none');
    $('.overlays').css('pointer-events','none');

    }*/
 }//insertionSort

  function algorithm2() { 
    var s, k, i;
    var bt;

    root = new State();
    bt = new State();                                      // bt (bottom or _|_)

    // Want to create transitions for all possible chars
    // from bt to root
    for (i = 0; i < Txt.length; i++)
      bt.addTransition(i,i, root);

    root.sLink = bt;
    s = root; k = 0;  // NB. Start k=0, unlike Ukkonen paper our strings are 0 based

    for (i = 0; i < Txt.length; i++) {
      var sAndk = upDate(s, k, i);   // (s,k) < - upDate(...)
      s = sAndk.fst; k = sAndk.snd;
      sAndk = canonize(s, k, i);     // (s,k) < - canonize(...)
      s = sAndk.fst; k = sAndk.snd;
    }
  } // algorithm2 

  this.showGATAGACA = function() {
    clearScreen();
    stDriver();
  }

  this.buildSuffixTree = function(txt) {
    clearScreen();
    Txt = txt;
// console.log('this.buildSuffixTree txt = ' + txt);
    stDriver(txt);
  }

  this.buildGeneralSuffixTree = function() {
    clearScreen();
    stGeneralDriver();
  }

  // return values:
  // .index of input that will be used to match later (>0)
  // .-1 when not match from the beginning
  // .-2 when match
  // .1  when partial match
  /*
  function isPrefix(input, input_idx, node_label) {
    if (node_label=='') return 0;
    var j = 0, i;
    for (i= input_idx; i < input.length; i++) {
      if (input[i] != node_label[j]) return -1; // not match
      j++;
      if (j == node_label.length) break;
    } 
    //if (input.length - input_idx > node_label.length) return i;
    //if (input.length - input_idx <= node_label.length) return -2;
    if ()
  }
*/

  function isPrefix(input, input_idx, node_label) {
// console.log('input = ' + input + ', input_idx = ' + input_idx + ', node_label = ' + node_label);
    if (node_label == '') return 0;
    if (input[input_idx] != node_label[0]) return -1; // no match
    var j = 1, i;
    for (i = input_idx+1; i < input.length; i++) {
      // if (input[i] != node_label[j]) return -1; // this character does not match
      // j++;
      // if (j == node_label.length) break; // return i; // full match
      if (j == node_label.length) return i-1;
      if (input[i] == node_label[j]) j++;
    }
    //if (j != node_label.length) return 1; // input.length-input_idx >  node_label.length) return i;
    // if (input.length-input_idx <= node_label.length) return -2;
    return -2;
  }

  function prepareStDriver() {
    // if (Txt.length == 0) {
    //   alert('Please enter a non-empty string');
    //   return;
    // }
    // if (Txt[Txt.length-1] != '$') {
    //   alert('$ has been appended to your string');
    //   Txt += '$';
    //   document.getElementById("arrv1").value = Txt;
    // }
    infinity = Txt.length + 1000; // well it's quite big :-)
    nForks = 0;
    draw_data = new Array();
    //document.theForm.opt.value = '';
    suffix_table = new Array();
    reverse_suffix_table = new Array();
    currentColorNode = -1;
    currentColorElem = -1;
    insertionSort(Txt);

    algorithm2();  // ------------ the business
    height_level = new Array();
    for (var i=0; i < Txt.length; i++) height_level[i] = 0;
    //show(root, '', 'tree:|', 0, '');
    //document.theForm.opt.value += nForks + ' branching nodes';
    height = Txt.length*32;

    /*
    var ctx = document.getElementById("canvas").getContext("2d");
    ctx.clearRect(0, 0, 3000, 3000);

    ctx.save();
    */
    height_level[0] = height_offset ;
    for (var i=1; i < Txt.length; i++) {
        height_level[i] = height_level[0]*i*5.5;
    }
    maxY = 0; maxX = 0;
    // TODO:
    var startX = 70;
  }

  function stDriver(txt) { 
    Txt = txt;
    // if (Txt.length == 0) {
    //   alert('Please enter a non-empty string');
    //   return
    // }
    // if (Txt[Txt.length-1] != '$') {
    //   alert('$ has been appended to your string');
    //   Txt += '$';
    //   document.getElementById("arrv1").value = Txt;
    // }

// console.log('Txt = ' + Txt);
    infinity = Txt.length + 1000; // well it's quite big :-)
    nForks = 0;
    draw_data = new Array();
    suffix_table = new Array();
    reverse_suffix_table = new Array();
    currentColorNode = -1;
    currentColorElem = -1;
    insertionSort(Txt);

    algorithm2();  // ------------ the business
    height_level = new Array();
    for (var i=0; i < Txt.length; i++) height_level[i] = 0;
    //show(root, '', 'tree:|', 0, '');
    //document.theForm.opt.value += nForks + ' branching nodes';
    height = Txt.length*32;

    /*
    var ctx = document.getElementById("canvas").getContext("2d");
    ctx.clearRect(0, 0, 3000, 3000);
    ctx.save();
    */
    height_level[0] = height_offset ;
    for (var i = 1; i < Txt.length; i++)
      height_level[i] = height_level[0]*i*5.5;
    maxY = 0; maxX = 0;

    // TODO:
    var startX = 70;
    drawSuffixTree(root, 0, startX, '');
    startX = (window.innerWidth - (maxX - startX))/2.5;
    clearScreen();
    Txt = txt;
    prepareStDriver();
    drawSuffixTree(root, 0, startX, '');
    // TODO:
    drawAllLabel();

    // update coord
    var count = 1;
    for (var i in draw_data) {
      //var st = Txt.substring(i);
      var node = draw_data[i];
      var idx = parseInt(node.class_id)+1;
      coord[idx] = new Array();
      coord[idx][0] = node.x;
      coord[idx][1] = node.y;
      //draw_data[i].class_id = count++;
    }
    // coord[1] = new Array();
    //coord[1][0] = draw_data[""].x;
    //coord[1][1] = draw_data[""].y;
  } // stDriver

  function drawSuffixTree(T, level, prev_x, text) {
    var count = 0, iter = 0;
    for (attr in T) {
      if (attr.length == 1) count++;
    }

    var used = new Array(), min = '';
    for (attr in T)
      if (attr.length == 1) {
        var wAndT2 = T[attr];
        var w = wAndT2.fst;
        var myStr = Txt.substring(w.left, w.right+1);
        used.push(new Node2(myStr, attr));
      }
    for (var i=0; i<used.length-1; i++)
      for (var j=i+1; j<used.length; j++) {
        if (stringCmp(used[i].index, used[j].index) == -1 ) {
          var tmp = used[i];
          used[i] = used[j];
          used[j] = tmp;
        }
        else if (stringCmp(used[i].index, used[j].index) == 0) {
          if (stringCmp(used[i].word, used[j].word) == -1) {
            var tmp = used[i];
            used[i] = used[j];
            used[j] = tmp;
          }
        }
      }

    var update_prev_x = prev_x;
    var tmp_store = text.split(":");
    var T_idx = text, T_string = text;
    //for(attr in T)//each subtree
      //if(attr.length == 1)//a char attribute selects a suffix-tree branch
    for (var i = 0; i < used.length; i++) {
      iter++;
      var attr = used[i];
      if (iter > count/2) break;
      var wAndT2 = T[attr.index];
      var w = wAndT2.fst, T2 = wAndT2.snd;
      var Str_idx = Txt.substring(w.left, w.right+1);
      var myStr = T_string+ Str_idx ;
      //height = height_level[level];
      var y = (level+1)*height + height_offset;
      //drawVertex(update_prev_x,y,myStr,'black');
      var suffix_idx = -1;
      if (reverse_suffix_table[T_string + Str_idx]) {
        suffix_idx = reverse_suffix_table[T_string + Str_idx];
      }
      draw_data[T_string + Str_idx] = new Node3(T_string + Str_idx, suffix_idx, T_idx, 0, 0, T_string + Str_idx);
      update_prev_x = Math.max(update_prev_x, drawSuffixTree(T2, level+1, update_prev_x, myStr));
    }
    update_prev_x += width;
    var vertex_name = "";
    if (reverse_suffix_table[text] || reverse_suffix_table[text] === 0) vertex_name = reverse_suffix_table[text];
    height = height_level[level];
    if (maxX < update_prev_x) maxX = update_prev_x;
    if (maxY < height) maxY = height;

    //drawVertex(update_prev_x, height, vertex_name, 'black'); TODO:
    A[amountVertex] = new ObjectPair(vertex_name, amountVertex);
    graphWidget.addVertex(update_prev_x, height, A[amountVertex].getFirst(), A[amountVertex++].getSecond(), true);
    if (T_idx == "")
      draw_data[""] = new Node3(T_string, -1, -2, update_prev_x, level*height + height_offset, "", amountVertex-1);
    else {
      draw_data[T_idx].x = update_prev_x;
      draw_data[T_idx].y = height;
      draw_data[T_idx].class_id = amountVertex - 1;
    }
    iter = 0;
    for (var i = 0; i < used.length; i++) {
      iter++;
      if (iter > count/2) {
        var attr = used[i];
        var wAndT2 = T[attr.index];
        var w = wAndT2.fst, T2 = wAndT2.snd;
        var Str_idx = Txt.substring(w.left, w.right+1);
        //if (Str_idx.indexOf("#") > -1)
        //Str_idx = Str_idx.substring(0, Str_idx.indexOf("#")+1);
        var myStr = T_string + Str_idx;
        //show(T2, str2, myStr);
        var y = (level+1)*height + height_offset;
        //drawVertex(update_prev_x,y,myStr,'black');
        var suffix_idx = -1;
        if (reverse_suffix_table[T_string + Str_idx]) {
          suffix_idx = reverse_suffix_table[T_string + Str_idx];
        }
        draw_data[T_string + Str_idx] = new Node3(T_string + Str_idx, suffix_idx, T_idx, 0, 0, T_string + Str_idx);
        update_prev_x = Math.max(update_prev_x, drawSuffixTree(T2, level+1, update_prev_x, myStr));
      }
    }
    return update_prev_x;
  }

  function drawAllLabel() {
    var node;
    for (attr in draw_data) {
      if (attr == "") continue;
      node = draw_data[attr];
      if (typeof(node.parent_index) != 'undefined') {
        var tmp = draw_data[node.parent_index];
        var a = node.path_label, b = tmp.path_label, c="", i;
        if (b) {
          for (i = 0; i < a.length; i++) {
            if (a[i] != b[i]) break;
          }
          for (; i < a.length; i++) {
            c += a[i];
          }
        } else c = a;
        var pts = getCircleLineIntersectionPoint(tmp.x, tmp.y, node.x, node.y, 14, tmp.x, tmp.y);
        var pts2 = getCircleLineIntersectionPoint(tmp.x, tmp.y, node.x, node.y, 14, node.x, node.y);
        var min = 5000;
        var save1 = 0, save2 = 0;
        for (var i=1; i<=3; i+=2)
          for (var j=1; j<=3; j+=2)
        {
          if (Math.abs(pts[i] - pts2[j]) < min) {
            min = Math.abs(pts[i] - pts2[j]);
            save1 = i; save2 = j;
          }
        }

        drawLabel(tmp.class_id, node.class_id, pts[save1-1], pts[save1], pts2[save2-1], pts2[save2], c, node.color);
        //drawLabel(tmp.x, tmp.y, node.x, node.y, c, node.color);
        //drawLabel(pts[save1-1], pts[save1], pts2[save2-1],pts2[save2],c, node.color);
      }
    }
  }

  function drawLabel(from_class_id, to_class_id, xA, yA, xB, yB, text, color) {
    graphWidget.addEdge(from_class_id, to_class_id, ++amountEdge, EDGE_TYPE_UDE, 1, true);
    edgeList["#e" + amountEdge.toString()] = new Array();
    edgeList["#e" + amountEdge.toString()][0] = from_class_id;
    edgeList["#e" + amountEdge.toString()][1] = to_class_id;
    mainSvg.select("#e" + (amountEdge).toString()).attr("style", "stroke-width:0.5");
    var slope = (yA - yB)/(xA - xB);
    var x0 = xA, y0 = 0;
    var b = (yA - slope*xA);
    var deltaX = xA - xB;
    var delta = deltaX/(text.length+1);
    for (var i=0; i<text.length; i++) {
      x0-=delta;
      y0=slope*x0 + b;
      //ctx.fillText(text[i],x0,y0);
      mainSvg
     .append("text")
     .attr("class", "edgelabel")
     .attr("x", x0)
     .attr("y", y0)
     .attr("dx", 1)
     .attr("dy", ".35em")
     .attr("text-anchor", "middle")
     .text(function(d) { return text[i] });
    }
  }

  function clicked(d) {
    return;
    var cur = d3.mouse(this);
    mainSvg.selectAll(".edgelabel")
      .style("pointer-events", "none")
    .transition()
      .duration(750)
      .attr("transform", "translate(80,80)");

    if (!d || centered === d) {
    projection.translate([MAIN_SVG_WIDTH / 2, MAIN_SVG_HEIGHT / 2]);
    centered = null;
  } else {
    var centroid = path.centroid(d),
        translate = projection.translate();
    projection.translate([
      translate[0] - centroid[0] + MAIN_SVG_WIDTH / 2,
      translate[1] - centroid[1] + MAIN_SVG_HEIGHT / 2
    ]);
    centered = d;
  }

  // Transition to the new projection.
  g.selectAll("path").transition()
    .duration(750)
    .attr("d", path);
  }

  function createState(internalHeapObject) {
    var state = {
      "vl":{},
      "el":{},
      "status":{}
    };

    for (var i = 0; i < internalHeapObject.length; i++) {
      var key = internalHeapObject[i].getSecond();
      //var key = i;
      state["vl"][key] = {};
      state["vl"][key]["cx"] = coord[key+1][0];
      state["vl"][key]["cy"] = coord[key+1][1];
      state["vl"][key]["text"] = internalHeapObject[i].getFirst();
      state["vl"][key]["state"] = VERTEX_DEFAULT;
    }

    //for (var i = 1; i < internalHeapObject.length; i++){
    for (var i = 1; i <= Object.size(edgeList); i++){
      var edgeId = i;
      state["el"][edgeId] = {};
      state["el"][edgeId]["vertexA"] = edgeList["#e" + i.toString()][0]; //internalHeapObject[parent(i)].getSecond();
      state["el"][edgeId]["vertexB"] = edgeList["#e" + i.toString()][1];//internalHeapObject[i].getSecond();
      state["el"][edgeId]["type"] = EDGE_TYPE_UDE;
      state["el"][edgeId]["weight"] = 1;
      state["el"][edgeId]["state"] = EDGE_DEFAULT;
      state["el"][edgeId]["animateHighlighted"] = false;
    }

    return state;
  }

  this.testAnimation = function() {
    var currentState = createState(A);
    currentState["vl"][A[4].getSecond()]["state"] = VERTEX_HIGHLIGHTED;
    currentState["status"] = 'animate1 animate';
    currentState["lineNo"] = 0;
    stateList.push(currentState);
    //graphWidget.startAnimation(stateList);

    currentState = createState(A);
    currentState["vl"][A[4].getSecond()]["state"] = VERTEX_TRAVERSED;
    currentState["vl"][A[1].getSecond()]["state"] = VERTEX_HIGHLIGHTED;
    currentState["status"] = 'animate123';
    //currentState["lineNo"] = 1;
    //currentState["status"] = 'animate_2';
    stateList.push(currentState);
    //graphWidget.startAnimation(stateList);
    for (var i=0; i < 10; i++) {
      currentState = createState(A);
      currentState["vl"][A[i+1].getSecond()]["state"] = VERTEX_TRAVERSED;
      currentState["vl"][A[i].getSecond()]["state"] = VERTEX_HIGHLIGHTED;
      currentState["status"] = 'animate' + i.toString();
      currentState["lineNo"] = 2;
      stateList.push(currentState);
     //graphWidget.startAnimation(stateList);
    }

    var s2 = createState(A);
    currentState["vl"][A[4].getSecond()]["state"] = VERTEX_TRAVERSED;
    stateList.push(currentState);

    graphWidget.startAnimation(stateList);
    return true;
  }

  this.doSearch = function(input, callback) {
    populatePseudocode(0);
    this.buildSuffixTree(currentT);

    // (path_label, node_label, x, y, match_flag)
    var stateList = new Array();
    foundResult = false;
    processQueue = new Array();
    processQueue.push(new Node4('', '', draw_data[''].x, draw_data[''].y, -1));
    processTreeForSearch(root, '', '', '', input, 0);
    if (!foundResult) {
      // alert("Missing feature alert (not updated yet). Pattern string P is not in the Suffix Tree. The search should attempt searching all vertices in Suffix Tree and report failure at the end.");
      // return false;
      // processQueue.push(-1);
// console.log('oi');
    }
    var stack = new Array(), prev = new Array();
    var tmpProcessQ = new Array();
    var isGoingUp = new Array();
    tmpProcessQ[0] = processQueue[0];
    stack.push(processQueue[0]);
    var is_popping = false;
    for (var i=1; i < processQueue.length; i++) {
      var top = stack[stack.length-1];
      var next_node = processQueue[i];
      if ((draw_data[next_node.path_label].parent_index == top.path_label) && !is_popping) {
        stack.push(next_node);
        is_popping = false;
        tmpProcessQ.push(next_node);
      }
      else {
        while (true) {
          stack.pop();
          is_popping = true;
          top = stack[stack.length-1];
          if (draw_data[next_node.path_label].parent_index == top.path_label) {
            tmpProcessQ.push(top);
            isGoingUp[tmpProcessQ.length-1] = true;
            tmpProcessQ.push(next_node);
            stack.push(next_node);
            is_popping = false;
            break;
          }
          else {
            tmpProcessQ.push(top);
            isGoingUp[tmpProcessQ.length-1] = true;
          }
        }
      }
    }
    processQueue = tmpProcessQ;

    var prev = new Array();
    var prev_edge = new Array();
    var curState = createState(A);
    var populateResult = false;
    var isResultPartial = true;
    var results = new Array();
    var noMatch = false;
    curState["status"] = 'Current result will be yellow colored.';
    stateList.push(curState);
    for (var i in processQueue) {
      var currentState = createState(A);

      if (populateResult) {
        if (!isResultPartial) {
          isResultPartial = true;
          results = new Array();
        }
        var pl = processQueue[i].path_label;
        var tmp_q = new Array();
        tmp_q.push(pl);
        while (Object.size(tmp_q)) {
          pl = tmp_q.pop();
          if (pl[pl.length-1] != "$") {
            for (var j in draw_data) {
              var tpp = draw_data[j];
              if (tpp.parent_index == pl) tmp_q.push(tpp.path_label);
            }
          } else {
            results.push(pl);
          }
        }
        //results.push(processQueue[i].path_label);
        continue;
      }

      var node = processQueue[i];
      var node_idx = null;
      node_idx = parseInt(draw_data[node.path_label].class_id);
      if (isGoingUp[i]) {
        currentState = createState(A);
        currentState["status"] = 'Going back.';
        for (var j = 0; j < prev.length; j++)
          currentState["vl"][prev[j]]["state"] = VERTEX_TRAVERSED;
        for (var w = 0; w < Object.size(prev_edge); w++)
          currentState["el"][prev_edge[w]]["state"] = EDGE_TRAVERSED;
        currentState["vl"][node_idx]["state"] = VERTEX_HIGHLIGHTED;
        stateList.push(currentState);
        continue;
      }

      currentState["vl"][node_idx]["state"]= VERTEX_HIGHLIGHTED;
      for (var w = 0; w < Object.size(prev_edge); w++)
        currentState["el"][prev_edge[w]]["state"] = EDGE_TRAVERSED;
      for (var w = 1; w <= Object.size(edgeList); w++) {
        var e = edgeList["#e" + w.toString()];
        if (typeof(e) == "undefined") continue;
        if (e[1] == node_idx) {
          currentState["el"][w]["state"]= EDGE_HIGHLIGHTED;
          prev_edge.push(w);
          break;
        }
      }

      for (var j = 0; j < prev.length; j++)
        currentState["vl"][prev[j]]["state"]= VERTEX_TRAVERSED;
      prev.push(node_idx);
      if (node.match_flag == -2) {
        currentState["status"] = 'Path label: "{path_label}"<div>Pattern string P matches the prefix of path label. Done.</div>'.replace("{path_label}", node.path_label);
        currentState["lineNo"] = 5;
        isResultPartial = false;
        results.push(node.path_label);
        stateList.push(currentState);
        populateResult = true;
      }
      else if (node.match_flag == -1) {
        if (i == "0") {
          currentState["status"] = 'Start from the root';
          currentState["lineNo"] = 1;
        }
        else {
          currentState["status"] = 'Path label: "{path_label}".<div>Pattern string P does not match the prefix of path label. Skip.</div>'.replace("{path_label}", node.path_label);
          currentState["lineNo"] = 4;
        }
      }
      else {
        currentState["status"] = 'Path label: "{path_label}".<div>Pattern string P partially matches the prefix of path label. Go.</div>'.replace("{path_label}", node.path_label);
        currentState["lineNo"] = 6;
      }
      stateList.push(currentState);
    }

// console.log(processQueue[i]);
    if (!foundResult) { // processQueue[i] == -1) {
      currentState["status"] = 'No match found.'
      currentState["lineNo"] = 7;
      noMatch = true;
      for (var j = 0; j < prev.length; ++j)
        currentState["vl"][prev[j]]["state"] = VERTEX_TRAVERSED;
      stateList.push(currentState);
      // break;
    }
    else {
    // if (!noMatch) {
      currentState = createState(A);
      currentState["status"] = 'The results are yellow colored.'
      currentState["lineNo"] = 5;
      for (var j = 0; j<results.length; ++j) { // color all results with yellow
        var tmp_idx = parseInt(draw_data[results[j]].class_id);
        currentState["vl"][tmp_idx]["state"] = VERTEX_RESULT;
      }
      stateList.push(currentState);
    }

    graphWidget.startAnimation(stateList, callback);
    return true;
  }

  function processTreeForSearch(T, str, arc, node_label, input, input_idx) {
    if (T.isLeaf)
      return;
    var attr, iter = 0, i;
    //spaces += '|';   // |spaces|==|arc|
    //var str2 = str+spaces;//nosilla l

    var used = new Array();
    var min = '';

    for (attr in T)
      if (attr.length == 1) {
        var wAndT2 = T[attr];
        var w = wAndT2.fst;
        var myStr = Txt.substring(w.left, w.right+1);
        used.push(new Node2(myStr, attr));
      }
    for (var i = 0; i < used.length-1; i++)
      for (var j = i+1; j < used.length; j++) {
        if (stringCmp(used[i].index, used[j].index) == -1) {
          var tmp = used[i];
          used[i] = used[j];
          used[j] = tmp;
        }
        else if (stringCmp(used[i].index, used[j].index) == 0) {
          if (stringCmp(used[i].word, used[j].word) == -1) {
            var tmp = used[i];
            used[i] = used[j];
            used[j] = tmp;
          }
        }
      }
    for (var i = 0; i < used.length; i++) {
      attr = used[i];
      var wAndT2 = T[attr.index];
      var w = wAndT2.fst, T2 = wAndT2.snd;
      var node_label_cur = Txt.substring(w.left, w.right+1);
      var myStr = '('+(w.left)+':'+ node_label_cur +')|';
      var is_prefix = isPrefix(input, input_idx, node_label_cur);
      //(path_label, node_label, x, y, match_flag)
      processQueue.push(new Node4(node_label+node_label_cur, node_label_cur, draw_data[node_label+node_label_cur].x, draw_data[node_label+node_label_cur].y, is_prefix));
// console.log('is_prefix ' + is_prefix);
      if (is_prefix >= 0) {
        //processTreeForSearch(T2, "", myStr, Txt.substring(w.left, w.right+1), input, is_prefix+1);
        processTreeForSearch(T2, "", myStr, node_label+node_label_cur, input, is_prefix+1);
// console.log('IS THIS EVER EXECUTED ');
        return;
      }
      else if (is_prefix == -2) {
        fromResultNode = T;
        toResultNode = T2;
        var tmpQ = new Array();
        for (aattr in T2) {
          if (aattr.length == 1) {
            var wAndT2 = T2[aattr];
            var w = wAndT2.fst;
            var myStr = Txt.substring(w.left, w.right+1);
            // tmpQ.push(new Node4(input+myStr, myStr, draw_data[input+myStr].x, draw_data[input+myStr].y, 0));
            tmpQ.push(new Node4(node_label+node_label_cur+myStr, myStr, draw_data[node_label+node_label_cur+myStr].x, draw_data[node_label+node_label_cur+myStr].y, 0));
          }
        }
        for (var k = 0; k < tmpQ.length-1; k++)
          for (var j = k+1; j < tmpQ.length; j++)
            if (stringCmp(tmpQ[k].path_label, tmpQ[j].path_label) == -1) {
              var tmp = tmpQ[k];
              tmpQ[k] = tmpQ[j];
              tmpQ[j] = tmp;
            }
        for (var k = 0; k < tmpQ.length; k++)
          processQueue.push(tmpQ[k]);
        foundResult = true;
        return;
      }
    }
  }

  function addTraversedNode(state_list, prevs, current_state) {
    var stateList = state_list;
    for (var j = 0; j < prevs.length; j++)
      current_state["vl"][prevs[j]]["state"]= VERTEX_TRAVERSED;
    stateList.push(currentState);
    return stateList;
  }

  this.doLRS = function(callback) {
    populatePseudocode(1);
    this.buildSuffixTree(currentT);

    processQueueLRS = new Array();
    processQueueLRS.push(new NodeLRS('', draw_data[''].x, draw_data[''].y, false));
    var is_LCS = false;
    processTreeForLRS(root, '', is_LCS); // is_LCS always false

    var stateList = new Array();
    var currentState = createState(A);
    // if (is_LCS) { // legacy, I think Duong separates LRS with LCS eventually
    //   currentState["status"] = 'Purple vertices belong to string 1. Green vertices belong to string 2. Current result will be yellow colored.';
    //   stateList.push(currentState);
    // }
    currentState = createState(A);
    currentState["status"] = 'Start from the root.';
    currentState["lineNo"] = 1;
    //currentState["vl"][6]["state"] = VERTEX_HIGHLIGHTED;
    stateList.push(currentState);

    var stack = new Array(), prev = new Array();
    var tmpProcessQ = new Array();
    var isGoingUp = new Array();
    tmpProcessQ[0] = processQueueLRS[0];
    stack.push(processQueueLRS[0]);
    var is_popping = false;
    for (var i = 1; i < processQueueLRS.length; i++) {
      var top = stack[stack.length-1];
      var next_node = processQueueLRS[i];
      if ((draw_data[next_node.path_label].parent_index == top.path_label) && !is_popping) {
        stack.push(next_node);
        is_popping = false;
        tmpProcessQ.push(next_node);
      }
      else {
        while (true) {
          stack.pop();
          is_popping = true;
          top = stack[stack.length-1];
          if (draw_data[next_node.path_label].parent_index == top.path_label) {
            tmpProcessQ.push(top);
            isGoingUp[tmpProcessQ.length-1] = true;
            tmpProcessQ.push(next_node);
            stack.push(next_node);
            is_popping = false;
            break;
          }
          else {
            tmpProcessQ.push(top);
            isGoingUp[tmpProcessQ.length-1] = true;
          }
        }
      }
    }

    processQueueLRS = tmpProcessQ;
    var results = new Array();
    var max = "";
    // the animation starts here
    var prev = new Array();
    var prev_edge = new Array();
    for (var i in processQueueLRS) {
      var currentState = createState(A);
      var node = processQueueLRS[i];
      var node_idx = null;
      node_idx = parseInt(draw_data[node.path_label].class_id);
      currentState["vl"][node_idx]["state"]= VERTEX_HIGHLIGHTED;
      var edgeId = 0;
      for (var w = 0; w < Object.size(prev_edge); w++) {
        currentState["el"][prev_edge[w]]["state"]= EDGE_TRAVERSED;
      }
      for (var w = 1; w <= Object.size(edgeList); w++) {
        var e = edgeList["#e" + w.toString()];
        if (typeof(e) == "undefined") continue;
        if (e[1] == node_idx) {
          currentState["el"][w]["state"]= EDGE_HIGHLIGHTED;
          prev_edge.push(w);
          break;
        }
      }

      for (var j = 0; j < prev.length; j++)
        currentState["vl"][prev[j]]["state"]= VERTEX_TRAVERSED;
      prev.push(node_idx);

      if (isGoingUp[i]) {
        currentState["status"] = 'Going back.'
        currentState["lineNo"] = [2, 3];
      }
      else if (node.is_leaf) {
        currentState["status"] = 'This is a leaf vertex (not repeated), we skip this.';
        currentState["lineNo"] = 4;
      }
      else {
        currentState["status"] = 'Path label: "{path_label}". '.replace("{path_label}", node.path_label) + '<br>';
        if (node.path_label.length > max.length) {
          max = node.path_label;
          results = [];
          results.push(node.path_label);
          currentState["lineNo"] = 6;
          currentState["status"]+= 'Longer than the length of current ans, ans is now "{newans}".'.replace("{newans}", max);
        }
        else if (node.path_label.length == max.length) {
          results.push(node.path_label);
          currentState["lineNo"] = 6;
          currentState["status"]+= 'Equal to the length of current ans; add "{newans}" to ans.'.replace("{newans}", max);
        }
        else {
          currentState["lineNo"] = 5;
          currentState["status"]+= 'Smaller than the length of current ans, ignored.';
        }
      }
      for (var j = 0; j < results.length; j++) {
        var tmp_idx = parseInt(draw_data[results[j]].class_id);
        currentState["vl"][tmp_idx]["state"] = VERTEX_RESULT;
        currentState["vl"][tmp_idx]["extratext"]= "ans";
      }
      if (isGoingUp[i])
        currentState["vl"][node_idx]["state"]= VERTEX_HIGHLIGHTED;
      stateList.push(currentState);
    }
    currentState = createState(A);
    currentState["lineNo"] = 7;

    var lrsResult = "";
    for (var i = 0; i < results.length; i++) {
      if (i > 0) lrsResult += ", ";
      lrsResult += results[i] + " ";
    }

    if (results.length > 1) {
      currentState["status"] = 'LRS are {lrsResult}'.replace("{lrsResult}", lrsResult);
    }
    else {
      if (results.length == 1 && results[0].length == 0)
        currentState["status"] = 'LRS is an empty string.';
      else
        currentState["status"] = 'LRS is "{lrsResult}" (highlighted with yellow color)'.replace("{lrsResult}", lrsResult);
    }

    for (var j = 0; j < prev.length; j++) {
      currentState["vl"][prev[j]]["state"]= VERTEX_TRAVERSED;
    }
    for (var j = 0; j < results.length; j++) {
      var tmp_idx = parseInt(draw_data[results[j]].class_id);
      currentState["vl"][tmp_idx]["state"] = VERTEX_RESULT;
      currentState["vl"][tmp_idx]["extratext"] = "LRS";
    }
    for (var w = 0; w < Object.size(prev_edge); w++) {
      currentState["el"][prev_edge[w]]["state"]= EDGE_TRAVERSED;
    }
    stateList.push(currentState);
    graphWidget.startAnimation(stateList, callback);
    return true;
  }

  function processTreeForLRS(T, path_label, isLCS) {
    if (T.isLeaf)
      return;
    var attr, iter = 0;
    var spaces = '';  var i;

    var used = new Array();
    var min = '';
    if (isLCS && draw_data[path_label].color!='black') return;
    for (attr in T)
      if (attr.length == 1) {
        var wAndT2 = T[attr];
        var w = wAndT2.fst;
        var myStr = Txt.substring(w.left, w.right+1);
        used.push(new Node2(myStr, attr));
      }
    for (var i = 0; i < used.length-1; i++)
      for (var j = i+1; j < used.length; j++) {
        if (stringCmp(used[i].index, used[j].index) == -1) {
          var tmp = used[i];
          used[i] = used[j];
          used[j] = tmp;
        }
        else if (stringCmp(used[i].index, used[j].index) == 0) {
          if (stringCmp(used[i].word, used[j].word) == -1) {
            var tmp = used[i];
            used[i] = used[j];
            used[j] = tmp;
          }
        }
      }
    for (var i=0; i < used.length; i++) {
      attr = used[i];
      var wAndT2 = T[attr.index];
      var w = wAndT2.fst, T2 = wAndT2.snd;
      var node_label_cur = Txt.substring(w.left, w.right+1);
      var path_lb = path_label + node_label_cur;
      processQueueLRS.push(new NodeLRS(path_lb, draw_data[path_lb].x, draw_data[path_lb].y, T2.isLeaf));
      processTreeForLRS(T2, path_lb, isLCS);
    }
  }

  this.coloring = function() {
    for (var j=0; j < 100; j++)
    for (var i in draw_data) {
      var tmp_vertex = mainSvg.selectAll(".v" + draw_data[i].class_id.toString());
      tmp_vertex[0] = tmp_vertex[0].splice(0,2);
      tmp_vertex.attr("fill", "yellow !important");
      tmp_vertex.attr("class", "comeon");
    }
  }

  this.doLCS = function(callback) {
    clearScreen();
    var stateList = new Array();
    // Determine whether an inside vertex contains both strings
    processQueueLRS = new Array();
    var internals = stGeneralDriver(true);
    populatePseudocode(2);
    // TODO: remove color of inside vertex that belongs to 1 string here
    /*
    for (var i in draw_data) {
      // check if i is internal vetex
      var tmp = draw_data[i];
      var isInternal = false;
      for (var j in draw_data) {
        if (j == i) continue;
        if (draw_data[j].parent_index == tmp.path_label) {
          isInternal = true;
          break;
        }
      }
      if (isInternal) {
        var tmp_vertex = mainSvg.selectAll(".v" + tmp.class_id.toString());
        if (tmp.color == "orchid")
          tmp_vertex.classed("lcs_first", false);
        else if (tmp.color != "black")
          tmp_vertex.classed("lcs_second", false);
      }
    } */

    processQueueLRS.push(new NodeLRS('', draw_data[''].x, draw_data[''].y, false));
    processTreeForLRS(root, '', false);
    var currentState = createState(A);
    currentState["status"] = 'Start from the root.';
    currentState["lineNo"] = 1;
    //currentState["vl"][6]["state"] = VERTEX_HIGHLIGHTED;
    stateList.push(currentState);

    var stack = new Array(), prev = new Array();
    var tmpProcessQ = new Array();
    var isGoingUp = new Array();
    tmpProcessQ[0] = processQueueLRS[0];
    stack.push(processQueueLRS[0]);
    var is_popping = false;
    for (var i=1; i < processQueueLRS.length; i++) {
      var top = stack[stack.length-1];
      var next_node = processQueueLRS[i];
      if ((draw_data[next_node.path_label].parent_index == top.path_label) && !is_popping) {
        stack.push(next_node);
        is_popping = false;
        tmpProcessQ.push(next_node);
      } else {
        while (true) {
          stack.pop();
          is_popping = true;
          top = stack[stack.length-1];
          if (draw_data[next_node.path_label].parent_index == top.path_label) {
            tmpProcessQ.push(top);
            isGoingUp[tmpProcessQ.length-1] = true;
            tmpProcessQ.push(next_node);
            stack.push(next_node);
            is_popping = false;
            break;
          } else {
            tmpProcessQ.push(top);
            isGoingUp[tmpProcessQ.length-1] = true;
          }
        }
      }
    }

    processQueueLRS = tmpProcessQ;
    var results = new Array();
    var max = "";
    // the animation starts here
    var prev = new Array();
    var prev_edge = new Array();
    var string1s = new Array();
    var string2s = new Array();
    for (var i in processQueueLRS) {
      var currentState = createState(A);
      var node = processQueueLRS[i];      
      var node_idx = null;
      node_idx = parseInt(draw_data[node.path_label].class_id);

      var edgeId = 0;

      for (var w=1; w <= Object.size(edgeList); w++) {
        var e = edgeList["#e" + w.toString()];
        if (typeof(e) == "undefined") continue;
        if (e[1] == node_idx) {
          currentState["el"][w]["state"]= EDGE_HIGHLIGHTED;
          prev_edge.push(w);
          break;
        }
      }

      for (var w = 0; w < Object.size(prev_edge); w++)
        currentState["el"][prev_edge[w]]["state"] = EDGE_TRAVERSED;
      for (var j = 0; j < prev.length; j++)
        currentState["vl"][prev[j]]["state"] = VERTEX_TRAVERSED;
      prev.push(node_idx);
      currentState["vl"][node_idx]["state"] = VERTEX_HIGHLIGHTED;

      if (isGoingUp[i]) {
        // currentState["status"] = 'Going back';
        // currentState["lineNo"] = 1;
        // for (var k = 0; k < Object.size(string1s); k++)
        //   currentState["vl"][string1s[k]]["state"] = VERTEX_BLUE_FILL; 
        // for (var k = 0; k < Object.size(string2s); k++)
        //   currentState["vl"][string2s[k]]["state"] = VERTEX_GREEN_FILL; 
        // stateList.push(currentState);
        currentState = createState(A);
        currentState["status"] = 'Going back';
        currentState["lineNo"] = 1;
        for (var w = 0; w < Object.size(prev_edge); w++)
          currentState["el"][prev_edge[w]]["state"] = EDGE_TRAVERSED;
        for (var j = 0; j < prev.length; j++)
          currentState["vl"][prev[j]]["state"] = VERTEX_TRAVERSED;
        var tmp_vertex = mainSvg.selectAll(".v" + draw_data[node.path_label].class_id.toString());
        if (draw_data[node.path_label].color == "orchid") {
          currentState["status"] = 'This internal vertex only contains suffix(es) from string 1';
          currentState["lineNo"] = 1;
          string1s.push(node_idx);
        }
        else if (draw_data[node.path_label].color != 'black') {
          currentState["status"] = 'This internal vertex only contains suffix(es) from string 2';
          currentState["lineNo"] = 1;
          string2s.push(node_idx);
        }
        for (var k = 0; k < Object.size(string1s); k++)
          currentState["vl"][string1s[k]]["state"] = VERTEX_BLUE_FILL; 
        for (var k = 0; k < Object.size(string2s); k++)
          currentState["vl"][string2s[k]]["state"] = VERTEX_GREEN_FILL; 
        currentState["vl"][node_idx]["extratext"] = "^";
        stateList.push(currentState);
        continue;
      }
      else if (node.is_leaf) {
        currentState["status"] = 'This is a leaf vertex, going back.';
        currentState["lineNo"] = 1;
        currentState["vl"][node_idx]["state"]= VERTEX_HIGHLIGHTED;
        //currentState["lineNo"] = 4;
        for (var k = 0; k < Object.size(string1s); k++)
          currentState["vl"][string1s[k]]["state"] = VERTEX_BLUE_FILL;
        for (var k = 0; k < Object.size(string2s); k++)
          currentState["vl"][string2s[k]]["state"] = VERTEX_GREEN_FILL;
      }
      else {
        // TODO: do the check here and color node that belongs to 1 string
        //if (draw_data[i].color == "orchid")
        //tmp_vertex.attr("class", "lcs_first");
        //else tmp_vertex.attr("class", "lcs_second");
        currentState["status"] = 'This is an internal vertex';
        currentState["lineNo"] = 1;
        for (var k = 0; k < Object.size(string1s); k++)
          currentState["vl"][string1s[k]]["state"] = VERTEX_BLUE_FILL;
        for (var k = 0; k < Object.size(string2s); k++)
          currentState["vl"][string2s[k]]["state"] = VERTEX_GREEN_FILL;
      }
      if (isGoingUp[i]) currentState["vl"][node_idx]["state"]= VERTEX_HIGHLIGHTED;
      currentState["vl"][node_idx]["state"] = VERTEX_HIGHLIGHTED;
      currentState["vl"][node_idx]["extratext"] = "^";
      stateList.push(currentState);
    }
    currentState = createState(A);
    currentState["status"] = 'The internal vertices that belongs to only 1 string are highlighted with the same color as the original string color';
    for (var w = 0; w < Object.size(prev_edge); w++)
      currentState["el"][prev_edge[w]]["state"] = EDGE_TRAVERSED;
    for (var j = 0; j < prev.length; j++)
      currentState["vl"][prev[j]]["state"] = VERTEX_TRAVERSED;
    for (var k = 0; k < Object.size(string1s); k++)
      currentState["vl"][string1s[k]]["state"] = VERTEX_BLUE_FILL;
    for (var k = 0; k < Object.size(string2s); k++)
      currentState["vl"][string2s[k]]["state"] = VERTEX_GREEN_FILL;
    stateList.push(currentState);

    // ends
    stGeneralDriver(true);
    populatePseudocode(3);
    processQueueLRS = new Array();
    processQueueLRS.push(new NodeLRS('', draw_data[''].x, draw_data[''].y, false));
    processTreeForLRS(root, '', true);
    prev_edge = new Array();

    var currentState = createState(A);
    currentState["status"] = 'Start of the actual process of finding LCS';
    for (var i = 0; i < Object.size(internals); i++) {
      var node_idx = null;
      var node = internals[i];
      node_idx = parseInt(draw_data[node].class_id);
      if (draw_data[node].color == "orchid")
        currentState["vl"][node_idx]["state"]= VERTEX_NORMAL_BLUE;
      else 
        currentState["vl"][node_idx]["state"]= VERTEX_NORMAL_GREEN;
    }
    stateList.push(currentState);
    currentState = createState(A);
    currentState["status"] = 'Start from the root.';
    //currentState["vl"][6]["state"] = VERTEX_HIGHLIGHTED;
    currentState["lineNo"] = 2;
    for (var i=0; i < Object.size(internals); i++) {
      var node_idx = null;
      var node = internals[i];
      node_idx = parseInt(draw_data[node].class_id);
      if (draw_data[node].color == "orchid")
        currentState["vl"][node_idx]["state"]= VERTEX_NORMAL_BLUE;
      else 
        currentState["vl"][node_idx]["state"]= VERTEX_NORMAL_GREEN;
    }
    stateList.push(currentState);

    var stack = new Array(), prev = new Array();
    var tmpProcessQ = new Array();
    var isGoingUp = new Array();
    tmpProcessQ[0] = processQueueLRS[0];
    stack.push(processQueueLRS[0]);
    var is_popping = false;
    for (var i=1; i < processQueueLRS.length; i++) {
      var top = stack[stack.length-1];
      var next_node = processQueueLRS[i];
      if ((draw_data[next_node.path_label].parent_index == top.path_label) && !is_popping) {
        stack.push(next_node);
        is_popping = false;
        tmpProcessQ.push(next_node);
      } else {
        while (true) {
          stack.pop();
          is_popping = true;
          top = stack[stack.length-1];
          if (draw_data[next_node.path_label].parent_index == top.path_label) {
            tmpProcessQ.push(top);
            isGoingUp[tmpProcessQ.length-1] = true;
            tmpProcessQ.push(next_node);
            stack.push(next_node);
            is_popping = false;
            break;
          } else {
            tmpProcessQ.push(top);
            isGoingUp[tmpProcessQ.length-1] = true;
          }
        }
      }
    }

    processQueueLRS = tmpProcessQ;
    var results = new Array();
    var max = "";
    // the animation starts here
    var prev = new Array();
    for (var i in processQueueLRS) {
      var currentState = createState(A);
      var node = processQueueLRS[i];
      var node_idx = null;
      for (var j0=0; j0 < Object.size(internals); j0++) {
        var node_idx = null;
        var node1 = internals[j0];
        node_idx = parseInt(draw_data[node1].class_id);
        if (draw_data[node1].color == "orchid")
          currentState["vl"][node_idx]["state"]= VERTEX_NORMAL_BLUE;
        else 
          currentState["vl"][node_idx]["state"]= VERTEX_NORMAL_GREEN;
      }
      node_idx = parseInt(draw_data[node.path_label].class_id);
      currentState["vl"][node_idx]["state"]= VERTEX_HIGHLIGHTED;
      for (var w=0; w < Object.size(prev_edge); w++) {
        currentState["el"][prev_edge[w]]["state"]= EDGE_TRAVERSED;
      }
      for (var j=0; j < prev.length; j++) {
        currentState["vl"][prev[j]]["state"]= VERTEX_TRAVERSED;
      }
      for (var w=1; w <= Object.size(edgeList); w++) {
        var e = edgeList["#e" + w.toString()];
        if (typeof(e) == "undefined") continue;
        if (e[1] == node_idx) {
          currentState["el"][w]["state"]= EDGE_HIGHLIGHTED;  
          prev_edge.push(w);
          break;
        }
      }
      prev.push(node_idx);

      if (isGoingUp[i]) {
        currentState["status"] = 'Going back'
      }
      else if (node.is_leaf) {
        currentState["status"] = 'This is a leaf vertex, going back.';
        currentState["lineNo"] = 4;
      }
      else if (draw_data[node.path_label].color != 'black') {
        currentState["status"] = 'This is not a common vertex, going back.';
        currentState["lineNo"] = 5;
      }
      else {
        currentState["status"] = 'Path label: "{path_label}". '.replace("{path_label}", node.path_label);
        currentState["lineNo"] = [6,7]; // highlight two lines
        if (node.path_label.length > max.length) {
          max = node.path_label;
          results = [];
          results.push(node.path_label);
          currentState["status"]+= 'Longer than current max<div>Updating max and recurse</div>';
        }
        else if (node.path_label.length == max.length && node.path_label != max) {
          results.push(node.path_label);
          currentState["status"]+= 'Equal to current max<div>Updating max and recurse</div>';
        }
        else if (node.path_label != max)
          currentState["status"]+= 'Smaller than current max.<div>Ignore</div>';
      }
      for (var j = 0; j < results.length; j++) {
        var tmp_idx = parseInt(draw_data[results[j]].class_id);
        currentState["vl"][tmp_idx]["state"] = VERTEX_RESULT;
        currentState["vl"][tmp_idx]["extratext"] = "ans";
      }
      if (isGoingUp[i]) currentState["vl"][node_idx]["state"] = VERTEX_HIGHLIGHTED;
      currentState["vl"][node_idx]["extratext"] = "^";
      stateList.push(currentState);
    }
    currentState = createState(A);
    
    var lcsResult = "";
    for (var i = 0; i < results.length; i++) {
      if (i > 0) lcsResult += ", ";
      lcsResult += results[i] + " ";
    }

    if (results.length > 1)
      currentState["status"] = 'LCS are "{lcsResult}"'.replace("{lcsResult}", lcsResult);
    else
      currentState["status"] = 'LCS is "{lcsResult}" (highlighted with yellow color)'.replace("{lcsResult}", lcsResult);

    for (var i = 0; i < Object.size(internals); i++) {
      var node_idx = null;
      var node = internals[i];
      node_idx = parseInt(draw_data[node].class_id);
      if (draw_data[node].color == "orchid")
        currentState["vl"][node_idx]["state"]= VERTEX_NORMAL_BLUE;
      else
        currentState["vl"][node_idx]["state"]= VERTEX_NORMAL_GREEN;
    }
    for (var j = 0; j < prev.length; j++)
      currentState["vl"][prev[j]]["state"]= VERTEX_TRAVERSED;
    for (var j = 0; j < results.length; j++) {
      var tmp_idx = parseInt(draw_data[results[j]].class_id);
      currentState["vl"][tmp_idx]["state"] = VERTEX_RESULT;
      currentState["vl"][tmp_idx]["extratext"] = "LCS";
    }

    stateList.push(currentState);
    graphWidget.startAnimation(stateList, callback);
    return true;
  }

  var lcs_txt = "";
  function stGeneralDriver(notColorInternal) {
   //Txt = document.getElementById("s1").value;
    var s1 = document.getElementById("s1").value, s2 = document.getElementById("s2").value;
    //var s1 = "GATAGACA$", s2 = "CATA#";
    if (s1.length == 0 || s2.length == 0) {
      alert("Please enter non-empty strings");
      return;
    }
    if (s1[s1.length-1] != '$') {
      alert("$ has been appended to your first string");
      s1 += '$';
      document.getElementById("s1").value = s1;
    }
    if (s2[s2.length-1] != '#') {
      alert("# has been appended to your second string");
      s2 += '#';
      document.getElementById("s2").value = s2;
    }
    Txt =  s1 + s2;

    infinity = Txt.length + 1000; 
    nForks = 0;
    draw_data = new Array();
    suffix_table = new Array();
    reverse_suffix_table = new Array();
    insertionSort(s1);
    insertionSort(s2);

    algorithm2();  // ------------ the business
    height_level = new Array();
    for (var i=0; i < Txt.length; i++) height_level[i] = 0;
    show2(root, '', 'tree:|', 0, '');
    height = Txt.length*32;
    height_level[0] = height_offset;
    for (var i=1; i < Txt.length; i++) {
      height_level[i] = height_level[0]*i*5.5;
    }
    maxY = 0; maxX = 0;
    var startX = 70;
    drawGeneralSuffixTree(root, 0, startX, '');
    startX = (window.innerWidth - (maxX - startX))/2.5;
    lcs_txt = Txt;
    clearScreen();
    Txt = lcs_txt;
    infinity = Txt.length + 1000;
    nForks = 0;
    draw_data = new Array();
    suffix_table = new Array();
    reverse_suffix_table = new Array();
    insertionSort(s1);
    insertionSort(s2);

    algorithm2(); // ------------ the business
    height_level = new Array();
    for (var i = 0; i < Txt.length; i++)
      height_level[i] = 0;
    show2(root, '', 'tree:|', 0, '');
    height = Txt.length*32;
    height_level[0] = height_offset;
    for (var i = 1; i < Txt.length; i++)
      height_level[i] = height_level[0]*i*5.5;
    drawGeneralSuffixTree(root, 0, startX, '');
    drawAllLabel();
    // update coord
    var count = 1;
    for (var i in draw_data) {
      //var st = Txt.substring(i);
      var node = draw_data[i];
      var idx = parseInt(node.class_id) + 1;
      coord[idx] = new Array();
      coord[idx][0] = node.x;
      coord[idx][1] = node.y;
      //draw_data[i].class_id = count++;
    }

    // coloring
    if (typeof(notColorInternal) == "undefined") {
      for (var i in draw_data) {
        var tmp_vertex = mainSvg.selectAll(".v" + draw_data[i].class_id.toString());
        tmp_vertex[0] = tmp_vertex[0].splice(0,2);
        if (draw_data[i].color == "black") continue;
        if (draw_data[i].color == "orchid")
          tmp_vertex.attr("class", "lcs_first");
        else tmp_vertex.attr("class", "lcs_second");
      }
    } else {
      var internals = new Array();
      for (var i in draw_data) {
        var tmp_vertex = mainSvg.selectAll(".v" + draw_data[i].class_id.toString());
        tmp_vertex[0] = tmp_vertex[0].splice(0,2);
        var tmp = draw_data[i];
        var isInternal = false;
        for (var j in draw_data) {
          if (j == i) continue;
          if (draw_data[j].parent_index == tmp.path_label) {
            isInternal = true;
            break;
          }
        }
        if (isInternal) {
          //tmp_vertex.attr("class", "lcs_internal");
          if (draw_data[i].color != "black")
            internals.push(i);
          continue;
        }
        if (draw_data[i].color == "black") continue;
        if (draw_data[i].color == "orchid")
          tmp_vertex.attr("class", "lcs_first");
        else tmp_vertex.attr("class", "lcs_second");
      }
      return internals;
    }
  } // stGeneralDriver

  function drawGeneralSuffixTree(T, level, prev_x, text) {
    var count = 0, iter=0;
    for (attr in T) {
      if (attr.length == 1) count++;
    }

    var used = new Array(), min = '';
    for (attr in T)
      if (attr.length == 1) {
        var wAndT2 = T[attr];
        var w = wAndT2.fst;
        var myStr = Txt.substring(w.left, w.right+1);
        used.push(new Node2(myStr, attr));
      }
    for (var i=0; i<used.length-1; i++)
      for (var j=i+1; j<used.length; j++) {
        if (stringCmp(used[i].index, used[j].index) == -1 ) {
          var tmp = used[i];
          used[i] = used[j];
          used[j] = tmp;
        }
        else if (stringCmp(used[i].index, used[j].index) == 0) {
          if (stringCmp(used[i].word, used[j].word) == -1) {
            var tmp = used[i];
            used[i] = used[j];
            used[j] = tmp;
          }
        }
      }

    var update_prev_x = prev_x;
    var tmp_store = text.split(":");
    var T_idx = text, T_string = text;
    var currentIs1 = false, currentIs2 = false;
    //for(attr in T)//each subtree
      //if(attr.length == 1)//a char attribute selects a suffix-tree branch
    for (var i=0; i < used.length; i++) {
      iter++;
      var attr = used[i];
      if (iter>count/2) break; 
      var wAndT2 = T[attr.index];
      var w = wAndT2.fst, T2 = wAndT2.snd;
      var Str_idx = Txt.substring(w.left, w.right+1);
      var myStr = T_string+ Str_idx ;
      //height = height_level[level];
      var y = (level+1)*height + height_offset;
      //drawVertex(update_prev_x,y,myStr,'black');
      var suffix_idx = -1;
      if (reverse_suffix_table[T_string + Str_idx]) {
        suffix_idx = reverse_suffix_table[T_string + Str_idx];
      }
      draw_data[T_string + Str_idx] = new Node3(T_string + Str_idx, suffix_idx, T_idx, 0, 0, T_string + Str_idx);
      //update_prev_x = Math.max(update_prev_x, drawSuffixTree(T2, level+1, update_prev_x, myStr));
      var tmpNode = drawGeneralSuffixTree(T2, level+1, update_prev_x, myStr);
      currentIs1 = currentIs1 || tmpNode.isString1; currentIs2 = currentIs2 || tmpNode.isString2;
      update_prev_x = Math.max(update_prev_x, tmpNode.prev_x);
    }
    update_prev_x += width;
    var vertex_name = "";
    var current_x = update_prev_x;
    if (reverse_suffix_table[text] || reverse_suffix_table[text] === 0) vertex_name = reverse_suffix_table[text];
    height = height_level[level];
    if (maxX < update_prev_x) maxX = update_prev_x;
    if (maxY < height) maxY = height;

    var current_height = height;
    A[amountVertex] = new ObjectPair(vertex_name, amountVertex);
    graphWidget.addVertex(update_prev_x, height, A[amountVertex].getFirst(), A[amountVertex++].getSecond(), true);
    if (maxX < update_prev_x) maxX = update_prev_x;
    //drawVertex(update_prev_x, height, vertex_name, 'black');
    if (T_idx == "") {
      draw_data[""] = new Node3(T_string, -1, -2, update_prev_x, level*height + height_offset, "");
      draw_data[T_idx].class_id = amountVertex - 1;
    }
    else {
      draw_data[T_idx].x = update_prev_x;
      draw_data[T_idx].y = height;
      draw_data[T_idx].class_id = amountVertex - 1;
    }
    iter = 0;
    for (var i = 0; i < used.length; i++) {
      iter++;
      if (iter>count/2) {
        var attr = used[i];
        var wAndT2 = T[attr.index];
        var w = wAndT2.fst, T2 = wAndT2.snd;
        var Str_idx = Txt.substring(w.left, w.right+1);

        var myStr = T_string + Str_idx;
        //show(T2, str2, myStr);
        var y = (level+1)*height + height_offset;
        //drawVertex(update_prev_x,y,myStr,'black');
        var suffix_idx = -1;
        if (reverse_suffix_table[T_string + Str_idx]) {
          suffix_idx = reverse_suffix_table[T_string + Str_idx];
        }
        draw_data[T_string + Str_idx] = new Node3(T_string + Str_idx, suffix_idx, T_idx, 0, 0, T_string + Str_idx);
        //update_prev_x = Math.max(update_prev_x, drawSuffixTree(T2, level+1, update_prev_x, myStr));
        var tmpNode = drawGeneralSuffixTree(T2, level+1, update_prev_x, myStr);
        if (!currentIs1) currentIs1 = tmpNode.isString1;
        if (!currentIs2) currentIs2 = tmpNode.isString2;
        update_prev_x = Math.max(update_prev_x, tmpNode.prev_x);
      }
    }

    if (T.isLeaf) {
        if (text[text.length-1] == '$') currentIs1 = true;
        else currentIs2 = true;
    }

    if (currentIs1 && currentIs2) {
      draw_data[T_idx].color = 'black';
      //drawVertex(current_x, current_height, vertex_name, 'darkorchid');
    } else if (currentIs1) {
      draw_data[T_idx].color = 'orchid';
      //drawVertex(current_x, current_height, vertex_name, 'black');
    } else {
      draw_data[T_idx].color = 'chartreuse';
      //drawVertex(current_x, current_height, vertex_name, 'chartreuse');
    }
    return new NodeG(update_prev_x, currentIs1, currentIs2);
  }

  function show2(T, str, arc, level, node_label) { // print the suffix tree
    if (T == null) // should not happen!
      return; // should not be here
    if (T.isLeaf) {
      if (node_label.length > height_level[level]) height_level[level] = node_label.length;
      return; // llewop d
    }
    nForks++;
    var attr, iter = 0;
    var spaces = '';  var i;
    for (i = 1; i < arc.length; i++) spaces += ' ';
    spaces += '|';   // |spaces|==|arc|
    var str2 = str+spaces;//nosilla l

    var used = new Array();
    var min = '';

    for (attr in T)
      if (attr.length == 1) {
        var wAndT2 = T[attr];
        var w = wAndT2.fst;
        var myStr = Txt.substring(w.left, w.right+1);
        used.push(new Node2(myStr, attr));
      }
    for (var i=0; i<used.length-1; i++)
      for (var j=i+1; j<used.length; j++) {
        if (stringCmp(used[i].index, used[j].index) == -1 ) {
          var tmp = used[i];
          used[i] = used[j];
          used[j] = tmp;
        }
        else if (stringCmp(used[i].index, used[j].index) == 0) {
          if (stringCmp(used[i].word, used[j].word) == -1) {
            var tmp = used[i];
            used[i] = used[j];
            used[j] = tmp;
          }
        }
    }
    if (node_label.length > height_level[level]) height_level[level] = node_label.length;
    for (var i=0; i < used.length; i++) {
      iter++;
      attr = used[i];
      var wAndT2 = T[attr.index];
      var w = wAndT2.fst, T2 = wAndT2.snd;
      var myStr = '('+(w.left)+':'+Txt.substring(w.left, w.right+1)+')|';
      var label = node_label + Txt.substring(w.left, w.right + 1);

      if (label.indexOf('$') > -1) {
        T[attr.index].fst.right = Txt.indexOf('$');
        wAndT2 = T[attr.index];
        w = wAndT2.fst;
      }

      show2(T2, str2, myStr, level+1, Txt.substring(w.left, w.right+1))
    }
  } // show

  function populatePseudocode(act) {
    switch (act) {
      case 0: // Search
        //document.getElementById('code1').innerHTML = 'consider current node';
        // document.getElementById('code2').innerHTML = 'for (i in current node child)';
        // document.getElementById('code3').innerHTML = '&nbsp&nbsp if (i not match)';
        // document.getElementById('code4').innerHTML = '&nbsp&nbsp&nbsp&nbsp continue';
        // document.getElementById('code5').innerHTML = '&nbsp&nbsp if (i is full match) return all results';
        // document.getElementById('code6').innerHTML = '&nbsp&nbsp else if (i is partial match) go deeper';
        // document.getElementById('code7').innerHTML = 'return no match';
        document.getElementById('code1').innerHTML = 'consider current vertex cur';
        document.getElementById('code2').innerHTML = 'for (each child of current vertex cur)';
        document.getElementById('code3').innerHTML = '&nbsp;&nbsp;if (P does not match child.label)';
        document.getElementById('code4').innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;continue';
        document.getElementById('code5').innerHTML = '&nbsp;&nbsp;if (a full match) return all results';
        document.getElementById('code6').innerHTML = '&nbsp;&nbsp;if (a partial match) go deeper';
        document.getElementById('code7').innerHTML = 'return no match';
        break;
      case 1: // LRS
        // document.getElementById('code1').innerHTML = 'result = \'\'';
        // document.getElementById('code2').innerHTML = 'consider current node';
        // document.getElementById('code3').innerHTML = 'for (i in current node child)';
        // document.getElementById('code4').innerHTML = '&nbsp&nbspif i is leave continue';
        // document.getElementById('code5').innerHTML = '&nbsp&nbspelse if (path label length >= result.length)';
        // document.getElementById('code6').innerHTML = '&nbsp&nbsp&nbsp&nbsp update result';
        // document.getElementById('code7').innerHTML = 'return result';
        document.getElementById('code1').innerHTML = 'ans = &quot;&quot;';
        document.getElementById('code2').innerHTML = 'consider current vertex cur';
        document.getElementById('code3').innerHTML = 'for (each child of current vertex cur)';
        document.getElementById('code4').innerHTML = '&nbsp;&nbsp;if (child is a leaf) continue';
        document.getElementById('code5').innerHTML = '&nbsp;&nbsp;if (len(child.label) >= len(ans))'; // ans = child.label'; // if (child.label.length &amp;gt;= ans.length)';
        document.getElementById('code6').innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;update ans with child.label';
        document.getElementById('code7').innerHTML = 'return ans';
        break;
      case 2: // LCS step 1, color internal node
        // document.getElementById('code1').innerHTML = 'if curent node is a leaf, return';
        // document.getElementById('code2').innerHTML = 'if current node belongs to string 1 only';
        // document.getElementById('code3').innerHTML = '&nbsp&nbspcolor current node as string 1';
        // document.getElementById('code4').innerHTML = 'if current node belongs to string 2 only';
        // document.getElementById('code5').innerHTML = '&nbsp&nbspcolor current node as string 2';    
        document.getElementById('code1').innerHTML = 'if curent node is a leaf, return';
        document.getElementById('code2').innerHTML = 'if current node belongs to string 1 only';
        document.getElementById('code3').innerHTML = '&nbsp;&nbsp;color current node as string 1';
        document.getElementById('code4').innerHTML = 'if current node belongs to string 2 only';
        document.getElementById('code5').innerHTML = '&nbsp;&nbsp;color current node as string 2';
        break;
      case 3: // LCS main
        // document.getElementById('code1').innerHTML = 'indexing the nodes';
        // document.getElementById('code2').innerHTML = 'max = root';
        // document.getElementById('code3').innerHTML = 'findLCS(current node):';
        // document.getElementById('code4').innerHTML = '&nbsp&nbspif current node is a leaf, return';
        // document.getElementById('code5').innerHTML = '&nbsp&nbspif current node is not common, return';
        // document.getElementById('code6').innerHTML = '&nbsp&nbspif current node length >= max, update max';
        // document.getElementById('code7').innerHTML = '&nbsp&nbspfindLCS(current node\'s children)';
        document.getElementById('code1').innerHTML = 'first pass: processing the internal nodes';
        document.getElementById('code2').innerHTML = 'ans = &quot;&quot;';
        document.getElementById('code3').innerHTML = 'findLCS(current vertex cur):';
        document.getElementById('code4').innerHTML = '&nbsp;&nbsp;if (cur is a leaf) return';
        document.getElementById('code5').innerHTML = '&nbsp;&nbsp;if (cur is not a candidate) return';
        document.getElementById('code6').innerHTML = '&nbsp;&nbsp;if (len(cur.label) >= len(ans)) update ans'; // if (cur.label.length &amp;gt;= ans.length) update';
        document.getElementById('code7').innerHTML = '&nbsp;&nbsp;findLCS(children of cur)';
        break;
    }
  }
}

// Suffix Tree action
var actionsWidth = 180;
var statusCodetraceWidth = 370;

var stWidget, gw, currentT;

// local
// start by showing actions panel
$(function() {
  $('#play').hide();
  stWidget = new SuffixTreeWidget();
  gw = stWidget.getGraphWidget();
  gw.setAnimationDuration(700 / speedVal);
  var option = ["GATAGACA$", "BANANABAN$", "MISSISSIPPI$", "ABRACADABRA$", "RATATAT$", "AAAAAAA$", "ABCDE$", "AABBCC$"];
  currentT = option[Math.floor(Math.random()*7)];
  stWidget.buildSuffixTree(currentT);
});

// to do: accept T from query string?

function closeBuild() {
  closeAction('build');
}

function closeSearch() {
  closeAction('search');
}

function closeLCS() {
  closeAction('lcs');
}

function buildSuffixTree() {
  if (isPlaying) stop();
  currentT = $("#arrv1").val();
  if (currentT == "" || currentT == "$") currentT = "GATAGACA$"; // if empty or $ only, go to default test case
  currentT = currentT.replace(/\$/g, "") + "$"; // ensure that $ is only used once, and at the back
  $("#arrv1").val(currentT);
  commonAction(stWidget.buildSuffixTree(currentT), "Suffix Tree of T = \"" + currentT + "\"");
  if (isStatusOpen()) $("#status-hide").click(); // right side is irrelevant after a new build
  if (isCodetraceOpen()) $("#codetrace-hide").click();
}

function doSearch(callback) {
  if (isPlaying) stop();
  var input = $('#search_inp').val();
  commonAction(stWidget.doSearch(input, callback), "Search P = \'" + input + "\'<br>in T = \'" + currentT + "\'");

/*
  // console.log('res = ' + res);
  if (!res) {
    if (isStatusOpen()) $("#status-hide").click(); // right side is irrelevant in this bug scenario
    if (isCodetraceOpen()) $("#codetrace-hide").click();
  }
*/
}

function doLRS(callback) {
  if (isPlaying) stop();
  commonAction(stWidget.doLRS(callback), "Find Longest Repeated Substring of \"" + currentT + "\"");
}

function doLCS(callback) {
  if (isPlaying) stop();
  var input1 = $('#s1').val();
  var input2 = $('#s2').val();
  commonAction(stWidget.doLCS(callback), "Find Longest Common Substring of \"" + input1 + "\" and \"" + input2 + "\"");
}
</script>
</body>

<!-- Mirrored from visualgo.net/en/suffixtree by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:18:15 GMT -->
</html>
