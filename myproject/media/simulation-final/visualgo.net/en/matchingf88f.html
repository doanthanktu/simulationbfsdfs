<!DOCTYPE html>
<html lang="en">

<!-- Mirrored from visualgo.net/en/matching?slide=4-9 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:18:02 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="description" content="A Matching in a graph G = (V, E) is a subset M of E edges in G such that no two of which meet at a common vertex.Maximum Cardinality Matching (MCM) problem is a Graph Matching problem where we seek a matching M that contains the largest possible number of edges. A desirable but rarely possible result is Perfect Matching where all |V| vertices are matched (assuming |V| is even), i.e., the cardinality of M is |V|/2.A Bipartite Graph is a graph whose vertices can be partitioned into two disjoint sets U and V such that every edge can only connect a vertex in U to a vertex in V.Maximum Cardinality Bipartite Matching (MCBM) problem is the MCM problem in a Bipartite Graph, which is a lot easier than MCM problem in a General Graph.">
<meta name="keywords" content="Graph Matching Bipartite MCBM Augment Path Hopcroft Karp Randomized Greedy Preprocessing">
 
<meta name="csrf-token" content="dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../img/png/matching.png">
<title>Graph Matching (Maximum Cardinality Bipartite Matching/MCBM) - VisuAlgo</title>
<link rel="icon" href="../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../img/favicon.png">
<link rel="stylesheet" href="../css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../css/common-1.0.2.css">
<link rel="stylesheet" href="../css/viz-1.0.4.css">
<link rel="stylesheet" href="../css/visual.css">
<link rel="stylesheet" href="../css/drawgraph-1.0.2.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
        z-index: 8001;
      }
      #e-lecture-timeline {
        top: 80px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }
      .e-lecture-timeline-slide {
        height: 5px;
        width: 2px;
        background: black;
        float: left;
      }
      .e-lecture-timeline-checkpoint {
        height: 20px;
        width: 3px;
        margin-left: 2px;
        margin-top: -7.5px;
        background: black;
        float: left;
      }

      #e-lecture-f1map {
        top: 102.5px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }

      .e-lecture-f1map-sector {
        flex-grow: 1;
        background: black;
        float: left;
        height: 5px;
        margin-right: 1px;
      }

      .e-lecture-f1map-sector:last-child {
        margin-right: 0px;
      }

      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }

      .electure-read-status {
        position: absolute;
        bottom: 4px;
        right: 4px;
        font-size: 14px;
        cursor: default;
        color: #00FF7F;
        display: none;
      }

      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
      .electure-print, .electure-end {
        position: fixed;
        top: 45px;
        height: 20px;
        width: 17px;
        right: 80px;
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
        text-align: center;
      }
      .electure-end {
        right: 45px; /* beside the X */
      }

      #change-lang-popup {
        position: fixed;
        background: green;
        left: 40px;
        top: 50px;
        width: 250px;
        height: 125px;
        border: transparent;
        border-radius: 10px;
        padding: 10px 20px;
        z-index: 9000;
      }

      #change-lang-popup p {
        font-size: medium;
        color: white;
        line-height: 2;
        font-family: "PT Sans", sans-serif;
      }

      #change-lang-popup-btn {
        text-decoration: underline;
        margin-left: 50px;
      }

      #change-lang-popup-btn:hover {
        cursor: pointer;
      }

      #rotateDeviceOverlay {
        z-index: 10000;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        background-color: white;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        overflow: hidden;
      }

      #mobile-playback-overlay {
        z-index: 9600;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        gap: 100px;
        background-color: black;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        opacity: 0.3;
        overflow: hidden;
      }
      .mobile-playback-item {
        min-width: 2.5%;
        max-width: 35px;
      }
      .mobile-playback-item img {
        width: 100%
      }
      .mobile-playback-label {
        opacity: 0;
        color: white;
        font-size: 25px;
        font-weight: bold;
        min-width: 1.5%;
        max-width: 25px;
        transition: opacity 0.25s ease-out;
        -webkit-backface-visibility: hidden;
      }
      #mobile-playback-rewind-label {
        margin-right: -70px;
      }
      #mobile-playback-forward-label {
        margin-left: -70px;
      }
      #viz-speed-value {
          font-size: 15px;
          width: 10%;
      }

      #scale {
        position: fixed;
        left: 5px;
      }
    </style>
<style>

#rookattack-board {
  height: 500px;
  width: 600px;
  margin-left: -300px;
  margin-top: -200px;
}

/*#bipartite0, #bipartite1, #bipartite2, #bipartite3 {
  float: left;
  padding: 2px;
}

.modeling-actions {
  bottom: 300px;
  left: 200px;
  float: left;
}
  .modeling-actions p { padding: 5px 10px; cursor: pointer; }
  .modeling-actions p:hover { background: black; color: white;}
  .modeling-actions p:first-of-type { padding-top: 10px; }
  .modeling-actions p:last-of-type { padding-bottom: 10px; }
  .modeling-actions-hide {
    bottom: 60px;
    left: 0px;
    padding-left: 14px;
    padding-right: 15px;
  }
*/
  /*.greedyaug { bottom: 173px; }
    #greedyaug-err { padding: 8px 0px 7px }
  */

  /*.hopcroftkarp { bottom: 65px; }
    #hopcroftkarp-err { padding: 5px 8px; }
  */
</style>
<style>
/* copied here from common.css (perhaps need to use version numbering) until caches worldwide settles */
#reload-mobile-popup, #message-popup { /* #gdpr-popup, */
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  min-width: 320px;
  bottom: 62px;
  height: 300px;
  background-color: #0275d8;
  border-radius: 15px;
  padding: 30px 40px;
  z-index: 9500;
}
#reload-mobile-popup {
  background-color: green;
  height: 200px;
}
#message-popup {
  z-index: 9000;
  width: 40%;
  height: 130px;
  background-color: #d9534f;
}

#reload-mobile-popup p, #message-popup p { /* #gdpr-popup p, */
  font-size: large;
  color: white;
  line-height: 2;
  font-family: "PT Sans", sans-serif;
}

#reload-mobile-popup .inner-button, #message-popup .inner-button { /* #gdpr-popup .gdpr-button, */
  border: white solid 2px;
  border-radius: 4px;
  font-weight: bold;
  font-size: x-large;
  padding: 2px 8px;
  color: white;
  width: 90px;
  text-align: center;
  position: absolute;
  letter-spacing: 1px;
  text-decoration: none;
  cursor: pointer;
}

#gdpr-accept, #reload-mobile-button, #dismiss-message-btn {
  bottom: 30px;
  right: 40px;
}

#gdpr-reject, #cancel-reload-mobile-button {
  bottom: 30px;
  right: 170px;
}
    </style>
</head>
<body>
<div id="body-container" style="display: flex; flex-direction: column; min-height: 100vh;">
<style>
  #topbar {
    background-color: rgb(0,0,0);
    font-family: "PT Sans", sans-serif;
    font-size: 13px;
    height: 40px;

    padding-left: 40px;
    padding-right: 40px;

    display: flex;
    flex-wrap: wrap;
    align-items: center;
    position: relative;
    justify-content: flex-start;
  }

  #topbar a:hover {
    text-decoration: none;
  }

  #account-dropdown-btn {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;
    height: 24px;
    line-height: 1.5;
  }

  #account-dropdown-btn:hover {
    color: #0a58ca!important;
    border-color: #198754;
    text-decoration: none;
  }

  #login-button {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;

    height: 24px;
    line-height: 1.5;
  }

  #login-button a:hover {
    color: #0a58ca!important;
    text-decoration: none;
  }

  #account-dropdown-menu {
    display: none;
    position: absolute;
    background-color: white;
    z-index: 1000;
    min-width: 10rem;
    padding: 0.5rem 0;
    margin: 0;
    font-size: 1rem;
    color: rgb(0,0,0);
    text-align: left;
    list-style: none;
    background-clip: padding-box;
    border: 1px solid rgba(0,0,0,.15);
    border-radius: 0.25rem;
    top: 45px;
    right: 40px;
    line-height: 1.5;
  }

  .account-dropdown-item {
    display: block;
    width: auto;
    padding: 0.25rem 1rem;
    clear: both;
    font-weight: 400;
    color: rgb(0,0,0);
    text-align: inherit;
    text-decoration: none;
    white-space: nowrap;
    background-color: transparent;
    border: 0;
    height: 24px;
    font-family: SilkscreenNormal, sans-serif;
  }

  .account-dropdown-item:hover {
    background-color: #e9ecef;
    color: #0a58ca;
    text-decoration: none;
  }
</style>
<nav id="topbar">
<span style="margin-right: 0.25rem">
<a href="https://www.comp.nus.edu.sg/~stevenha" style="text-decoration: none; color: white">
<span class="colour" style="border: 1px solid; border-color: #198754!important; border-radius: .25rem!important">7</span>
</a>
<a href="https://visualgo.net/" style="font-family: SilkscreenNormal,sans-serif; font-size: 20px; margin-left: 4px;">
<span style="color: white">Visu</span><span class="colour">Algo</span><span style="font-size: 40%; color: white">.net</span>
</a>
<span style="color: white">/</span>
<select id="Language" class="select2-dropdown" onchange="changeURL()">
<option value="en" selected>en</option>
<option value="zh">zh</option>
<option value="id">id</option>
</select>
<span style="color: white; font-family: monospace">/matching</span>
</span>
<span style="max-height: 30px">
<span id="title">
<a id="menu-unweighted-bipartite" class="selected-viz">(Unweighted Bipartite) Graph Matching</a>
<a id="menu-unweighted-general">(Unweighted General) Graph Matching</a>
</span>
</span>
<span style="max-height: 30px; background-color:rgb(0,0,0)!important; color: white; margin-left: auto">
<div id="mode-menu">
<div id="mode-button" style="background-color: rgb(0,0,0)!important;" title="exploration">Exploration Mode &#9663;</div>
<div id="other-modes" style="background-color: rgb(0,0,0)!important; padding-top: 11px">
<a title="e-Lecture" style="background-color: rgb(0,0,0)!important;">e-Lecture Mode</a>
</div>
</div>
</span>
<span id="login-button" style="font-family: SilkscreenNormal,sans-serif">
<a href="https://visualgo.net/login">Login</a>
</span>
</nav>
<ul id="account-dropdown-menu">
<li><a class="account-dropdown-item" href="https://visualgo.net/profile">Profile</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/training">Training</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/tests">Tests</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/logout">Log Out</a></li>
</ul>
<script>
  function changeURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    URL[3] = document.getElementById("Language").value;
    window.location.assign(URL.join('https://visualgo.net/'));
  }

  function changeDefaultLanguageAndURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    let val = document.getElementById("Language").value;
    URL[3] = val;

    let data = {
      '_token': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
      'lang'  : val
    }
    $.post('https://visualgo.net/changeLanguage', data, function (res, status) {
      if(res['status'] === 'success') {
        window.location.assign(URL.join('https://visualgo.net/'));
      } else if (res['status'] === 'failed') {
        alert(res['message']);
      } else {
        alert('An unknown error occurred');
      }
    })
  }
</script>
<div id="dark-overlay"></div>
<div id="main-content-container" style="flex: 1">

<div id="mobile-playback-overlay" class="playing" style="display: none;">
<span id="mobile-playback-rewind-label" class="mobile-playback-label">-7</span>
<span id="mobile-playback-rewind" class="mobile-playback-item" onclick="mobilePlaybackRewind()"><img src="../img/prevFrame.png" alt="rewind 7 frames"></span>
<span id="mobile-playback-pause" class="mobile-playback-item" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/pause.png" alt="pause"></span>
<span id="mobile-playback-play" class="mobile-playback-item" style="display: none;" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/play.png" alt="play"></span>
<span id="mobile-playback-forward" class="mobile-playback-item" onclick="mobilePlaybackForward()"><img src="../img/nextFrame.png" alt="forward 7 frames"></span>
<span id="mobile-playback-forward-label" class="mobile-playback-label">+7</span>
</div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id="speed-control"><div id="speed-input"></div><div id="viz-speed-value">1x</div></div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick="goToBeginning()"><img src="../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick="stepBackward()"><img src="../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick="pause()"><img src="../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick="play()"><img src="../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick="stepForward()"><img src="../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick="goToEnd()"><img src="../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id="viz">
<p id="info" "></p>
</div>
<div id="current-action" class="panel"></div>
<div id="e-lecture" class="panel"></div> 
<div id="e-lecture-timeline"></div>
<div id="e-lecture-f1map">
<div class="e-lecture-f1map-sector" sectorNo="1"></div>
<div class="e-lecture-f1map-sector" sectorNo="2"></div>
<div class="e-lecture-f1map-sector" sectorNo="3"></div>
</div>
<div id="overlay" hidden onclick="end_eLecture()"> 
<div id="electure-dropdown">
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. Graph Matching</option>
<option value="1-1">&nbsp;&nbsp;&nbsp;1-1. Motivation-Applications</option>
<option value="1-2">&nbsp;&nbsp;&nbsp;1-2. Current Limitation: Unweighted Graphs</option>
<option value="1-3">&nbsp;&nbsp;&nbsp;1-3. Switching Modes</option>
<option value="2">2. Visualisation</option>
<option value="3">3. Input Graph</option>
<option value="4">4. MCBM Algorithms</option>
<option value="4-1">&nbsp;&nbsp;&nbsp;4-1. MCBM &le;p Max-Flow</option>
<option value="4-2">&nbsp;&nbsp;&nbsp;4-2. Potential Issue &amp; The Correct Reduction</option>
<option value="4-3">&nbsp;&nbsp;&nbsp;4-3. Should We Stop Here?</option>
<option value="4-4">&nbsp;&nbsp;&nbsp;4-4. Augmenting Path (Berge&#39;s) Theorem</option>
<option value="4-5">&nbsp;&nbsp;&nbsp;4-5. Proof of Berge&#39;s Theorem</option>
<option value="4-6">&nbsp;&nbsp;&nbsp;4-6. M&in;G is max &rarr; there is no AP in G w.r.t M</option>
<option value="4-7">&nbsp;&nbsp;&nbsp;4-7. M&in;G is max &larr; there is no AP in G w.r.t M</option>
<option value="4-8">&nbsp;&nbsp;&nbsp;4-8. Proof, Continued (1)</option>
<option value="4-9">&nbsp;&nbsp;&nbsp;4-9. Proof, Continued (2)</option>
<option value="4-10">&nbsp;&nbsp;&nbsp;4-10. O(VE) Augmenting Path Algorithm</option>
<option value="4-11">&nbsp;&nbsp;&nbsp;4-11. Example C++ Code - Part 1</option>
<option value="4-12">&nbsp;&nbsp;&nbsp;4-12. Example C++ Code - Part 2</option>
<option value="4-13">&nbsp;&nbsp;&nbsp;4-13. An Extreme Test Case</option>
<option value="4-14">&nbsp;&nbsp;&nbsp;4-14. O(&radic;(V)E) Hopcroft-Karp Algorithm</option>
<option value="4-15">&nbsp;&nbsp;&nbsp;4-15. O(kE) Augmenting Path Algorithm Plus</option>
<option value="4-16">&nbsp;&nbsp;&nbsp;4-16. Another Hard Test Case</option>
<option value="4-17">&nbsp;&nbsp;&nbsp;4-17. So, Max Flow or AP Route?</option>
<option value="4-18">&nbsp;&nbsp;&nbsp;4-18. Our Take (Part 1)</option>
<option value="4-19">&nbsp;&nbsp;&nbsp;4-19. Our Take (Part 2)</option>
<option value="4-20">&nbsp;&nbsp;&nbsp;4-20. Our Take (Part 3)</option>
<option value="4-21">&nbsp;&nbsp;&nbsp;4-21. Hall&#39;s Marriage Theorem (1)</option>
<option value="4-22">&nbsp;&nbsp;&nbsp;4-22. Hall&#39;s Marriage Theorem (2)</option>
<option value="4-23">&nbsp;&nbsp;&nbsp;4-23. Steven&#39;s Marriage Theorems (1)</option>
<option value="4-24">&nbsp;&nbsp;&nbsp;4-24. Steven&#39;s Marriage Theorems (2)</option>
<option value="4-25">&nbsp;&nbsp;&nbsp;4-25. Steven&#39;s Marriage Theorems (3)</option>
<option value="4-26">&nbsp;&nbsp;&nbsp;4-26. Steven&#39;s Marriage Theorems (4)</option>
<option value="5">5. Weighted MCBM Algorithms</option>
<option value="6">6. MCM Algorithms</option>
<option value="6-1">&nbsp;&nbsp;&nbsp;6-1. O(V^3) Edmonds&#39; Matching Algorithm</option>
<option value="6-2">&nbsp;&nbsp;&nbsp;6-2. O(V^3) Edmonds&#39; Matching Algorithm Plus</option>
<option value="7">7. Closing Remarks</option>
<option value="7-1">&nbsp;&nbsp;&nbsp;7-1. Programming Challenges</option>
<option value="7-2">&nbsp;&nbsp;&nbsp;7-2. Implementation</option>
</select>
</div>
<div class="electure-print" title="Print the e-Lecture note" style="z-index=8001;">&#9997;</div>
<div class="electure-end" title="Close the e-Lecture mode" style="z-index=8001;">&#10008;</div>
</div>
<div id="dropdown-temp-holder" hidden></div>

<div id="electure-1" class="electure-dialog" style="top:80px;left:60px;width:500px;">
<p>A <b>Matching</b> in a graph <b>G = (V, E)</b> is a subset <b>M</b> of <b>E</b> edges in <b>G</b> such that no two of which meet at a common vertex.</p><br><p><b>Maximum Cardinality Matching (MCM)</b> problem is a Graph Matching problem where we seek a matching <b>M</b> that contains the largest possible number of edges. A desirable but rarely possible result is <b>Perfect Matching</b> where all |<b>V</b>| vertices are matched (assuming |<b>V</b>| is even), i.e., the cardinality of <b>M</b> is |<b>V</b>|<b>/2</b>.</p><br><p>A <b>Bipartite Graph</b> is a graph whose vertices can be partitioned into two disjoint sets <b>U</b> and <b>V</b> such that every edge can only connect a vertex in <b>U</b> to a vertex in <b>V</b>.</p><br><p><b>Maximum Cardinality Bipartite Matching (MCBM)</b> problem is the <b>MCM</b> problem in a Bipartite Graph, which is a lot easier than <b>MCM</b> problem in a General Graph.</p>
<div class="electure-addition">
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
If you are an NUS student and a repeat visitor, please <a href="https://visualgo.net/login"><u>login</u></a>.</p>
</div>
<div class="electure-next" data-nextid="1-1" title="Go to the next slide 1-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-1-1" class="electure-dialog" style="top:80px;left:60px;width:500px;">
<p>Graph Matching problems (and its variants) arise in various applications, e.g.,</p><ol><li>The underlying reason on why <a href="https://www.sdn.sg/Pages/Home.aspx" target="_blank"><u>Social Development Network</u></a> exists in Singapore</li><li>Matching job openings (one disjoint set) to job applicants (the other disjoint set)</li><li>The weighted version of #2 is called the <a href="https://en.wikipedia.org/wiki/Assignment_problem" target="_blank"><u>Assignment problem</u></a></li><li>Special-case of some NP-hard optimization problems<br>(e.g., <a href="mvc.html"><u>MVC, MIS</u></a>, MPC on DAG, etc)</li><li>Deterministic 2-opt Approximation Algorithm for <a href="mvc.html"><u>MVC</u></a></li><li>Sub-routine of Christofides&#39;s 1.5-approximation algorithm for <a href="tsp.html"><u>TSP</u></a>, etc...</li></ol>
<div class="electure-addition">
<hr>
<p>Pro-tip 1: Since you are not <a href="https://visualgo.net/login"><u>logged-in</u></a>, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b>/<b>[PageUp]</b> to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use <b>[&rarr; or &darr;/&larr; or &uarr;]</b> to do the same),and <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
</div>
<div class="electure-prev" data-nextid="1" title="Go to the previous slide 1">&larr;</div>
<div class="electure-next" data-nextid="1-2" title="Go to the next slide 1-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-1-2" class="electure-dialog" style="top:80px;left:60px;width:500px;">
<p>In some applications, the weights of edges are not uniform (1 unit) but varies, and we may then want to take MCBM or MCM with minimum (or even maximum) total weight.</p><br><p>However, this visualization is currently limited to unweighted graphs only. Thus, we currently do not support Graph Matching problem variants involving weighted graphs...</p><br><p>The plan is to add Hungarian (Kuhn-Munkres) algorithm for weighted MCBM problem by April 2024, stay tuned...</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
</div>
<div class="electure-prev" data-nextid="1-1" title="Go to the previous slide 1-1">&larr;</div>
<div class="electure-next" data-nextid="1-3" title="Go to the next slide 1-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-1-3" class="electure-dialog" style="top:80px;left:60px;width:500px;">
<p>To switch between the unweighted <b>MCBM</b> (default, as it is much more popular) and unweighted <b>MCM</b> mode, click the respective header.</p><br><p>Here is an example of <b>MCM</b> mode. In <b>MCM</b> mode, one can draw a <b>General</b>, not necessarily <b>Bipartite</b> graphs. However, the graphs are unweighted (all edges have uniform weight 1).</p><br><p>The available algorithms are different in the two modes.</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode): <b>Spacebar</b> to play/pause/replay the animation, <b>&larr;</b>/<b>&rarr;</b> to step the animation backwards/forwards, respectively, and <b>-</b>/<b>+</b> to decrease/increase the animation speed, respectively.</p>
</div>
<div class="electure-prev" data-nextid="1-2" title="Go to the previous slide 1-2">&larr;</div>
<div class="electure-next" data-nextid="2" title="Go to the next slide 2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2" class="electure-dialog" style="bottom:230px;left:50%;margin-left:-250px;width:500px;">
<p>You can view the visualisation here!</p><br><p>For <b>Bipartite Graph</b> visualization, we will mostly layout the vertices of the graph so that the two disjoint sets (<b>U</b> and <b>V</b>) are clearly visible as Left (<b>U</b>) and Right (<b>V</b>) sets. When you draw your input bipartite graph, you can choose to re-layout your bipartite graph into this easier-to-visualize form. However, you do not have to visualize Bipartite Graph in this form, e.g., you can click <span class="slide-actions" onclick="doButtonAction149()">Grid Graph</span> to load an example grid graph and notice that vertices {0,1,2,3} can form set <b>U</b> and vertices {4,5,6,7,8} can form set <b>V</b>. There is no odd-length cycle in this grid graph.</p><br><p>For <b>General Graph</b>, we do not (and usually cannot) relayout the vertices into this Left Set and Right Set form.</p><br><p>Initially, edges have <span style="color: grey;">grey</span> color. Matched edges will have <span style="background-color: white; color: black;">black</span> color. Free/Matched edges along an augmenting path will have <span style="color: orange;">Orange</span>/<span style="color: lightblue;">Light Blue</span> colors, respectively.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="1-3" title="Go to the previous slide 1-3">&larr;</div>
<div class="electure-next" data-nextid="3" title="Go to the next slide 3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>There are three different sources for specifying an input graph:</p><ol><li><b>Edit Graph</b>: You can draw <strong>any</strong> undirected unweighted graph as the input graph.<br>However, due to the way we visualize our MCBM algorithms, we need to impose one additional graph drawing constraint that does not exist in the actual MCBM problems. That constraint is that vertices on the left set are numbered from [0, n), and vertices on the right set are numbered from [n, n+m). You do not have to visually draw them in left-right sets form, as shown in this <span class="slide-actions" onclick="doButtonAction149()">Grid Graph</span> example.</li><li><b>Modeling</b>: Several graph problems can be reduced into an <b>MCBM</b> problem. In this visualization, we have the modeling examples for the famous Rook Attack problem and standard <b>MCBM</b> problem (also valid in <b>MCM</b> mode).</li><li><b>Example Graphs</b>: You can select from the list of our example graphs to get you started. The list of examples is slightly different in the two <b>MCBM</b> vs <b>MCM</b> modes.</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2" title="Go to the previous slide 2">&larr;</div>
<div class="electure-next" data-nextid="4" title="Go to the next slide 4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>There are several Max Cardinality Bipartite Matching (MCBM) algorithms in this visualization, plus one more in Max Flow visualization:</p><ol><li>By reducing MCBM problem into a Max-Flow problem in polynomial time,<br>we can actually use any Max Flow algorithm to solve MCBM.</li><li>O(<b>VE</b>) <b>Augmenting Path Algorithm</b> (without greedy pre-processing),</li><li>O(<b>√(V)E</b>) <b>Dinic&#39;s</b> or <b>Hopcroft-Karp Algorithm</b>,</li><li>O(<b>kE</b>) <b>Augmenting Path Algorithm</b> (with randomized greedy pre-processing),</li></ol><p>PS1: Although possible, we will likely not use O(<b>V<sup>3</sup></b>) <b>Edmonds&#39; Matching Algorithm</b> if the input is guaranteed to be a <b>Bipartite Graph</b> (as it is much slower).</p><p>PS2: Although possible, we will also likely not use O(<b>V<sup>3</sup></b>) <b>Kuhn-Munkres Algorithm</b> (not available in VisuAlgo yet) if the input is guaranteed to be an <b>unweighted</b> Bipartite Graph (again, as it is much slower).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3" title="Go to the previous slide 3">&larr;</div>
<div class="electure-next" data-nextid="4-1" title="Go to the next slide 4-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-1" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>The <b>MCBM</b> problem can be modeled (or reduced into) as a Max Flow problem in polynomial time.</p><br><p>Go to <a href="maxflow.html" target="_blank"><u>Max Flow</u></a> visualization page and see the flow graph modeling of MCBM problem (select Modeling → Bipartite Matching → all 1). Basically, create a super source vertex <b>s</b> that connects to all vertices in the left set and also create a super sink vertex <b>t</b> where all vertices in the right set connect to <b>t</b>. Keep all edges in the flow graph <b>directed</b> from source to sink and with unit weight 1.</p><br><p>If we use one of the earliest Max Flow algorithm, i.e., a simple Ford-Fulkerson algorithm, the time complexity will be tighter than O(<b>mf × E</b>) as all edge weights in the flow graph are unit weight so <b>mf &le; V</b>, i.e., so O(<b>V × E</b>) overall.</p><br><p>If we use one of the fastest Max Flow algorithm, i.e., Dinic&#39;s algorithm on this flow graph, we can find Max Flow = MCBM in O(<b>√(V)E</b>) time — <a href="https://en.wikipedia.org/wiki/Dinic%27s_algorithm#Special_cases" target="_blank"><u>the analysis is omitted for now</u></a>. This allows us to solve MCBM problem with <b>V</b> ∈ [1000..1500] in a typical 1s allowed runtime in many programming competitions.</p><br><p>Discussion: The edges in the flow graph must be directed. Why?<br>Then prove that this reduction is correct.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4" title="Go to the previous slide 4">&larr;</div>
<div class="electure-next" data-nextid="4-2" title="Go to the next slide 4-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-2" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-1" title="Go to the previous slide 4-1">&larr;</div>
<div class="electure-next" data-nextid="4-3" title="Go to the next slide 4-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-3" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>Actually, we can just stop here, i.e., when given any MCBM(-related) problem, we can simply reduce it into a Max-Flow problem and use (the fastest) Max Flow algorithm.</p><br><p>However, there is a far simpler Graph Matching algorithm that we will see in the next few slides. It is based on a crucial theorem and can be implemented as an easy variation of the standard Depth-First Search (DFS) algorithm.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-2" title="Go to the previous slide 4-2">&larr;</div>
<div class="electure-next" data-nextid="4-4" title="Go to the next slide 4-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-4" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p><b>Augmenting Path</b> is a path that starts from a free (unmatched) vertex <b>u</b> in graph <b>G</b> (note that <b>G</b> does not necessarily has to be a bipartite graph although augmenting path, if any, is much easier to find in a bipartite graph), alternates through unmatched (or free/&#39;f&#39;), matched (or &#39;m&#39;), ..., unmatched (&#39;f&#39;) edges in <b>G</b>, until it ends at another free vertex <b>v</b>. The pattern of any Augmenting Path will be fmf...fmf and is of odd length.</p><br><p>If we flip the edge status along that augmenting path, i.e., fmf...fmf into mfm...mfm, we will increase the number of edges in the matching set <b>M</b> by exactly 1 unit and eliminates this augmenting path.</p><br><p>In 1957, Claude Berge proposes the following <a href="https://en.wikipedia.org/wiki/Berge%27s_theorem" target="_blank"><u>theorem</u></a>:<br><i>A matching <b>M</b> in graph <b>G</b> is maximum iff there is no more augmenting path in G</i>.</p><br><p>Discussion: In class, prove the correctness of Berge&#39;s theorem!<br>In practice, we can just <a href="matchingf88f.html?slide=4-9"><u>use it verbatim</u></a>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-3" title="Go to the previous slide 4-3">&larr;</div>
<div class="electure-next" data-nextid="4-5" title="Go to the next slide 4-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-5" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>The proof claims if and only if, thus it has two parts:<br>the forwards direction and the backwards direction.</p><br><p>The forwards proof is easier:<br><b>M∈G</b> is maximum → there is no augmenting path in <b>G</b> w.r.t <b>M</b>.</p><br><p>The backwards proof is a bit harder:<br><b>M∈G</b> is maximum ← there is no augmenting path in <b>G</b> w.r.t <b>M</b>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-4" title="Go to the previous slide 4-4">&larr;</div>
<div class="electure-next" data-nextid="4-6" title="Go to the next slide 4-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-6" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-5" title="Go to the previous slide 4-5">&larr;</div>
<div class="electure-next" data-nextid="4-7" title="Go to the next slide 4-7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-7" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-6" title="Go to the previous slide 4-6">&larr;</div>
<div class="electure-next" data-nextid="4-8" title="Go to the next slide 4-8">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-8" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-7" title="Go to the previous slide 4-7">&larr;</div>
<div class="electure-next" data-nextid="4-9" title="Go to the next slide 4-9">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-9" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-8" title="Go to the previous slide 4-8">&larr;</div>
<div class="electure-next" data-nextid="4-10" title="Go to the next slide 4-10">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-10" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>Recall: Berge&#39;s theorem states:<br><i>A matching <b>M</b> in graph <b>G</b> is maximum iff there is no more augmenting path in G</i>.</p><br><p>The <b>Augmenting Path Algorithm</b> (on Bipartite Graph) is a simple O(<b>V*(V+E)</b>) = O(<b>V<sup>2</sup> + VE</b>) = O(<b>VE</b>) implementation (a modification of DFS) of that theorem: Find and then eliminate augmenting paths in Bipartite Graph <b>G</b>.</p><br><p>Click <span class="slide-actions" onclick="doButtonAction110()">Augmenting Path Algorithm Demo</span> to visualize this algorithm on a special test case called X&#772; (X-bar).</p><br><p>Basically, this Augmenting Path Algorithm scans through all vertices on the left set (that were initially free vertices) one by one. Suppose <b>L</b> on the left set is a free vertex, this algorithm will recursively (via modification of DFS) go to a vertex <b>R</b> on the right set:</p><ol><li>If <b>R</b> is another free vertex, we have found one augmenting path (e.g., Augmenting Path 0-2 initially), and</li><li>If <b>R</b> is already matched (this information is stored at <b>match[R]</b>), we immediately return to the left set and recurse (e.g, path 1-2-immediately return to 0-then 0-3, to find the second Augmenting Path 1-2-0-3)</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-9" title="Go to the previous slide 4-9">&larr;</div>
<div class="electure-next" data-nextid="4-11" title="Go to the next slide 4-11">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-11" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<pre>vi match, vis;           // global variables<br><br>int Aug(int L) {         // notice similarities with DFS algorithm<br>  if (vis[L]) return 0;  // L visited, return 0<br>  vis[L] = 1;<br>  for (auto&amp; R : AL[L])<br>    if ((match[R] == -1) || Aug(match[R])) { // the key modification<br>      match[R] = L;      // flip status<br>      return 1;          // found 1 matching<br>    }<br>  return 0;              // Augmenting Path is not found<br>}</pre>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-10" title="Go to the previous slide 4-10">&larr;</div>
<div class="electure-next" data-nextid="4-12" title="Go to the next slide 4-12">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-12" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<pre>// in int main(), build the bipartite graph<br>// use directed edges from left set (of size VLeft) to right set<br>  int MCBM = 0;<br>  match.assign(V, -1);<br>  for (int L = 0; L &lt; VLeft; ++L) { // try all left vertices<br>    vis.assign(VLeft, 0);<br>    MCBM += Aug(L);      // find augmenting path starting from L<br>  }<br>  printf("Found %d matchings&bsol;n", MCBM);</pre><p>Please see the full implementation at Competitive Programming book repository: <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mcbm.cpp" target="_blank"><u>mcbm.cpp</u></a> | <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mcbm.py" target="_blank"><u>py</u></a> | <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mcbm.java" target="_blank"><u>java</u></a> | <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mcbm.ml" target="_blank"><u>ml</u></a>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-11" title="Go to the previous slide 4-11">&larr;</div>
<div class="electure-next" data-nextid="4-13" title="Go to the next slide 4-13">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-13" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>If we are given a <b>Complete</b> Bipartite Graph <b>K<sub>N/2,N/2</sub></b>, i.e.,<br><b>V = N/2+N/2 = N</b> and <b>E = N/2&times;N/2 = N<sup>2</sup>/4 &approx; N<sup>2</sup></b>, then<br>the Augmenting Path Algorithm discussed earlier will run in O(<b>VE</b>) = O(<b>N&times;N<sup>2</sup></b>) = O(<b>N<sup>3</sup></b>).</p><br><p>This is only OK for <b>V</b> &in; [400..500] in a typical 1s allowed runtime in many programming competitions.</p><br><p>Try executing the <b>standard</b> Augmenting Path Algorithm on this <span class="slide-actions" onclick="doButtonAction111()">Extreme Test Case</span>, which is an almost complete <b>K<sub>5,5</sub></b> Bipartite Graph.</p><br><p>It feels bad, especially on the latter iterations...<br>So, should we avoid using this simple Augmenting Path algorithm?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-12" title="Go to the previous slide 4-12">&larr;</div>
<div class="electure-next" data-nextid="4-14" title="Go to the next slide 4-14">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-14" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>The key idea of Hopcroft-Karp (HK) Algorithm (invented in 1973) is identical to <a href="maxflow.html" target="_blank"><u>Dinic&#39;s Max Flow Algorithm</u></a>, i.e., prioritize shortest augmenting paths (in terms of number of edges used) first. That&#39;s it, augmenting paths with 1 edge are processed first before longer augmenting paths with 3 edges, 5 edges, 7 edges, etc (the length always increase by 2 due to the nature of augmenting path in a Bipartite Graph).</p><br><p>Hopcroft-Karp Algorithm has time complexity of O(<b>√(V)E</b>) — <a href="https://en.wikipedia.org/wiki/Hopcroft–Karp_algorithm#Analysis" target="_blank"><u>analysis omitted for now</u></a>. This allows us to solve MCBM problem with <b>V</b> ∈ [1000..1500] in a typical 1s allowed runtime in many programming competitions — the similar range as with running Dinic&#39;s algorithm on Bipartite Matching flow graph.</p><br><p>Try HK Algorithm on the same <span class="slide-actions" onclick="doButtonAction112()">Extreme Test Case</span> earlier. You will notice that HK Algorithm can find the MCBM in a much faster time than the previous standard O(<b>VE</b>) Augmenting Path Algorithm.</p><br><p>Since Hopcroft-Karp algorithm is essentially also Dinic&#39;s algorithm, we treat both as &#39;approximately equal&#39;.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-13" title="Go to the previous slide 4-13">&larr;</div>
<div class="electure-next" data-nextid="4-15" title="Go to the next slide 4-15">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-15" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>However, we can actually make the easy-to-code <b>Augmenting Path Algorithm</b> <a href="matchingf88f.html?slide=4-9"><u>discussed earlier</u></a> to avoid its worst case O(<b>VE</b>) behavior by doing O(<b>V+E</b>) randomized (to avoid adversary test case) greedy pre-processing <i>before</i> running the actual algorithm.</p><br><p>This O(<b>V+E</b>) additional pre-processing step is simple: For every vertex on the left set, match it with a <i>randomly chosen</i> unmatched neighbouring vertex on the right set. This way, we eliminate many trivial (one-edge) Augmenting Paths that consist of a free vertex <b>u</b>, an unmatched edge <b>(u, v)</b>, and a free vertex <b>v</b>.</p><br><p>Try Augmenting Path Algorithm Plus on the same <span class="slide-actions" onclick="doButtonAction113()">Extreme Test Case</span> earlier. Notice that the pre-processing step already eliminates many trivial 1-edge augmenting paths, making the actual Augmenting Path Algorithm only need to do little amount of additional work.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-14" title="Go to the previous slide 4-14">&larr;</div>
<div class="electure-next" data-nextid="4-16" title="Go to the next slide 4-16">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-16" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>Quite often, on <b>randomly generated</b> Bipartite Graph, the randomized greedy pre-processing step has cleared most of the matchings.</p><br><p>However, we can construct test case like: <b>Example Graphs, Corner Case, Rand Greedy AP Killer</b> to make randomization as ineffective as possible. For every group of 4 vertices, there are 2 matchings. Random greedy processing has 50% chance of making mistake per group (but since each group has only short Augmenting Paths, the fixes are not &#39;long&#39;). Try this <span class="slide-actions" onclick="doButtonAction114()">Test Case with Multiple Components</span> case to see for yourself.</p><br><p>The worst case time complexity is no longer O(<b>VE</b>) but now O(<b>kE</b>) where <b>k</b> is a small integer, much smaller than <b>V</b>, <b>k</b> can be as small as 0 and is at most <b>V/2</b> (any maximal matching, as with this case, has size of at least half of the maximum matching). In our <i>empirical experiments</i>, we estimate <b>k</b> to be "about √(<b>V</b>)" too. This version of Augmenting Path Algorithm Plus also allows us to solve MCBM problem with <b>V</b> ∈ [1000..1500] in a typical 1s allowed runtime in many programming competitions.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-15" title="Go to the previous slide 4-15">&larr;</div>
<div class="electure-next" data-nextid="4-17" title="Go to the next slide 4-17">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-17" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>So, when presented with an MCBM problem, which route should we take?</p><ol><li>Reduce the MCBM problem into Max-Flow and use Dinic&#39;s algorithm (essentially Hopcroft-Karp algorithm) and gets <b>O(&radic;(V)E)</b> performance guarantee but with a much longer implementation?</li><li>Use Augmenting Path algorithm with Randomized Greedy Processing with <b>O(kE)</b> performance with good empirical results and a much shorter implementation?</li></ol><p>Discussion: Discuss these two routes!</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-16" title="Go to the previous slide 4-16">&larr;</div>
<div class="electure-next" data-nextid="4-18" title="Go to the next slide 4-18">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-18" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-17" title="Go to the previous slide 4-17">&larr;</div>
<div class="electure-next" data-nextid="4-19" title="Go to the next slide 4-19">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-19" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-18" title="Go to the previous slide 4-18">&larr;</div>
<div class="electure-next" data-nextid="4-20" title="Go to the next slide 4-20">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-20" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-19" title="Go to the previous slide 4-19">&larr;</div>
<div class="electure-next" data-nextid="4-21" title="Go to the next slide 4-21">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-21" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-20" title="Go to the previous slide 4-20">&larr;</div>
<div class="electure-next" data-nextid="4-22" title="Go to the next slide 4-22">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-22" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-21" title="Go to the previous slide 4-21">&larr;</div>
<div class="electure-next" data-nextid="4-23" title="Go to the next slide 4-23">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-23" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-22" title="Go to the previous slide 4-22">&larr;</div>
<div class="electure-next" data-nextid="4-24" title="Go to the next slide 4-24">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-24" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-23" title="Go to the previous slide 4-23">&larr;</div>
<div class="electure-next" data-nextid="4-25" title="Go to the next slide 4-25">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-25" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-24" title="Go to the previous slide 4-24">&larr;</div>
<div class="electure-next" data-nextid="4-26" title="Go to the next slide 4-26">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-26" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-25" title="Go to the previous slide 4-25">&larr;</div>
<div class="electure-next" data-nextid="5" title="Go to the next slide 5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>Unfortunately there is no weighted MCBM algorithm (e.g., Min-Cost-Max-Flow (mcmf) or Hungarian/Kuhn-Munkres) visualization in VisuAlgo <i>yet</i>. But the plan is to have this visualization eventually.</p><br><p>For this section, please refer to CP4 Book 2 Chapter 9.25 and 9.27.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-26" title="Go to the previous slide 4-26">&larr;</div>
<div class="electure-next" data-nextid="6" title="Go to the next slide 6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>When Graph Matching is posed on general graphs (the MCM problem), it is (much) harder to find Augmenting Path. In fact, before Jack Edmonds published his famous paper titled "Paths, Trees, and Flowers" in 1965, this MCM problem was thought to be an (NP-)hard optimization problem.</p><br><p>There are two Max Cardinality Matching (MCM) algorithms in this visualization:</p><ol><li>O(<b>V^3</b>) <b>Edmonds&#39; Matching</b> algorithm (without greedy pre-processing),</li><li>O(<b>V^3</b>) <b>Edmonds&#39; Matching</b> algorithm (with greedy pre-processing),</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5" title="Go to the previous slide 5">&larr;</div>
<div class="electure-next" data-nextid="6-1" title="Go to the next slide 6-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6-1" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>In General Graph (like the graph shown in the background that has |MCM| = 4), we may have Odd-Length cycle. Augmenting Path is not well defined in such a graph, hence we cannot easily implement <a href="matching9bee.html?slide=4-4"><u>Claude Berge&#39;s theorem</u></a> like what we did with Bipartite Graph.</p><br><p>Jack Edmonds call a path that starts from a free vertex <b>u</b>, alternates between free, matched, ..., free edges, and returns to the <b>same</b> free vertex <b>u</b> as a <b>Blossom</b>. This situation is only possible if we have Odd-Length cycle, i.e., in a non-Bipartite Graph. For example, assume edge 1-2 has been matched in the graph shown in the background, then path 3-1=2-3 is a blossom.</p><br><p>Edmonds then proposed <a href="https://en.wikipedia.org/wiki/Blossom_algorithm" target="_blank"><u>Blossom shrinking/contraction and expansion algorithm</u></a> to solve this issue. For details on how this algorithm works, read CP4 Section 9.28 as the current visualization of Edmonds&#39; matching algorithm in VisuAlgo is still &#39;a bit too hard too understand&#39; for beginners, try <span class="slide-actions" onclick="doButtonAction150()">Edmonds' Matching</span>. In a live class in NUS, these steps will be explained verbally.</p><br><p>This algorithm can be implemented in O(<b>V^3</b>).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6" title="Go to the previous slide 6">&larr;</div>
<div class="electure-next" data-nextid="6-2" title="Go to the next slide 6-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6-2" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
O(V^3) Edmonds&#39; Matching Algorithm Plus<br><br><p>As with the <b>Augmenting Path Algorithm Plus</b> for the MCBM problem, we can also do randomized greedy pre-processing step to eliminate as many &#39;trivial matchings&#39; as possible upfront. This reduces the amount of work of <b>Edmonds&#39; Matching Algorithm</b>, thus resulting in a faster time complexity &mdash; analysis TBA.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6-1" title="Go to the previous slide 6-1">&larr;</div>
<div class="electure-next" data-nextid="7" title="Go to the next slide 7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7" class="electure-dialog" style="top:80px;left:60px;width:500px;">
<p>We have not added the visualizations for weighted variant of <b>MCBM</b> and <b>MCM</b> problems. They are for future work. Among the two, <b>weighted MCBM</b> will likely be added earlier than the <b>weighted MCM</b> version.</p><br><p>One of the possible solution for <b>weighted MCBM</b> problem is the <a href="https://en.wikipedia.org/wiki/Hungarian_algorithm" target="_blank"><u>Hungarian</u></a> algorithm. This algorithm also has another name: The Kuhn-Munkres algorithm. This algorithm relies on Berge&#39;s Augmenting Path Theorem too, but it uses the theorem slightly differently.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6-2" title="Go to the previous slide 6-2">&larr;</div>
<div class="electure-next" data-nextid="7-1" title="Go to the next slide 7-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-1" class="electure-dialog" style="top:80px;left:60px;width:500px;">
<p>To strengthen your understanding about these Graph Matching problem, its variations, and the multiple possible solutions, please try solving as many of these programming competition problems listed below:</p><ol><li>Standard MCBM (but need a fast algorithm): <a href="https://open.kattis.com/problems/flippingcards" target="_blank"><u>Kattis - flippingcards</u></a></li><li>Greedy Bipartite Matching: <a href="https://open.kattis.com/problems/froshweek2" target="_blank"><u>Kattis - froshweek2</u></a><br>(you do <b>not</b> need a specific MCBM algorithm for this,<br>in fact, it will be too slow if you use any algorithm discussed here)</li><li>Special case of an NP-hard optimization problem: <a href="https://open.kattis.com/problems/bilateral" target="_blank"><u>Kattis - bilateral</u></a></li><li>Rather straightforward weighted MCBM: <a href="https://open.kattis.com/problems/engaging" target="_blank"><u>Kattis - engaging</u></a></li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7" title="Go to the previous slide 7">&larr;</div>
<div class="electure-next" data-nextid="7-2" title="Go to the next slide 7-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-2" class="electure-dialog" style="top:80px;left:60px;width:500px;">
<p>To tackle those programming contest problems, you are allowed to use/modify our implementation code for Augmenting Path Algorithm (with Randomized Greedy Preprocessing): <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mcbm.cpp" target="_blank"><u>mcbm.cpp</u></a> | <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mcbm.py" target="_blank"><u>py</u></a> | <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mcbm.java" target="_blank"><u>java</u></a> | <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mcbm.ml" target="_blank"><u>ml</u></a><br></p>
<div class="electure-addition">
<hr>
<p>You have reached the last slide. Return to 'Exploration Mode' to start exploring!</p>
<p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
</div>
<div class="electure-prev" data-nextid="7-1" title="Go to the previous slide 7-1">&larr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>Close</u></span>
</div>
<div id="rotateDeviceOverlay" style="display: none;">
<div id="rotateDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please rotate your device to landscape mode for a better user experience</div>
<div id="widenDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please make the window wider for a better user experience</div>
</div>

<style>
        .draw {
            bottom: 146px
        }
    </style>
<style>
        .modeling {
            bottom: 119px
        }
    </style>
<style>
        .examples {
            bottom: 92px
        }
    </style>
<style>
        .augpath {
            bottom: 65px
        }
    </style>
<div id="actions" class="panel">
<p class="execAction" id="draw" onClick="drawGraph()">Edit Graph</p>
<p id="modeling">Modeling</p>
<p id="examples">Example Graphs</p>
<p id="augpath">Augmenting Path</p>
</div>
<div id="actions-hide" class="panel-hide"><span style="color:white; font-size: x-large; display: inline-block;">&gt;</span></div>
<div id="actions-extras">
<div class="draw action-menu-pullout">
<div id="draw-err" class="err" style="float: left;"></div>
</div>
<div class="modeling action-menu-pullout">
<div id="rookattack" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;modeling&#039;, &#039;rookattack&#039;)">
<p>Rook Attack</p>
<div id="rookattack-third-tier" class="rookattack-third-tier new-menu-option" style="display: none;">
<div id="rookattack-input1" style="float: left;">
rows = <input id="rows" type="text" title="Enter the number of rows" autocomplete="off" value="5"> </div>
<div id="rookattack-input2" style="float: left;">
cols = <input id="columns" type="text" title="Enter the number of columns" autocomplete="off" value="5"> </div>
<div id="rookattack-go" class="execAction coloured-menu-option" style="float: right;" onClick="modeling(&#039;rookattack&#039;)">
<p>Go</p>
</div>
</div>
</div>
<div id="bipartite" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;modeling&#039;, &#039;bipartite&#039;)">
<p>Generate Random Bipartite Graph, specify n, m, and edge density</p>
<div id="bipartite-third-tier" class="bipartite-third-tier new-menu-option" style="display: none;">
<div id="bipartite-input-n" style="float: left;">
n = <input id="bipartite-n" type="number" title="Enter an Integer" autocomplete="off" value="3" min="1" max="7"> </div>
<div id="bipartite-input-m" style="float: left;">
m = <input id="bipartite-m" type="number" title="Enter an Integer" autocomplete="off" value="4" min="1" max="7"> </div>
<div id="bipartite-input-d" style="float: left;">
d = <input id="bipartite-d" type="number" title="Enter an Integer" autocomplete="off" value="70" min="0" max="100"> </div>
<div id="bipartite-go" class="execAction coloured-menu-option" style="float: right;" onClick="bipartiteRandom()">
<p>Go</p>
</div>
</div>
</div>
<div id="modeling-err" class="err" style="float: left;"></div>
</div>
<div class="examples action-menu-pullout">
<div id="example-k22" class="execAction new-menu-option coloured-menu-option" onClick="bmw.bipartiteRandom(2, 2, 100)">
<p>K2,2</p>
</div>
<div id="example-xbar" class="execAction new-menu-option coloured-menu-option" onClick="example(&#039;xbar&#039;)">
<p>X&#772;</p>
</div>
<div id="example-fmod" class="execAction new-menu-option coloured-menu-option" onClick="example(FMOD)">
<p>F-mod</p>
</div>
<div id="example-corner-case" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;examples&#039;, &#039;example-corner-case&#039;)">
<p>Corner Case</p>
<div id="example-corner-case-third-tier" class="example-corner-case-third-tier new-menu-option" style="display: none;">
<div id="example-houseofcards" class="execAction coloured-menu-option" style="float: right;" onClick="example(HOUSE_OF_CARDS)">
<p>House of Cards</p>
</div>
<div id="example2" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;Rand_Greedy_AP_Killer&#039;)">
<p>Rand Greedy AP Killer (many X&#772;)</p>
</div>
<div id="example1" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;Undirected_MF_Killer&#039;)">
<p>Undirected MF Killer</p>
</div>
</div>
</div>
<div id="example-special-case" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;examples&#039;, &#039;example-special-case&#039;)">
<p>Special Case</p>
<div id="example-special-case-third-tier" class="example-special-case-third-tier new-menu-option" style="display: none;">
<div id="example-grid" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;GridBipartite&#039;)">
<p>Grid</p>
</div>
<div id="example-tree" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;TreeBipartite&#039;)">
<p>Tree</p>
</div>
<div id="example-even-cycle" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;EvenCycleBipartite&#039;)">
<p>Even Cycle</p>
</div>
<div id="example-odd-line" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;OddLineBipartite&#039;)">
<p>Odd Line</p>
</div>
<div id="example-even-line" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;EvenLineBipartite&#039;)">
<p>Even Line</p>
</div>
</div>
</div>
<div id="example-performance" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;examples&#039;, &#039;example-performance&#039;)">
<p>Performance Test</p>
<div id="example-performance-third-tier" class="example-performance-third-tier new-menu-option" style="display: none;">
<div id="example-almost-k77" class="execAction coloured-menu-option" style="float: right;" onClick="bmw.bipartiteRandom(7, 7, 50)">
<p>K7,7 (d=50%)</p>
</div>
<div id="example-k77" class="execAction coloured-menu-option" style="float: right;" onClick="bmw.bipartiteRandom(7, 7, 100)">
<p>K7,7 (SMT 3)</p>
</div>
<div id="example-almost-k55" class="execAction coloured-menu-option" style="float: right;" onClick="bmw.bipartiteRandom(5, 5, 50)">
<p>K5,5 (d=50%)</p>
</div>
<div id="example-k55" class="execAction coloured-menu-option" style="float: right;" onClick="bmw.bipartiteRandom(5, 5, 100)">
<p>K5,5 (SMT 3)</p>
</div>
</div>
</div>
<div id="example-capacity" class="execAction new-menu-option coloured-menu-option" onClick="example(&#039;MatchingWithCapacity&#039;)">
<p>Matching with Capacity</p>
</div>
<div id="example-waif" class="execAction new-menu-option coloured-menu-option" onClick="example(&#039;waif_WA&#039;)">
<p>waif (WA)</p>
</div>
<div id="example-greedyable" class="execAction new-menu-option coloured-menu-option" onClick="example(&#039;greedy_raw&#039;)">
<p>CP4 3.11a*</p>
</div>
<div id="example-theorem" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;examples&#039;, &#039;example-theorem&#039;)">
<p>Theorem</p>
<div id="example-theorem-third-tier" class="example-theorem-third-tier new-menu-option" style="display: none;">
<div id="example-SMT-4" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;SMT_4&#039;)">
<p>SMT 4</p>
</div>
<div id="example-SMT-3" class="execAction coloured-menu-option" style="float: right;" onClick="bmw.bipartiteRandom(7, 3, 100)">
<p>SMT 3</p>
</div>
<div id="example-SMT-2" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;SMT_2&#039;)">
<p>SMT 2</p>
</div>
<div id="example-SMT-1" class="execAction coloured-menu-option" style="float: right;" onClick="bmw.bipartiteRandom(7, 7, 0)">
<p>SMT 1</p>
</div>
<div id="example-HMT-2" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;HMT_2&#039;)">
<p>HMT 2</p>
</div>
<div id="example-HMT-1" class="execAction coloured-menu-option" style="float: right;" onClick="example(&#039;HMT_1&#039;)">
<p>HMT 1</p>
</div>
</div>
</div>
<div id="examples-err" class="err" style="float: left;"></div>
</div>
<div class="augpath action-menu-pullout">
<div id="augpathnormal" class="execAction new-menu-option coloured-menu-option" onClick="augmentingPath()">
<p>Standard</p>
</div>
<div id="augpathgreedy" class="execAction new-menu-option coloured-menu-option" onClick="greedyAug()">
<p>With Randomized Greedy Preprocessing</p>
</div>
<div id="hopcraftkarp" class="execAction new-menu-option coloured-menu-option" onClick="hopcroftKarp()">
<p>Hopcroft Karp</p>
</div>
<div id="edmondsblossom" class="execAction new-menu-option coloured-menu-option" onClick="edmondsBlossomViz(false)">
<p>Edmonds Blossom</p>
</div>
<div id="edmondsblossomplusgreedy" class="execAction new-menu-option coloured-menu-option" onClick="edmondsBlossomViz(true)">
<p>Edmonds Blossom + Greedy</p>
</div>
<div id="augpath-err" class="err" style="float: left;"></div>
</div>
</div>

<div id="drawgraph" class="overlays"></div>
<div id="rookattack-board" class="overlays"></div>
</div>

<div id="bottom-bar">
<a id="scale" style="display: none;">1.0x</a>
<a id="trigger-about">About</a>
<a id="trigger-team">Team</a>
<a id="trigger-terms">Terms of use</a>
<a id="trigger-privacy">Privacy Policy</a>
</div>
<div id="about" class="overlays">
<h4>About</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.</p><p>Featuring numerous advanced algorithms discussed in Dr. Steven Halim&#39;s book, &#39;Competitive Programming&#39; — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.</p><p>While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.</p><p>Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.</p><p>VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.</p><p>Equipped with a built-in question generator and answer verifier, VisuAlgo&#39;s "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students&#39; answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students&#39; mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.</p><p>VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:</p>
<a href="https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689" target="_blank"><u>id</u></a>,
<a href="http://blog.naver.com/visualgo_nus" target="_blank"><u>kr</u></a>,
<a href="https://www.facebook.com/groups/163215593699283/permalink/824003417620494/" target="_blank"><u>vn</u></a>,
<a href="http://pantip.com/topic/32736343" target="_blank"><u>th</u></a>.
</div>
</div>
<div id="team" class="overlays">
<h4>Team</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>
<strong><span style="line-height: 150%;">Project Leader &amp; Advisor (Jul 2011-present)</span></strong><br>
<a href="https://www.comp.nus.edu.sg/~stevenha/" target="_blank">Associate Professor Steven Halim</a>, School of Computing (SoC), National University of Singapore (NUS)<br>
<a href="https://www.linkedin.com/in/felixhalim/" target="_blank">Dr Felix Halim</a>, Senior Software Engineer, Google (Mountain View)
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 1</span></strong><br>
<b>CDTL TEG 1: Jul 2011-Apr 2012</b>: Koh Zi Chun, Victor Loh Bo Huai
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 1</span></strong><br>
<b>Jul 2012-Dec 2013</b>: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang Duy<br>
<b>Jun 2013-Apr 2014</b> <a href="https://www.rosemarietan.com/" target="_blank">Rose Marie Tan Zhao Yun</a>, Ivan Reinaldo
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 2</span></strong><br>
<b>CDTL TEG 2: May 2014-Jul 2014</b>: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 2</span></strong><br>
<b>Jun 2014-Apr 2015</b>: Erin Teo Yi Ling, Wang Zi<br>
<b>Jun 2016-Dec 2017</b>: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin Mudzakir<br>
<b>Aug 2021-Apr 2023</b>: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius<br>
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 3</span></strong><br>
<b>Optiver: Aug 2023-Oct 2023</b>: Bui Hong Duc, Oleh Naver, Tay Ngan Lin<br>
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 3</span></strong><br>
<b>Aug 2023-Apr 2024</b>: Xiong Jingya, Radian Krisno, Ng Wee Han<br>
</p>
<p>
List of translators who have contributed &ge; 100 translations can be found at <a href="https://visualgo.net/statistics">statistics</a> page.
</p>
<p>
<strong><span style="line-height: 150%;">Acknowledgements</span></strong><br>
NUS <a href="https://nus.edu.sg/cdtl" target="_blank"><u>CDTL</u></a> gave Teaching Enhancement Grant to kickstart this project.<div>For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.</div>
</p>
</div>
</div>
<div id="termsofuse" class="overlays">
<h4>Terms of use</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that you <b>spread the word about its existence to fellow Computer Science students and instructors</b>. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.</p><p>Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (<a href="https://visualgo.net/">https://visualgo.net</a>) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo&#39;s client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.</p><p>Please note that VisuAlgo&#39;s online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the &#39;training mode.&#39; The &#39;test mode&#39; offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.</p><p><strong><span style="line-height: 200%;">List of Publications</span></strong></p> <p>This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can click <a href="https://ioinformatics.org/journal/INFOL099.pdf" target="_blank">this link</a> to read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) and <a href="https://ioinformatics.org/journal/v9_2015_243_245.pdf" target="_blank">this link</a> for the short update in 2015 (to link VisuAlgo name with the previous project).</p><p><strong><span style="line-height: 200%;">Bug Reports or Request for New Features</span></strong></p> <p>VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.</p>
</div>
</div>
<div id="privacy-policy" class="overlays">
<h4>Privacy Policy</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p><b>Version 1.2 (Updated Fri, 18 Aug 2023).</b></p><p>Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.</p><p>Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).</p><p>Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.</p><p>For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.<br></p><p>For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.</p>
</div>
</div>
</div>


<script src="../../code.jquery.com/jquery-3.7.0.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
<script src="../../cdn.jsdelivr.net/npm/bootstrap%405.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<script src="../../unpkg.com/d3-force-boundary%400.0.1/dist/d3-force-boundary.min.js"></script>
<script>
  $(function () {
    // overlays stuffs
    $('#trigger-about').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#about').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-team').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#team').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-terms').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#termsofuse').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-privacy').click(function () {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#privacy-policy').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    })

    $('.close-overlay').click(function() {
      $('.overlays').fadeOut(function() {
        $('#dark-overlay').fadeOut();
      });
    });

    $('#dark-overlay').click(function() {
      $('.overlays').fadeOut();
      $('#dark-overlay').fadeOut();
      if (typeof GeometryWidget !== 'undefined') {
        GeometryWidget.stopLoop();
      }
    });
  })
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-1566631-4"></script>
<script>
      $.ajaxSetup({
        headers: {
          'X-CSRF-TOKEN': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H"
        }
      });

      // handles account dropdown menu
      $(function () {
        $('#language-dropdown-btn').click(function (e) {
          $('#language-dropdown-menu').css('display', 'block');
          $('#account-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function () {
          $('#language-dropdown-menu').css('display', 'none')
        })
      })

      $(function () {
        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        })
      })

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        if (retval) {
          $('#current-action').show();
          $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
          $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
          triggerRightPanels();
          isPlaying = true;
        }
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; ++i) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      const MOBILE_WIDTH = 1000;
      const matchMediaMobile = window.matchMedia(`only screen and (max-width: ${MOBILE_WIDTH}px)`);
      const matchMediaNarrow = window.matchMedia(`only screen and (max-width: 500px)`);
      function isMobile() {
        return matchMediaMobile.matches;
      }
      //To fix the issue of a narrow desktop window being asked to rotate, I am now checking for it based on the navigator.userAgent to see if its mobile or not.
      //This may change in the future if browsers decide to change the naming of userAgent for mobile browsers so may need to keep an eye on this.
      function isMobileOS() {
        return /Mobi/i.test(navigator.userAgent) && !/ipad/i.test(navigator.userAgent);
      }
      let portraitMatcher = window.matchMedia("(orientation:portrait)");
      function isPortrait() {
        return portraitMatcher.matches;
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.colour').css("color", surpriseColour);
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
        });
      });

/*
      // GA dropped 26 Jun 2023 and then made official on 18 Aug 2023
/*
      // the sunset-ed GA, commented on 26 Jun 2023, and Prof Halim doesn't bother to use anymore
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
*/

      // function setCookie(cname, cvalue, exdays) {
      //   const d = new Date();
      //   d.setTime(d.getTime() + (exdays*24*60*60*1000));
      //   let expires = "expires="+ d.toUTCString();
      //   document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
      // }

//       //         $(function() {
//           $('#gdpr-accept').click(function () {
// /*
//             // added on 26 Jun 2023
//             window.dataLayer = window.dataLayer || [];
//             function gtag(){dataLayer.push(arguments);}
//             gtag('js', new Date());

//             gtag('config', 'UA-1566631-4');
// */
// //            ga('create', 'UA-1566631-4', 'auto');
// //            ga('send', 'pageview');
//             setCookie('use_google_analytics', 'true', 365)
//             $('#gdpr-popup').hide()
//           });
//           $('#gdpr-reject').click(function () {
//             setCookie('use_google_analytics', 'false', 365)
//             $('#gdpr-popup').hide()
//           });
//         });
//       
      $('#gdpr-privacy-policy').click(function () {
        if ($(window).width() > 600) {
          $('#dark-overlay').fadeIn(function() {
            $('#privacy-policy').fadeIn();
          });
        }
        else
          alert('Sorry, this dialog is too big. Please load it on bigger screen');
      })
    </script>

<script src="../js/jquery-ui.min.js"></script>

<script src="../js/d3.min.js"></script>
<script src="../js/viz-1.0.10.js"></script>

<script src="../js/graph_library/constant.js"></script>
<script src="../js/graph_library/drawgraph.js"></script>
<script src="../js/graph_library/GraphEdgeWidget.js"></script>
<script src="../js/graph_library/GraphPolygonWidget.js"></script>
<script src="../js/graph_library/GraphVertexWidget.js"></script>
<script src="../js/graph_library/GraphWidget.js"></script>
<script src="../js/graph_library/helperObjects89db.js?refresh22aug9pm"></script> 
<script src="../js/graph_library/misc.js"></script>
<script src="../js/graph_library/properties.js"></script>
<script src="../js/graph_library/Widget.js"></script>
<script src="../js/graph_library/force_directed_library.js"></script>

<script>
      $(function () {
        let defaultPlaybackSpeed = 1;
                createPlaybackSpeedSlider(defaultPlaybackSpeed);


        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        });
        //Mobile Design Related DOM Manipulations
        if (isMobile()) {
          $("#status").css({
            "bottom": "10%",
            "height": "12%",
            "max-height": "54px"
          });
          $("#current-action").css("bottom", "22%");
          $('#status-hide').remove();
          $('#left-bar').remove();
          $('#right-bar').remove();
          $("#mode-menu").remove();
          $("#codetrace").css("z-index", 1);
          $("#bottom-bar a").hide();
          $("#bottom-bar").css("height", $("#topbar").css("height"));
          $(".speed-dropup-btn").show();
          $("#go-to-beginning").remove();
          $("#go-to-end").remove();
          $("#pause").remove();
          $("#play").remove();
          $("#previous").remove();
          $("#next").remove();

          //make progress bar longer
          $("#progress-bar").css({
            left: "30%",
            width: "60%",
            'margin-left': 0
          })
        }
      })

      let mobilePlaybackOverlayTimeout;
      $(function() {
        $("#viz").on("click", () => {
          if (isMobile()) {
            if ($("#mobile-playback-overlay").is(":hidden") && isPlaying) {
              $("#mobile-playback-overlay").fadeIn();
              hideMobilePlaybackOverlay(6000);
            } else {
              $("#mobile-playback-overlay").fadeOut();
            }
          }
        });
        $("#mobile-playback-overlay").on("click", (event) => {
          if (event.target === event.currentTarget) //to ensure clicks on the controls dont fade the overlay
            $("#mobile-playback-overlay").fadeOut();
          else
            hideMobilePlaybackOverlay(5000);
        })
      });
      function hideMobilePlaybackOverlay(timeOut) {
        if (mobilePlaybackOverlayTimeout)
          clearTimeout(mobilePlaybackOverlayTimeout);
        mobilePlaybackOverlayTimeout = setTimeout(() => {
            $("#mobile-playback-overlay").fadeOut();
        }, timeOut);
      }
      function mobilePlaybackPauseOrPlay() {
        if ($("#mobile-playback-overlay").hasClass("playing")) {
          pause();
          hideMobilePlaybackOverlay(5000);
        } else {
          play();
          hideMobilePlaybackOverlay(3000);
        }
      }
      let rewindLabelTimeout, forwardLabelTimeout;
      function mobilePlaybackRewind() {
        $("#mobile-playback-rewind-label").css("opacity", 1);
        if (rewindLabelTimeout)
          clearTimeout(rewindLabelTimeout);
        rewindLabelTimeout = setTimeout(() => {
          $("#mobile-playback-rewind-label").css("opacity", 0);
        }, 800);
        stepBackward(7);
      }
      function mobilePlaybackForward() {
        $("#mobile-playback-forward-label").css("opacity", 1);
        if (forwardLabelTimeout)
          clearTimeout(forwardLabelTimeout);
        forwardLabelTimeout = setTimeout(() => {
          $("#mobile-playback-forward-label").css("opacity", 0);
        }, 800);
        stepForward(7);
      }

      //let eLectureSessionHistory = {};
      const sectorColors = ['#05a4d0', '#f1c706', '#fa0202'];
      function setSlideTimelineColor(slideNo) {
        const sectionNo = slideNo.split('-')[0];
        $(`[slideNo="${slideNo}"]`).css('background', sectorColors[(parseInt(sectionNo) % 3)]);
      }

      let currSlideTimer = null; //global so that we can clear the timeout when required

      const lectureIds = [{"id":61,"category":"matching","order":1,"top":"80px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:21:44","updated_at":"2022-09-11 01:06:15","section":-1,"code":"","section_order":-1,"value":"1","text":"<p>A <b>Matching<\/b> in a graph <b>G = (V, E)<\/b> is a subset <b>M<\/b> of <b>E<\/b> edges in <b>G<\/b> such that no two of which meet at a common vertex.<\/p><br><p><b>Maximum Cardinality Matching (MCM)<\/b> problem is a Graph Matching problem where we seek a matching <b>M<\/b> that contains the largest possible number of edges. A desirable but rarely possible result is <b>Perfect Matching<\/b> where all |<b>V<\/b>| vertices are matched (assuming |<b>V<\/b>| is even), i.e., the cardinality of <b>M<\/b> is |<b>V<\/b>|<b>\/2<\/b>.<\/p><br><p>A <b>Bipartite Graph<\/b> is a graph whose vertices can be partitioned into two disjoint sets <b>U<\/b> and <b>V<\/b> such that every edge can only connect a vertex in <b>U<\/b> to a vertex in <b>V<\/b>.<\/p><br><p><b>Maximum Cardinality Bipartite Matching (MCBM)<\/b> problem is the <b>MCM<\/b> problem in a Bipartite Graph, which is a lot easier than <b>MCM<\/b> problem in a General Graph.<\/p>","title":"Graph Matching"},{"id":802,"category":"matching","order":1,"top":"80px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-09-10 05:52:17","updated_at":"2023-09-21 07:48:24","section":61,"code":"","section_order":1,"value":"1-1","text":"<p>Graph Matching problems (and its variants) arise in various applications, e.g.,<\/p><ol><li>The underlying reason on why <a href=\"https:\/\/www.sdn.sg\/Pages\/Home.aspx\" target=\"_blank\"><u>Social Development Network<\/u><\/a> exists in Singapore<\/li><li>Matching job openings (one disjoint set) to job applicants (the other disjoint set)<\/li><li>The weighted version of #2 is called the <a href=\"https:\/\/en.wikipedia.org\/wiki\/Assignment_problem\" target=\"_blank\"><u>Assignment problem<\/u><\/a><\/li><li>Special-case of some NP-hard optimization problems<br>(e.g., <a href=\".\/mvc\"><u>MVC, MIS<\/u><\/a>, MPC on DAG, etc)<\/li><li>Deterministic 2-opt Approximation Algorithm for <a href=\".\/mvc\"><u>MVC<\/u><\/a><\/li><li>Sub-routine of Christofides&#39;s 1.5-approximation algorithm for <a href=\".\/tsp\"><u>TSP<\/u><\/a>, etc...<\/li><\/ol>","title":"Motivation-Applications"},{"id":683,"category":"matching","order":2,"top":"80px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-12 05:50:58","updated_at":"2023-09-21 07:52:39","section":61,"code":"","section_order":1,"value":"1-2","text":"<p>In some applications, the weights of edges are not uniform (1 unit) but varies, and we may then want to take MCBM or MCM with minimum (or even maximum) total weight.<\/p><br><p>However, this visualization is currently limited to unweighted graphs only. Thus, we currently do not support Graph Matching problem variants involving weighted graphs...<\/p><br><p>The plan is to add Hungarian (Kuhn-Munkres) algorithm for weighted MCBM problem by April 2024, stay tuned...<\/p>","title":"Current Limitation: Unweighted Graphs"},{"id":685,"category":"matching","order":3,"top":"80px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-12 06:58:37","updated_at":"2022-09-10 05:52:19","section":61,"code":"$(\"#menu-unweighted-general\").click();","section_order":1,"value":"1-3","text":"<p>To switch between the unweighted <b>MCBM<\/b> (default, as it is much more popular) and unweighted <b>MCM<\/b> mode, click the respective header.<\/p><br><p>Here is an example of <b>MCM<\/b> mode. In <b>MCM<\/b> mode, one can draw a <b>General<\/b>, not necessarily <b>Bipartite<\/b> graphs. However, the graphs are unweighted (all edges have uniform weight 1).<\/p><br><p>The available algorithms are different in the two modes.<\/p>","title":"Switching Modes"},{"id":62,"category":"matching","order":2,"top":"","right":"","bottom":"230px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:22:56","updated_at":"2023-09-21 07:57:42","section":-1,"code":"$(\"#menu-unweighted-bipartite\").click();\nbmw.bipartiteRandom(3, 4, 70); \/\/ medium size","section_order":-1,"value":"2","text":"<p>You can view the visualisation here!<\/p><br><p>For <b>Bipartite Graph<\/b> visualization, we will mostly layout the vertices of the graph so that the two disjoint sets (<b>U<\/b> and <b>V<\/b>) are clearly visible as Left (<b>U<\/b>) and Right (<b>V<\/b>) sets. When you draw your input bipartite graph, you can choose to re-layout your bipartite graph into this easier-to-visualize form. However, you do not have to visualize Bipartite Graph in this form, e.g., you can click <span class=\"slide-actions\" onclick=\"doButtonAction149()\">Grid Graph<\/span> to load an example grid graph and notice that vertices {0,1,2,3} can form set <b>U<\/b> and vertices {4,5,6,7,8} can form set <b>V<\/b>. There is no odd-length cycle in this grid graph.<\/p><br><p>For <b>General Graph<\/b>, we do not (and usually cannot) relayout the vertices into this Left Set and Right Set form.<\/p><br><p>Initially, edges have <span style=\"color: grey;\">grey<\/span> color. Matched edges will have <span style=\"background-color: white; color: black;\">black<\/span> color. Free\/Matched edges along an augmenting path will have <span style=\"color: orange;\">Orange<\/span>\/<span style=\"color: lightblue;\">Light Blue<\/span> colors, respectively.<\/p>","title":"Visualisation"},{"id":63,"category":"matching","order":3,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:23:30","updated_at":"2023-09-21 07:58:53","section":-1,"code":"$(\"#draw\").addClass(\"menu-highlighted\");\n$(\"#modeling\").addClass(\"menu-highlighted\");\n$(\"#examples\").addClass(\"menu-highlighted\");\ncloseAugPath();","section_order":-1,"value":"3","text":"<p>There are three different sources for specifying an input graph:<\/p><ol><li><b>Edit Graph<\/b>: You can draw <strong>any<\/strong> undirected unweighted graph as the input graph.<br>However, due to the way we visualize our MCBM algorithms, we need to impose one additional graph drawing constraint that does not exist in the actual MCBM problems. That constraint is that vertices on the left set are numbered from [0, n), and vertices on the right set are numbered from [n, n+m). You do not have to visually draw them in left-right sets form, as shown in this <span class=\"slide-actions\" onclick=\"doButtonAction149()\">Grid Graph<\/span> example.<\/li><li><b>Modeling<\/b>: Several graph problems can be reduced into an <b>MCBM<\/b> problem. In this visualization, we have the modeling examples for the famous Rook Attack problem and standard <b>MCBM<\/b> problem (also valid in <b>MCM<\/b> mode).<\/li><li><b>Example Graphs<\/b>: You can select from the list of our example graphs to get you started. The list of examples is slightly different in the two <b>MCBM<\/b> vs <b>MCM<\/b> modes.<\/li><\/ol>","title":"Input Graph"},{"id":64,"category":"matching","order":4,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:24:04","updated_at":"2022-09-11 01:44:31","section":-1,"code":"$(\"#menu-unweighted-bipartite\").click();\n$(\"#augpath\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"4","text":"<p>There are several Max Cardinality Bipartite Matching (MCBM) algorithms in this visualization, plus one more in Max Flow visualization:<\/p><ol><li>By reducing MCBM problem into a Max-Flow problem in polynomial time,<br>we can actually use any Max Flow algorithm to solve MCBM.<\/li><li>O(<b>VE<\/b>) <b>Augmenting Path Algorithm<\/b> (without greedy pre-processing),<\/li><li>O(<b>\u221a(V)E<\/b>) <b>Dinic&#39;s<\/b> or <b>Hopcroft-Karp Algorithm<\/b>,<\/li><li>O(<b>kE<\/b>) <b>Augmenting Path Algorithm<\/b> (with randomized greedy pre-processing),<\/li><\/ol><p>PS1: Although possible, we will likely not use O(<b>V<sup>3<\/sup><\/b>) <b>Edmonds&#39; Matching Algorithm<\/b> if the input is guaranteed to be a <b>Bipartite Graph<\/b> (as it is much slower).<\/p><p>PS2: Although possible, we will also likely not use O(<b>V<sup>3<\/sup><\/b>) <b>Kuhn-Munkres Algorithm<\/b> (not available in VisuAlgo yet) if the input is guaranteed to be an <b>unweighted<\/b> Bipartite Graph (again, as it is much slower).<\/p>","title":"MCBM Algorithms"},{"id":689,"category":"matching","order":1,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-13 06:54:38","updated_at":"2023-09-21 08:04:10","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('Undirected_MF_Killer');","section_order":4,"value":"4-1","text":"<p>The <b>MCBM<\/b> problem can be modeled (or reduced into) as a Max Flow problem in polynomial time.<\/p><br><p>Go to <a href=\".\/maxflow\" target=\"_blank\"><u>Max Flow<\/u><\/a> visualization page and see the flow graph modeling of MCBM problem (select Modeling \u2192 Bipartite Matching \u2192 all 1). Basically, create a super source vertex <b>s<\/b> that connects to all vertices in the left set and also create a super sink vertex <b>t<\/b> where all vertices in the right set connect to <b>t<\/b>. Keep all edges in the flow graph <b>directed<\/b> from source to sink and with unit weight 1.<\/p><br><p>If we use one of the earliest Max Flow algorithm, i.e., a simple Ford-Fulkerson algorithm, the time complexity will be tighter than O(<b>mf \u00d7 E<\/b>) as all edge weights in the flow graph are unit weight so <b>mf &le; V<\/b>, i.e., so O(<b>V \u00d7 E<\/b>) overall.<\/p><br><p>If we use one of the fastest Max Flow algorithm, i.e., Dinic&#39;s algorithm on this flow graph, we can find Max Flow = MCBM in O(<b>\u221a(V)E<\/b>) time \u2014 <a href=\"https:\/\/en.wikipedia.org\/wiki\/Dinic%27s_algorithm#Special_cases\" target=\"_blank\"><u>the analysis is omitted for now<\/u><\/a>. This allows us to solve MCBM problem with <b>V<\/b> \u2208 [1000..1500] in a typical 1s allowed runtime in many programming competitions.<\/p><br><p>Discussion: The edges in the flow graph must be directed. Why?<br>Then prove that this reduction is correct.<\/p>","title":"MCBM &le;p Max-Flow"},{"id":803,"category":"matching","order":2,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-09-10 06:29:16","updated_at":"2022-09-11 01:35:10","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('Undirected_MF_Killer');","section_order":4,"value":"4-2","text":"<p>The MCBM on the currently displayed test case is 2 edges, e.g., {0-3 and 2-5}.<\/p><br><p>However, if we reduce this MCBM instance into an <b>undirected<\/b> Max-Flow instance, we may get max flow = 3, e.g., {s-3-5-t, s-1-6-t, s-2-5-1-4-t}. Notice that edge 5 &rarr; 1 is going into the wrong direction and causes vertex 5 to be used \"twice\".<\/p><br><p>If we do the reduction correctly (using directed edges from <b>s<\/b> to <b>t<\/b>), then the reduction is correct because the capacity of 1 from <b>s<\/b> to a vertex <b>x<\/b> in the left set and the capacity 1 from a vertex <b>y<\/b> in the right set to <b>t<\/b> guarantees that if there is a flow involving edge <b>x &rarr; y<\/b>, then <b>x<\/b> is only matched with <b>y<\/b> and no other &mdash; a matching. Thus, the max flow obtained will be the maximum possible matchings in the underlying bipartite graph.<\/p>","title":"Potential Issue &amp; The Correct Reduction"},{"id":804,"category":"matching","order":3,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-09-10 06:55:12","updated_at":"2022-09-11 01:35:38","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('Undirected_MF_Killer');","section_order":4,"value":"4-3","text":"<p>Actually, we can just stop here, i.e., when given any MCBM(-related) problem, we can simply reduce it into a Max-Flow problem and use (the fastest) Max Flow algorithm.<\/p><br><p>However, there is a far simpler Graph Matching algorithm that we will see in the next few slides. It is based on a crucial theorem and can be implemented as an easy variation of the standard Depth-First Search (DFS) algorithm.<\/p>","title":"Should We Stop Here?"},{"id":686,"category":"matching","order":4,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-13 06:32:27","updated_at":"2022-09-10 14:07:38","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('xbar'); \/\/ specifically show this example","section_order":4,"value":"4-4","text":"<p><b>Augmenting Path<\/b> is a path that starts from a free (unmatched) vertex <b>u<\/b> in graph <b>G<\/b> (note that <b>G<\/b> does not necessarily has to be a bipartite graph although augmenting path, if any, is much easier to find in a bipartite graph), alternates through unmatched (or free\/&#39;f&#39;), matched (or &#39;m&#39;), ..., unmatched (&#39;f&#39;) edges in <b>G<\/b>, until it ends at another free vertex <b>v<\/b>. The pattern of any Augmenting Path will be fmf...fmf and is of odd length.<\/p><br><p>If we flip the edge status along that augmenting path, i.e., fmf...fmf into mfm...mfm, we will increase the number of edges in the matching set <b>M<\/b> by exactly 1 unit and eliminates this augmenting path.<\/p><br><p>In 1957, Claude Berge proposes the following <a href=\"https:\/\/en.wikipedia.org\/wiki\/Berge%27s_theorem\" target=\"_blank\"><u>theorem<\/u><\/a>:<br><i>A matching <b>M<\/b> in graph <b>G<\/b> is maximum iff there is no more augmenting path in G<\/i>.<\/p><br><p>Discussion: In class, prove the correctness of Berge&#39;s theorem!<br>In practice, we can just <a href=\"?slide=4-9\"><u>use it verbatim<\/u><\/a>.<\/p>","title":"Augmenting Path (Berge&#39;s) Theorem"},{"id":806,"category":"matching","order":5,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-09-10 07:05:16","updated_at":"2023-09-20 09:39:03","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('xbar'); \/\/ specifically show this example","section_order":4,"value":"4-5","text":"<p>The proof claims if and only if, thus it has two parts:<br>the forwards direction and the backwards direction.<\/p><br><p>The forwards proof is easier:<br><b>M\u2208G<\/b> is maximum \u2192 there is no augmenting path in <b>G<\/b> w.r.t <b>M<\/b>.<\/p><br><p>The backwards proof is a bit harder:<br><b>M\u2208G<\/b> is maximum \u2190 there is no augmenting path in <b>G<\/b> w.r.t <b>M<\/b>.<\/p>","title":"Proof of Berge&#39;s Theorem"},{"id":807,"category":"matching","order":6,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-09-10 07:09:45","updated_at":"2022-09-14 07:27:08","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('OddLineBipartite'); \/\/ specifically show this example","section_order":4,"value":"4-6","text":"<p>Proof by contradiction:<br>Suppose <b>M\u2208G<\/b> is maximum but <b>G<\/b> <i>still has<\/i> an augmenting path w.r.t matching <b>M<\/b>.<\/p><br><p>Now, this augmenting path: fmf...fmf (which has odd length) can be flipped into another matching <b>M&#39;<\/b> that drops the previously matched edges (the &#39;m&#39;s) and takes the <i>other<\/i> free edges (the &#39;f&#39;s) along the augmenting path. Thus, making <b>|M&#39;| = |M|+1<\/b>.<\/p><br><p>This contradicts the statement that <b>M<\/b> is maximum matching.<\/p><br><p>So, if <b>M\u2208G<\/b> is maximum \u2192 there is no more augmenting path w.r.t matching <b>M<\/b> in G.<\/p>","title":"M&in;G is max &rarr; there is no AP in G w.r.t M"},{"id":808,"category":"matching","order":7,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-09-10 07:15:58","updated_at":"2022-09-14 07:30:25","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('EvenLineBipartite'); \/\/ specifically show this example","section_order":4,"value":"4-7","text":"<p>This part is usually challenging to be understood in one go. Please read carefully.<\/p><br><p>We use proof by contradiction again:<br>Suppose there is no augmenting path in <b>G<\/b> w.r.t <b>M<\/b> but <b>M\u2208G<\/b> is not maximum,<br>i.e., we have <b>M&#39;<\/b> that is larger than <b>M<\/b>.<\/p><br><p>First, we take a <a href=\"https:\/\/en.wikipedia.org\/wiki\/Symmetric_difference\" target=\"_blank\"><u>symmetric difference<\/u><\/a> of <b>M&#39;<\/b> and <b>M<\/b> to produce a new graph <b>G&#39;<\/b> that has the same vertices as <b>G<\/b>, but only edges that are involved in either <b>M&#39;<\/b> or <b>M<\/b> (but not both).<\/p><p><br><\/p><p>Let&#39;s observe this new graph <b>G&#39;<\/b>. Notice that <b>G&#39;<\/b> will only consist of vertices with degree 0 (isolated vertices, we ignore them), degree 1 (endpoint of an augmenting path), or degree 2 (in the middle of augmenting path, a vertex that connects an edge in <b>M<\/b> and another edge in <b>M&#39;<\/b>). Graph with degree not more than 2 can only consist of paths or cycles.<\/p><br><p>On cycles and paths, we have two sub-possibilities: odd-length or even-length.<\/p><br><p>We can have even-length path (as currently show in the background), but it also doesn&#39;t help with this proof (as it implies <b>|M| = |M&#39;|<\/b>, i.e., <b>M&#39;<\/b> is not larger than <b>M<\/b>).<\/p>","title":"M&in;G is max &larr; there is no AP in G w.r.t M"},{"id":809,"category":"matching","order":8,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-09-10 07:37:46","updated_at":"2023-09-21 08:05:46","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('EvenCycleBipartite'); \/\/ specifically show this example","section_order":4,"value":"4-8","text":"<p>We can have even-length cycle (as currently shown in the background) but it doesn&#39;t help with this proof (as it implies <b>|M| = |M&#39;|<\/b>, i.e., <b>M&#39;<\/b> is not larger than <b>M<\/b>).<\/p><br><p>We won&#39;t have odd-length cycle as the edges in <b>G&#39;<\/b> only comes from <b>M<\/b> and <b>M&#39;<\/b> (draw a triangle which is the smallest odd length cycle and convince yourself that after assigning one edge to <b>M<\/b> and another edge to <b>M&#39;<\/b>, we cannot assign the third edge of the triangle into either <b>M<\/b> or <b>M&#39;<\/b> \u2014 same situation for any other longer odd-length cycles).<\/p>","title":"Proof, Continued (1)"},{"id":818,"category":"matching","order":9,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-09-14 07:30:40","updated_at":"2023-09-21 08:07:01","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('OddLineBipartite'); \/\/ specifically show this example","section_order":4,"value":"4-9","text":"<p>Lastly, we can have odd-length path where the path starts and ends with edges from the &#39;larger&#39; <b>M&#39;<\/b> and edges in <b>M<\/b> are slightly inside, that fmf...fmf pattern. Now what is this? This is an augmenting path w.r.t. <b>M<\/b>. We earlier claimed that is no augmenting path in <b>G<\/b> w.r.t <b>M<\/b>, so again we arrive at a contradiction.<\/p><br><p>Overall conclusion: Berge&#39;s theorem is correct and it is an integral part of Augmenting Path (Plus) algorithm and also later on: Kuhn-Munkres (Hungarian) and Edmonds&#39; Matching algorithms.<\/p>","title":"Proof, Continued (2)"},{"id":805,"category":"matching","order":10,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-09-10 07:03:39","updated_at":"2022-09-14 07:36:03","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('xbar'); \/\/ specifically show this example","section_order":4,"value":"4-10","text":"<p>Recall: Berge&#39;s theorem states:<br><i>A matching <b>M<\/b> in graph <b>G<\/b> is maximum iff there is no more augmenting path in G<\/i>.<\/p><br><p>The <b>Augmenting Path Algorithm<\/b> (on Bipartite Graph) is a simple O(<b>V*(V+E)<\/b>) = O(<b>V<sup>2<\/sup> + VE<\/b>) = O(<b>VE<\/b>) implementation (a modification of DFS) of that theorem: Find and then eliminate augmenting paths in Bipartite Graph <b>G<\/b>.<\/p><br><p>Click <span class=\"slide-actions\" onclick=\"doButtonAction110()\">Augmenting Path Algorithm Demo<\/span> to visualize this algorithm on a special test case called X&#772; (X-bar).<\/p><br><p>Basically, this Augmenting Path Algorithm scans through all vertices on the left set (that were initially free vertices) one by one. Suppose <b>L<\/b> on the left set is a free vertex, this algorithm will recursively (via modification of DFS) go to a vertex <b>R<\/b> on the right set:<\/p><ol><li>If <b>R<\/b> is another free vertex, we have found one augmenting path (e.g., Augmenting Path 0-2 initially), and<\/li><li>If <b>R<\/b> is already matched (this information is stored at <b>match[R]<\/b>), we immediately return to the left set and recurse (e.g, path 1-2-immediately return to 0-then 0-3, to find the second Augmenting Path 1-2-0-3)<\/li><\/ol>","title":"O(VE) Augmenting Path Algorithm"},{"id":693,"category":"matching","order":11,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-14 05:20:24","updated_at":"2022-09-14 07:30:45","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('xbar'); \/\/ specifically show this example","section_order":4,"value":"4-11","text":"<pre>vi match, vis;           \/\/ global variables<br><br>int Aug(int L) {         \/\/ notice similarities with DFS algorithm<br>  if (vis[L]) return 0;  \/\/ L visited, return 0<br>  vis[L] = 1;<br>  for (auto&amp; R : AL[L])<br>    if ((match[R] == -1) || Aug(match[R])) { \/\/ the key modification<br>      match[R] = L;      \/\/ flip status<br>      return 1;          \/\/ found 1 matching<br>    }<br>  return 0;              \/\/ Augmenting Path is not found<br>}<\/pre>","title":"Example C++ Code - Part 1"},{"id":694,"category":"matching","order":12,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-14 05:22:26","updated_at":"2022-09-14 07:30:45","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('xbar'); \/\/ specifically show this example","section_order":4,"value":"4-12","text":"<pre>\/\/ in int main(), build the bipartite graph<br>\/\/ use directed edges from left set (of size VLeft) to right set<br>  int MCBM = 0;<br>  match.assign(V, -1);<br>  for (int L = 0; L &lt; VLeft; ++L) { \/\/ try all left vertices<br>    vis.assign(VLeft, 0);<br>    MCBM += Aug(L);      \/\/ find augmenting path starting from L<br>  }<br>  printf(\"Found %d matchings&bsol;n\", MCBM);<\/pre><p>Please see the full implementation at Competitive Programming book repository: <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/mcbm.cpp\" target=\"_blank\"><u>mcbm.cpp<\/u><\/a> | <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/mcbm.py\" target=\"_blank\"><u>py<\/u><\/a> | <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/mcbm.java\" target=\"_blank\"><u>java<\/u><\/a> | <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/mcbm.ml\" target=\"_blank\"><u>ml<\/u><\/a>.<\/p>","title":"Example C++ Code - Part 2"},{"id":695,"category":"matching","order":13,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-14 05:47:50","updated_at":"2022-09-14 07:30:45","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample(K55_ALMOST);","section_order":4,"value":"4-13","text":"<p>If we are given a <b>Complete<\/b> Bipartite Graph <b>K<sub>N\/2,N\/2<\/sub><\/b>, i.e.,<br><b>V = N\/2+N\/2 = N<\/b> and <b>E = N\/2&times;N\/2 = N<sup>2<\/sup>\/4 &approx; N<sup>2<\/sup><\/b>, then<br>the Augmenting Path Algorithm discussed earlier will run in O(<b>VE<\/b>) = O(<b>N&times;N<sup>2<\/sup><\/b>) = O(<b>N<sup>3<\/sup><\/b>).<\/p><br><p>This is only OK for <b>V<\/b> &in; [400..500] in a typical 1s allowed runtime in many programming competitions.<\/p><br><p>Try executing the <b>standard<\/b> Augmenting Path Algorithm on this <span class=\"slide-actions\" onclick=\"doButtonAction111()\">Extreme Test Case<\/span>, which is an almost complete <b>K<sub>5,5<\/sub><\/b> Bipartite Graph.<\/p><br><p>It feels bad, especially on the latter iterations...<br>So, should we avoid using this simple Augmenting Path algorithm?<\/p>","title":"An Extreme Test Case"},{"id":688,"category":"matching","order":14,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-13 06:52:36","updated_at":"2022-09-14 07:30:45","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample(K55_ALMOST);","section_order":4,"value":"4-14","text":"<p>The key idea of Hopcroft-Karp (HK) Algorithm (invented in 1973) is identical to <a href=\".\/maxflow\" target=\"_blank\"><u>Dinic&#39;s Max Flow Algorithm<\/u><\/a>, i.e., prioritize shortest augmenting paths (in terms of number of edges used) first. That&#39;s it, augmenting paths with 1 edge are processed first before longer augmenting paths with 3 edges, 5 edges, 7 edges, etc (the length always increase by 2 due to the nature of augmenting path in a Bipartite Graph).<\/p><br><p>Hopcroft-Karp Algorithm has time complexity of O(<b>\u221a(V)E<\/b>) \u2014 <a href=\"https:\/\/en.wikipedia.org\/wiki\/Hopcroft%E2%80%93Karp_algorithm#Analysis\" target=\"_blank\"><u>analysis omitted for now<\/u><\/a>. This allows us to solve MCBM problem with <b>V<\/b> \u2208 [1000..1500] in a typical 1s allowed runtime in many programming competitions \u2014 the similar range as with running Dinic&#39;s algorithm on Bipartite Matching flow graph.<\/p><br><p>Try HK Algorithm on the same <span class=\"slide-actions\" onclick=\"doButtonAction112()\">Extreme Test Case<\/span> earlier. You will notice that HK Algorithm can find the MCBM in a much faster time than the previous standard O(<b>VE<\/b>) Augmenting Path Algorithm.<\/p><br><p>Since Hopcroft-Karp algorithm is essentially also Dinic&#39;s algorithm, we treat both as &#39;approximately equal&#39;.<\/p>","title":"O(&radic;(V)E) Hopcroft-Karp Algorithm"},{"id":687,"category":"matching","order":15,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-13 06:39:09","updated_at":"2022-09-14 07:30:45","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample(K55_ALMOST);","section_order":4,"value":"4-15","text":"<p>However, we can actually make the easy-to-code <b>Augmenting Path Algorithm<\/b> <a href=\"?slide=4-9\"><u>discussed earlier<\/u><\/a> to avoid its worst case O(<b>VE<\/b>) behavior by doing O(<b>V+E<\/b>) randomized (to avoid adversary test case) greedy pre-processing <i>before<\/i> running the actual algorithm.<\/p><br><p>This O(<b>V+E<\/b>) additional pre-processing step is simple: For every vertex on the left set, match it with a <i>randomly chosen<\/i> unmatched neighbouring vertex on the right set. This way, we eliminate many trivial (one-edge) Augmenting Paths that consist of a free vertex <b>u<\/b>, an unmatched edge <b>(u, v)<\/b>, and a free vertex <b>v<\/b>.<\/p><br><p>Try Augmenting Path Algorithm Plus on the same <span class=\"slide-actions\" onclick=\"doButtonAction113()\">Extreme Test Case<\/span> earlier. Notice that the pre-processing step already eliminates many trivial 1-edge augmenting paths, making the actual Augmenting Path Algorithm only need to do little amount of additional work.<\/p>","title":"O(kE) Augmenting Path Algorithm Plus"},{"id":696,"category":"matching","order":16,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-14 08:44:41","updated_at":"2022-09-14 14:23:05","section":64,"code":"$(\"#menu-unweighted-bipartite\").click();\n$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('Rand_Greedy_AP_Killer');","section_order":4,"value":"4-16","text":"<p>Quite often, on <b>randomly generated<\/b> Bipartite Graph, the randomized greedy pre-processing step has cleared most of the matchings.<\/p><br><p>However, we can construct test case like: <b>Example Graphs, Corner Case, Rand Greedy AP Killer<\/b> to make randomization as ineffective as possible. For every group of 4 vertices, there are 2 matchings. Random greedy processing has 50% chance of making mistake per group (but since each group has only short Augmenting Paths, the fixes are not &#39;long&#39;). Try this <span class=\"slide-actions\" onclick=\"doButtonAction114()\">Test Case with Multiple Components<\/span> case to see for yourself.<\/p><br><p>The worst case time complexity is no longer O(<b>VE<\/b>) but now O(<b>kE<\/b>) where <b>k<\/b> is a small integer, much smaller than <b>V<\/b>, <b>k<\/b> can be as small as 0 and is at most <b>V\/2<\/b> (any maximal matching, as with this case, has size of at least half of the maximum matching). In our <i>empirical experiments<\/i>, we estimate <b>k<\/b> to be \"about \u221a(<b>V<\/b>)\" too. This version of Augmenting Path Algorithm Plus also allows us to solve MCBM problem with <b>V<\/b> \u2208 [1000..1500] in a typical 1s allowed runtime in many programming competitions.<\/p>","title":"Another Hard Test Case"},{"id":810,"category":"matching","order":17,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-09-10 07:49:55","updated_at":"2023-09-21 03:21:56","section":64,"code":"$(\"#menu-unweighted-bipartite\").click();\n$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('Rand_Greedy_AP_Killer');","section_order":4,"value":"4-17","text":"<p>So, when presented with an MCBM problem, which route should we take?<\/p><ol><li>Reduce the MCBM problem into Max-Flow and use Dinic&#39;s algorithm (essentially Hopcroft-Karp algorithm) and gets <b>O(&radic;(V)E)<\/b> performance guarantee but with a much longer implementation?<\/li><li>Use Augmenting Path algorithm with Randomized Greedy Processing with <b>O(kE)<\/b> performance with good empirical results and a much shorter implementation?<\/li><\/ol><p>Discussion: Discuss these two routes!<\/p>","title":"So, Max Flow or AP Route?"},{"id":811,"category":"matching","order":18,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-09-10 07:54:16","updated_at":"2023-09-21 03:21:58","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('MatchingWithCapacity');","section_order":4,"value":"4-18","text":"<p>Use Max-Flow route (and use the reasonably long but correct Dinic&#39;s algorithm implementation) if we are dealing with MCBM variation where there are capacities involved, e.g., <a href=\"https:\/\/onlinejudge.org\/external\/128\/12873.pdf\" target=\"_blank\"><u>UVa 12873 - The Programmers<\/u><\/a>.<\/p><br><p>Compare <a href=\".\/maxflow\"><u>Max Flow<\/u><\/a> visualization, Example Graphs, Matching with Capacity versus the equivalent Bipartite Graph that requires us to to blow up each vertex according to its capacity currently as shown in the background. This won&#39;t be efficient if the capacities are (very) large.<\/p>","title":"Our Take (Part 1)"},{"id":813,"category":"matching","order":19,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-09-11 01:39:22","updated_at":"2023-09-21 03:21:59","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('waif_WA');","section_order":4,"value":"4-19","text":"<p>Use Max-Flow route (and use the reasonably long but correct Dinic&#39;s algorithm implementation) if we are dealing with MCBM variation where there are more than two layers (Left Set and Right Set) involved, e.g., <a href=\"https:\/\/open.kattis.com\/problems\/waif\" target=\"_blank\"><u>Kattis - waif<\/u><\/a> (this one requires <b>three<\/b> layers).<\/p><br><p>Compare <a href=\".\/maxflow\"><u>Max Flow<\/u><\/a> visualization, Example Graphs, waif (AC) versus the <i>wrong<\/i> Bipartite Graph that cannot handle the third layer as shown in the background.<\/p>","title":"Our Take (Part 2)"},{"id":819,"category":"matching","order":20,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-09-14 07:39:52","updated_at":"2023-09-21 03:22:01","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('greedy_raw');","section_order":4,"value":"4-20","text":"<p>Sometimes, certain Bipartite Matching graph has curious property that admits a greedy solution (after they are sorted). For example, the currently shown bipartite graph in the background as the following property: A vertex <b>x<\/b> on the Left Set can be matched with any vertex <b>y<\/b> on the Right Set as long as <b>x &le; y<\/b>. If we run <span class=\"slide-actions\" onclick=\"doButtonAction142()\">Augmenting Path Algorithm<\/span>, we will get the answer (3 matchings), but only after some efforts.<\/p><br><p>However, if we sort the values on the Left Set and the values on the Right Set (using two calls of O(<b>N log N<\/b>) sorting algorithms, we will have this <span class=\"slide-actions\" onclick=\"doButtonAction143()\">New Bipartite Graph<\/span>. Notice that on this curious looking Bipartite Graphs, we can have an O(<b>N<\/b>) greedy bipartite matching solution: take the earlier edge as far as possible :).<\/p><br><p>Now, you can solve Greedy Bipartite Matching even if Left\/Right Sets have size up to 100&thinsp;000 vertices, for example. It is not possible to use any MCBM-related algorithm to solve this variant.<\/p><br><p>However, for most other normal MCBM cases, just use the much shorter Augmenting Path algorithm implementation, and if need be, supplement it with the (optional) randomized greedy preprocessing sub-routine.<\/p>","title":"Our Take (Part 3)"},{"id":815,"category":"matching","order":21,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2022-09-11 01:47:15","updated_at":"2023-09-21 08:11:14","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('HMT_1');","section_order":4,"value":"4-21","text":"<p>This slide is only shown in Prof Halim&#39;s official class due to the very sensitive nature of the background story.<\/p><br><p>Hall&#39;s Marriage Theorem is as follows: Let <b>G<\/b> be a bipartite graph with bipartite sets <b>U<\/b> (Left set) and <b>V<\/b> (Right set). Then &mdash; without running any MCBM algorithm &mdash; we can declare that there exists a matching that covers <b>U<\/b> if and only if <i>for each subset<\/i> <b>W<\/b> of <b>U, |W| \u2264 |N(W)|<\/b>, i.e., every subset\u00a0<b>W<\/b>\u00a0of\u00a0<b>U<\/b>\u00a0has sufficiently many adjacent neighboring vertices in\u00a0<b>V<\/b>.<\/p><br><p>In the bipartite graph example at the background, a matching that covers <b>U<\/b> <u>does not exist<\/u> according to Hall&#39;s Marriage Theorem, because if <b>W = {Steven, 1, 2}<\/b> with <b>|W| = 3|<\/b>, then <b>|N(W)| = 2<\/b>. There is one other subset of <b>W<\/b> of <b>U<\/b> that also fails <b>|W| \u2264 |N(W)|<\/b> test.<\/p>","title":"Hall&#39;s Marriage Theorem (1)"},{"id":892,"category":"matching","order":22,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2023-09-21 03:21:14","updated_at":"2023-09-21 03:40:18","section":64,"code":"$(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('HMT_2');","section_order":4,"value":"4-22","text":"<p>This slide is only shown in Prof Halim&#39;s official class due to the very sensitive nature of the background story.<\/p><br><p>In the updated bipartite graph example at the background, a matching that covers <b>U<\/b> now <u>exist<\/u> according to Hall&#39;s Marriage Theorem, because <i>for each subset<\/i> <b>W<\/b> of <b>U, |W| \u2264 |N(W)|<\/b>.<\/p><br><p>Next, and show a few of the unofficial Steven&#39;s Marriage Theorems.<\/p>","title":"Hall&#39;s Marriage Theorem (2)"},{"id":893,"category":"matching","order":23,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2023-09-21 03:31:09","updated_at":"2023-09-21 05:08:45","section":64,"code":"\/\/ (\"#augpath\").click().addClass(\"menu-highlighted\");\nbmw.bipartiteRandom(7, 7, 0);","section_order":4,"value":"4-23","text":"<p>The following four theorems have been proven.<\/p><br><p>Theorem 1: If <b>|E|=0<\/b>, then <b>|MCBM|=0<\/b><br>Real-life corollary 1: Make friend(s) of opposite gender!<br>Real-life corollary 2: <b>|MCBM|<\/b> can only be <b>&gt; 0<\/b> if <b>|E| &gt; 0<\/b><br><\/p><p>See Example Graphs \u2192 Theorem \u2192 SMT 1 as shown in the background.<\/p>","title":"Steven&#39;s Marriage Theorems (1)"},{"id":894,"category":"matching","order":24,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2023-09-21 03:33:44","updated_at":"2023-09-21 08:15:26","section":64,"code":"\/\/ $(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('SMT_2');","section_order":4,"value":"4-24","text":"<p>Theorem 2: If there is a vertex <b>x \u2208 {U}<\/b> or <b>y \u2208 {V}<\/b> with (out-\/in-)degree <b>0<\/b> in <b>G<\/b>,<br>Then neither <b>x<\/b> nor <b>y<\/b> will be part of any MCBM<br>No matter how dense <b>|E|<\/b> is: Example Graphs \u2192 Theorem \u2192 SMT 2 as shown in the background (with <b>x = 0<\/b> and <b>y = 10<\/b>).<\/p><br><p>Real-life corollary 1: Again, make friend(s) of opposite gender!<br>Real-life corollary 2: Join social networking events, who know there is a workable edge between x and (y or any free vertex on the right set), thus |MCBM|+1<\/p><\/b>","title":"Steven&#39;s Marriage Theorems (2)"},{"id":895,"category":"matching","order":25,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2023-09-21 03:36:06","updated_at":"2023-09-21 08:18:23","section":64,"code":"\/\/ $(\"#augpath\").click().addClass(\"menu-highlighted\");\nbmw.bipartiteRandom(7, 3, 100);","section_order":4,"value":"4-25","text":"<p>Theorem 3: If <b>G<\/b> is a complete bipartite graph, denoted as <b>K<sub>n,m<\/sub><\/b>, where <b>n<\/b>\/<b>m<\/b> is the size of set <b>U<\/b>\/<b>V<\/b>, respectively, then <b>|MCBM|= min(n, m)<\/b>, i.e., <b>max(n, m) - min(n, m)<\/b> vertices remain unmatched if the two sides are not balanced<\/p><br><p>Real-life implication: Ensure your left set is smaller than (or equal to) the right set for your MCBM code\u2026, unlike the screenshot of Example Graphs \u2192 Theorem \u2192 SMT 3 as shown in the background.<br>Real-life corollary: If your current social circle is not balanced in terms of size of boy\/girl set, try to befriend other social circles that have more members of the other set, e.g., see <a href=\"https:\/\/www.nus.edu.sg\/registrar\/docs\/info\/student-statistics\/enrolment-statistics\/undergraduate-studies\/ug-enrol-20222023.pdf\" target=\"_blank\"><u>this<\/u><\/a> to discuss the situation in NUS School of Computing.<\/p>","title":"Steven&#39;s Marriage Theorems (3)"},{"id":896,"category":"matching","order":26,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2023-09-21 03:39:35","updated_at":"2023-09-21 05:08:52","section":64,"code":"$(\"#menu-unweighted-bipartite\").click();\n\/\/ $(\"#augpath\").click().addClass(\"menu-highlighted\");\nexample('SMT_4');","section_order":4,"value":"4-26","text":"<p>Theorem 4: If <b>G<\/b> contains <b>|E|<\/b> disjoint edges, then <b>|MCBM|=|E|<\/b>.<br>Moreover, the MCBM is also a perfect matching if there is no isolated vertex<\/p><br><p>Real-life corollary: This is the most ideal situation to get a perfect matching with the least number of edges (friendship) involved...<br>Unfortunately, it is very difficult to have this kind of ideal situation...<br>Also, probably not socially ideal if there are only very few cross-gender friendships like the one depicted in this picture.<\/p>","title":"Steven&#39;s Marriage Theorems (4)"},{"id":814,"category":"matching","order":5,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-09-11 01:44:24","updated_at":"2023-10-04 07:12:06","section":-1,"code":"$(\"#menu-unweighted-bipartite\").click();","section_order":-1,"value":"5","text":"<p>Unfortunately there is no weighted MCBM algorithm (e.g., Min-Cost-Max-Flow (mcmf) or Hungarian\/Kuhn-Munkres) visualization in VisuAlgo <i>yet<\/i>. But the plan is to have this visualization eventually.<\/p><br><p>For this section, please refer to CP4 Book 2 Chapter 9.25 and 9.27.<\/p>","title":"Weighted MCBM Algorithms"},{"id":684,"category":"matching","order":6,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-12 05:55:47","updated_at":"2023-10-04 07:33:51","section":-1,"code":"$(\"#menu-unweighted-general\").click();\nexample(FMOD);\n$(\"#augpath\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"6","text":"<p>When Graph Matching is posed on general graphs (the MCM problem), it is (much) harder to find Augmenting Path. In fact, before Jack Edmonds published his famous paper titled \"Paths, Trees, and Flowers\" in 1965, this MCM problem was thought to be an (NP-)hard optimization problem.<\/p><br><p>There are two Max Cardinality Matching (MCM) algorithms in this visualization:<\/p><ol><li>O(<b>V^3<\/b>) <b>Edmonds&#39; Matching<\/b> algorithm (without greedy pre-processing),<\/li><li>O(<b>V^3<\/b>) <b>Edmonds&#39; Matching<\/b> algorithm (with greedy pre-processing),<\/li><\/ol>","title":"MCM Algorithms"},{"id":690,"category":"matching","order":1,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-13 06:56:18","updated_at":"2023-10-04 07:34:31","section":684,"code":"$(\"#menu-unweighted-general\").click();\nexample(FMOD);\n$(\"#augpath\").click().addClass(\"menu-highlighted\");","section_order":6,"value":"6-1","text":"<p>In General Graph (like the graph shown in the background that has |MCM| = 4), we may have Odd-Length cycle. Augmenting Path is not well defined in such a graph, hence we cannot easily implement <a href=\".\/matching?slide=4-4\"><u>Claude Berge&#39;s theorem<\/u><\/a> like what we did with Bipartite Graph.<\/p><br><p>Jack Edmonds call a path that starts from a free vertex <b>u<\/b>, alternates between free, matched, ..., free edges, and returns to the <b>same<\/b> free vertex <b>u<\/b> as a <b>Blossom<\/b>. This situation is only possible if we have Odd-Length cycle, i.e., in a non-Bipartite Graph. For example, assume edge 1-2 has been matched in the graph shown in the background, then path 3-1=2-3 is a blossom.<\/p><br><p>Edmonds then proposed <a href=\"https:\/\/en.wikipedia.org\/wiki\/Blossom_algorithm\" target=\"_blank\"><u>Blossom shrinking\/contraction and expansion algorithm<\/u><\/a> to solve this issue. For details on how this algorithm works, read CP4 Section 9.28 as the current visualization of Edmonds&#39; matching algorithm in VisuAlgo is still &#39;a bit too hard too understand&#39; for beginners, try <span class=\"slide-actions\" onclick=\"doButtonAction150()\">Edmonds' Matching<\/span>. In a live class in NUS, these steps will be explained verbally.<\/p><br><p>This algorithm can be implemented in O(<b>V^3<\/b>).<\/p>","title":"O(V^3) Edmonds&#39; Matching Algorithm"},{"id":817,"category":"matching","order":2,"top":"","right":"","bottom":"190px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-09-11 11:50:10","updated_at":"2023-10-04 07:33:54","section":684,"code":"$(\"#menu-unweighted-general\").click();\nexample(FMOD);\n$(\"#augpath\").click().addClass(\"menu-highlighted\");","section_order":6,"value":"6-2","text":"O(V^3) Edmonds&#39; Matching Algorithm Plus<br><br><p>As with the <b>Augmenting Path Algorithm Plus<\/b> for the MCBM problem, we can also do randomized greedy pre-processing step to eliminate as many &#39;trivial matchings&#39; as possible upfront. This reduces the amount of work of <b>Edmonds&#39; Matching Algorithm<\/b>, thus resulting in a faster time complexity &mdash; analysis TBA.<\/p>","title":"O(V^3) Edmonds&#39; Matching Algorithm Plus"},{"id":692,"category":"matching","order":7,"top":"80px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-03-13 06:59:16","updated_at":"2022-09-11 11:50:55","section":-1,"code":"","section_order":-1,"value":"7","text":"<p>We have not added the visualizations for weighted variant of <b>MCBM<\/b> and <b>MCM<\/b> problems. They are for future work. Among the two, <b>weighted MCBM<\/b> will likely be added earlier than the <b>weighted MCM<\/b> version.<\/p><br><p>One of the possible solution for <b>weighted MCBM<\/b> problem is the <a href=\"https:\/\/en.wikipedia.org\/wiki\/Hungarian_algorithm\" target=\"_blank\"><u>Hungarian<\/u><\/a> algorithm. This algorithm also has another name: The Kuhn-Munkres algorithm. This algorithm relies on Berge&#39;s Augmenting Path Theorem too, but it uses the theorem slightly differently.<\/p>","title":"Closing Remarks"},{"id":812,"category":"matching","order":1,"top":"80px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-09-10 10:01:27","updated_at":"2023-10-04 07:20:05","section":692,"code":"","section_order":7,"value":"7-1","text":"<p>To strengthen your understanding about these Graph Matching problem, its variations, and the multiple possible solutions, please try solving as many of these programming competition problems listed below:<\/p><ol><li>Standard MCBM (but need a fast algorithm): <a href=\"https:\/\/open.kattis.com\/problems\/flippingcards\" target=\"_blank\"><u>Kattis - flippingcards<\/u><\/a><\/li><li>Greedy Bipartite Matching: <a href=\"https:\/\/open.kattis.com\/problems\/froshweek2\" target=\"_blank\"><u>Kattis - froshweek2<\/u><\/a><br>(you do <b>not<\/b> need a specific MCBM algorithm for this,<br>in fact, it will be too slow if you use any algorithm discussed here)<\/li><li>Special case of an NP-hard optimization problem: <a href=\"https:\/\/open.kattis.com\/problems\/bilateral\" target=\"_blank\"><u>Kattis - bilateral<\/u><\/a><\/li><li>Rather straightforward weighted MCBM: <a href=\"https:\/\/open.kattis.com\/problems\/engaging\" target=\"_blank\"><u>Kattis - engaging<\/u><\/a><\/li><\/ol>","title":"Programming Challenges"},{"id":732,"category":"matching","order":2,"top":"80px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2020-07-24 05:12:12","updated_at":"2022-09-11 11:46:55","section":692,"code":"","section_order":7,"value":"7-2","text":"<p>To tackle those programming contest problems, you are allowed to use\/modify our implementation code for Augmenting Path Algorithm (with Randomized Greedy Preprocessing): <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/mcbm.cpp\" target=\"_blank\"><u>mcbm.cpp<\/u><\/a> | <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/mcbm.py\" target=\"_blank\"><u>py<\/u><\/a> | <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/mcbm.java\" target=\"_blank\"><u>java<\/u><\/a>  | <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/mcbm.ml\" target=\"_blank\"><u>ml<\/u><\/a><br><\/p>","title":"Implementation"}];
      const numSlides = lectureIds.length;
      var sectorJunction12Section = 0, sectorJunction12Slide = 0;
      var sectorJunction23Section = 0, sectorJunction23Slide = 0;
      var sector1Count = 0, sector2Count = 0, sector3Count = 0;
      const sectorLength = Math.floor(numSlides / 3);
      function createELectureTimelineDisplay() {
        for (let j = 0; j < numSlides; ++j) {
          const currLecture = lectureIds[j].value;
          if (currLecture.includes('-')) {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-slide" slideNo=${lectureIds[j].value}></div>`)
            );
          } else {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-checkpoint" slideNo=${lectureIds[j].value}></div>`)
            );
          }
        }
      }

      function setSectorJunctionInfo() {
          //setting the sector junction slide numbers
          const j12 = sectorLength !== 0 ? (sectorLength - 1): 0;
          const j23 = sectorLength !== 0 ? (2 * sectorLength - 1) : 0;

          const sectorJunction12 = lectureIds[j12].value.split('-');
          sectorJunction12Section = parseInt(sectorJunction12[0]);
          sectorJunction12Slide = sectorJunction12.length > 1 ? parseInt(sectorJunction12[1]) : sectorJunction12Slide;

          const sectorJunction23 = lectureIds[j23].value.split('-');
          sectorJunction23Section = parseInt(sectorJunction23[0]);
          sectorJunction23Slide = sectorJunction23.length > 1 ? parseInt(sectorJunction23[1]) : sectorJunction23Slide;
      }

      function runSlide(slide) { // Steven's patch on 28 Jan 2022: Properly remove slide 99, 99-1, 99-2, 99-3, integrate with the earlier slides
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 2 + "%)");
          
        }
        if (slide == '1-1') {
          $("#e-lecture").html("slide " + slide + " (" + 5 + "%)");
          
        }
        if (slide == '1-2') {
          $("#e-lecture").html("slide " + slide + " (" + 7 + "%)");
          
        }
        if (slide == '1-3') {
          $("#e-lecture").html("slide " + slide + " (" + 10 + "%)");
          $("#menu-unweighted-general").click();
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 12 + "%)");
          $("#menu-unweighted-bipartite").click();
bmw.bipartiteRandom(3, 4, 70); // medium size
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 15 + "%)");
          $("#draw").addClass("menu-highlighted");
$("#modeling").addClass("menu-highlighted");
$("#examples").addClass("menu-highlighted");
closeAugPath();
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 17 + "%)");
          $("#menu-unweighted-bipartite").click();
$("#augpath").click().addClass("menu-highlighted");
        }
        if (slide == '4-1') {
          $("#e-lecture").html("slide " + slide + " (" + 20 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example('Undirected_MF_Killer');
        }
        if (slide == '4-2') {
          $("#e-lecture").html("slide " + slide + " (" + 22 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example('Undirected_MF_Killer');
        }
        if (slide == '4-3') {
          $("#e-lecture").html("slide " + slide + " (" + 25 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example('Undirected_MF_Killer');
        }
        if (slide == '4-4') {
          $("#e-lecture").html("slide " + slide + " (" + 27 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example('xbar'); // specifically show this example
        }
        if (slide == '4-5') {
          $("#e-lecture").html("slide " + slide + " (" + 30 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example('xbar'); // specifically show this example
        }
        if (slide == '4-6') {
          $("#e-lecture").html("slide " + slide + " (" + 32 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example('OddLineBipartite'); // specifically show this example
        }
        if (slide == '4-7') {
          $("#e-lecture").html("slide " + slide + " (" + 35 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example('EvenLineBipartite'); // specifically show this example
        }
        if (slide == '4-8') {
          $("#e-lecture").html("slide " + slide + " (" + 37 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example('EvenCycleBipartite'); // specifically show this example
        }
        if (slide == '4-9') {
          $("#e-lecture").html("slide " + slide + " (" + 40 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example('OddLineBipartite'); // specifically show this example
        }
        if (slide == '4-10') {
          $("#e-lecture").html("slide " + slide + " (" + 42 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example('xbar'); // specifically show this example
        }
        if (slide == '4-11') {
          $("#e-lecture").html("slide " + slide + " (" + 45 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example('xbar'); // specifically show this example
        }
        if (slide == '4-12') {
          $("#e-lecture").html("slide " + slide + " (" + 47 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example('xbar'); // specifically show this example
        }
        if (slide == '4-13') {
          $("#e-lecture").html("slide " + slide + " (" + 50 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example(K55_ALMOST);
        }
        if (slide == '4-14') {
          $("#e-lecture").html("slide " + slide + " (" + 52 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example(K55_ALMOST);
        }
        if (slide == '4-15') {
          $("#e-lecture").html("slide " + slide + " (" + 55 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example(K55_ALMOST);
        }
        if (slide == '4-16') {
          $("#e-lecture").html("slide " + slide + " (" + 57 + "%)");
          $("#menu-unweighted-bipartite").click();
$("#augpath").click().addClass("menu-highlighted");
example('Rand_Greedy_AP_Killer');
        }
        if (slide == '4-17') {
          $("#e-lecture").html("slide " + slide + " (" + 60 + "%)");
          $("#menu-unweighted-bipartite").click();
$("#augpath").click().addClass("menu-highlighted");
example('Rand_Greedy_AP_Killer');
        }
        if (slide == '4-18') {
          $("#e-lecture").html("slide " + slide + " (" + 62 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example('MatchingWithCapacity');
        }
        if (slide == '4-19') {
          $("#e-lecture").html("slide " + slide + " (" + 65 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example('waif_WA');
        }
        if (slide == '4-20') {
          $("#e-lecture").html("slide " + slide + " (" + 67 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example('greedy_raw');
        }
        if (slide == '4-21') {
          $("#e-lecture").html("slide " + slide + " (" + 70 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example('HMT_1');
        }
        if (slide == '4-22') {
          $("#e-lecture").html("slide " + slide + " (" + 72 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example('HMT_2');
        }
        if (slide == '4-23') {
          $("#e-lecture").html("slide " + slide + " (" + 75 + "%)");
          // ("#augpath").click().addClass("menu-highlighted");
bmw.bipartiteRandom(7, 7, 0);
        }
        if (slide == '4-24') {
          $("#e-lecture").html("slide " + slide + " (" + 77 + "%)");
          // $("#augpath").click().addClass("menu-highlighted");
example('SMT_2');
        }
        if (slide == '4-25') {
          $("#e-lecture").html("slide " + slide + " (" + 80 + "%)");
          // $("#augpath").click().addClass("menu-highlighted");
bmw.bipartiteRandom(7, 3, 100);
        }
        if (slide == '4-26') {
          $("#e-lecture").html("slide " + slide + " (" + 82 + "%)");
          $("#menu-unweighted-bipartite").click();
// $("#augpath").click().addClass("menu-highlighted");
example('SMT_4');
        }
        if (slide == '5') {
          $("#e-lecture").html("slide " + slide + " (" + 85 + "%)");
          $("#menu-unweighted-bipartite").click();
        }
        if (slide == '6') {
          $("#e-lecture").html("slide " + slide + " (" + 87 + "%)");
          $("#menu-unweighted-general").click();
example(FMOD);
$("#augpath").click().addClass("menu-highlighted");
        }
        if (slide == '6-1') {
          $("#e-lecture").html("slide " + slide + " (" + 90 + "%)");
          $("#menu-unweighted-general").click();
example(FMOD);
$("#augpath").click().addClass("menu-highlighted");
        }
        if (slide == '6-2') {
          $("#e-lecture").html("slide " + slide + " (" + 92 + "%)");
          $("#menu-unweighted-general").click();
example(FMOD);
$("#augpath").click().addClass("menu-highlighted");
        }
        if (slide == '7') {
          $("#e-lecture").html("slide " + slide + " (" + 95 + "%)");
          
        }
        if (slide == '7-1') {
          $("#e-lecture").html("slide " + slide + " (" + 97 + "%)");
          
        }
        if (slide == '7-2') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
        }
        clearTimeout(currSlideTimer);
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };
      var slideTimeline = {};

      //reads all visited slides in the slideTimeline and gives them their sector color
      function setVisitedSlideTimelineColors() {
        for(const [sectionNo, visitedSlides] of Object.entries(slideTimeline)) {
          const visitedSlides = slideTimeline[sectionNo];
          for(const visitedSlideNo of visitedSlides) {
            setSlideTimelineColor(visitedSlideNo);
          }
        }
      }

      //only called on load if there is nothing in session
      function setTimelineForCompletedSector(sectorNum) {
        let len = sectorLength;
        switch (sectorNum) {
          case 1 : len = sectorLength; break;
          case 2 : len = 2 * sectorLength; break;
          default: len = numSlides;
        }
        let i = 0;
        switch (sectorNum) {
          case 1 : i = 0; break;
          case 2 : i = sectorLength; break;
          default: i = 2 * sectorLength;
        }
        for (; i < len; i++) {
          saveELectureTimeline(lectureIds[i].value, true);
        }
      }

      function getUserSectorHistory(callback) {
        $.ajax({
          type: 'GET',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            topic: "/matching".substring(1)
          }
        }
        ).done(function (data) {
            if (data.data[0] === 1) {
              setF1SectorColor(1);
              setTimelineForCompletedSector(1);
            }
            if (data.data[1] === 1) {
              setF1SectorColor(2);
              setTimelineForCompletedSector(2);
            }
            if (data.data[2] === 1) {
              setF1SectorColor(3);
              setTimelineForCompletedSector(3);
            }
            callback();
        }).fail(function (data) {
            console.log('get user sector history failed!');
        });
      }

      function getELectureTimelineFromSession() {
        const page = "/matching".substring(1);
        const timelineKey = page + '-slide-timeline';
        const storedTimeline = window.sessionStorage.getItem(timelineKey);
        if (storedTimeline) {
          slideTimeline = JSON.parse(storedTimeline);
        } else {
          return false;
        }
        let slideInfo = [];
        for (const [sectionNum, slides] of Object.entries(slideTimeline)) {
          for (const slide of slides) {
            indicateSlideCompletedUI(slide);
            slideInfo = slide.split('-');
            incrementSectorVisits(parseInt(sectionNum), slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0);
          }
        }
        return true;
      }

      async function initializeELectureTimeline() {
        setSectorJunctionInfo();
        if (!getELectureTimelineFromSession())
          getUserSectorHistory(sectorBasedModeSelection);
        else
          sectorBasedModeSelection();

        createELectureTimelineDisplay();
        setVisitedSlideTimelineColors();
      }

      function setF1SectorColor(sectorNum) {
        $(`[sectorNo="${sectorNum}"]`).css('background', sectorColors[(parseInt(sectorNum) % 3)]);
      }

      function updateSectorInDB(sectorNum) {
        $.ajax({
          type: 'POST',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            section: (sectorNum - 1),
            topic: "/matching".substring(1)
          }
        }
        ).done(function (data) {
            //console.log("Saved the sector " + sectorNum + " as done " + JSON.stringify(data));
        }).fail(function (data) {
            console.log("Setting sector done failed new attempt! "+ JSON.stringify(data));
        });
      }

      //If 87.5% or more of the slides in sector are done
      function setF1SectorCompleted(sectorNum, isInitializationCall) {
        setF1SectorColor(sectorNum);
        //avoid api call on initialization
        if (!isInitializationCall) {
          updateSectorInDB(sectorNum);
          $(`[sectorNo="${sectorNum}"]`).css("animation", "green-pulse 2s 4");
          setTimeout(() => {
            $(`[sectorNo="${sectorNum}"]`).css("animation", "");
          }, 8000);
        }
      }

      function incrementSectorVisits(sectionNum, slideNumWithinSection, isInitializationCall) {
        //updating sector count
        if (sectionNum < sectorJunction12Section
          || (sectionNum === sectorJunction12Section && slideNumWithinSection <= sectorJunction12Slide)) {
          ++sector1Count;
          if (sector1Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(1, isInitializationCall);
        } else if (sectionNum < sectorJunction23Section
          || (sectionNum === sectorJunction23Section && slideNumWithinSection <= sectorJunction23Slide)) {
          ++sector2Count;
          if (sector2Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(2, isInitializationCall);
        } else {
          ++sector3Count;
          if (sector3Count >= Math.ceil(0.875 * (numSlides - 2 * sectorLength)))
            setF1SectorCompleted(3, isInitializationCall);
        }
      }

      function saveELectureTimeline(slideNo, isInitialization) {
        const slideInfo = slideNo.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        if (slideTimeline[sectionNo]) {
          if (!slideTimeline[sectionNo].includes(slideNo)) {
            slideTimeline[sectionNo].push(slideNo);
            const sectionNum = parseInt(sectionNo);
            incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
          }
        } else {
          slideTimeline[sectionNo] = [];
          slideTimeline[sectionNo].push(slideNo);
          const sectionNum = parseInt(sectionNo);
          incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
        }
        setSlideTimelineColor(slideNo);
        indicateSlideCompletedUI(slideNo);
      }

      function saveELectureTimelineToSession() {
        const page = "/matching".substring(1);
        const timelineKey = page + '-slide-timeline';
        window.sessionStorage.setItem(timelineKey, JSON.stringify(slideTimeline));
      }

      function handleTimelineOnRunSlide(slideValue) {
        const slideInfo = slideValue.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        //start timer only if the slide isnt already done
        if (!slideTimeline[sectionNo] || !slideTimeline[sectionNo].includes(slideValue)) {
          const slideTextLength = $('#electure-'+slideValue + " p").text().length + $('#electure-'+slideValue + " li").text().length;
          const CHARS_READ_PER_MS = 0.05; //when fast, 50 characters a second
          //setting max reading time as 10 seconds for around 500 character slide
          const minSlideReadingTime = Math.min(Math.max(2000, (slideTextLength / CHARS_READ_PER_MS) +  + (2000 * $('#electure-'+slideValue + " img").length)), 10000);
          currSlideTimer = setTimeout(() => {
            saveELectureTimeline(slideValue);
          }, minSlideReadingTime);
        }
      }

      function indicateSlideCompletedUI(slide) {
        $('#electure-'+slide).css("box-shadow", "3px 3px 8px green"); //set green shadow for completed slides
        $('#electure-'+slide + ' .electure-read-status').html("&#10004;");
        $('#electure-'+slide + ' .electure-read-status').attr("title", "Slide Completed!");
        $('#electure-'+slide + ' .electure-read-status').css("font-size", "17px");
      }

      function pushState(slideValue) {
        var url = '/en/matching';
        if (typeof slideValue != 'undefined' && slideValue != null) {
          url += '?slide=' + slideValue;
                  }
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5);
        $('#overlay').show();

        $("#e-lecture-timeline").show();
        $("#e-lecture-f1map").show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
        $("#e-lecture-timeline").hide();
        $("#e-lecture-f1map").hide();
        clearTimeout(currSlideTimer);
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      function sectorBasedModeSelection() {
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        //check params are empty and then that all sectors are completed or not
        if (!Object.keys(params).length
          && sector1Count === sectorLength && sector2Count === sectorLength && sector3Count === (numSlides - 2 * sectorLength)) {
            hideOverlay();
        }
        else
          $('#mode-menu a').click();
      }

      $(function() {
        if (isMobileOS() && portraitMatcher.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').show();
          $('#widenDeviceText').hide();
          $('#topbar').css("z-index", 10001);
        } else if (matchMediaNarrow.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').hide();
          $('#widenDeviceText').show();
          $('#topbar').css("z-index", 10001);
        } else {
          $('#rotateDeviceOverlay').hide();
          $('#topbar').css("z-index", "");
        }

        matchMediaNarrow.addEventListener('change', e => {
          //screws up for square device! NEED RESIZE EVENT
          if (e.matches) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').hide();
              $('#widenDeviceText').show();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        portraitMatcher.addEventListener('change', e => {
          if (e.matches && isMobileOS()) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').show();
              $('#widenDeviceText').hide();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        let slide = getUrlParameter('slide');
        if (typeof slide !== undefined && slide != null) {
          cur_slide = slide;
        }
        //do all timeline and slide stuff only if specific params not provided
        if (!Object.keys(params).length || params["slide"]) {
          if (!isMobile()) {
                            $('#mode-menu a').click();
                      }
        }
        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
        $('#electure-1-1 .electure-next').click(function() {
          hidePopup();
          runSlide('1-2');
          pushState('1-2');
        });
        $('#electure-1-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
        $('#electure-1-2 .electure-next').click(function() {
          hidePopup();
          runSlide('1-3');
          pushState('1-3');
        });
        $('#electure-1-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
        $('#electure-1-3 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-1-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-2');
          pushState('1-2');
        });
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-3');
          pushState('1-3');
        });
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-4-1 .electure-next').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-4-2 .electure-next').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
        $('#electure-4-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
        $('#electure-4-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
        $('#electure-4-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
        $('#electure-4-5 .electure-next').click(function() {
          hidePopup();
          runSlide('4-6');
          pushState('4-6');
        });
        $('#electure-4-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
        $('#electure-4-6 .electure-next').click(function() {
          hidePopup();
          runSlide('4-7');
          pushState('4-7');
        });
        $('#electure-4-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
        $('#electure-4-7 .electure-next').click(function() {
          hidePopup();
          runSlide('4-8');
          pushState('4-8');
        });
        $('#electure-4-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-6');
          pushState('4-6');
        });
        $('#electure-4-8 .electure-next').click(function() {
          hidePopup();
          runSlide('4-9');
          pushState('4-9');
        });
        $('#electure-4-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-7');
          pushState('4-7');
        });
        $('#electure-4-9 .electure-next').click(function() {
          hidePopup();
          runSlide('4-10');
          pushState('4-10');
        });
        $('#electure-4-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-8');
          pushState('4-8');
        });
        $('#electure-4-10 .electure-next').click(function() {
          hidePopup();
          runSlide('4-11');
          pushState('4-11');
        });
        $('#electure-4-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-9');
          pushState('4-9');
        });
        $('#electure-4-11 .electure-next').click(function() {
          hidePopup();
          runSlide('4-12');
          pushState('4-12');
        });
        $('#electure-4-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-10');
          pushState('4-10');
        });
        $('#electure-4-12 .electure-next').click(function() {
          hidePopup();
          runSlide('4-13');
          pushState('4-13');
        });
        $('#electure-4-12 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-11');
          pushState('4-11');
        });
        $('#electure-4-13 .electure-next').click(function() {
          hidePopup();
          runSlide('4-14');
          pushState('4-14');
        });
        $('#electure-4-13 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-12');
          pushState('4-12');
        });
        $('#electure-4-14 .electure-next').click(function() {
          hidePopup();
          runSlide('4-15');
          pushState('4-15');
        });
        $('#electure-4-14 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-13');
          pushState('4-13');
        });
        $('#electure-4-15 .electure-next').click(function() {
          hidePopup();
          runSlide('4-16');
          pushState('4-16');
        });
        $('#electure-4-15 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-14');
          pushState('4-14');
        });
        $('#electure-4-16 .electure-next').click(function() {
          hidePopup();
          runSlide('4-17');
          pushState('4-17');
        });
        $('#electure-4-16 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-15');
          pushState('4-15');
        });
        $('#electure-4-17 .electure-next').click(function() {
          hidePopup();
          runSlide('4-18');
          pushState('4-18');
        });
        $('#electure-4-17 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-16');
          pushState('4-16');
        });
        $('#electure-4-18 .electure-next').click(function() {
          hidePopup();
          runSlide('4-19');
          pushState('4-19');
        });
        $('#electure-4-18 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-17');
          pushState('4-17');
        });
        $('#electure-4-19 .electure-next').click(function() {
          hidePopup();
          runSlide('4-20');
          pushState('4-20');
        });
        $('#electure-4-19 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-18');
          pushState('4-18');
        });
        $('#electure-4-20 .electure-next').click(function() {
          hidePopup();
          runSlide('4-21');
          pushState('4-21');
        });
        $('#electure-4-20 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-19');
          pushState('4-19');
        });
        $('#electure-4-21 .electure-next').click(function() {
          hidePopup();
          runSlide('4-22');
          pushState('4-22');
        });
        $('#electure-4-21 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-20');
          pushState('4-20');
        });
        $('#electure-4-22 .electure-next').click(function() {
          hidePopup();
          runSlide('4-23');
          pushState('4-23');
        });
        $('#electure-4-22 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-21');
          pushState('4-21');
        });
        $('#electure-4-23 .electure-next').click(function() {
          hidePopup();
          runSlide('4-24');
          pushState('4-24');
        });
        $('#electure-4-23 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-22');
          pushState('4-22');
        });
        $('#electure-4-24 .electure-next').click(function() {
          hidePopup();
          runSlide('4-25');
          pushState('4-25');
        });
        $('#electure-4-24 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-23');
          pushState('4-23');
        });
        $('#electure-4-25 .electure-next').click(function() {
          hidePopup();
          runSlide('4-26');
          pushState('4-26');
        });
        $('#electure-4-25 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-24');
          pushState('4-24');
        });
        $('#electure-4-26 .electure-next').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-4-26 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-25');
          pushState('4-25');
        });
        $('#electure-5 .electure-next').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-26');
          pushState('4-26');
        });
        $('#electure-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-6-1 .electure-next').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-6-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-6-2 .electure-next').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-6-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-7 .electure-next').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-7-1 .electure-next').click(function() {
          hidePopup();
          runSlide('7-2');
          pushState('7-2');
        });
        $('#electure-7-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-7-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
      });

      function doButtonAction110() {
        CUSTOM_ACTION('augmentingpath');
      }
      function doButtonAction111() {
        example(K55_ALMOST);
CUSTOM_ACTION('augmentingpath');
      }
      function doButtonAction112() {
        example(K55_ALMOST);
CUSTOM_ACTION('hopcroftkarp');
      }
      function doButtonAction113() {
        example(K55_ALMOST);
CUSTOM_ACTION('greedyaug');
      }
      function doButtonAction114() {
        example('Rand_Greedy_AP_Killer');
CUSTOM_ACTION('greedyaug');
      }
      function doButtonAction142() {
        example('greedy_raw');
CUSTOM_ACTION('augmentingpath');
      }
      function doButtonAction143() {
        example('greedy_sorted');
      }
      function doButtonAction149() {
        example('GridBipartite');
      }
      function doButtonAction150() {
        CUSTOM_ACTION('edmonds');
      }

      $('.electure-print').click(() => {
        window.open(`/en/matching/print`);
      });
      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url.html) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}

      // This function will be called everytime 1.0x is changed to 0.5x or vice versa
      function redraw() {}

      $(document).ready(function () {
        setTimeout(function () {
          $('#change-lang-popup').fadeOut('slow')
        }, 5000)
      })
    </script>
<script type="text/javascript">
    var extraCSS = {"augpath":"65px","examples":"92px","modeling":"119px","draw":"146px"};
    var actionsIds = {"draw":{"p":"Edit Graph","onClick":"drawGraph()"},"modeling":{"p":"Modeling","parents":["rookattack","bipartite"]},"examples":{"p":"Example Graphs","parents":["example-corner-case","example-special-case","example-performance","example-theorem"]},"augpath":{"p":"Augmenting Path"}};
    var isOpens = {};
    var len = 4;
    var keys = ["draw","modeling","examples","augpath"]; 
    for (i = 0; i < len; i++) {
        var actionDetails = keys[i];
        isOpens[actionDetails] = false;
    }
    function openAction(id) {
        hideThirdTiers(id);
        $("." + id).css("bottom", extraCSS[id]);
        if (!isOpens[id]) {
            $('.' + id).fadeIn('fast');
            isOpens[id] = true;
        }
    }
    function closeAction(id) {
        hideThirdTiers(id);
        if (isOpens[id]) {
            $('.' + id).fadeOut('fast');
            $('#' + id + '-err').html("");
            isOpens[id] = false;
        }
    }

    function hideEntireActionsPanel() {
        //hideAllThirdTiers();
                    closeAction('draw');
                    closeAction('modeling');
                    closeAction('examples');
                    closeAction('augpath');
                hideActionsPanel();
    }

    function hideThirdTiers(tier1Action) {
        if ("parents" in actionsIds[tier1Action]) {
            for (const secondTierAction of actionsIds[tier1Action]["parents"]) {
                $('#' + secondTierAction + '-third-tier').fadeOut('fast');
            }
        }
    }

    function hideAllThirdTiers() {
        for (const tier1Action in actionsIds) {
            hideThirdTiers(tier1Action);
        }
    }

    function toggleChildExtras(tier1, selectedParentTier2) {
        hideThirdTiers(tier1);
        //this actionId must have childExtras
        var style = extraCSS[tier1];
        $("." + tier1).css("bottom", (parseInt(style.substring(0, style.length - 2)) - 27));
        //fade ins and outs are done on the ID whereas css class is set on the class
        //fade in the third tier of the selected 2nd tier parent
        $('#' + selectedParentTier2 + '-third-tier').fadeIn('fast');

        // //fade out all other third tiers of that 'action'
        // for (const parent of actions[tier1]["parents"]) {
        //     console.log("parent is " + parent + " for " + selectedParentTier2);
        //     if (parent != selectedParentTier2) {
        //         $('#' + parent + '-third-tier').fadeOut('fast');
        //     }
        // }
    }

    function setActionHeightOriginal(tier1Action) {
        $("." + tier1Action).css("bottom", extraCSS[tier1Action]);
    }

            $('#' + 'draw').click(function() {
            openAction('draw');
                                                                            closeAction('modeling');
                                                                closeAction('examples');
                                                                closeAction('augpath');
                                    });
            $('#' + 'modeling').click(function() {
            openAction('modeling');
                                                closeAction('draw');
                                                                                            closeAction('examples');
                                                                closeAction('augpath');
                                    });
            $('#' + 'examples').click(function() {
            openAction('examples');
                                                closeAction('draw');
                                                                closeAction('modeling');
                                                                                            closeAction('augpath');
                                    });
            $('#' + 'augpath').click(function() {
            openAction('augpath');
                                                closeAction('draw');
                                                                closeAction('modeling');
                                                                closeAction('examples');
                                                                });
    
    //important to have all the input fields in actions menu take an id containing '-input'
    $("[id*='-input']").on("keypress keydown keyup", (event) => {
        event.stopPropagation();
    });
</script>
<script src="../js/manifest.js"></script>
<script src="../js/vendor.js"></script>
<script src="../js/matching_algos.js"></script>
<script>
// Matching Widget
// original author (various, but all partials): Peter Phandi, Mohan Jishnu, Jonathan Irvin Gunawan, Steven Halim

var MCBM_EXAMPLE_CP3_4_44 = 0;
var MCBM_EXAMPLE_CP3_4_42 = 1;
var MCBM_EXAMPLE_CP3_4_43 = 2;
var COMPLETE_GRAPH = 3;

var MCBM = function() {
  var gw = new GraphWidget();

  var valueRange = [1,100];

  var iVL = {};
  var iEL = {};
  var amountVertex = 0;
  var amountEdge = 0;
  var amountLeftSet = 0;
  var sourceVertex = 0;
  this.getiVL = function() {
    return iVL;
  }
  this.getiEL = function() {
    return iEL;
  }

  this.getGraphWidget = function() { return gw; }

  this.refreshView = function() {
    // fixJSON();
    var newState = createState({iVL: iVL, iEL: iEL});
    gw.updateGraph(newState, 500);
  }

  fixJSON = function() {
    amountVertex = 0;
    amountEdge = 0;
    for (var key in iVL) ++amountVertex;
    for (var key in iEL) ++amountEdge;

    // for (var key in iEL) {
    //   delete iEL[key]["type"];
    //   delete iEL[key]["displayWeight"];
    //   if (iEL[key]["vertexA"] > iEL[key]["vertexB"]) {
    //     var temp = iEL[key]["vertexA"];
    //     iEL[key]["vertexA"] = iEL[key]["vertexB"];
    //     iEL[key]["vertexB"] = temp;
    //   }
    // }

    // for (var key in iVL) {
    //   iVL[key]["text"] = +key;
    //   delete iVL[key]["state"];
    // }
  }

  takeJSON = function(graph) {
    if (graph == null) return;
    graph = JSON.parse(graph);
    amountVertex = $.map(graph["vl"], function(n, i) { return i; }).length;
    amountEdge = $.map(graph["el"], function(n, i) { return i; }).length;
    iVL = graph["vl"];
    iEL = graph["el"];
    amountLeftSet = graph.amountLeftSet;
    fixJSON();
  }

  var whichSide = new Array;
  var bipartite;

  bipartiteChecking = function(now) {
    for (var i in iEL) {
      if (iEL[i]["vertexA"] == now) {
        if (whichSide[iEL[i]["vertexB"]] == -1) {
          whichSide[iEL[i]["vertexB"]] = 1 - whichSide[iEL[i]["vertexA"]];
          bipartiteChecking(iEL[i]["vertexB"]);
        }
        else if (whichSide[iEL[i]["vertexB"]] == whichSide[iEL[i]["vertexA"]])
          bipartite = false;
      }
      else if (iEL[i]["vertexB"] == now) {
        if (whichSide[iEL[i]["vertexA"]] == -1) {
          whichSide[iEL[i]["vertexA"]] = 1 - whichSide[iEL[i]["vertexB"]];
          bipartiteChecking(iEL[i]["vertexA"]);
        }
        else if (whichSide[iEL[i]["vertexA"]] == whichSide[iEL[i]["vertexB"]])
          bipartite = false;
      }
    }
  }

  statusChecking = function(update = false) {
    const [curiVL, curiEL] = parseCurrentJSONresult()
    if (currentGraphVisu.amountVertex() == 0)
      $("#draw-status p").html("Graph is empty");
    else {
      if ($("#draw-err p").html() == "No Error") {
        if ((selectedState & BIPARTITE_MATCHING) > 0) {
          for (var border = 0; border < currentGraphVisu.amountVertex()-1; border++) { // check whether left side = [0, border]
            var okay = true;
            for (var i = 0; i <= border; i++)
              for (var j = 0; j <= border; j++)
                for (var k in curiEL)
                  if (curiEL[k]["u"] == i && curiEL[k]["v"] == j)
                    okay = false;

            for (var i = border+1; i < currentGraphVisu.amountVertex(); i++)
              for (var j = border+1; j < currentGraphVisu.amountVertex(); j++)
                for (var k in curiEL)
                  if (curiEL[k]["u"] == i && curiEL[k]["v"] == j)
                    okay = false;

            if (okay) {
              $("#draw-status p").html(
                "Left side vertices = [0,{left}]. Right side vertices = [{right},{last}]"
                  .replace("{left}", border)
                  .replace("{right}", border+1)
                  .replace("{last}", currentGraphVisu.amountVertex()-1)
              );
              if (update) {
                amountLeftSet = border + 1;
              }
              return;
            }
          }
        }
      }
      else $("#draw-status p").html("");
    }
  }

  warnChecking = function() {
    var warn = "";
    if (currentGraphVisu.amountVertex() >= 10)
      warn += "Too much vertex on screen, consider drawing smaller graph. ";

    if (warn == "") $("#draw-warn p").html("No Warning");
    else $("#draw-warn p").html(warn);
  }

  errorChecking = function() {
    const [curiVL, curiEL] = parseCurrentJSONresult()
    var error = "";
    if (currentGraphVisu.amountVertex() < 2) {
      $("#draw-err p").html("There must be at least 2 vertices. ");
      return;
    }

    if ((selectedState & BIPARTITE_MATCHING) > 0) {
      for (var i = 0; i < currentGraphVisu.amountVertex(); i++) whichSide[i] = -1;
      bipartite = true;
      for (var i = 0; i < currentGraphVisu.amountVertex(); i++) {
        if (whichSide[i] == -1) {
          whichSide[i] = i%2;
          bipartiteChecking(i);
        }
      }

      if (!bipartite)
        error += "Graph is not bipartite. Currently Graph Matching only supports Bipartite Graph. :( ";

      var separatable = false;
      for (var border = 0; border < currentGraphVisu.amountVertex()-1; border++) { // check whether left side = [0,border]
        var okay = true;
        for (var i = 0; i <= border; i++)
          for (var j = 0; j <= border; j++)
            for (var k in curiEL)
              if (curiEL[k]["u"] == i && curiEL[k]["v"] == j)
                okay = false;

        for (var i = border+1; i < currentGraphVisu.amountVertex(); i++)
          for (var j = border+1; j < currentGraphVisu.amountVertex(); j++)
            for (var k in curiEL)
              if (curiEL[k]["u"] == i && curiEL[k]["v"] == j)
                okay = false;

        if (okay)
          separatable = true;
      }

      if (bipartite && !separatable)
        error += "There is no <b>n</b> such that the left vertices are numbered [0, <b>n</b>) and the right vertices are numbered [<b>n</b>, <b>n+m</b>).";
    }

    if (error == "") $("#draw-err p").html("No Error");
    else $("#draw-err p").html(error);
  }

  var intervalID;

  this.startLoop = function() {
    intervalID = setInterval(function() {
      warnChecking();
      errorChecking();
      statusChecking();
    }, 100);
  }

  this.stopLoop = function() {
    clearInterval(intervalID);
  }

  relayout = function() {
    var amountRightSet = amountVertex-amountLeftSet;
    for (var i = 1; i <= amountLeftSet; i++) {
      iVL[i-1]["x"] = 300; // previously 200 before 4 March 2022
      // iVL[i-1]["y"] = 250 + (i - (amountLeftSet+1)/2) * (amountLeftSet == 1 ? 0 : 400 / (amountLeftSet-1)); // previously
      iVL[i-1]["y"] = 175 + (i - (amountLeftSet+1)/2) * (amountLeftSet == 1 ? 0 : 300 / (amountLeftSet-1));
    }

    for (var i = 1; i <= amountRightSet; ++i) {
      iVL[i+amountLeftSet-1]["x"] = 400;
      // iVL[i-1]["y"] = 250 + (i - (amountLeftSet+1)/2) * (amountLeftSet == 1 ? 0 : 400 / (amountLeftSet-1)); // previously
      iVL[i+amountLeftSet-1]["y"] = 175 + (i - (amountRightSet+1)/2) * (amountRightSet == 1 ? 0 : 300 / (amountRightSet-1));
    }
  }

  this.draw = function() {
    if ($("#draw-err p").html() != "No Error") 
      return false;
    takeJSON(JSONresult);
    // this is a hack to update the amountleftset since jsonresult doesnt actually have it
    statusChecking(update = true);
    if ($("#submit").is(':checked'))
      this.submit(JSONresult);
    if ($("#copy").is(':checked')) {
      window.prompt("Copy to clipboard:", JSONresult);
    }
    if ($("#relayout").is(':checked'))
      relayout();

    graph = createState(iVL, iEL);
    gw.updateGraph(graph, 500);
    return true;
  }

  this.submit = function(graph) {
    $.ajax({
      url: PHP_DOMAIN + "/php/Graph.php?mode=" + MODE_SUBMIT_GRAPH + "&sessionID=" + $.cookie("sessionID"),
      type: "POST",
      data: {canvasWidth: 1000, canvasHeight: 500, graphTopics: 'Graph Matching', graphState: graph},
      error: function(xhr, errorType, exception) { //Triggered if an error communicating with server  
        var errorMessage = exception || xhr.statusText; //If exception null, then default to xhr.statusText  
        alert("There was an error submitting your graph " + errorMessage);
      }
    }).done(function(data) {
      console.log(data);
    });
  }

  this.importjson = function(text) {
    // var text = $("#samplejson-input").val();
    takeJSON(text);
    statusChecking(); // TODO: reenable this later
    graph = createState(iVL, iEL);
    gw.updateGraph(graph, 500);
  }

  this.initRandom = function(graph) {
    iVL = graph.iVL;
    iEL = graph.iEL;
    amountVertex = iVL.length;
    amountEdge = iEL.length;
    fixJSON();
    statusChecking();
    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
  }

  this.generateRandom = function() {
    amountVertex = Math.floor(Math.random()*9) + 4; // 4 to 12
    var numL = Math.floor(Math.random() * (amountVertex-3)) + 1; // 1 to N-3
    if (numL > 6) numL = 6;
    var rightVertex = amountVertex-numL;
    iVL = new Object();
    iEL = new Object();
    amountEdge = 0;

    for (var i = 0; i < numL; ++i) {
      iVL[i] = {
        "x": 200,
        "y": (250 + (i+1-(numL+1)/2) * (numL == 1 ? 0 : 400/(numL-1)))
      }
    }

    for (var i = 0; i < rightVertex; ++i) {
      iVL[i+numL] = {
        "x": 450,
        "y": (250 + (i+1-(rightVertex+1)/2) * (rightVertex == 1 ? 0 : 400/(rightVertex-1)))
      }
    }

    for (var i = 0; i < numL; ++i)
      for (var j = 0; j < rightVertex; ++j) {
        var existEdge = Math.floor(Math.random()*2);
        if (existEdge == 1) {
          iEL[amountEdge] = {
            "u": i,
            "v": j+numL,
            "w": 1
          }
          ++amountEdge;
        }
      }

    amountVertex = 0;
    amountEdge = 0;
    for (var i in iVL) ++amountVertex;
    for (var i in iEL) ++amountEdge;
    amountLeftSet = numL;
    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
    return true;
  }

  this.augmentingPath = function(isGreedy, callback) {
    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, vertexHighlighted = {}, edgeHighlighted = {}, edgeTraversed2 = {}, vertexTraversed2 = {};
    var cs, key;
    var toSet = [], toUnSet = [];
    var LeftToRightEdge = [], RightToLeftEdge = [];
    var edgeDict = {};

    if (amountVertex == 0) { // no graph
      $('#augpath-err').html("There is no graph to run this on. Please select a sample graph first.");
      return false;
    }

    for (key in iEL) {
      var edgeDictKeyOne = [];
      var edgeDictKeyTwo = [];
      edgeDictKeyOne.push(iEL[key]["u"]);
      edgeDictKeyOne.push(iEL[key]["v"]);
      edgeDictKeyTwo.push(iEL[key]["v"]);
      edgeDictKeyTwo.push(iEL[key]["u"]);
      edgeDict[edgeDictKeyOne] = key;
      edgeDict[edgeDictKeyTwo] = key;
    }

    // relayout(); // let's not do this (turned off on 9 Sep early morning)

    var match = {}, vis = {};

    for (key in iVL) match[key] = -1;

    if (isGreedy) {
      populatePseudocode(3);
      match = greedyMatch();
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
      cs["status"] = "Random greedy pairing has been picked.";
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else
      populatePseudocode(0);

    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
    cs["status"] = "For each vertex in the left hand set,<br>look for an augmenting path.";
    cs["lineNo"] = isGreedy ? 4 : 1;
    stateList.push(cs);

    for (var i = 0; i < amountLeftSet; ++i) {
      vertexTraversed = {};
      vertexTraversed[i] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
      cs["status"] = "For vertex {i}:".replace("{i}", i);
      cs["lineNo"] = isGreedy ? 4 : 1;
      stateList.push(cs);
      for (key in iVL) vis[key] = 0;

      LeftToRightEdge = [];
      RightToLeftEdge = [];

      if (match[i] === -1) Aug(i);

      LeftToRightEdge.reverse();
      RightToLeftEdge.reverse();

      for (var x = 0; x < RightToLeftEdge.length; ++x) {
// behavior modified on 4 March 2022, to better show Aug(match[R]) behavior
        edgeTraversed[LeftToRightEdge[x][0]] = true;
        vertexTraversed[LeftToRightEdge[x][1]] = true;
        vertexTraversed2[LeftToRightEdge[x][2]] = true;
        //cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, vertexTraversed2, edgeTraversed2);
        //cs["status"] = "Free edge from {fromEdge} to {toEdge} is added to augmenting path."
        //                .replace("{fromEdge}", iVL[LeftToRightEdge[x][1]]["text"])
        //                .replace("{toEdge}", iVL[LeftToRightEdge[x][2]]["text"]);
        //cs["lineNo"] = isGreedy ? 4 : 2;
        //stateList.push(cs);
        toSet.push(LeftToRightEdge[x]);

        edgeTraversed2[RightToLeftEdge[x][0]] = true;
        vertexTraversed2[RightToLeftEdge[x][1]] = true;
        vertexTraversed[RightToLeftEdge[x][2]] = true;
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, vertexTraversed2, edgeTraversed2);
        cs["status"] = "Free edge from {fromEdge} to {toEdge} is added to augmenting path."
                        .replace("{fromEdge}", iVL[LeftToRightEdge[x][1]]["text"])
                        .replace("{toEdge}", iVL[LeftToRightEdge[x][2]]["text"]) + "<br>" +
                       "Matched edge from {fromEdge} back to {toEdge} is added to augmenting path."
                        .replace("{fromEdge}", iVL[RightToLeftEdge[x][1]]["text"])
                        .replace("{toEdge}", iVL[RightToLeftEdge[x][2]]["text"]);
        cs["lineNo"] = isGreedy ? 4 : 2;
        stateList.push(cs);
        toUnSet.push(RightToLeftEdge[x]);

/*
        // original
        edgeTraversed[LeftToRightEdge[x][0]] = true;
        vertexTraversed[LeftToRightEdge[x][1]] = true;
        vertexTraversed2[LeftToRightEdge[x][2]] = true;
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, vertexTraversed2, edgeTraversed2);
        cs["status"] = "Free edge from {fromEdge} to {toEdge} is added to augmenting path."
                        .replace("{fromEdge}", iVL[LeftToRightEdge[x][1]]["text"])
                        .replace("{toEdge}", iVL[LeftToRightEdge[x][2]]["text"]);
        cs["lineNo"] = isGreedy ? 4 : 2;
        stateList.push(cs);
        toSet.push(LeftToRightEdge[x]);

        edgeTraversed2[RightToLeftEdge[x][0]] = true;
        vertexTraversed2[RightToLeftEdge[x][1]] = true;
        vertexTraversed[RightToLeftEdge[x][2]] = true;
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, vertexTraversed2, edgeTraversed2);
        cs["status"] = "Matched edge from {fromEdge} back to {toEdge} is added to augmenting path."
                        .replace("{fromEdge}", iVL[RightToLeftEdge[x][1]]["text"])
                        .replace("{toEdge}", iVL[RightToLeftEdge[x][2]]["text"]);
        cs["lineNo"] = isGreedy ? 4 : 2;
        stateList.push(cs);
        toUnSet.push(RightToLeftEdge[x]);
*/
      }

      if (LeftToRightEdge.length > RightToLeftEdge.length) {
        var x = RightToLeftEdge.length;
        edgeTraversed[LeftToRightEdge[x][0]] = true;
        vertexTraversed[LeftToRightEdge[x][1]] = true;
        vertexTraversed2[LeftToRightEdge[x][2]] = true;
        toSet.push(LeftToRightEdge[x]);
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, vertexTraversed2, edgeTraversed2);
        cs["status"] = "Free edge from {fromEdge} to {toEdge} (free vertex) is added to augmenting path.<br>We find an augmenting path of length {length} edge(s)."
                        .replace("{fromEdge}", iVL[LeftToRightEdge[x][1]]["text"])
                        .replace("{toEdge}", iVL[LeftToRightEdge[x][2]]["text"])
                        .replace("{length}", toSet.length+toUnSet.length);
        cs["lineNo"] = isGreedy ? 4 : 2;
        stateList.push(cs);
      }

      vertexTraversed = {};
      vertexTraversed2 = {};
      for (var x = 0; x < toUnSet.length; ++x) {
/*
// combined... why doesn't work?
        edgeHighlighted[toSet[x][0]] = true;
        delete edgeTraversed[toSet[x][0]];
        // cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, vertexTraversed2, edgeTraversed2);
        delete edgeHighlighted[RightToLeftEdge[x][0]];
        delete edgeTraversed2[toUnSet[x][0]];
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
        cs["status"] = "Flipped free edge from {fromEdge} to {toEdge} to matched edge."
                        .replace("{fromEdge}", iVL[LeftToRightEdge[x][1]]["text"])
                        .replace("{toEdge}", iVL[LeftToRightEdge[x][2]]["text"]) + "<br>" +
                        "Flipped matched edge from {fromEdge} to {toEdge} to free edge."
                        .replace("{fromEdge}", iVL[LeftToRightEdge[x][1]]["text"])
                        .replace("{toEdge}", iVL[LeftToRightEdge[x][2]]["text"]);
        cs["lineNo"] = isGreedy ? 4 : 3;
*/

        // original version
        edgeHighlighted[toSet[x][0]] = true;
        delete edgeTraversed[toSet[x][0]];
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, vertexTraversed2, edgeTraversed2);
        cs["status"] = "Flipped free edge from {fromEdge} to {toEdge} to matched edge."
                        .replace("{fromEdge}", iVL[LeftToRightEdge[x][1]]["text"])
                        .replace("{toEdge}", iVL[LeftToRightEdge[x][2]]["text"]);
        cs["lineNo"] = isGreedy ? 4 : 3;

        delete edgeHighlighted[RightToLeftEdge[x][0]];
        delete edgeTraversed2[toUnSet[x][0]];
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
        cs["status"] = "Flipped matched edge from {fromEdge} to {toEdge} to free edge."
                        .replace("{fromEdge}", iVL[LeftToRightEdge[x][1]]["text"])
                        .replace("{toEdge}", iVL[LeftToRightEdge[x][2]]["text"]);
        cs["lineNo"] = isGreedy ? 4 : 3;
      }

      if (toSet.length > toUnSet.length) {
        var x = toSet.length-1;
        edgeHighlighted[toSet[x][0]] = true;
        delete edgeTraversed[toSet[x][0]];
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, vertexTraversed2, edgeTraversed2);
        cs["status"] = "Flipped free edge from {fromEdge} to {toEdge} to matched edge."
                        .replace("{fromEdge}", iVL[LeftToRightEdge[x][1]]["text"])
                        .replace("{toEdge}", iVL[LeftToRightEdge[x][2]]["text"]);
        cs["lineNo"] = isGreedy ? 4 : 3;
      }

      if (LeftToRightEdge.length > 0) { // is there an augmenting path of length 1 (or more)?
        toSet = [];
        toUnSet = [];
        edgeTraversed = {};
        edgeTraversed2 = {};
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
        cs["status"] = "All edges in this augmenting path are flipped.<div>Cardinality of matching increases by +1.</div>";
        cs["lineNo"] = isGreedy ? 4 : 3;
        stateList.push(cs);
      }
    }

    vertexTraversed = {};
    vertexTraversed2 = {};

    var numberOfMatchings = 0;
    for (var i = amountLeftSet; i < amountVertex; ++i)
      if (match[i] != -1)
        ++numberOfMatchings;

    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
    cs["status"] = "Done.<br>Found {numberOfMatchings} matchings (the black highlighted edges).".replace("{numberOfMatchings}", numberOfMatchings);
    cs["lineNo"] = isGreedy ? 4 : 4;
    stateList.push(cs);

    gw.startAnimation(stateList, callback);
    return true;

    function uncolourAllEdges(v) {
      for (var j = 0; j < amountEdge; ++j) {
        var edge = iEL[j];
        if (v === edge["vertexA"] ||v === edge["vertexB"]) {
          toUnSet.push(j);
        }
      }
      return;
    }

    function Aug(l) {
      if (vis[l] !== 0) return 0;
      vis[l] = 1;
      for (var j = 0; j < amountEdge; ++j) {
        var edge = iEL[j];
        var e, r;
        if (l === edge["u"]) {
          r = edge["v"];
          if (match[r] === -1 || Aug(match[r])) {
            e = edgeDict[[l, r]];
            LeftToRightEdge.push([e,l,r]);
            if (match[r] !== -1) {
              e = edgeDict[[r, match[r]]];
              RightToLeftEdge.push([e,r,match[r]]);
            }
            match[r] = l;
            return 1;
          }
        }
        else if (l === edge["v"]) {
          r = edge["u"];
          if (match[r] === -1 || Aug(match[r])) {
            e = edgeDict[[l, r]];
            LeftToRightEdge.push([e,l,r]);
            if (match[r] !== -1) {
              e = edgeDict[[r,match[r]]];
              RightToLeftEdge.push([e,r,match[r]]);
            }
            match[r] = l;
            return 1;
          }
        }
      }
      return 0;
    }

    function greedyMatch() {
      for (var x = 0; x < amountLeftSet; ++x) {
        x = +x;
        var unmatchedNeighbour = new Array();
        for (var key in iEL) if(iEL[key]["u"] == x) {
          var y = iEL[key]["v"];
          if (match[y] != -1) continue;
          edgeTraversed[key] = true;  
          unmatchedNeighbour.push(y);
        }
        if (unmatchedNeighbour.length > 0) {
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
          cs["status"] = "Unmatched neighbour of {vertex} are {".replace("{vertex}", iVL[x]["text"]);
          for (var i = 0; i < unmatchedNeighbour.length; i++) {
            cs["status"] += iVL[unmatchedNeighbour[i]]["text"];
            if (i < unmatchedNeighbour.length-1) cs["status"] += ', ';
          }
          cs["status"] += '}';
          cs["lineNo"] = [2];
          stateList.push(cs);

          var randomSelect = unmatchedNeighbour[Math.floor(Math.random() * unmatchedNeighbour.length)];
          for (var key in iEL) if (iEL[key]["u"] == x) {
            var y = iEL[key]["v"];
            if (match[y] != -1) continue;
            if (y != randomSelect)
              delete edgeTraversed[key];
          }
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
          cs["status"] = "Randomly match vertex {vertex} with vertex {randomVertex}."
                          .replace("{randomVertex}", iVL[randomSelect]["text"])
                          .replace("{vertex}", iVL[x]["text"]);
          cs["lineNo"] = [3];
          stateList.push(cs);

          match[x] = randomSelect;
          match[randomSelect] = x;

          for (var key in iEL) if(iEL[key]["u"] == x && iEL[key]["v"] == randomSelect) {
            delete edgeTraversed[key];
            edgeHighlighted[key] = true;
          }
        }
        else {
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
          cs["status"] = "There is no unmatched neighbour of {vertex}".replace("{vertex}", iVL[x]["text"]);
          cs["lineNo"] = [2];
          stateList.push(cs);
        }
      }
      return match;
    }
  }

  this.rookattack = function() {
    var numOfRows = parseInt($('#rows').val());
    var numOfColumns = parseInt($('#columns').val());
    var blocked = new Array(numOfRows);

    for (var i = 0; i < numOfRows; ++i) {
      blocked[i] = new Array(numOfColumns);
      for (var j = 0; j < numOfColumns; ++j)
        blocked[i][j] = false;
    }

    if (numOfRows < 1 || numOfColumns < 1 || numOfRows > 6 || numOfColumns > 6) { // no graph
      $('#modeling-err').html("Invalid size. Row and column size must be between 1 and 6 inclusive.");
      return false;
    }

    this.changeState = function(rowIndex,columnIndex) {
      var temp = '#cell' + rowIndex + columnIndex;
      if (blocked[rowIndex][columnIndex]) {
        $(temp).attr("bgcolor","white");
        blocked[rowIndex][columnIndex] = false;
      }
      else {
        $(temp).attr("bgcolor","black");
        blocked[rowIndex][columnIndex] = true;
      }
    }

    this.createBipartiteGraph = function() {
      iVL = {};
      iEL = {};
      vertexHighlighted = {};
      edgeRed = {};
      stateList = [];
      var cs;
      amountEdge = 0;
      amountVertex = numOfRows + numOfColumns;
      amountLeftSet = numOfRows;

      for (var i = 1; i <= numOfRows; ++i) {
        iVL[i-1] = {
          "x": 300, // previously 225,
          //"y": (250 + (i - (numOfRows + 1) / 2) * (numOfRows == 1 ? 0 : 450 / (numOfRows - 1))),
          "y": (175 + (i - (numOfRows + 1) / 2) * (numOfRows == 1 ? 0 : 300 / (numOfRows - 1))),
          "text": "R"+i
        }
        vertexHighlighted[i-1] = true;
      }

      cs = createState(iVL, iEL,vertexHighlighted);
      cs["status"] = 'Create a vertex for each rows';
      cs["status"] += '<br>and connect source vertex to each vertex with capacity 1</br>';
      cs["lineNo"] = [2];
      stateList.push(cs);
      for (var i = 1; i <= numOfRows; ++i)
        delete vertexHighlighted[i-1];

      for (var i = 1; i <= numOfColumns; ++i) {
        iVL[i+numOfRows-1] = {
          "x": 400, // previously 425,
          //"y": (250 + (i - (numOfColumns + 1) / 2) * (numOfColumns == 1 ? 0 : 450 / (numOfColumns - 1))),
          "y": (175 + (i - (numOfColumns + 1) / 2) * (numOfColumns == 1 ? 0 : 300 / (numOfColumns - 1))),
          "text": "C"+i
        }
        vertexHighlighted[i+numOfRows-1] = true;
      }
      cs = createState(iVL, iEL,vertexHighlighted);
      cs["status"] = 'Create a vertex for each columns';
      cs["status"] += '<br>and connect each vertex to sink vertex with capacity 1</br>';
      cs["lineNo"] = [3];
      stateList.push(cs);
      for (var i = 1; i <= numOfColumns; i++)
        delete vertexHighlighted[i+numOfRows-1];

      for (var i = 0; i < numOfRows; i++) {
        for (var j = 0; j < numOfColumns; j++) {
          var existEdge = 1-blocked[i][j];
          if (existEdge == 1) {
            iEL[amountEdge] = {
              "u": i,
              "v": j+numOfRows,
              "w": 9
            }
            amountEdge++;
            edgeRed[amountEdge-1] = true;
            cs = createState(iVL, iEL,vertexHighlighted, edgeRed);
            cs["status"] = 'Adding edge from R' + (i+1) + ' to C' + (j+1);
            cs["lineNo"] = [4,5];
            stateList.push(cs);
            delete edgeRed[amountEdge-1];
          }
        }
      }

      amountVertex = 0;
      amountEdge = 0;
      for (var i in iVL) amountVertex++;
      for (var i in iEL) amountEdge++;

      cs = createState(iVL, iEL);
      cs["status"] = 'Run any Max Cardinality Bipartite Matching';
      cs["status"] += '<br>to get the value of the maximum rooks that can be placed</br>';
      cs["lineNo"] = [6];
      stateList.push(cs);
      gw.startAnimation(stateList);
      return true;
    }

    this.inputFinished = function() {
      $('.overlays').hide("slow");
      $('#dark-overlay').hide("slow");
      $('#rookattack-board').hide("slow");
      bmw.createBipartiteGraph();
      $('#current-action').show();
      $('#current-action p').html("Modeling()");
      $('#progress-bar').slider( "option", "max", gw.getTotalIteration()-1);
      triggerRightPanels();
      populatePseudocode(2);
      isPlaying = true;
      return true;
    }

    this.cancel = function() {
      $('.overlays').hide("slow");
      $('#dark-overlay').hide("slow");
      $('#rookattack-board').hide("slow");
      $('#progress-bar').slider( "option", "max", gw.getTotalIteration()-1);
      return true;
    }

    this.inputRandomized = function() {
      for (var i = 0; i < numOfRows; i++)
        for (var j = 0; j < numOfColumns; j++)
          if (Math.random() < 0.5) this.changeState(i,j);
    }

    $('#dark-overlay').show("slow");
    var toWrite = '<html>\n';
    toWrite += '<p>Click on any cell to toggle between black/white cell</p>\n';
    toWrite += '<p>Rooks can\'t be placed in black cells</p>\n';
    toWrite += '<table border="1" id="board">'
    for (var j = 0; j < numOfColumns; j++)
      toWrite += '<col width="50">';
    for (var i = 0; i < numOfRows; i++) {
      toWrite += '<tr>';
      for (var j = 0; j < numOfColumns; j++)
        toWrite += '<td height="50" bgcolor="white" id="cell' + i + j + '" onclick=bmw.changeState('+i+','+j+')></td>';
      toWrite += '</tr>';
    }

    toWrite += '</table>\n';
    toWrite += '<div class="modeling-actions">';
    toWrite += '<p onclick=bmw.inputRandomized()>Randomized</p>';
    toWrite += '<p onclick=bmw.inputFinished()>Done</p>';
    toWrite += '<p onclick=bmw.cancel()>Cancel</p>';
    toWrite += '</div>\n'
    toWrite += '</html>\n';
    $('#rookattack-board').html(toWrite);
    $('#rookattack-board').show("slow");
  }

  this.modeling = function(modelingType) {
    iEL = {};
    iVL = {};
    if (modelingType == "rookattack") this.rookattack();
    if (modelingType == "baseball") this.baseball();
    return true;
  }

  this.hopcroftKarpViz = function(callback) {
    var graph = new HopcroftKarp.Graph(amountVertex);
    for (var key in iEL) {
      var u = +iEL[key]['u'];
      var v = +iEL[key]['v'];
      graph.adj[u][v] = graph.adj[v][u] = 1;
    }
    function findEdgeId(u, v) {
      for (var key in iEL) {
        if (+iEL[key]['u'] === u && +iEL[key]['v'] === v) {
          return +key;
        }
        if (+iEL[key]['v'] === u && +iEL[key]['u'] === v) {
          return +key;
        }
      }
      return -1;
    }
    var cs, stateList = [];
    var vizInfo = [];
    var result = HopcroftKarp.HopcroftKarp(graph, amountLeftSet, vizInfo);
    // console.log(JSON.stringify(vizInfo));
    var matchingSize = 0;
    var edgeHighlighted = {};
    for (var i = 0; i < vizInfo.length; ++i) {
      var info = vizInfo[i];
      edgeHighlighted = {};
      for (var j = 0; j < graph.n; j++) {
        if (info.curMatching[j] !== -1) {
          var edgeId = findEdgeId(j, info.curMatching[j]);
          edgeHighlighted[edgeId] = true;
        }
      }
      switch (info.payload.kind) {
        case "BFSDistance":
          var maxDistance = -1;
          for (var j = 0; j < graph.n; j++) {
            iVL[j]["extratext"] = info.payload.distance[j] < 0 ? "INF" : info.payload.distance[j];
            if (info.payload.distance[j] > maxDistance) {
              maxDistance = info.payload.distance[j];
            }
          }
          cs = createState(iVL, iEL, {}, edgeHighlighted);
          if (maxDistance >= 0) {
            cs["status"] = "Partition the graph into layers based on augmenting path.";
            cs["lineNo"] = [1, 2];
            stateList.push(cs);
          } else {
            cs["status"] = "No more augmenting paths.";
            cs["lineNo"] = 1;
            stateList.push(cs);
          }
          break;
        case "NewMatching":
          var edgeTraversed = {};  // !matched && selected
          var edgeTraversed2 = {};  // matched && selected
          for (var j = 0; j < info.payload.newMatchings.length - 1; j++) {
            var edgeId = findEdgeId(info.payload.newMatchings[j][1], info.payload.newMatchings[j + 1][0]);
            if (edgeId === -1) {
              alert("W");
            }
            delete edgeHighlighted[edgeId];
            edgeTraversed2[edgeId] = true;
          }
          ++matchingSize;
          var augmentingPath = [];
          for (var j = 0; j < info.payload.newMatchings.length; ++j) {
            augmentingPath.push(info.payload.newMatchings[j][0]);
            augmentingPath.push(info.payload.newMatchings[j][1]);
            var edgeId = findEdgeId(info.payload.newMatchings[j][0], info.payload.newMatchings[j][1]);
            if (edgeId === -1) {
              alert("W");
            }
            edgeTraversed[edgeId] = true;
          }
          cs = createState(iVL, iEL, {}, edgeHighlighted, {}, edgeTraversed, {}, edgeTraversed2);
          cs['status'] = 'Found new matching from the following augmenting path: ' + augmentingPath.join(', ');
          cs['lineNo'] = [3, 4];
          stateList.push(cs);
          break;
        default:
      }
    }
    for (var i = 0; i < graph.n; i++) {
      iVL[i]['extratext'] = '';
    }
    cs = createState(iVL, iEL, {}, edgeHighlighted);
    cs["status"] = "Found matchings of size " + matchingSize;
    cs["lineNo"] = [];
    stateList.push(cs);
    populatePseudocode(1);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.edmondsBlossomViz = function(performGreedyAssignment, callback) {
    var graph = new EdmondsBlossom.Graph(amountVertex);
    for (var key in iEL) {
      var u = +iEL[key]['u'];
      var v = +iEL[key]['v'];
      graph.adj[u][v] = graph.adj[v][u] = 1;
    }
    var vizInfo = [];
    var result = EdmondsBlossom.EdmondsBlossom(graph, performGreedyAssignment, vizInfo);
    var canRemove = {};
    // never hide vertices with degree 0
    {
      var degree = [];
      for (var i = 0; i < amountVertex; i++) {
        degree[i] = 0;
      }
      for (var key in iEL) {
        degree[+iEL[key]['u']]++;
        degree[+iEL[key]['v']]++;
      }
      for (var i = 0; i < amountVertex; i++) {
        canRemove[i] = degree[i] === 0 ? false : true;
      }
    }
    // console.log(JSON.stringify(vizInfo));
    var lastRoot = -1;
    function createVL(el, blossom = []) {
      var degree = [];
      for (var i = 0; i < amountVertex; i++) {
        degree[i] = 0;
      }
      for (var key in el) {
        degree[+el[key]['u']]++;
        degree[+el[key]['v']]++;
      }
      var newVL = {};
      for (var i = 0; i < amountVertex; i++) {
        newVL[i] = $.extend({}, iVL[i]);
        if (blossom.length != 0 && i == blossom[0]) {
          var blossomR = blossom[0];
          newVL[blossomR]['text'] = i;
          newVL[blossomR]['radius'] = 16;
          for (var blossomL = 0; blossomL < blossomLength; blossomL++) {
            newVL[blossomR]['text'] += '\'';
            newVL[blossomR]['radius'] += 4;
          }
        }
        if (degree[i] === 0 && i !== lastRoot && canRemove[i]) {
          // hide this
          // newVL[i]['x'] = 1000;
          // newVL[i]['y'] = 1000;
          if (blossom.length != 0) {
            var blossomR = blossom[0];
            newVL[i]['x'] = iVL[blossomR]['x'];
            newVL[i]['y'] = iVL[blossomR]['y'];
            newVL[i]['text'] = '';
            newVL[i]['radius'] = 16;
            for (var blossomL = 0; blossomL < blossomLength; blossomL++) {
              newVL[i]['radius'] += 4;
            }
          }
        }
      }
      return newVL;
    }
    function createEL(graph) {
      var newEL = {};
      var edgeCount = 0;
      for (var i = 0; i < graph.n; i++) {
        for (var j = i + 1; j < graph.n; j++) {
          if (graph.adj[i][j]) {
            newEL[edgeCount++] = {'u': i, 'v': j};
          }
        }
      }
      return newEL;
    }
    function findEdgeIndex(el, from, to) {
      for (var key in el) {
        if (el[key]['u'] === from && el[key]['v'] === to) {
          return +key;
        }
        if (el[key]['v'] === from && el[key]['u'] === to) {
          return +key;
        }
      }
      return -1;
    }
    var lastMatching = [];
    var lastVL = iVL;
    var lastEL = iEL;
    var cs, stateList = [];
    var matchingSize = 0;
    var edgeHighlighted = {};  // matched && !selected
    var blossomLength = 0;
    var blossoms = [[]];
    for (var i = 0; i < vizInfo.length; i++) {
      if (lastEL === undefined) {
        alert("ERROR!" + i);
      }
      var info = vizInfo[i];
      var status = "";
      var vertexHighlighted = {};
      edgeHighlighted = {};
      var edgeTraversed = {};  // !matched && selected
      var edgeTraversed2 = {};  // matched && selected
      var vertexHighlighted = {};  // for blossom
      var vertexTraversed = {};
      var newEL = undefined;
      for (var j = 0; j < graph.n; j++) {
        var edgeIndex = findEdgeIndex(lastEL, j, info.curMatching[j]);
        if (edgeIndex === -1) {
          // hidden
          continue;
        }
        edgeHighlighted[edgeIndex] = true;
      }
      switch (info.payload.kind) {
        case "AddGreedyMatching":
          status = "Randomly match " + info.payload.newMatching[0] + " and " + info.payload.newMatching[1];
          cs = createState(iVL, iEL, {}, edgeHighlighted);
          cs["status"] = status;
          cs["lineNo"] = 1;
          stateList.push(cs);
          matchingSize++;
          break;
        case "FoundAugmentingPath":
          var path = info.payload.path;
          var newPath = [];
          for (var p = 0; p < path.length; p++) {
            if (path[p] != blossoms[blossoms.length - 1][0]) {
              newPath.push(path[p]);
            } else {
              var tempString = `${path[p]}`;
              for (var rec = 0; rec < blossoms.length - 1; rec++) {
                tempString += '\'';
              }
              newPath.push(tempString);
            }
          }
          status = "Found an augmenting path " + newPath.join(" -> ");
          for (var j = 1; j < info.payload.path.length; j++) {
            var prev = info.payload.path[j - 1];
            var cur = info.payload.path[j];
            var edgeIndex = findEdgeIndex(lastEL, info.payload.path[j - 1], info.payload.path[j]);
            if (edgeIndex === -1) {
              // error
              alert("what?");
              return false;
            }
            if (info.curMatching[prev] === cur) {
              delete edgeHighlighted[edgeIndex];
              edgeTraversed2[edgeIndex] = true;
            } else {
              edgeTraversed[edgeIndex] = true;
            }
          }
          cs = createState(createVL(lastEL, blossoms[blossoms.length - 1]), lastEL, {}, edgeHighlighted, {}, edgeTraversed, {}, edgeTraversed2);
          cs["status"] = status;
          if (performGreedyAssignment) {
            cs["lineNo"] = [2, 3];
          } else {
            cs["lineNo"] = [1, 2];
          }
          stateList.push(cs);
          break;
        case "NoAugmentingPath":
          status = "No augmenting path from " + info.payload.start + " found";
          cs = createState(createVL(lastEL), lastEL);
          cs["status"] = status;
          cs["lineNo"] = 1;
          stateList.push(cs);
          break;
        case "IncreaseMatching":
          status = "Increased the number of matching by one.";
          // do nothing
          cs = createState(createVL(lastEL), lastEL, {}, edgeHighlighted, {}, edgeTraversed, {}, edgeTraversed2);
          cs["status"] = status;
          if (performGreedyAssignment) {
            cs["lineNo"] = [2, 4, 5]
          } else {
            cs["lineNo"] = [1, 2, 4];
          }
          lastMatching = info.curMatching.slice(0);
          stateList.push(cs);
          matchingSize++;
          break;
        case "ContractBlossom":
          var path = info.payload.blossom.concat([info.payload.blossom[0]]);
          var newPath = [];
          for (var p = 0; p < path.length; p++) {
            if (path[p] != blossoms[blossoms.length - 1][0]) {
              newPath.push(path[p]);
            } else {
              var tempString = `${path[p]}`;
              for (var rec = 0; rec < blossoms.length - 1; rec++) {
                tempString += '\'';
              }
              newPath.push(tempString);
            }
          }
          status = "Found an odd-length cycle " + (newPath.join(" -> "));
          lastRoot = info.payload.root;
          for (var j = 0; j < info.payload.blossom.length; j++) {
            vertexHighlighted[info.payload.blossom[j]] = true;
          }
          for (var j = 0; j < info.payload.pathToBlossom.length; j++) {
            var cur = info.payload.pathToBlossom[j];
            var next = j === info.payload.pathToBlossom.length - 1 ? info.payload.root : info.payload.pathToBlossom[j + 1];
            var edgeIndex = findEdgeIndex(lastEL, cur, next);
            if (edgeIndex === -1) {
              // error
              alert("WHAT? " + JSON.stringify(lastEL) + " " + cur + " " + next);
              return false;
            }
            if (info.curMatching[cur] === next) {
              delete edgeHighlighted[edgeIndex];
              edgeTraversed2[edgeIndex] = true;
            } else {
              edgeTraversed[edgeIndex] = true;
            }
          }
          cs = createState(createVL(lastEL, blossoms[blossoms.length - 1]), lastEL, {}, edgeHighlighted, {}, edgeTraversed, {}, edgeTraversed2);
          cs["status"] = status;
          if (performGreedyAssignment) {
            cs["lineNo"] = [2, 6, 7];
          } else {
            cs["lineNo"] = [1, 5, 6];
          }
          stateList.push(cs);

          //INTERMEDIARY STEPS
          tempBlossom = info.payload.blossom

          var path = info.payload.blossom;
          var newPath = [];
          for (var p = 0; p < path.length; p++) {
            if (path[p] != blossoms[blossoms.length - 1][0]) {
              newPath.push(path[p]);
            } else {
              var tempString = `${path[p]}`;
              for (var rec = 0; rec < blossoms.length - 1; rec++) {
                tempString += '\'';
              }
              newPath.push(tempString);
            }
          }
          
          var blossomMap = {}
          for (var index = 0; index < tempBlossom.length; index++) {
            blossomMap[tempBlossom[index]] = tempBlossom[index]
          }


          tempEL = JSON.parse(JSON.stringify(lastEL))
          for (var e in tempEL) {
            if (tempBlossom.includes(tempEL[e]["u"]) && tempBlossom.includes(tempEL[e]["v"])) {
              delete tempEL[e]
            }
          }
          cs = createState(createVL(lastEL, blossoms[blossoms.length - 1]), tempEL, blossomMap, edgeHighlighted);
          cs["status"] = `Contracting blossom rooted at ${newPath[0]}: [${newPath}]. Deleting edges within the blossom.`
          stateList.push(cs)

          for (var e in tempEL) {
            if (tempBlossom.includes(tempEL[e]["u"]) || tempBlossom.includes(tempEL[e]["v"])) {
              delete tempEL[e]
            }
          }
          cs = createState(createVL(lastEL, blossoms[blossoms.length - 1]), tempEL, blossomMap, edgeHighlighted);
          cs["status"] = `Contracting blossom rooted at ${newPath[0]}: [${newPath}]. Deleting edges that are connected to the blossom.`
          stateList.push(cs)

          newEL = createEL(info.payload.newGraph);
          edgeHighlighted = {};
          for (var j = 0; j < graph.n; j++) {
            var k = info.curMatching[j];
            if (k !== -1) {
              var edgeIndex = findEdgeIndex(newEL, j, k);
              if (edgeIndex !== -1) {
                edgeHighlighted[edgeIndex] = true;
              }
            }
          }
          blossoms.push(info.payload.blossom);
          blossomLength++;
          cs = createState(createVL(newEL, blossoms[blossoms.length - 1]), newEL, {}, edgeHighlighted);
          cs["status"] = `Contracted blossom to ${info.payload.blossom[0]}`;
          for (var rec = 0; rec < blossoms.length - 1; rec++) {
            cs["status"] += '\'';
          }
          if (performGreedyAssignment) {
            cs["lineNo"] = [2, 6, 7];
          } else {
            cs["lineNo"] = [1, 5, 6];
          }
          stateList.push(cs);
          break;
        case "ExpandBlossom":
          var refBlossom = blossoms[blossoms.length - 1];
          var rootBlossom = `${info.payload.root}`;
          if (refBlossom[0] == info.payload.root) {
            for (var rec = 0; rec < blossoms.length - 2; rec++) {
              rootBlossom += '\'';
            }
          }
          status = `Expanded blossom rooted at ${rootBlossom}. `;
          var rootIndexInPath = -1;
          for (var j = 0; j < info.payload.highlightedPath.length; j++) {
            if (info.payload.highlightedPath[j] === info.payload.root) {
              rootIndexInPath = j;
              break;
            }
          }
          newEL = createEL(info.payload.newGraph);
          edgeHighlighted = {};
          for (var j = 0; j < graph.n; j++) {
            var k = info.curMatching[j];
            if (k === -1) {
              continue;
            }
            var edgeIndex = findEdgeIndex(newEL, j, k);
            if (edgeIndex === -1) {
              // ignore
              continue;
            }
            edgeHighlighted[edgeIndex] = true;
          }
          for (var j = 1; j < info.payload.highlightedPath.length; j++) {
            var prev = info.payload.highlightedPath[j - 1];
            var cur = info.payload.highlightedPath[j];
            if (j - 1 === rootIndexInPath) {
              continue;
            }
            var edgeIndex = findEdgeIndex(newEL, prev, cur);
            if (edgeIndex === -1) {
              // error
              alert("NANI?");
              return false;
            }
            if (info.curMatching[prev] === cur) {
              delete edgeHighlighted[edgeIndex];
              edgeTraversed2[edgeIndex] = true;
            } else {
              edgeTraversed[edgeIndex] = true;
            }
          }
          for (var j = 0; j < info.payload.pathTakenInside.length; j++) {
            var prev = j == 0 ? info.payload.root : info.payload.pathTakenInside[j - 1];
            var cur = info.payload.pathTakenInside[j];
            vertexTraversed[cur] = true;
            var edgeIndex = findEdgeIndex(newEL, prev, cur);
            if (edgeIndex === -1) {
              // error
              alert("?? " + prev + " " + cur + " " + JSON.stringify(newEL));
              return false;
            }
            if (info.curMatching[prev] === cur) {
              delete edgeHighlighted[edgeIndex];
              edgeTraversed2[edgeIndex] = true;
            } else {
              edgeTraversed[edgeIndex] = true;
            }
          }
          if (rootIndexInPath !== -1) {
            var prev = info.payload.blossomFrom;
            var cur = info.payload.highlightedPath[rootIndexInPath + 1];
            var edgeIndex = findEdgeIndex(newEL, prev, cur);
            if (info.curMatching[prev] === cur) {
              delete edgeHighlighted[edgeIndex];
              edgeTraversed2[edgeIndex] = true;
            } else {
              edgeTraversed[edgeIndex] = true;
            }
          }
          if (info.payload.pathTakenInside.length > 0) {
            var path = [info.payload.blossomRoot].concat(info.payload.pathTakenInside).concat([info.payload.highlightedPath[rootIndexInPath + 1]]);
            var newPath = [];
            for (var p = 0; p < path.length; p++) {
              if (path[p] != blossoms[blossoms.length - 1][0]) {
                newPath.push(path[p]);
              } else {
                var tempString = `${path[p]}`;
                for (var rec = 0; rec < blossoms.length - 1; rec++) {
                  tempString += '\'';
                }
                newPath.push(tempString);
              }
            }
            status += info.payload.highlightedPath[rootIndexInPath + 1] + " is connected to " + info.payload.blossomFrom + " from the blossom. ";
            status += "Taking the following path " + rootBlossom + newPath.join(" -> ") + " inside the blossom.";
          }

          //INTERMEDIARY STEPS
          tempEL1 = JSON.parse(JSON.stringify(newEL));
          for (var e in tempEL1) {
            if (blossoms[blossoms.length - 1].includes(tempEL1[e]["u"]) || blossoms[blossoms.length - 1].includes(tempEL1[e]["v"])) {
              delete tempEL1[e]
            }
          }

          tempEL2 = JSON.parse(JSON.stringify(newEL));
          for (var e in tempEL2) {
            if (blossoms[blossoms.length - 1].includes(tempEL2[e]["u"]) && blossoms[blossoms.length - 1].includes(tempEL2[e]["v"])) {
              delete tempEL2[e]
            }
          }
          var lastBlossom = blossoms.pop();

          var path = lastBlossom;
          var newPath = [];
          for (var p = 0; p < path.length; p++) {
            if (path[p] != blossoms[blossoms.length - 1][0]) {
              newPath.push(path[p]);
            } else {
              var tempString = `${path[p]}`;
              for (var rec = 0; rec < blossoms.length - 1; rec++) {
                tempString += '\'';
              }
              newPath.push(tempString);
            }
          }

          var blossomMap = {};
          for (var index = 0; index < lastBlossom.length; index++) {
            blossomMap[lastBlossom[index]] = lastBlossom[index];
          }
          blossomLength--;
          cs = createState(createVL(newEL, blossoms[blossoms.length - 1]), tempEL1, blossomMap);
          cs["status"] = `Expanding blossom rooted at ${newPath[0]}: [${newPath}].`;
          stateList.push(cs);

          cs = createState(createVL(newEL, blossoms[blossoms.length - 1]), tempEL2, blossomMap);
          cs["status"] = `Expanding blossom rooted at ${newPath[0]}: [${newPath}]. Drawing edges that are connected to the blossom.`;
          stateList.push(cs);

          cs = createState(createVL(newEL, blossoms[blossoms.length - 1]), newEL, blossomMap);
          cs["status"] = `Expanding blossom rooted at ${newPath[0]}: [${newPath}]. Drawing edges that are connected within the blossom.`;
          stateList.push(cs);

          cs = createState(createVL(newEL, blossoms[blossoms.length - 1]), newEL, {}, edgeHighlighted, vertexTraversed, edgeTraversed, {}, edgeTraversed2);
          cs["status"] = status;
          if (performGreedyAssignment) {
            cs["lineNo"] = [2, 3, 4];
          } else {
            cs["lineNo"] = [1, 2, 3];  // TODO(raisfathin)
          }
          stateList.push(cs);
          break;
        default:
          alert("UNHANDLED " + info.kind);
          return false;
      }
      if (newEL !== undefined) {
        lastEL = newEL;
      }
    }
    var edgeHighlighted = {};
    for (var i = 0; i < graph.n; i++) {
      if (lastMatching[i] !== -1) {
        var edgeId = findEdgeIndex(iEL, i, lastMatching[i]);
        if (edgeId !== -1) {
          edgeHighlighted[edgeId] = true;
        }
      }
    }
    cs = createState(iVL, iEL, {}, edgeHighlighted);
    cs['status'] = 'Found matchings of size ' + matchingSize;
    cs['lineNo'] = [];
    stateList.push(cs);
    populatePseudocode(performGreedyAssignment ? 5 : 4);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.generalRandom = function() {
    // var id = CS4234_TUTORIAL_THREE;
    var id = HOUSE_OF_CARDS; // not really random leh
    iVL = getExampleGraph(id, VL);
    iEL = getExampleGraph(id, EL);
    fixJSON();
    // console.log(JSON.stringify(iVL));
    // console.log(JSON.stringify(iEL));
    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
    return true;
  }

  this.bipartiteRandom = function(n, m, d) { // now this is properly done (10 Sep 2022)
    // note on 11 Sep, these error messages not yet displayed correctly... just use carefully first
    if ((n < 1) || (n > 7)) {
      // Please enter a valid index between [1..{limit}].
//      $('#modeling-err').html('Please enter a valid n between [1..{limit}]'.replace("{limit}", 7));
      $('#modeling-err').html("Please enter a valid n between [1..7]");
console.log('debug this ' + n);
      return false;
    }
    if ((m < 1) || (m > 7)) {
      $('#modeling-err').html("Please enter a valid m between [1..7]");
console.log('debug this ' + m);
      return false;
    }
    if ((d < 0) || (d > 100)) {
      $('#modeling-err').html("Please enter a valid d between [0..100]");
console.log('debug this ' + d);
      return false;
    }

    amountVertex = n+m;
    amountLeftSet = n; // to help with the AugmentingPath algorithm too

    iVL = new Object();
    iEL = new Object();

    for (var i = 0; i < n; ++i) {
      iVL[i] = {
        "x": 300,
        "y": 25 + i * (n == 1 ? 0 : 240/(n-1)),
        "text": i,
      }
    }

    for (var j = 0; j < m; ++j) {
      iVL[n+j] = {
        "x": 400,
        "y": 25 + j * (m == 1 ? 0 : 240/(m-1)),
        "text": (n+j),
      }
    }

    amountEdge = 0;
    for (var i = 0; i < n; ++i)
      for (var j = 0; j < m; ++j)
        if (Math.floor(Math.random()*100) < d) { // this edge (i, n+j) has d% chance to be created, random between [0..99], when d = 100, K_{n,m} created, when d = 0, no edge is created
          iEL[amountEdge] = {
            "u": i,
            "v": n+j,
            "w": 1,
          }
          ++amountEdge;
        }

    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);

    return true;
  }

  this.examples = function(id) {
    // quick patch on 8 Sep 2022 to add a few example graphs without touching graph library yet
    if (id == 'xbar') { // the smallest test case to illustrate Augmenting Path algorithm
      iVL = {
        0: { "x": 300, "y":  25 },
        1: { "x": 300, "y": 265 },
        2: { "x": 400, "y":  25 },
        3: { "x": 400, "y": 265 },
      };
      iEL = {
        0: { "u": 0, "v": 2, "w": 1 },
        1: { "u": 0, "v": 3, "w": 1 },
        2: { "u": 1, "v": 2, "w": 1 },
      };
    }
    else if (id == 'OddLineBipartite') { // an odd-length line graph (to help show Berge's theorem proof)
      iVL = {
        0: { "x": 300, "y":  25 },
        1: { "x": 400, "y":  25 },
        2: { "x": 500, "y":  25 },
        3: { "x": 600, "y":  25 },
        4: { "x": 350, "y":  25 },
        5: { "x": 450, "y":  25 },
        6: { "x": 550, "y":  25 },
        7: { "x": 250, "y":  25 },
      };
      iEL = {
        0: { "u": 0, "v": 4, "w": 1 },
        1: { "u": 4, "v": 1, "w": 1 },
        2: { "u": 1, "v": 5, "w": 1 },
        3: { "u": 5, "v": 2, "w": 1 },
        4: { "u": 2, "v": 6, "w": 1 },
        5: { "u": 6, "v": 3, "w": 1 },
        6: { "u": 7, "v": 0, "w": 1 },
      };
    }
    else if (id == 'EvenLineBipartite') { // an even-length line graph (to help show Berge's theorem proof)
      iVL = {
        0: { "x": 300, "y":  25 },
        1: { "x": 400, "y":  25 },
        2: { "x": 500, "y":  25 },
        3: { "x": 600, "y":  25 },
        4: { "x": 350, "y":  25 },
        5: { "x": 450, "y":  25 },
        6: { "x": 550, "y":  25 },
      };
      iEL = {
        0: { "u": 0, "v": 4, "w": 1 },
        1: { "u": 4, "v": 1, "w": 1 },
        2: { "u": 1, "v": 5, "w": 1 },
        3: { "u": 5, "v": 2, "w": 1 },
        4: { "u": 2, "v": 6, "w": 1 },
        5: { "u": 6, "v": 3, "w": 1 },
      };
    }
    else if (id == 'EvenCycleBipartite') { // can be used for Christofides weighted perfect matching on even number of odd-degree vertices of the MST of the input graph
      iVL = { // suppose there are 8 (even) vertices with odd-degree, must be numbered this way in this visualization...
        0: { "x": 300, "y":  25 },
        1: { "x": 500, "y":  25 },
        2: { "x": 300, "y": 225 },
        3: { "x": 500, "y": 225 },
        4: { "x": 400, "y":  25 },
        5: { "x": 300, "y": 125 },
        6: { "x": 500, "y": 125 },
        7: { "x": 400, "y": 225 },
      };
      iEL = { // we can construct a ring out of these 8
        0: { "u": 0, "v": 4, "w": 1 },
        1: { "u": 4, "v": 1, "w": 1 },
        2: { "u": 1, "v": 6, "w": 1 },
        3: { "u": 6, "v": 3, "w": 1 },
        4: { "u": 3, "v": 7, "w": 1 },
        5: { "u": 7, "v": 2, "w": 1 },
        6: { "u": 2, "v": 5, "w": 1 },
        7: { "u": 5, "v": 0, "w": 1 },
      };
    }
    else if (id == 'TreeBipartite') { // visually a tree, but with special labels for this visualization to work
      iVL = {
        0: { "x": 400, "y": 185 },
        1: { "x": 400, "y":  25 },
        2: { "x": 500, "y": 185 },
        3: { "x": 400, "y": 105 },
        4: { "x": 500, "y": 105 },
        5: { "x": 350, "y": 265 },
        6: { "x": 450, "y": 265 },
        7: { "x": 300, "y": 105 },
      };
      iEL = {
        0: { "u": 0, "v": 3, "w": 1 },
        1: { "u": 0, "v": 5, "w": 1 },
        2: { "u": 0, "v": 6, "w": 1 },
        3: { "u": 1, "v": 3, "w": 1 },
        4: { "u": 1, "v": 4, "w": 1 },
        5: { "u": 1, "v": 7, "w": 1 },
        6: { "u": 2, "v": 4, "w": 1 },
      };
    }
    else if (id == 'GridBipartite') { // visually a grid, but with special labels for this visualization to work
      iVL = {
        0: { "x": 400, "y":  25 },
        1: { "x": 300, "y": 125 },
        2: { "x": 500, "y": 125 },
        3: { "x": 400, "y": 225 },
        4: { "x": 300, "y":  25 },
        5: { "x": 500, "y":  25 },
        6: { "x": 400, "y": 125 },
        7: { "x": 300, "y": 225 },
        8: { "x": 500, "y": 225 },
      };
      iEL = {
        0: { "u": 0, "v": 4, "w": 1 },
        1: { "u": 0, "v": 5, "w": 1 },
        2: { "u": 0, "v": 6, "w": 1 },
        3: { "u": 1, "v": 4, "w": 1 },
        4: { "u": 1, "v": 6, "w": 1 },
        5: { "u": 1, "v": 7, "w": 1 },
        6: { "u": 2, "v": 5, "w": 1 },
        7: { "u": 2, "v": 6, "w": 1 },
        8: { "u": 2, "v": 8, "w": 1 },
        9: { "u": 3, "v": 6, "w": 1 },
        10: { "u": 3, "v": 7, "w": 1 },
        11: { "u": 3, "v": 8, "w": 1 },
      };
    }
    else if (id == 'MatchingWithCapacity') {
      iVL = {
        0: { "x": 300, "y": 265 },
        1: { "x": 300, "y":  25 },
        2: { "x": 300, "y": 125, "text": "2a" },
        3: { "x": 300, "y": 175, "text": "2b" },
        4: { "x": 300, "y": 225, "text": "2c" },
        5: { "x": 400, "y":  25, "text": "3a" },
        6: { "x": 400, "y":  75, "text": "3b" },
        7: { "x": 400, "y": 175, "text": "4a" },
        8: { "x": 400, "y": 225, "text": "4b" },
        9: { "x": 400, "y": 265 },
      };
      iEL = {
        0: { "u": 1, "v": 5, "w": 1 },
        1: { "u": 1, "v": 6, "w": 1 },
        2: { "u": 1, "v": 7, "w": 1 },
        3: { "u": 1, "v": 8, "w": 1 },
        4: { "u": 2, "v": 7, "w": 1 },
        5: { "u": 3, "v": 7, "w": 1 },
        6: { "u": 4, "v": 7, "w": 1 },
        7: { "u": 2, "v": 8, "w": 1 },
        8: { "u": 3, "v": 8, "w": 1 },
        9: { "u": 4, "v": 8, "w": 1 },
      };
    }
    else if (id == 'waif_WA') {
      iVL = {
        0: { "x": 300, "y": 265 },
        1: { "x": 300, "y":  25, "text": "c1" },
        2: { "x": 300, "y":  92, "text": "c2" },
        3: { "x": 300, "y": 159, "text": "c3" },
        4: { "x": 300, "y": 225, "text": "c4" },
        5: { "x": 400, "y":  25, "text": "t1" },
        6: { "x": 400, "y": 125, "text": "t2" },
        7: { "x": 400, "y": 225, "text": "t3" },
        8: { "x": 400, "y": 265 },
      };
      iEL = {
        0: { "u": 1, "v": 5, "w": 1 },
        1: { "u": 1, "v": 6, "w": 1 },
        2: { "u": 2, "v": 5, "w": 1 },
        3: { "u": 2, "v": 6, "w": 1 },
        4: { "u": 3, "v": 7, "w": 1 },
        5: { "u": 4, "v": 7, "w": 1 },
      };
    }
    else if (id == 'greedy_raw') {
      iVL = {
        0: { "x": 300, "y":  25, "text": "5" },
        1: { "x": 300, "y": 145, "text": "4" },
        2: { "x": 300, "y": 265, "text": "8" },
        3: { "x": 400, "y":  25, "text": "7" },
        4: { "x": 400, "y": 145, "text": "8" },
        5: { "x": 400, "y": 265, "text": "4" },
      };
      iEL = {
        0: { "u": 0, "v": 3, "w": 1 },
        1: { "u": 0, "v": 4, "w": 1 },
        2: { "u": 1, "v": 3, "w": 1 },
        3: { "u": 1, "v": 4, "w": 1 },
        4: { "u": 1, "v": 5, "w": 1 },
        5: { "u": 2, "v": 4, "w": 1 },
      };
    }
    else if (id == 'greedy_sorted') {
      iVL = {
        0: { "x": 300, "y":  25, "text": "4" },
        1: { "x": 300, "y": 145, "text": "5" },
        2: { "x": 300, "y": 265, "text": "8" },
        3: { "x": 400, "y":  25, "text": "4" },
        4: { "x": 400, "y": 145, "text": "7" },
        5: { "x": 400, "y": 265, "text": "8" },
      };
      iEL = {
        0: { "u": 0, "v": 3, "w": 1 },
        1: { "u": 0, "v": 4, "w": 1 },
        2: { "u": 0, "v": 5, "w": 1 },
        3: { "u": 1, "v": 4, "w": 1 },
        4: { "u": 1, "v": 5, "w": 1 },
        5: { "u": 2, "v": 5, "w": 1 },
      };
    }
    else if (id == 'Undirected_MF_Killer') { // must be consistent with /maxflow version
      iVL = {
        0: { "x": 300, "y": 265 },
        1: { "x": 300, "y":  25 },
        2: { "x": 300, "y": 105 },
        3: { "x": 300, "y": 185 },
        4: { "x": 400, "y":  25 },
        5: { "x": 400, "y": 105 },
        6: { "x": 400, "y": 185 },
        7: { "x": 400, "y": 265 },
      };
      iEL = {
        0: { "u": 1, "v": 4, "w": 1 },
        1: { "u": 1, "v": 5, "w": 1 },
        2: { "u": 1, "v": 6, "w": 1 },
        3: { "u": 2, "v": 5, "w": 1 },
        4: { "u": 3, "v": 5, "w": 1 },
      };
    }
    else if (id == 'Rand_Greedy_AP_Killer') { // multiple copies of xbars
      iVL = {
        0: { "x": 300, "y":  25 },
        1: { "x": 300, "y":  58 },
        2: { "x": 300, "y":  94 },
        3: { "x": 300, "y": 127 },
        4: { "x": 300, "y": 163 },
        5: { "x": 300, "y": 196 },
        6: { "x": 300, "y": 232 },
        7: { "x": 300, "y": 265 },
        8: { "x": 400, "y":  25 },
        9: { "x": 400, "y":  58 },
        10: { "x": 400, "y":  94 },
        11: { "x": 400, "y": 127 },
        12: { "x": 400, "y": 163 },
        13: { "x": 400, "y": 196 },
        14: { "x": 400, "y": 232 },
        15: { "x": 400, "y": 265 },
      };
      iEL = {
        0: { "u": 0, "v": 8, "w": 1 },
        1: { "u": 0, "v": 9, "w": 1 },
        2: { "u": 1, "v": 8, "w": 1 },
        3: { "u": 2, "v": 10, "w": 1 },
        4: { "u": 2, "v": 11, "w": 1 },
        5: { "u": 3, "v": 10, "w": 1 },
        6: { "u": 4, "v": 12, "w": 1 },
        7: { "u": 4, "v": 13, "w": 1 },
        8: { "u": 5, "v": 12, "w": 1 },
        9: { "u": 6, "v": 14, "w": 1 },
        10: { "u": 6, "v": 15, "w": 1 },
        11: { "u": 7, "v": 14, "w": 1 },
      };
    }
    else if (id == 'HMT_1') { // Hall's Marriage Theorem using Steven's 2006 case
      iVL = {
        0: { "x": 300, "y":  25, "text": "Steven" },
        1: { "x": 300, "y": 145 },
        2: { "x": 300, "y": 265 },
        3: { "x": 400, "y":  25 },
        4: { "x": 400, "y": 145 },
        5: { "x": 400, "y": 265 },
      };
      iEL = {
        0: { "u": 0, "v": 3, "w": 1 }, // Steven-A
        1: { "u": 1, "v": 3, "w": 1 }, // X-A too
        2: { "u": 2, "v": 3, "w": 1 }, // Y-A again
        3: { "u": 2, "v": 4, "w": 1 }, // Y-B
      };
    }
    else if (id == 'HMT_2') { // Hall's Marriage Theorem using Steven's 2007 case (Grace appeared)
      iVL = {
        0: { "x": 300, "y":  25, "text": "Steven" },
        1: { "x": 300, "y": 145 },
        2: { "x": 300, "y": 265 },
        3: { "x": 400, "y":  25 },
        4: { "x": 400, "y": 105 },
        5: { "x": 400, "y": 185 },
        6: { "x": 400, "y": 265, "text": "Grace" },
      };
      iEL = {
        0: { "u": 0, "v": 6, "w": 1 }, // Steven-Grace
        1: { "u": 1, "v": 3, "w": 1 }, // X-A too (actually never happened)
        2: { "u": 2, "v": 3, "w": 1 }, // Y-A again (also never happened)
        3: { "u": 2, "v": 4, "w": 1 }, // Y-B
      };
    }
    else if (id == 'SMT_2') { // Steven's Marriage Theorem 2 = "If there is a vertex x in {U, V} with (out-)degree 0 in G, then x will not be part of any MCBM"
      iVL = {
        0: { "x": 300, "y":  25 },
        1: { "x": 300, "y":  65 },
        2: { "x": 300, "y": 105 },
        3: { "x": 300, "y": 145 },
        4: { "x": 300, "y": 185 },
        5: { "x": 300, "y": 225 },
        6: { "x": 300, "y": 265 },
        7: { "x": 400, "y":  25 },
        8: { "x": 400, "y":  65 },
        9: { "x": 400, "y": 105 },
        10: { "x": 400, "y": 145 },
        11: { "x": 400, "y": 185 },
        12: { "x": 400, "y": 225 },
        13: { "x": 400, "y": 265 },
      };
      iEL = { // there is no edge involving 0 (left) and 10 (right)
        0: { "u": 1, "v": 7, "w": 1 },
        1: { "u": 1, "v": 8, "w": 1 },
        2: { "u": 1, "v": 9, "w": 1 },
        3: { "u": 1, "v": 11, "w": 1 },
        4: { "u": 1, "v": 12, "w": 1 },
        5: { "u": 1, "v": 13, "w": 1 },
        6: { "u": 2, "v": 7, "w": 1 },
        7: { "u": 2, "v": 8, "w": 1 },
        8: { "u": 2, "v": 9, "w": 1 },
        9: { "u": 2, "v": 11, "w": 1 },
        10: { "u": 2, "v": 12, "w": 1 },
        11: { "u": 2, "v": 13, "w": 1 },
        12: { "u": 3, "v": 7, "w": 1 },
        13: { "u": 3, "v": 8, "w": 1 },
        14: { "u": 3, "v": 9, "w": 1 },
        15: { "u": 3, "v": 11, "w": 1 },
        16: { "u": 3, "v": 12, "w": 1 },
        17: { "u": 3, "v": 13, "w": 1 },
        18: { "u": 4, "v": 7, "w": 1 },
        19: { "u": 4, "v": 8, "w": 1 },
        20: { "u": 4, "v": 9, "w": 1 },
        21: { "u": 4, "v": 11, "w": 1 },
        22: { "u": 4, "v": 12, "w": 1 },
        23: { "u": 4, "v": 13, "w": 1 },
        24: { "u": 5, "v": 7, "w": 1 },
        25: { "u": 5, "v": 8, "w": 1 },
        26: { "u": 5, "v": 9, "w": 1 },
        27: { "u": 5, "v": 11, "w": 1 },
        28: { "u": 5, "v": 12, "w": 1 },
        29: { "u": 5, "v": 13, "w": 1 },
        30: { "u": 6, "v": 7, "w": 1 },
        31: { "u": 6, "v": 8, "w": 1 },
        32: { "u": 6, "v": 9, "w": 1 },
        33: { "u": 6, "v": 11, "w": 1 },
        34: { "u": 6, "v": 12, "w": 1 },
        35: { "u": 6, "v": 13, "w": 1 },
      };
    }
    else if (id == 'SMT_4') { // Steven's Marriage Theorem 4 (2022) = "If E contains |E| disjoint edges, then |MCBM| = |E|. Moreover, MCBM is also a perfect matching"
      iVL = { // 14 vertices
        0: { "x": 300, "y":  25 },
        1: { "x": 300, "y":  65 },
        2: { "x": 300, "y": 105 },
        3: { "x": 300, "y": 145 },
        4: { "x": 300, "y": 185 },
        5: { "x": 300, "y": 225 },
        6: { "x": 300, "y": 265 },
        7: { "x": 400, "y":  25 },
        8: { "x": 400, "y":  65 },
        9: { "x": 400, "y": 105 },
        10: { "x": 400, "y": 145 },
        11: { "x": 400, "y": 185 },
        12: { "x": 400, "y": 225 },
        13: { "x": 400, "y": 265 },
      };
      iEL = { // 7 disjoint edges, so |MCBM| = |E| = 7
        0: { "u": 0, "v": 8, "w": 1 },
        1: { "u": 1, "v": 7, "w": 1 },
        2: { "u": 2, "v": 12, "w": 1 },
        3: { "u": 3, "v": 9, "w": 1 },
        4: { "u": 4, "v": 13, "w": 1 },
        5: { "u": 5, "v": 11, "w": 1 },
        6: { "u": 6, "v": 10, "w": 1 },
      };
    }
    else {
      iVL = getExampleGraph(id, VL);
      iEL = getExampleGraph(id, EL);
    }
    amountVertex = 0;
    amountEdge = 0;
    for (var key in iVL) ++amountVertex;
    for (var key in iEL) ++amountEdge;
    for (var key in iVL)
      if (iVL[key]['text'] == null) // add this special check on 10 Sep so that some label (Steven/Grace) can be custom...
        iVL[key]['text'] = key;

    //amountLeftSet = templateToUse[4]; // FIX THIS... I don't have this value yet
    for (var i = 0; i < amountVertex; ++i) {
      var validAmountLeftSet = true;
      for (var key in iEL) {
        var u = +iEL[key]['u'];
        var v = +iEL[key]['v'];
        if ((u <= i) == (v <= i)) {
          validAmountLeftSet = false;
        }
      }
      if (validAmountLeftSet) {
        amountLeftSet = i+1;
        break;
      }
    }
    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
    return true;
  }
}

// function createState(iVLObject, iELObject, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, vertexTraversed2, edgeTraversed2){
//   if (vertexHighlighted == null) vertexHighlighted = {};
//   if (edgeHighlighted == null) edgeHighlighted = {};
//   if (vertexTraversed == null) vertexTraversed = {};
//   if (edgeTraversed == null) edgeTraversed = {};
//   if (vertexTraversed2 == null) vertexTraversed2 = {};
//   if (edgeTraversed2 == null) edgeTraversed2 = {};

//   var key;
//   var state = {
//     "vl":{},
//     "el":{}
//   };

//   for (key in iVLObject) {
//     state["vl"][key] = {};
//     state["vl"][key]["cx"] = iVLObject[key]["x"];
//     state["vl"][key]["cy"] = iVLObject[key]["y"];
//     if (iVLObject[key]["text"] == null)
//       state["vl"][key]["text"] = +key;
//     else
//       state["vl"][key]["text"] = iVLObject[key]["text"];
//     if (iVLObject[key]["state"] == OBJ_HIDDEN)
//       state["vl"][key]["state"] = OBJ_HIDDEN;
//     else
//       state["vl"][key]["state"] = VERTEX_DEFAULT;
//     state["vl"][key]["extratext"] = iVLObject[key]["extratext"];
//   }

//   for (key in iELObject) {
//     state["el"][key] = {};
//     state["el"][key]["vertexA"] = iELObject[key]["u"];
//     state["el"][key]["vertexB"] = iELObject[key]["v"];
//     state["el"][key]["type"] = EDGE_TYPE_UDE;
//     state["el"][key]["weight"] = iELObject[key]["w"];
//     if (iELObject[key]["state"] == OBJ_HIDDEN)
//       state["el"][key]["state"] = OBJ_HIDDEN;
//     else
//       state["el"][key]["state"] = EDGE_GREY;
//     state["el"][key]["displayWeight"] = false;
//     state["el"][key]["animateHighlighted"] = false;
//   }

//   for (key in vertexHighlighted)
//     state["vl"][key]["state"] = VERTEX_HIGHLIGHTED;

//   for (key in edgeHighlighted)
//     state["el"][key]["state"] = EDGE_DEFAULT;

//   for (key in vertexTraversed)
//     state["vl"][key]["state"] = VERTEX_TRAVERSED;

//   for (key in edgeTraversed)
//     state["el"][key]["state"] = EDGE_TRAVERSED;

//   for (key in vertexTraversed2)
//     state["vl"][key]["state"] = VERTEX_BLUE_OUTLINE;

//   for (key in edgeTraversed2)
//     state["el"][key]["state"] = EDGE_BLUE;

//   return state;
// }

function createState(iVLObject, iELObject, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, vertexTraversed2, edgeTraversed2){
  if (vertexHighlighted == null) vertexHighlighted = {};
  if (edgeHighlighted == null) edgeHighlighted = {};
  if (vertexTraversed == null) vertexTraversed = {};
  if (edgeTraversed == null) edgeTraversed = {};
  if (vertexTraversed2 == null) vertexTraversed2 = {};
  if (edgeTraversed2 == null) edgeTraversed2 = {};

  var key;
  var state = {
    "vl":{},
    "el":{}
  };

  for (key in iVLObject) {
    state["vl"][key] = {};
    state["vl"][key]["cx"] = iVLObject[key]["x"];
    state["vl"][key]["cy"] = iVLObject[key]["y"];
    if (iVLObject[key]["text"] == null)
      state["vl"][key]["text"] = +key;
    else
      state["vl"][key]["text"] = iVLObject[key]["text"];
    if (iVLObject[key]["state"] == OBJ_HIDDEN)
      state["vl"][key]["state"] = OBJ_HIDDEN;
    else
      state["vl"][key]["state"] = VERTEX_DEFAULT;
    if (iVLObject[key]["radius"] != null) {
      state["vl"][key]['inner-r'] = iVLObject[key]["radius"] - 2;
      state["vl"][key]['outer-r'] = iVLObject[key]["radius"];
      state["vl"][key]['inner-w'] = iVLObject[key]["radius"] * 2 - 2;
      state["vl"][key]['outer-w'] = iVLObject[key]["radius"] * 2;
      state["vl"][key]['inner-h'] = iVLObject[key]["radius"] * 2 - 2;
      state["vl"][key]['outer-h'] = iVLObject[key]["radius"] * 2;
    }
    state["vl"][key]["extratext"] = iVLObject[key]["extratext"];
  }

  for (i in iELObject) {
    small = Math.min(iELObject[i]["u"], iELObject[i]["v"])
    big = Math.max(iELObject[i]["u"], iELObject[i]["v"])
    key = `${small}_${big}`
    state["el"][key] = {};
    state["el"][key]["vertexA"] = small;
    state["el"][key]["vertexB"] = big;
    state["el"][key]["type"] = EDGE_TYPE_UDE;
    state["el"][key]["weight"] = iELObject[i]["w"];
    if (iELObject[i]["state"] == OBJ_HIDDEN)
      state["el"][key]["state"] = OBJ_HIDDEN;
    else
      state["el"][key]["state"] = EDGE_GREY;
    state["el"][key]["displayWeight"] = false;
    state["el"][key]["animateHighlighted"] = false;
  }

  for (key in vertexHighlighted)
    state["vl"][key]["state"] = VERTEX_HIGHLIGHTED;

  for (i in edgeHighlighted) {
    small = Math.min(iELObject[i]["u"], iELObject[i]["v"])
    big = Math.max(iELObject[i]["u"], iELObject[i]["v"])
    key = `${small}_${big}`
    state["el"][key]["state"] = EDGE_DEFAULT;
  }

  for (key in vertexTraversed)
    state["vl"][key]["state"] = VERTEX_TRAVERSED;

  for (i in edgeTraversed) {
    small = Math.min(iELObject[i]["u"], iELObject[i]["v"])
    big = Math.max(iELObject[i]["u"], iELObject[i]["v"])
    key = `${small}_${big}`
    state["el"][key]["state"] = EDGE_TRAVERSED;
  }

  for (key in vertexTraversed2)
    state["vl"][key]["state"] = VERTEX_BLUE_OUTLINE;

  for (i in edgeTraversed2) {
    small = Math.min(iELObject[i]["u"], iELObject[i]["v"])
    big = Math.max(iELObject[i]["u"], iELObject[i]["v"])
    key = `${small}_${big}`
    state["el"][key]["state"] = EDGE_BLUE;
  }

  return state;
}

function populatePseudocode(act) {
  switch (act) {
    case 0: // Augmenting Path
      $('#code1').html('for each vertex in the left set');
      $('#code2').html('&nbsp&nbspif &exist; an augmenting path of 1 (or more) edge(s)');
      $('#code3').html('&nbsp&nbsp&nbsp;&nbsp;flip edge status along augmenting path');
      $('#code4').html('return');
      $('#code5').html('');
      $('#code6').html('');
      $('#code7').html('');
      break;
    case 1: // Hopcroft-Karp
      $('#code1').html('while &exist; some augmenting path(s)');
      $('#code2').html('&nbsp;run BFS to partition the graph into layers');
      $('#code3').html('&nbsp;while &exist; an augmenting path in this layer');
      $('#code4').html('&nbsp;&nbsp;flip edge status along augmenting path');
      $('#code5').html('');
      $('#code6').html('');
      $('#code7').html('');
      break;
    case 2: // Rook Attack modeling
      $('#code1').html('create source and sink vertex');
      $('#code2').html('create one vertex Ri for each row i');
      $('#code3').html('create one vertex Cj for each column j');
      $('#code4').html('for each rook-placable cell (i, j)');
      $('#code5').html('&nbsp;&nbsp;add an edge from Ri to Cj');
      $('#code6').html('run any MCBM algorithm');
      $('#code7').html('');
      break;
    case 3: // Augmenting Path with randomized greedy preprocessing
      $('#code1').html('for each vertex v in the left set');
      $('#code2').html('&nbsp&nbsp(randomly) choose unmatched neighbour x');
      $('#code3').html('&nbsp&nbspmatch v (left set) with x (right set)');
      $('#code4').html('Run the standard Augmenting Path Algorithm');
      $('#code5').html('');
      $('#code6').html('');
      $('#code7').html('');
      break;
    case 4:
      $('#code1').html('while &exist; an unprocessed vertex');
      $('#code2').html('&nbsp;if &exist; an augmenting path');
      $('#code3').html('&nbsp;&nbsp;expand the blossom');
      $('#code4').html('&nbsp;&nbsp;flip the status of edges in the augmenting path');
      $('#code5').html('&nbsp;else if there is an odd-length cycle');
      $('#code6').html('&nbsp;&nbsp;contract the odd cycle and update the graph');
      $('#code7').html('');
      break;
    case 5:
      $('#code1').html('go through each edge and pair them randomly');
      $('#code2').html('while &exist; an unprocessed vertex');
      $('#code3').html('&nbsp;if &exist; an augmenting path');
      $('#code4').html('&nbsp;&nbsp;expand the blossom');
      $('#code5').html('&nbsp;&nbsp;flip the status of edges in the augmenting path');
      $('#code6').html('&nbsp;else if there is an odd-length cycle');
      $('#code7').html('&nbsp;&nbsp;contract the odd cycle and update the graph');
      break;
  }
}



// matching_action.js
var actionsWidth = 150;
var statusCodetraceWidth = 410;


// local
var bmw, gw;
var BIPARTITE_MATCHING = 1 << 0;
var WEIGHTED_GRAPH = 1 << 1;
var selectedState = -1;

$(function() {
  write(true, true);
  $('#play').hide();
  $('#drawgraph-form').append('<br><input type="checkbox" id="relayout" name="submit" value="submit" checked="checked">Relayout');
  $('#relayout').removeAttr('checked');
  bmw = new MCBM();
  gw = bmw.getGraphWidget();
  gw.setAnimationDuration(700 / speedVal);
  // randomize first
  $('#bipartite-n').val(1 + Math.floor(Math.random()*7)); // [1..7]
  $('#bipartite-m').val(1 + Math.floor(Math.random()*7)); // [1..7]
  $('#bipartite-d').val(Math.floor(Math.random()*101)); // [0..100]
  bipartiteRandom();

  $("#menu-unweighted-bipartite").on("click", function() {
    selectedState = BIPARTITE_MATCHING;
    $(".unweighted-general").hide();
    $(".unweighted-bipartite").show();
    $("#menu-unweighted-bipartite").removeClass("selected-viz");
    $("#menu-unweighted-general").removeClass("selected-viz");
    $("#menu-unweighted-general").html("U/G");
    $("#menu-unweighted-bipartite").addClass("selected-viz");
    $("#menu-unweighted-bipartite").html("(Unweighted Bipartite) Graph Matching");

    $("#example-houseofcards").hide();
    $("#example-fmod").hide();
    //$("#example4").hide();

    $("#augpathnormal").show();
    $("#augpathgreedy").show();
    $("#hopcraftkarp").show();

    $("#edmondsblossom").hide();
    $("#edmondsblossomplusgreedy").hide();

    bipartiteRandom(); // always different every time
  });

  $("#menu-unweighted-general").on("click", function() {
    selectedState = 0;
    $(".unweighted-bipartite").hide();
    $(".unweighted-general").show();
    $("#menu-unweighted-bipartite").removeClass("selected-viz");
    $("#menu-unweighted-general").removeClass("selected-viz");
    $("#menu-unweighted-bipartite").html("U/B");
    $("#menu-unweighted-general").addClass("selected-viz");
    $("#menu-unweighted-general").html("(Unweighted General) Graph Matching");

    $("#example-houseofcards").show();
    $("#example-fmod").show();
    //$("#example4").show();

    $("#augpathnormal").hide();
    $("#augpathgreedy").hide();
    $("#hopcraftkarp").hide();

    $("#edmondsblossom").show();
    $("#edmondsblossomplusgreedy").show();

    bmw.generalRandom();
  });

  $("#menu-unweighted-bipartite").click();

  var graphJSON = getQueryVariable("create");
  if (graphJSON.length > 0) {
    importjson(graphJSON);
    window.history.pushState("object or string", "Title", window.location.href.split('?')[0]);
  }

  // userGraph = bmw.getGraph(); // save the current graph
});

function closeAugPath() {
  closeAction('augpath');
}

function importjson(text) {
  if(isPlaying) { stop(); }
  if (mode=="exploration") {
    bmw.importjson(text);
    isPlaying = false;
  }
}

function drawGraph() {
  if(isPlaying) { stop(); }
  if (mode=="exploration") {
    const [newiVL, newiEL] = representationConvert(bmw.getiVL(), bmw.getiEL());
    currentGraphVisu = new GraphVisu(true, true, true, newiVL, newiEL, true);
    $('#dark-overlay').fadeIn(function(){
      $('#drawgraph').fadeIn();
    });
    bmw.startLoop();
    isPlaying = false;
  }
}

function drawDone() {
  if (!bmw.draw()) return false;
  bmw.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

function drawCancel() {
  bmw.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

function createRandom() {
  return; // this function is temporarily disabled
  if(isPlaying) { stop(); }
  if (mode=="exploration") {
    var n = Math.floor(5 + Math.random()*6);
    $.ajax({
      url: PHP_DOMAIN + "/php/Graph.php?mode=" + MODE_GET_RANDOM_SUBMITTED_GRAPH + "&directed=" + 0 + "&connected=" + 1 + "&bipartite=" + 1 + "&separatable=" + 1
    }).done(function(data){
      data = JSON.parse(data);
      var graph = extractQnGraph(data.graph);
      randomGraphID = data.graphID;
      bmw.initRandom(graph);
      $('#rate-sample-graph').show();
    })
    setTimeout(function(){
      $('#progress-bar').slider( "option", "max", 0);
      isPlaying = false;
    },500);
  }
}

function example(id) {
  if (isPlaying) stop();
  setTimeout(function() {
    if (bmw.examples(id)) {
      $('#progress-bar').slider("option", "max", 0);
      isPlaying = false;
    }
  }, 500);
}

function augmentingPath(callback) {
  if (isPlaying) stop();
  commonAction(bmw.augmentingPath(false, callback), "Augmenting Path Algorithm");
}

function greedyAug(callback) {
  if (isPlaying) stop();
  commonAction(bmw.augmentingPath(true, callback), "Augmenting Path Algorithm Plus");
}

function hopcroftKarp(callback) {
  if (isPlaying) stop();
  commonAction(bmw.hopcroftKarpViz(callback), "Hopcroft-Karp Algorithm");
}

// function modelingOpen(modelingType) {
//   $(".modeling").css("bottom","117px");
//   if (modelingType != "rookattack") $('#rookattack-input').fadeOut('fast');
//   if (modelingType != "baseball")   $('#baseball-input').fadeOut('fast');
//   if (modelingType != "bipartite")  $('#bipartite-input').fadeOut('fast');
//   $('#' + modelingType + '-input').fadeIn('fast');
// }

function modeling(modelingType) {
  if(isPlaying) { stop(); }
  setTimeout( function() {
    if (mode != "exploration") return;
    if (!bmw.modeling(modelingType)) return;
  }, 500);
}

function bipartiteRandom() {
  var n = parseInt($('#bipartite-n').val());
  var m = parseInt($('#bipartite-m').val());
  var d = parseInt($('#bipartite-d').val());

  bmw.bipartiteRandom(n, m, d);
  closeAction('modeling');

  setTimeout(function() {
    $('#bipartite-n').val(1 + Math.floor(Math.random()*7)); // [1..7]
    $('#bipartite-m').val(1 + Math.floor(Math.random()*7)); // [1..7]
    $('#bipartite-d').val(Math.floor(Math.random()*101)); // [0..100]
  }, 500);
}

/*
function edmondsBlossomViz(performGreedyAssignment) {
  if (isPlaying) {stop();}
  setTimeout( function() {
    if ((mode=="exploration")&&bmw.edmondsBlossomViz(performGreedyAssignment)) {
      $('#current-action').show();
      $('#current-action p').html("Greedy + Augmenting Path MCBM");
      $('#progress-bar').slider("option","max",gw.getTotalIteration()-1);
      triggerRightPanels();
      isPlaying = true;
    }
  }, 500);
}
*/

function edmondsBlossomViz(performGreedyAssignment, callback) {
  if (isPlaying) stop();
  commonAction(bmw.edmondsBlossomViz(performGreedyAssignment, callback), "Edmonds' Matching Algorithm" + (performGreedyAssignment ? " Plus" : ""));
}

// Implement these functions in each visualisation
var userGraph = {
  'vl': {},
  'el': {},
};

// This function will be called before entering E-Lecture Mode
function ENTER_LECTURE_MODE() {
  //if (bmw) userGraph = bmw.getGraph();
}

// This function will be called before returning to Explore Mode
function ENTER_EXPLORE_MODE() {
  //loadGraph(userGraph);
}

// Lecture action functions
function CUSTOM_ACTION(action, data, mode) {
  if (action == 'augmentingpath') {
    hideSlide(function() {
      augmentingPath(showSlide);
    });
  }
  else if (action == 'hopcroftkarp') {
    hideSlide(function() {
      hopcroftKarp(showSlide);
    });
  }
  else if (action == 'greedyaug') {
    hideSlide(function() {
      greedyAug(showSlide);
    });
  }
  else if (action == 'edmonds') {
    hideSlide(function() {
      edmondsBlossomViz(false, showSlide);
    });
  }
}
</script>
</body>

<!-- Mirrored from visualgo.net/en/matching?slide=4-9 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:18:02 GMT -->
</html>
