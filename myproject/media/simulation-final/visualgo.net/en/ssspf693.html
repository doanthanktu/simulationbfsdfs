<!DOCTYPE html>
<html lang="en">

<!-- Mirrored from visualgo.net/en/sssp?slide=7-5 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:17:59 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="description" content="In the Single-Source Shortest Paths (SSSP) problem, we aim to find the shortest paths weights (and the actual paths) from a particular single-source vertex to all other vertices in a directed weighted graph (if such paths exist).The SSSP problem is a(nother) very well-known Computer Science (CS) problem that every CS students worldwide need to be aware of and hopefully master.The SSSP problem has several different efficient (polynomial) algorithms (e.g., Bellman-Ford, BFS, DFS, Dijkstra — 2 versions, and/or Dynamic Programming) that can be used depending on the nature of the input directed weighted graph, i.e. weighted/unweighted, with/without (negative weight) cycle, or structurally special (a tree/a DAG).">
<meta name="keywords" content="Single-Source Shortest Paths SSSP BFS Dijkstra Bellman-Ford&amp;nbsp;SPFA Tree DFS DAG Topological Sort Toposort">
 
<meta name="csrf-token" content="dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../img/png/sssp.png">
<title>Single-Source Shortest Paths (Dijkstra/+ve Weighted, BFS/Unweighted, Bellman-Ford, DFS/Tree, Dynamic Programming/DAG) - VisuAlgo</title>
<link rel="icon" href="../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../img/favicon.png">
<link rel="stylesheet" href="../css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../css/common-1.0.2.css">
<link rel="stylesheet" href="../css/viz-1.0.4.css">
<link rel="stylesheet" href="../css/visual.css">
<link rel="stylesheet" href="../css/drawgraph-1.0.2.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
        z-index: 8001;
      }
      #e-lecture-timeline {
        top: 80px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }
      .e-lecture-timeline-slide {
        height: 5px;
        width: 2px;
        background: black;
        float: left;
      }
      .e-lecture-timeline-checkpoint {
        height: 20px;
        width: 3px;
        margin-left: 2px;
        margin-top: -7.5px;
        background: black;
        float: left;
      }

      #e-lecture-f1map {
        top: 102.5px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }

      .e-lecture-f1map-sector {
        flex-grow: 1;
        background: black;
        float: left;
        height: 5px;
        margin-right: 1px;
      }

      .e-lecture-f1map-sector:last-child {
        margin-right: 0px;
      }

      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }

      .electure-read-status {
        position: absolute;
        bottom: 4px;
        right: 4px;
        font-size: 14px;
        cursor: default;
        color: #00FF7F;
        display: none;
      }

      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
      .electure-print, .electure-end {
        position: fixed;
        top: 45px;
        height: 20px;
        width: 17px;
        right: 80px;
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
        text-align: center;
      }
      .electure-end {
        right: 45px; /* beside the X */
      }

      #change-lang-popup {
        position: fixed;
        background: green;
        left: 40px;
        top: 50px;
        width: 250px;
        height: 125px;
        border: transparent;
        border-radius: 10px;
        padding: 10px 20px;
        z-index: 9000;
      }

      #change-lang-popup p {
        font-size: medium;
        color: white;
        line-height: 2;
        font-family: "PT Sans", sans-serif;
      }

      #change-lang-popup-btn {
        text-decoration: underline;
        margin-left: 50px;
      }

      #change-lang-popup-btn:hover {
        cursor: pointer;
      }

      #rotateDeviceOverlay {
        z-index: 10000;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        background-color: white;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        overflow: hidden;
      }

      #mobile-playback-overlay {
        z-index: 9600;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        gap: 100px;
        background-color: black;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        opacity: 0.3;
        overflow: hidden;
      }
      .mobile-playback-item {
        min-width: 2.5%;
        max-width: 35px;
      }
      .mobile-playback-item img {
        width: 100%
      }
      .mobile-playback-label {
        opacity: 0;
        color: white;
        font-size: 25px;
        font-weight: bold;
        min-width: 1.5%;
        max-width: 25px;
        transition: opacity 0.25s ease-out;
        -webkit-backface-visibility: hidden;
      }
      #mobile-playback-rewind-label {
        margin-right: -70px;
      }
      #mobile-playback-forward-label {
        margin-left: -70px;
      }
      #viz-speed-value {
          font-size: 15px;
          width: 10%;
      }

      #scale {
        position: fixed;
        left: 5px;
      }
    </style>
<style>
/* copied here from common.css (perhaps need to use version numbering) until caches worldwide settles */
#reload-mobile-popup, #message-popup { /* #gdpr-popup, */
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  min-width: 320px;
  bottom: 62px;
  height: 300px;
  background-color: #0275d8;
  border-radius: 15px;
  padding: 30px 40px;
  z-index: 9500;
}
#reload-mobile-popup {
  background-color: green;
  height: 200px;
}
#message-popup {
  z-index: 9000;
  width: 40%;
  height: 130px;
  background-color: #d9534f;
}

#reload-mobile-popup p, #message-popup p { /* #gdpr-popup p, */
  font-size: large;
  color: white;
  line-height: 2;
  font-family: "PT Sans", sans-serif;
}

#reload-mobile-popup .inner-button, #message-popup .inner-button { /* #gdpr-popup .gdpr-button, */
  border: white solid 2px;
  border-radius: 4px;
  font-weight: bold;
  font-size: x-large;
  padding: 2px 8px;
  color: white;
  width: 90px;
  text-align: center;
  position: absolute;
  letter-spacing: 1px;
  text-decoration: none;
  cursor: pointer;
}

#gdpr-accept, #reload-mobile-button, #dismiss-message-btn {
  bottom: 30px;
  right: 40px;
}

#gdpr-reject, #cancel-reload-mobile-button {
  bottom: 30px;
  right: 170px;
}
    </style>
</head>
<body>
<div id="body-container" style="display: flex; flex-direction: column; min-height: 100vh;">
<style>
  #topbar {
    background-color: rgb(0,0,0);
    font-family: "PT Sans", sans-serif;
    font-size: 13px;
    height: 40px;

    padding-left: 40px;
    padding-right: 40px;

    display: flex;
    flex-wrap: wrap;
    align-items: center;
    position: relative;
    justify-content: flex-start;
  }

  #topbar a:hover {
    text-decoration: none;
  }

  #account-dropdown-btn {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;
    height: 24px;
    line-height: 1.5;
  }

  #account-dropdown-btn:hover {
    color: #0a58ca!important;
    border-color: #198754;
    text-decoration: none;
  }

  #login-button {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;

    height: 24px;
    line-height: 1.5;
  }

  #login-button a:hover {
    color: #0a58ca!important;
    text-decoration: none;
  }

  #account-dropdown-menu {
    display: none;
    position: absolute;
    background-color: white;
    z-index: 1000;
    min-width: 10rem;
    padding: 0.5rem 0;
    margin: 0;
    font-size: 1rem;
    color: rgb(0,0,0);
    text-align: left;
    list-style: none;
    background-clip: padding-box;
    border: 1px solid rgba(0,0,0,.15);
    border-radius: 0.25rem;
    top: 45px;
    right: 40px;
    line-height: 1.5;
  }

  .account-dropdown-item {
    display: block;
    width: auto;
    padding: 0.25rem 1rem;
    clear: both;
    font-weight: 400;
    color: rgb(0,0,0);
    text-align: inherit;
    text-decoration: none;
    white-space: nowrap;
    background-color: transparent;
    border: 0;
    height: 24px;
    font-family: SilkscreenNormal, sans-serif;
  }

  .account-dropdown-item:hover {
    background-color: #e9ecef;
    color: #0a58ca;
    text-decoration: none;
  }
</style>
<nav id="topbar">
<span style="margin-right: 0.25rem">
<a href="https://www.comp.nus.edu.sg/~stevenha" style="text-decoration: none; color: white">
<span class="colour" style="border: 1px solid; border-color: #198754!important; border-radius: .25rem!important">7</span>
</a>
<a href="https://visualgo.net/" style="font-family: SilkscreenNormal,sans-serif; font-size: 20px; margin-left: 4px;">
<span style="color: white">Visu</span><span class="colour">Algo</span><span style="font-size: 40%; color: white">.net</span>
</a>
<span style="color: white">/</span>
<select id="Language" class="select2-dropdown" onchange="changeURL()">
<option value="en" selected>en</option>
<option value="zh">zh</option>
<option value="id">id</option>
</select>
<span style="color: white; font-family: monospace">/sssp</span>
</span>
<span style="max-height: 30px">
<span id="title">
<a id="title-sssp" class="selected-viz">Single-Source Shortest Paths</a>
</span>
</span>
<span style="max-height: 30px; background-color:rgb(0,0,0)!important; color: white; margin-left: auto">
<div id="mode-menu">
<div id="mode-button" style="background-color: rgb(0,0,0)!important;" title="exploration">Exploration Mode &#9663;</div>
<div id="other-modes" style="background-color: rgb(0,0,0)!important; padding-top: 11px">
<a title="e-Lecture" style="background-color: rgb(0,0,0)!important;">e-Lecture Mode</a>
</div>
</div>
</span>
<span id="login-button" style="font-family: SilkscreenNormal,sans-serif">
<a href="https://visualgo.net/login">Login</a>
</span>
</nav>
<ul id="account-dropdown-menu">
<li><a class="account-dropdown-item" href="https://visualgo.net/profile">Profile</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/training">Training</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/tests">Tests</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/logout">Log Out</a></li>
</ul>
<script>
  function changeURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    URL[3] = document.getElementById("Language").value;
    window.location.assign(URL.join('https://visualgo.net/'));
  }

  function changeDefaultLanguageAndURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    let val = document.getElementById("Language").value;
    URL[3] = val;

    let data = {
      '_token': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
      'lang'  : val
    }
    $.post('https://visualgo.net/changeLanguage', data, function (res, status) {
      if(res['status'] === 'success') {
        window.location.assign(URL.join('https://visualgo.net/'));
      } else if (res['status'] === 'failed') {
        alert(res['message']);
      } else {
        alert('An unknown error occurred');
      }
    })
  }
</script>
<div id="dark-overlay"></div>
<div id="main-content-container" style="flex: 1">

<div id="mobile-playback-overlay" class="playing" style="display: none;">
<span id="mobile-playback-rewind-label" class="mobile-playback-label">-7</span>
<span id="mobile-playback-rewind" class="mobile-playback-item" onclick="mobilePlaybackRewind()"><img src="../img/prevFrame.png" alt="rewind 7 frames"></span>
<span id="mobile-playback-pause" class="mobile-playback-item" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/pause.png" alt="pause"></span>
<span id="mobile-playback-play" class="mobile-playback-item" style="display: none;" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/play.png" alt="play"></span>
<span id="mobile-playback-forward" class="mobile-playback-item" onclick="mobilePlaybackForward()"><img src="../img/nextFrame.png" alt="forward 7 frames"></span>
<span id="mobile-playback-forward-label" class="mobile-playback-label">+7</span>
</div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id="speed-control"><div id="speed-input"></div><div id="viz-speed-value">1x</div></div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick="goToBeginning()"><img src="../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick="stepBackward()"><img src="../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick="pause()"><img src="../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick="play()"><img src="../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick="stepForward()"><img src="../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick="goToEnd()"><img src="../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id="viz">
<p id="info" "></p>
</div>
<div id="current-action" class="panel"></div>
<div id="e-lecture" class="panel"></div> 
<div id="e-lecture-timeline"></div>
<div id="e-lecture-f1map">
<div class="e-lecture-f1map-sector" sectorNo="1"></div>
<div class="e-lecture-f1map-sector" sectorNo="2"></div>
<div class="e-lecture-f1map-sector" sectorNo="3"></div>
</div>
<div id="overlay" hidden onclick="end_eLecture()"> 
<div id="electure-dropdown">
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. Single-Source Shortest Paths (SSSP)</option>
<option value="1-1">&nbsp;&nbsp;&nbsp;1-1. Motivation</option>
<option value="1-2">&nbsp;&nbsp;&nbsp;1-2. SSSP Problem - Two Inputs</option>
<option value="1-3">&nbsp;&nbsp;&nbsp;1-3. SSSP Problem - Output</option>
<option value="1-4">&nbsp;&nbsp;&nbsp;1-4. SSSP Problem - Output Variables</option>
<option value="1-5">&nbsp;&nbsp;&nbsp;1-5. Example with s = 0</option>
<option value="1-6">&nbsp;&nbsp;&nbsp;1-6. Ill-Defined Case</option>
<option value="1-7">&nbsp;&nbsp;&nbsp;1-7. Main Operation: relax(u, v, w(u, v))</option>
<option value="2">2. Input Graph</option>
<option value="3">3. SSSP Algorithms</option>
<option value="4">4. O(V&times;E) Bellman-Ford Algorithm</option>
<option value="4-1">&nbsp;&nbsp;&nbsp;4-1. Optimized Form: O(k&times;E)</option>
<option value="4-2">&nbsp;&nbsp;&nbsp;4-2. The Answer</option>
<option value="4-3">&nbsp;&nbsp;&nbsp;4-3. T.1: Shortest Paths are Simple Paths*</option>
<option value="4-4">&nbsp;&nbsp;&nbsp;4-4. Proof by Contradiction - Part 1</option>
<option value="4-5">&nbsp;&nbsp;&nbsp;4-5. Proof by Contradiction - Part 2</option>
<option value="4-6">&nbsp;&nbsp;&nbsp;4-6. T.2: Bellman-Ford Algorithm is Correct</option>
<option value="4-7">&nbsp;&nbsp;&nbsp;4-7. Proof by Induction</option>
<option value="4-8">&nbsp;&nbsp;&nbsp;4-8. Worst Case Behavior</option>
<option value="4-9">&nbsp;&nbsp;&nbsp;4-9. On Graph with -ve Weight Cycle</option>
<option value="5">5. Five Simplifying Assumptions</option>
<option value="6">6. Breadth-First Search</option>
<option value="6-1">&nbsp;&nbsp;&nbsp;6-1. The Explanation</option>
<option value="6-2">&nbsp;&nbsp;&nbsp;6-2. Minor Implementation Tweak</option>
<option value="6-3">&nbsp;&nbsp;&nbsp;6-3. Wrong Answer on General Graphs</option>
<option value="7">7. Dijkstra&#39;s Algorithm (Original Implementation)</option>
<option value="7-1">&nbsp;&nbsp;&nbsp;7-1. Key Ideas</option>
<option value="7-2">&nbsp;&nbsp;&nbsp;7-2. O((V+E) log V) Time Complexity - Part 1</option>
<option value="7-3">&nbsp;&nbsp;&nbsp;7-3. O((V+E) log V) Time Complexity - Part 2</option>
<option value="7-4">&nbsp;&nbsp;&nbsp;7-4. Proof of Correctness</option>
<option value="7-5">&nbsp;&nbsp;&nbsp;7-5. Wrong Answer on Graph with -ve Weight</option>
<option value="8">8. Modified Dijkstra&#39;s Algorithm</option>
<option value="8-1">&nbsp;&nbsp;&nbsp;8-1. Key Ideas</option>
<option value="8-2">&nbsp;&nbsp;&nbsp;8-2. O((V+E) log V) Time Complexity?</option>
<option value="8-3">&nbsp;&nbsp;&nbsp;8-3. Correct on Graph without -ve Weight Cycle</option>
<option value="8-4">&nbsp;&nbsp;&nbsp;8-4. Problem with Graph with -ve Weight Cycle</option>
<option value="8-5">&nbsp;&nbsp;&nbsp;8-5. Worst Case Input</option>
<option value="9">9. Depth-First Search</option>
<option value="9-1">&nbsp;&nbsp;&nbsp;9-1. The Answer</option>
<option value="9-2">&nbsp;&nbsp;&nbsp;9-2. Wrong Answer on Non Tree Graphs</option>
<option value="10">10. Dynamic Programming (DP)</option>
<option value="10-1">&nbsp;&nbsp;&nbsp;10-1. Strength and Weakness</option>
<option value="10-2">&nbsp;&nbsp;&nbsp;10-2. Similarities with Bellman-Ford Algorithm</option>
<option value="11">11. Extras</option>
<option value="11-1">&nbsp;&nbsp;&nbsp;11-1. Online Quiz</option>
<option value="11-2">&nbsp;&nbsp;&nbsp;11-2. Online Judge Exercises</option>
</select>
</div>
<div class="electure-print" title="Print the e-Lecture note" style="z-index=8001;">&#9997;</div>
<div class="electure-end" title="Close the e-Lecture mode" style="z-index=8001;">&#10008;</div>
</div>
<div id="dropdown-temp-holder" hidden></div>

<div id="electure-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>In the <strong>Single-Source Shortest Paths (SSSP)</strong> problem, we aim to find the shortest paths weights (and the actual paths) from a particular single-source vertex to all other vertices in a directed weighted graph (if such paths exist).</p><br><p>The SSSP problem is a(nother) very <b>well-known</b> Computer Science (CS) problem that <b>every</b> CS students worldwide need to be aware of and hopefully master.</p><br><p>The SSSP problem has several different efficient (polynomial) algorithms (e.g., Bellman-Ford, BFS, DFS, Dijkstra — 2 versions, and/or Dynamic Programming) that can be used depending on the nature of the input directed weighted graph, i.e. weighted/unweighted, with/without (negative weight) cycle, or structurally special (a tree/a DAG).</p>
<div class="electure-addition">
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
If you are an NUS student and a repeat visitor, please <a href="https://visualgo.net/login"><u>login</u></a>.</p>
</div>
<div class="electure-next" data-nextid="1-1" title="Go to the next slide 1-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-1-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>SSSP is one of the most frequent graph problem encountered in real-life. Every time we want to move from one place (usually our current location) to another (our destination), we will try to pick a short — if not the shortest — path.</p><br><p>SSSP algorithm(s) is embedded inside various map software like <a href="https://map.google.com/" target="_blank"><u>Google Maps</u></a> and in various Global Positioning System (GPS) tool.</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 1: Since you are not <a href="https://visualgo.net/login"><u>logged-in</u></a>, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b>/<b>[PageUp]</b> to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use <b>[&rarr; or &darr;/&larr; or &uarr;]</b> to do the same),and <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
</div>
<div class="electure-prev" data-nextid="1" title="Go to the previous slide 1">&larr;</div>
<div class="electure-next" data-nextid="1-2" title="Go to the next slide 1-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-1-2" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Input 1: A directed weighted graph G(V, E), not necessarily connected, where <b>V</b>/vertices can be used to describe intersections, junctions, houses, landmarks, etc and <b>E</b>/edges can be used to describe streets, roads, avenues with proper direction and weight/cost.</p><br><p>Input 2: As the name implies, the SSSP problem has another input: A source vertex <b>s</b> ∈ <b>V</b>.</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
</div>
<div class="electure-prev" data-nextid="1-1" title="Go to the previous slide 1-1">&larr;</div>
<div class="electure-next" data-nextid="1-3" title="Go to the next slide 1-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-1-3" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>The objective of the SSSP problem is to find the shortest path weight from <b>s</b> to each vertex <b>u</b> ∈ <b>V</b>, denoted as <b>δ(s, u)</b> (δ is pronounced as &#39;delta&#39;) and also the actual shortest path from <b>s</b> to <b>u</b>.</p><br><p>The path weight of a path <b>p</b> is simply the summation of edge weights along that path.</p><br><p>The weight of the shortest path from <b>s</b> to <b>s</b> is trivial: 0.<br>The weight of the shortest path from <b>s</b> to any unreachable vertex is also trivial: +∞.</p><br><p>PS: The weight of the shortest path from <b>s</b> to <b>v</b> where <b>(s, v) ∈ E</b> does not necessarily the weight of <b>w(s, v)</b>. See the next few slides to realise this.</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode): <b>Spacebar</b> to play/pause/replay the animation, <b>&larr;</b>/<b>&rarr;</b> to step the animation backwards/forwards, respectively, and <b>-</b>/<b>+</b> to decrease/increase the animation speed, respectively.</p>
</div>
<div class="electure-prev" data-nextid="1-2" title="Go to the previous slide 1-2">&larr;</div>
<div class="electure-next" data-nextid="1-4" title="Go to the next slide 1-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-1-4" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>The outputs of all six (6) SSSP algorithms for the SSSP problem discussed in this visualization are these two arrays/Vectors:</p><ol><li>An array/Vector <b>D</b> of size <b>V</b> (<b>D</b> stands for &#39;distance&#39;)<br>Initially, <b>D[u]</b> = 0 if <b>u</b> = <b>s</b>; otherwise <b>D[u]</b> = +∞ (a large number, e.g. 10<sup>9</sup>)<br><b>D[u]</b> decreases as we find better (shorter) paths<br><b>D[u]</b> ≥ <b>δ(s, u)</b> throughout the execution of SSSP algorithm<br><b>D[u]</b> = <b>δ(s, u)</b> at the end of SSSP algorithm</li><li>An array/Vector <b>p</b> of size <b>V</b> (p stands for &#39;parent&#39;/&#39;predecessor&#39;/&#39;previous&#39;)<br><b>p[u]</b> = the predecessor on best path from source <b>s</b> to <b>u</b><br><b>p[u]</b> = NULL (not defined, we can use a value like -1 for this)<br>This array/Vector <b>p</b> describes the resulting SSSP spanning tree</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="1-3" title="Go to the previous slide 1-3">&larr;</div>
<div class="electure-next" data-nextid="1-5" title="Go to the next slide 1-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-1-5" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>Initially, <b>D[u]</b> = +∞ (practically, a large value like 10<sup>9</sup>) ∀<b>u</b> ∈ <b>V&bsol;{s}</b>, but <b>D[s]</b> = <b>D[0]</b> = 0.<br>Initially, <b>p[u]</b> = -1 (to say &#39;no predecessor&#39;) ∀<b>u</b> ∈ <b>V</b>.</p><br><p>Now click <span class="slide-actions" onclick="doButtonAction70()">Dijkstra(0)</span> — don&#39;t worry about the details as they will be explained later — and wait until it is over (approximately 10s on this small graph).</p><br><p>At the end of that SSSP algorithm, <b>D[s]</b> = <b>D[0]</b> = 0 (unchanged) and <b>D[u]</b> = <b>δ(s, u)</b> ∀<b>u</b> ∈ <b>V</b><br>e.g. <b>D[2]</b> = 6, <b>D[4]</b> = 7 (these values are stored as <span style="color: red;">red text</span> under each vertex).<br>At the end of that SSSP algorithm, <b>p[s]</b> = <b>p[0]</b> = -1 (the source has no predecessor), but <b>p[v]</b> = the origin of the <span style="color: red;">red edges</span> for the rest, e.g. <b>p[2]</b> = 0, <b>p[4] = 2</b>.</p><br><p>Thus, if we are at <b>s</b> = 0 and want to go to vertex 4, we will use shortest path 0 → 2 → 4 with path weight 7.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="1-4" title="Go to the previous slide 1-4">&larr;</div>
<div class="electure-next" data-nextid="1-6" title="Go to the next slide 1-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-1-6" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>Some graphs contain <b>negative weight edge(s)</b> (not necessarily cyclic) and/or <b>negative weight cycle(s)</b>. For example (fictional): Suppose you can travel forward in time (normal, edges with positive weight) or back in time by passing through time tunnel (special wormhole edges with negative weight), as the example shown above.</p><br><p>On that graph, the shortest paths from the source vertex <b>s</b> = 0 to vertices {1, 2, 3} are all <b>ill-defined</b>. For example 1 &rarr; 2 &rarr; 1 is a negative weight <b>cycle</b> as it has negative total path (cycle) weight of 15-42 = -27. Thus we can cycle around that negative weight cycle 0 &rarr; <u>1 &rarr; 2 &rarr; 1 &rarr; 2 </u> &rarr; ... forever to get overall ill-defined shortest path weight of -&#x221e;.</p><br><p>However, notice that the shortest path from the source vertex <b>s</b> = 0 to vertex 4 is ok with &delta;(0, 4) = -99. So the presence of negative weight <b>edge(s)</b> is not the <b>main</b> issue. The main issue is the presence of negative weight <b>cycle(s)</b> reachable from source vertex <b>s</b>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="1-5" title="Go to the previous slide 1-5">&larr;</div>
<div class="electure-next" data-nextid="1-7" title="Go to the next slide 1-7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-1-7" class="electure-dialog" style="top:230px;left:50%;margin-left:-250px;width:500px;">
<p>The main operation for all SSSP algorithms discussed in this visualization is the <samp>relax(u, v, w(u, v))</samp> operation with the following pseudo-code:</p><pre>relax(u, v, w_u_v)<br>  if D[v] &gt; D[u]+w_u_v // if the path can be shortened<br>    D[v] = D[u]+w_u_v // we &#39;relax&#39; this edge<br>    p[v] = u // remember/update the predecessor<br>    // update some other data structure(s) as necessary</pre><p>For example, see <samp>relax(1,2,4)</samp> operation on the figure below: <img src="../img/relax.png" width="500" alt="relax operation example"></p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="1-6" title="Go to the previous slide 1-6">&larr;</div>
<div class="electure-next" data-nextid="2" title="Go to the next slide 2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2" class="electure-dialog" style="bottom:330px;left:60px;width:500px;">
<p>There are two different sources for specifying an input graph:</p><ol><li><b>Edit Graph</b>: You can draw, edit, or import&nbsp;<strong>any</strong> directed weighted graph as the input graph.</li><li><b>Example Graphs</b>: You can select from the list of our selected example graphs to get you started. These example graphs have different characteristics.</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="1-7" title="Go to the previous slide 1-7">&larr;</div>
<div class="electure-next" data-nextid="3" title="Go to the next slide 3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3" class="electure-dialog" style="bottom:330px;left:60px;width:500px;">
<p>In this visualization, we will discuss 6 (SIX) SSSP algorithms.</p><br><p>We will start with the O(<b>V×E</b>) Bellman-Ford algorithm first as it is the most versatile (but also the slowest) SSSP algorithm. We will then discuss 5 (FIVE) other algorithms (including two variants of Dijkstra&#39;s algorithm) that solve <b>special-cases</b> of SSSP problem in a much faster manner.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="2" title="Go to the previous slide 2">&larr;</div>
<div class="electure-next" data-nextid="4" title="Go to the next slide 4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>The general purpose <b>Bellman-Ford algorithm</b> can solve <b>all kinds</b> of valid SSSP problem variants (expect one — the one that is ill-defined anyway, to be discussed soon), albeit with a <b>rather slow</b> O(<b>V×E</b>) running time. It also has an extremely simple pseudo-code:</p><pre>for i = 1 to |V|-1 // O(V) here, so O(V×E×1) = O(V×E)<br>  for each edge(u, v) ∈ E // O(E) here, e.g. by using an Edge List<br>    relax(u, v, w(u, v)) // O(1) here</pre><p>Without further ado, let&#39;s see a preview of how it works on the example graph above by clicking <span class="slide-actions" onclick="doButtonAction71()">BellmanFord(0)</span> (≈30s, and for now, please ignore the additional loop at the bottom of the pseudo-code).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3" title="Go to the previous slide 3">&larr;</div>
<div class="electure-next" data-nextid="4-1" title="Go to the next slide 4-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-1" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>Bellman-Ford algorithm can be made to run slightly faster on normal input graph, from the worst case of O(<b>V×E</b>) to just O(<b>k×E</b>) where <b>k</b> is the number of iterations of the outer loop of Bellman-Ford.</p><br><p>Discussion: How to do this? Is the speed-up significant?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4" title="Go to the previous slide 4">&larr;</div>
<div class="electure-next" data-nextid="4-2" title="Go to the next slide 4-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-2" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-1" title="Go to the previous slide 4-1">&larr;</div>
<div class="electure-next" data-nextid="4-3" title="Go to the next slide 4-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-3" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>To convince the worldwide audience that Bellman-Ford algorithm works, let&#39;s temporarily move from visualization mode to proof mode for a few slides.</p><br><p>Theorem 1: If G = (V, E) contains <b>no negative weight cycle</b>, then the shortest path <b>p</b> from source vertex <b>s</b> to a vertex <b>v</b> must be a <b>simple path</b>.</p><br><p>Recall: A simple path is a path <b>p = {v<sub>0</sub>, v<sub>1</sub>, v<sub>2</sub>, ..., v<sub>k</sub>}</b>, (<b>v<sub>i</sub></b>, <b>v<sub>i+1</sub></b>) ∈ <b>E</b>, ∀ 0 ≤ <b>i</b> ≤ (<b>k</b>-1) and there is <b>no</b> repeated vertex along this path.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-2" title="Go to the previous slide 4-2">&larr;</div>
<div class="electure-next" data-nextid="4-4" title="Go to the next slide 4-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-4" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<ol><li>Suppose the shortest path <b>p</b> is <b>not</b> a simple path</li><li>Then <b>p</b> must contains one (or more) cycle(s) (by definition of non-simple path)</li><li>Suppose there is a cycle <b>c</b> in <b>p</b> with <b>positive weight</b> (e.g.,&nbsp;<span style="color: green;">green</span> → <span style="color: lightblue;">blue</span> → <span style="color: green;">green</span> on the left image) <img src="../img/cycle.png" alt="cycle" width="400&quot;"></li><li>If we remove <b>c</b> from <b>p</b>, then we will have a shorter &#39;shortest path&#39; than our shortest path <b>p</b></li><li>A glaring contradiction, so <b>p</b> must be a simple path</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-3" title="Go to the previous slide 4-3">&larr;</div>
<div class="electure-next" data-nextid="4-5" title="Go to the next slide 4-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-5" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<ol start="6"><li>Even if <b>c</b> is actually a cycle with <b>zero (0) total weight</b> — it is possible according to our Theorem 1 assumption: no negative weight cycle (see the same <span style="color: green;">green</span> → <span style="color: lightblue;">blue</span> → <span style="color: green;">green</span> but on the right image), we can still remove <b>c</b> from <b>p</b> without increasing the shortest path weight of <b>p</b> <img src="../img/cycle.png" alt="cycle" width="400&quot;"></li><li>In conclusion, <b>p</b> is a simple path (from point 5) or can always be made into a simple path (from point 6)</li></ol><p>In another word, shortest path <b>p</b> has at most |<b>V</b>|-1 edges from the source vertex <b>s</b> to the &#39;furthest possible&#39; vertex <b>v</b> in <b>G</b> (in terms of number of edges in the shortest path — see the Bellman-Ford Killer example above).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-4" title="Go to the previous slide 4-4">&larr;</div>
<div class="electure-next" data-nextid="4-6" title="Go to the next slide 4-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-6" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>Theorem 2: If G = (V, E) contains <b>no negative weight cycle</b>, then after Bellman-Ford algorithm terminates, we will have <b>D[u]</b> = <b>δ(s, u)</b>, ∀ <b>u</b> ∈ <b>V</b>.</p><br><p>For this, we will use <b>Proof by Induction</b> and here are the starting points:</p><br><p>Consider the shortest path <b>p</b> from source vertex <b>s</b> to vertex <b>v<sub>i</sub></b> where <b>v<sub>i</sub></b> is defined as a vertex which the actual shortest path to reach it requires <b>i</b> hops (edges) from source vertex <b>s</b>. Recall from Theorem 1 that <b>p</b> will be simple path as we have the same assumption of <b>no negative weight cycle</b>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-5" title="Go to the previous slide 4-5">&larr;</div>
<div class="electure-next" data-nextid="4-7" title="Go to the next slide 4-7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-7" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<ol><li>Initially, <b>D[v<sub>0</sub>] = δ(s, v<sub>0</sub>) = 0</b>, as v<sub>0</sub> is just the source vertex <b>s</b></li><li>After <b>1</b> pass through <b>E</b>, we have <b>D[v<sub>1</sub>] = δ(s, v<sub>1</sub>)</b></li><li>After <b>2</b> pass through <b>E</b>, we have <b>D[v<sub>2</sub>] = δ(s, v<sub>2</sub>)</b></li><li>...</li><li>After <b>k</b> pass through <b>E</b>, we have <b>D[v<sub>k</sub>] = δ(s, v<sub>k</sub>)</b></li><li>When there is no negative weight cycle, the shortest path <b>p</b> is a simple path (see Theorem 1), thus the last iteration should be iteration |<b>V</b>|-1</li><li>After |<b>V</b>|-1 pass through <b>E</b>, we have <b>D[v<sub>|V|-1</sub>] = δ(s, v<sub>|V|-1</sub>)</b>, regardless the ordering of edges in <b>E</b> — see the Bellman-Ford Killer example above</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-6" title="Go to the previous slide 4-6">&larr;</div>
<div class="electure-next" data-nextid="4-8" title="Go to the next slide 4-8">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-8" class="electure-dialog" style="top:180px;left:50%;margin-left:-250px;width:500px;">
<p>Try running <span class="slide-actions" onclick="doButtonAction71()">BellmanFord(0)</span> on the &#39;Bellman-Ford Killer&#39; example above. There are <b>V</b> = 7 vertices and <b>E</b> = 6 edges but the edge list <b>E</b> is configured to be at its worst possible order. Notice that after (<b>V</b>-1)×<b>E</b> = (7-1)*6 = 36 operations (~40s, be patient), Bellman-Ford will terminate with the correct answer and there is no way we can terminate Bellman-Ford algorithm earlier.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-7" title="Go to the previous slide 4-7">&larr;</div>
<div class="electure-next" data-nextid="4-9" title="Go to the next slide 4-9">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-9" class="electure-dialog" style="top:250px;left:50%;margin-left:-250px;width:500px;">
<p>The only input graph that Bellman-Ford algorithm has issue is the input graph with negative weight cycle reachable from the source vertex <b>s</b>.</p><br><p>However, Bellman-Ford can be used to detect if the input graph contains at least one negative weight cycle reachable from the source vertex <b>s</b> by using the corollary of Theorem 2: If at least one value <b>D[u]</b> fails to converge after |<b>V</b>|-1 passes, then there exists a negative-weight cycle reachable from the source vertex <b>s</b>.</p><br><p>Now run <span class="slide-actions" onclick="doButtonAction71()">BellmanFord(0)</span> on the example graph that contains negative edges and a negative weight cycle. Please concentrate on the loop at the bottom of the pseudo-code.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-8" title="Go to the previous slide 4-8">&larr;</div>
<div class="electure-next" data-nextid="5" title="Go to the next slide 5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5" class="electure-dialog" style="bottom:330px;left:60px;width:500px;">
<p>Sometimes, the actual problem that we face is <b>not the general form</b> of the original problem. Therefore in this e-Lecture, we want to highlight five (5) special cases involving the SSSP problem. When we encounter any one of them, we can solve it with <b>different</b> and <b>(much) faster</b> algorithm than the generic O(<b>V×E</b>) Bellman-Ford algorithm. They are:</p><ol><li>On Unweighted Graphs: O(<b>V</b>+<b>E</b>) BFS,</li><li>On Graphs without negative weight: O((<b>V</b>+<b>E</b>) log <b>V</b>) Dijkstra&#39;s algorithm,</li><li>On Graphs without negative weight cycle: O((<b>V</b>+<b>E</b>) log <b>V</b>) Modified Dijkstra&#39;s,</li><li>On Tree: O(<b>V</b>+<b>E</b>) DFS/BFS,</li><li>On Directed Acyclic Graphs (DAG): O(<b>V</b>+<b>E</b>) Dynamic Programming (DP)</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-9" title="Go to the previous slide 4-9">&larr;</div>
<div class="electure-next" data-nextid="6" title="Go to the next slide 6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>The O(<b>V</b>+<b>E</b>) <strong>Breadth-First Search (BFS)</strong> algorithm can solve <b>special case</b> of SSSP problem when the input graph is <b>unweighted</b> (all edges have unit weight 1, try <span class="slide-actions" onclick="doButtonAction72()">BFS(5)</span> on example: &#39;CP3 4.3&#39; above) or <b>positive constant weighted</b> (all edges have the same constant weight, e.g. you can change <b>all</b> edge weights of the example graph above with any positive constant weight of your choice).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5" title="Go to the previous slide 5">&larr;</div>
<div class="electure-next" data-nextid="6-1" title="Go to the next slide 6-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6-1" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>When the graph is <b>unweighted</b> — this appears quite frequently in real life — the SSSP problem can be viewed as a problem of finding the <b>least number of edges</b> traversed from the source vertex <b>s</b> to other vertices.</p><br><p>The BFS spanning tree from source vertex <b>s</b> produced by the fast O(<b>V</b>+<b>E</b>) BFS algorithm — notice the + sign — precisely fits the requirement.</p><br><p>Compared with the O(<b>V</b>×<b>E</b>) of Bellman-Ford — notice the × sign — it is a no-brainer to use BFS for this special case of SSSP problem.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6" title="Go to the previous slide 6">&larr;</div>
<div class="electure-next" data-nextid="6-2" title="Go to the next slide 6-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6-2" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>Compared to the standard BFS in <a href="dfsbfs.html"><u>Graph Traversal</u></a> module, we need to perform simple modifications to make BFS able to solve the unweighted version of the SSSP problem:</p><ol><li>First, we change the Boolean array <samp>visited</samp> into an Integer array <b>D</b>.</li><li>At the start of BFS, instead of setting <samp>visited[u] = false</samp>, we set <samp>D[u] = 1e9</samp> (a large number to symbolise +&#x221e; or even -1 to symbolise &#39;unvisited&#39; state, but we cannot use 0 as <samp>D[0] = 0</samp>) &forall;<b>u</b> &in; <b>V&#92;{s}</b>; Then we set <samp>D[s] = 0</samp></li><li>We change the BFS main loop from<br><samp>if (visited[v] = 0) { visited[v] = 1 ... } // v is unvisited</samp><br>to <br><samp>if (D[v] = 1e9) { D[v] = D[u]+1 ... } // v is 1 step away from u</samp></li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6-1" title="Go to the previous slide 6-1">&larr;</div>
<div class="electure-next" data-nextid="6-3" title="Go to the next slide 6-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6-3" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>However, BFS will very likely produce wrong answer when run on weighted graphs as BFS is not actually designed for to solve the weighted version of SSSP problem. There may be a case that taking a path with more number of edges used produces lower total overall path weight than taking a path with minimum number of edges used — which is the output of BFS algorithm.</p><br><p>In this visualization, we will allow you to run BFS even on &#39;wrong&#39; input graph for pedagogical purpose, but we will display a <b>warning message</b> at the end of the algorithm. For example, try <span class="slide-actions" onclick="doButtonAction75()">BFS(0)</span> on the general graph above and you will see that vertices {3,4} will have wrong D[3] and D[4] values (and also p[3] and p[4] values).</p><br><p>We will soon see Dijkstra&#39;s algorithm (2 implementation variants) for solving certain weighted SSSP problems in a faster way than the general Bellman-Ford algorithm.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6-2" title="Go to the previous slide 6-2">&larr;</div>
<div class="electure-next" data-nextid="7" title="Go to the next slide 7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>The O((<b>V</b>+<b>E</b>) log <b>V</b>) <b>Dijkstra&#39;s algorithm</b> is the most frequently used SSSP algorithm for typical input: Directed weighted graph that has <b>no negative weight edge at all</b>, formally: <b>∀ edge(u, v) ∈ E</b>, <b>w(u, v) ≥ 0</b>. Such weighted graph is very common in real life as travelling from one place to another always use positive time unit(s). Try <span class="slide-actions" onclick="doButtonAction70()">Dijkstra(0)</span> on one of the Example Graphs: CP4 4.16 shown above.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6-3" title="Go to the previous slide 6-3">&larr;</div>
<div class="electure-next" data-nextid="7-1" title="Go to the next slide 7-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-1" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>Dijkstra&#39;s algorithm maintains a set <b>S</b> (Solved) of vertices whose final shortest path weights have been determined. Initially <b>S</b> = <b>{s}</b>, the source vertex <b>s</b> only.</p><br><p>Then, it repeatedly selects vertex <b>u</b> in <b>{V&#92;S}</b> with the minimum shortest path estimate, adds <b>u</b> to <b>S</b>, and relaxes all outgoing edges of <b>u</b>. Detailed proof of correctness of this Dijkstra&#39;s algorithm is usually written in typical Computer Science algorithm textbooks. For a simpler intuitive visual explanation on why this greedy strategy works, see <a href="https://www.quora.com/What-is-the-simplest-intuitive-proof-of-Dijkstra’s-shortest-path-algorithm" target="_blank"><u>this</u></a>.<p><br><p>This entails the use of a Priority Queue as the shortest path estimates keep changing as more edges are processed. The choice of relaxing edges emanating from vertex with the minimum shortest path estimate first is <b>greedy</b>, i.e. use the "best so far", but we will see later that it can be proven that it will eventually ends up with an optimal result &mdash; if the graph has no negative weight edge.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7" title="Go to the previous slide 7">&larr;</div>
<div class="electure-next" data-nextid="7-2" title="Go to the next slide 7-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-2" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>In Dijkstra&#39;s algorithm, each vertex will only be extracted from the Priority Queue (PQ) once. As there are <b>V</b> vertices, we will do this maximum O(<b>V</b>) times.</p><br><p>ExtractMin() operation runs in O(log <b>V</b>) whether the PQ is implemented using a <a href="heap.html"><u>Binary Min Heap</u></a> or using a <a href="bstb4ef.html"><u>balanced BST like AVL Tree</u></a>.</p><br><p>Therefore this part is O(<b>V</b> log <b>V</b>).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-1" title="Go to the previous slide 7-1">&larr;</div>
<div class="electure-next" data-nextid="7-3" title="Go to the next slide 7-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-3" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>Every time a vertex is processed, we relax its neighbors. In total, <b>E</b> edges are processed.</p><br><p>If by relaxing <b>edge(u, v)</b>, we have to decrease <b>D[v]</b>, we call the O(log <b>V</b>) DecreaseKey() operation in <a href="heap.html"><u>Binary Min Heap</u></a> (harder to implement as C++ STL priority_queue/Python heapq/Java PriorityQueue does not support this operation efficiently <i>yet</i>) or simply delete the old entry and then re-insert a new entry in <a href="bstb4ef.html"><u>balanced BST like AVL Tree</u></a> (which also runs in O(log <b>V</b>), but this is much easier to implement, just use C++ STL set/Java TreeSet &mdash; unfortunately not natively supported in Python).</p><br><p>Therefore, this part is O(<b>E</b> log <b>V</b>).</p><br><p>Thus in overall, Dijkstra&#39;s algorithm runs in O(<b>V</b> log <b>V</b> + <b>E</b> log <b>V</b>) = O((<b>V</b>+<b>E</b>) log <b>V</b>) time, which is much faster than the O(<b>V&times;E</b>) Bellman-Ford algorithm.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-2" title="Go to the previous slide 7-2">&larr;</div>
<div class="electure-next" data-nextid="7-4" title="Go to the next slide 7-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-4" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-3" title="Go to the previous slide 7-3">&larr;</div>
<div class="electure-next" data-nextid="7-5" title="Go to the next slide 7-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7-5" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>When the input graph contains at least one negative weight edge &mdash; not necessarily negative weight cycle &mdash; Dijkstra&#39;s algorithm can produce wrong answer.</p><br><p>Try <span class="slide-actions" onclick="doButtonAction70()">Dijkstra(0)</span> on one of the Example Graphs: CP3 4.18.</p><br><p>At the end of the execution of Dijkstra&#39;s algorithm, vertex 4 has wrong D[4] value as the algorithm started &#39;wrongly&#39; thinking that subpath 0 &rarr; 1 &rarr; 3 is the better subpath of weight 1+2 = 3, thus making D[4] = 6 after calling <samp>relax(3,4,3)</samp>. However, the presence of negative weight -10 at edge 2 &rarr; 3 makes the other subpath 0 &rarr; 2 &rarr; 3 eventually the better subpath of weight 10-10 = 0 although it started worse with path weight 10 after the first edge 0 &rarr; 2. This better D[3] = 0 is never propagated further due to the greedy nature of Dijkstra&#39;s algorithm, hence D[4] is wrong.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-4" title="Go to the previous slide 7-4">&larr;</div>
<div class="electure-next" data-nextid="8" title="Go to the next slide 8">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>Dijkstra&#39;s algorithm can also be implemented differently. The O((<b>V</b>+<b>E</b>) log <b>V</b>) <b>Modified Dijkstra&#39;s algorithm</b> can be used for directed weighted graphs that may have negative weight edges but no negative weight cycle.</p><br><p>Such input graph appears in some practical cases, e.g., travelling using an <b>electric car</b> that has battery and our objective is to find a path from source vertex <b>s</b> to another vertex that minimizes overall <b>battery usage</b>. As usual, during acceleration (or driving on flat/uphill road), the electric car <b>uses</b> (positive) energy from the battery. However, during braking (or driving on downhill road), the electric car <b>recharges</b> (or use negative) energy to the battery. There is no negative weight cycle due to kinetic energy loss.</p><br><p>For example, try <span class="slide-actions" onclick="doButtonAction76()">ModifiedDijkstra(0)</span> on one of the Example Graphs: CP3 4.18 that has troubled the original version of Dijkstra&#39;s algorithm (see <a href="ssspf693.html?slide=7-5"><u>previous slide</u></a>).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7-5" title="Go to the previous slide 7-5">&larr;</div>
<div class="electure-next" data-nextid="8-1" title="Go to the next slide 8-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8-1" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>The key idea is the &#39;usage modification&#39; done to C++ STL priority_queue/Python heapq/Java PriorityQueue to allow it to perform the required &#39;DecreaseKey&#39; operation efficiently, i.e., in O(log <b>V</b>) time.</p><br><p>The technique is called &#39;Lazy Update&#39; where we leave the &#39;outdated/weaker/bigger-valued information&#39; in the Min Priority Queue instead of deleting it straight-away. As the items are ordered from smaller values to bigger values in a Min PQ, we are guaranteeing ourself that we will encounter the smallest/most-up-to-date item first before encountering the weaker/outdated item(s) later - which by then can be easily ignored.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="8" title="Go to the previous slide 8">&larr;</div>
<div class="electure-next" data-nextid="8-2" title="Go to the next slide 8-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8-2" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>On non-negative weighted graphs, the behavior of Modified Dijkstra&#39;s implementation is exactly the same as the Original Dijkstra&#39;s so we can use the same time complexity analysis of O((<b>V</b>+<b>E</b>) log <b>V</b>).</p><br><p>PS: We note that when we use the Modified Dijkstra&#39;s algorithm, there can be more items (up to <b>E</b>) in the Priority Queue than if we use the Original Dijkstra&#39;s algorithm (up to <b>V</b>). However, since O(log E) = O(log V^2) = O(2 log V) = O(log V), we still treat the Priority Queue operations as O(log V).</p><br><p>However, if the graph has at least one negative weight edge, the analysis is harder.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="8-1" title="Go to the previous slide 8-1">&larr;</div>
<div class="electure-next" data-nextid="8-3" title="Go to the next slide 8-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8-3" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>When the input graph contains at least one negative weight edge but no negative weight cycle &mdash; the modified Dijkstra&#39;s algorithm produces correct answer.</p><br><p>Try <span class="slide-actions" onclick="doButtonAction76()">ModifiedDijkstra(0)</span> on one of the Example Graphs: CP3 4.18 that causes problem for <span class="slide-actions" onclick="doButtonAction70()">Dijkstra(0)</span>.</p><br><p>At the end of the execution of ModifiedDijkstra&#39;s algorithm, vertex 4 has correct D[4] value as although the modified Dijkstra&#39;s algorithm also started &#39;wrongly&#39; thinking that subpath 0 &rarr; 1 &rarr; 3 is the better subpath of weight 1+2 = 3, thus making D[4] = 6 after calling <samp>relax(3,4,3)</samp>. Here, the modified Dijkstra&#39;s algorithm <b>continues</b> propagating D[3] = 0 after it founds out that the other subpath 0 &rarr; 2 &rarr; 3 is eventually the better subpath of weight 10-10 = 0. Hence D[4] is eventually correct again. However, this is at the expense of potentially running (much more) operations than O((<b>V</b>+<b>E</b>) log <b>V</b>).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="8-2" title="Go to the previous slide 8-2">&larr;</div>
<div class="electure-next" data-nextid="8-4" title="Go to the next slide 8-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8-4" class="electure-dialog" style="top:250px;left:50%;margin-left:-250px;width:500px;">
<p>Unfortunately, running <span class="slide-actions" onclick="doButtonAction76()">ModifiedDijkstra(0)</span> on the graph with negative weight cycle as shown on one of the Example Graphs: CP3 4.17 above will cause an endless loop (the animation is very long but we limit the number of loop to be 100 edges processed so your web browser will not hang).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="8-3" title="Go to the previous slide 8-3">&larr;</div>
<div class="electure-next" data-nextid="8-5" title="Go to the next slide 8-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8-5" class="electure-dialog" style="top:250px;left:50%;margin-left:-250px;width:500px;">
<p>Try <span class="slide-actions" onclick="doButtonAction76()">ModifiedDijkstra(0)</span> on the extreme corner case above that is very hard to derive without proper understanding of this algorithm and was part of Asia Pacific Informatics Olympiad (APIO) 2013 task set by Steven.</p><br><p>The Modified Dijkstra&#39;s algorithm will terminate with correct answer, but only after running exponential number of operations (each carefully constructed triangle raises the number of required operations by another power of two). Thus we cannot prematurely terminate Modified Dijkstra&#39;s in this worst case input situation.</p><br><p>However, such extreme corner case is rare and thus in practice, Modified Dijkstra&#39;s algorithm can be used on directed graphs that have <i>some</i> negative weighted edges as long as the graph has no negative weight cycle reachable from the source vertex <b>s</b>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="8-4" title="Go to the previous slide 8-4">&larr;</div>
<div class="electure-next" data-nextid="9" title="Go to the next slide 9">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-9" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>The O(<b>V</b>) <b>Depth-First Search (DFS)</b> algorithm can solve <b>special case</b> of SSSP problem, i.e. when the input graph is a (weighted) <b>Tree</b>.</p><br><p>In a Tree, there is only one unique and acylic path that connects two distinct vertices. Thus the unique path that connects the source vertex <b>s</b> to any another vertex <b>u</b> &in; <b>V</b> is actually also the shortest path. For example, try <span class="slide-actions" onclick="doButtonAction78()">DFS(0)</span> on the Tree above.</p><br><p>Notice that for a (weighted) Tree, we can also use BFS. For example, try <span class="slide-actions" onclick="doButtonAction75()">BFS(0)</span> on the same Tree above.</p><br><p>Discussion: Why DFS (and also BFS) runs in O(<b>V</b>) instead of O(<b>V</b>+<b>E</b>) if the input is a (weighted) Tree?</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="8-5" title="Go to the previous slide 8-5">&larr;</div>
<div class="electure-next" data-nextid="9-1" title="Go to the next slide 9-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-9-1" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<div class="electure-addition">
<p>The content of this interesting slide (the answer of the usually intriguing discussion point from the earlier slide) is hidden and only available for legitimate CS lecturer worldwide. This mechanism is used in the various <a href="https://en.wikipedia.org/wiki/Flipped_classroom" target="_blank"><u>flipped classrooms</u></a> in NUS.</p><br>
<p><b>If you are really a CS lecturer (or an IT teacher)</b> (outside of NUS) and are interested to know the answers, please drop an email to stevenhalim at gmail dot com (<b>show your University staff profile/relevant proof to Steven</b>) for Steven to manually activate this CS lecturer-only feature for you.</p><br>
<p>FAQ: This feature will <b>NOT</b> be given to anyone else who is not a CS lecturer.</p>
</div>
</div>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="9" title="Go to the previous slide 9">&larr;</div>
<div class="electure-next" data-nextid="9-2" title="Go to the next slide 9-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-9-2" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>DFS will very likely produce wrong answer when run on any other graph that is not a Tree. We will display a <b>warning message</b> for such cases although we do not prevent you from trying this feature for pedagogical purpose.</p><br><p>For example, try <span class="slide-actions" onclick="doButtonAction78()">DFS(0)</span> on the general graph above and you will see that vertex {4} will have wrong D[4] value (and also wrong p[4] value) as DFS(0) goes deep 0 &rarr; 1 &rarr; 3 &rarr; 4 first, backtrack all the way to vertex 0 and eventually visit 0 &rarr; 2 but edge 2 &rarr; 4 cannot be processed as vertex 4 has been visited by DFS earlier.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="9-1" title="Go to the previous slide 9-1">&larr;</div>
<div class="electure-next" data-nextid="10" title="Go to the next slide 10">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-10" class="electure-dialog" style="top:380px;left:50%;margin-left:-250px;width:500px;">
<p>The O(<b>V</b>+<b>E</b>) <b>Dynamic Programming</b> algorithm can solve <b>special case</b> of SSSP problem, i.e. when the input graph is a <b>Directed Acyclic Graph (DAG)</b> thus we can find at least one topological order of the DAG and process the edge relaxation according to this topological order.</p><br><p>For example, try <span class="slide-actions" onclick="doButtonAction77()">DP(0)</span> on the example DAG above. First, it computes one (there are other) possible topological order using either the O(<b>V</b>+<b>E</b>) DFS or the BFS/Kahn&#39;s algorithm outlined in <a href="dfsbfs.html"><u>Graph Traversal</u></a> module. For example, assume one topological order is {0,2,1,3,4,5}. Then, it relaxes the outgoing edges of vertices listed in that topological order. After just one O(<b>V</b>+<b>E</b>) pass, we will have correct <b>D[u]</b> values &forall;<b>u</b> &in; <b>V</b>.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="9-2" title="Go to the previous slide 9-2">&larr;</div>
<div class="electure-next" data-nextid="10-1" title="Go to the next slide 10-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-10-1" class="electure-dialog" style="top:280px;left:50%;margin-left:-250px;width:500px;">
<p>On the Modified Dijkstra&#39;s killer example shown above, <span class="slide-actions" onclick="doButtonAction77()">DP(0)</span> works fast as the graph is actually a DAG, albeit having negative weight edge. As the graph is a DAG, there will not be any negative weight cycle to worry about.</p><br><p>However, DP will not work for any non DAG as non DAG contains at least one cycle and thus no topological order can be found within that cycle.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="10" title="Go to the previous slide 10">&larr;</div>
<div class="electure-next" data-nextid="10-2" title="Go to the next slide 10-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-10-2" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-250px;width:500px;">
<p>DP algorithm for solving SSSP on DAG is also called <b>one-pass</b> Bellman-Ford algorithm as it replaces the outermost <b>V</b>-1 loop (we do not know the correct order so we just repeat until the maximum possible) with just one topological order pass (we know that this is (one of) the correct order(s) of this DAG).</p><br><p>Compare <span class="slide-actions" onclick="doButtonAction77()">DP(0)</span> (relax <b>E</b> edges just once — according to topological order of its vertices) versus <span class="slide-actions" onclick="doButtonAction71()">BellmanFord(0)</span> (relax <b>E</b> edges in random order, <b>V</b>-1 times) on the same example DAG above.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="10-1" title="Go to the previous slide 10-1">&larr;</div>
<div class="electure-next" data-nextid="11" title="Go to the next slide 11">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-11" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>We have lots of other stuffs on top of this basic explanation of SSSP algorithms for SSSP problems.</p><br><p>Meanwhile, you are allowed to use/modify our implementation code for Bellman-Ford/Bellman-Ford-Moore/Dijkstra&#39;s Algorithms:<br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/bellman_ford.cpp" target="_blank"><u>bellman_ford.cpp</u></a>/<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/bellman_ford_moore.cpp" target="_blank"><u>bellman_ford_moore.cpp</u></a>/<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/dijkstra.cpp" target="_blank"><u>dijkstra.cpp</u></a><br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/bellman_ford.java" target="_blank"><u>bellman_ford.java</u></a>/<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/bellman_ford_moore.java" target="_blank"><u>bellman_ford_moore.java</u></a>/<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/dijkstra.java" target="_blank"><u>dijkstra.java</u></a><br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/bellman_ford.py" target="_blank"><u>bellman_ford.py</u></a>/<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/bellman_ford_moore.py" target="_blank"><u>bellman_ford_moore.py</u></a>/<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/dijkstra.py" target="_blank"><u>dijkstra.py</u></a><br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/bellman_ford.ml" target="_blank"><u>bellman_ford.ml</u></a>/<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/bellman_ford_moore.ml" target="_blank"><u>bellman_ford_moore.ml</u></a>/<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/dijkstra.ml" target="_blank"><u>dijkstra.ml</u></a><br></p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="10-2" title="Go to the previous slide 10-2">&larr;</div>
<div class="electure-next" data-nextid="11-1" title="Go to the next slide 11-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-11-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>For a few more interesting questions about this SSSP problem and its various algorithms, please practice on <a href="https://visualgo.net/training?diff=Medium&amp;n=7&amp;tl=0&amp;module=sssp"><u>SSSP</u></a> training module (no login is required).</p><br><p>However, for registered users, you should login and then go to the <a href="https://visualgo.net/training"><u>Main Training Page</u></a> to officially clear this module (after clearing the other pre-requisites modules) and such achievement will be recorded in your user account.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="11" title="Go to the previous slide 11">&larr;</div>
<div class="electure-next" data-nextid="11-2" title="Go to the next slide 11-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-11-2" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>We also have a few programming problems that somewhat requires the usage of the correct SSSP algorithm: <a href="https://open.kattis.com/problems/hidingplaces" target="_blank"><u>Kattis - hidingplaces</u></a> and <a href="https://open.kattis.com/problems/shortestpath1" target="_blank"><u>Kattis - shortestpath1</u></a>.</p><br><p>Try to solve them and then try the <b>many more</b> interesting twists/variants of this interesting SSSP problem.</p><hr><p>Advertisement: <a href="https://cpbook.net/" target="_blank"><u>Buy Competitive Programming textbook</u></a> to read more on this interesting problem.</p>
<div class="electure-addition">
<hr>
<p>You have reached the last slide. Return to 'Exploration Mode' to start exploring!</p>
<p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
</div>
<div class="electure-prev" data-nextid="11-1" title="Go to the previous slide 11-1">&larr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>Close</u></span>
</div>
<div id="rotateDeviceOverlay" style="display: none;">
<div id="rotateDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please rotate your device to landscape mode for a better user experience</div>
<div id="widenDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please make the window wider for a better user experience</div>
</div>

<style>
        .mediumscale {
            bottom: 281px
        }
    </style>
<style>
        .draw {
            bottom: 227px
        }
    </style>
<style>
        .examples {
            bottom: 200px
        }
    </style>
<style>
        .bellmanford {
            bottom: 173px
        }
    </style>
<style>
        .bfs {
            bottom: 146px
        }
    </style>
<style>
        .dijkstra {
            bottom: 119px
        }
    </style>
<style>
        .dfs {
            bottom: 92px
        }
    </style>
<style>
        .dp {
            bottom: 65px
        }
    </style>
<div id="actions" class="panel">
<p id="mediumscale">Visualisation Scale</p>
<p class="execAction" id="vertexnumber" onClick="toggleVertexNumber()">Toggle V. Number for 0.5x</p>
<p class="execAction" id="draw" onClick="drawGraph()">Edit Graph</p>
<p id="examples">Example Graphs</p>
<p id="bellmanford">BellmanFord(s)</p>
<p id="bfs">BFS(s)</p>
<p id="dijkstra">Dijkstra(s)</p>
<p id="dfs">DFS(s)</p>
<p id="dp">DP(s)</p>
</div>
<div id="actions-hide" class="panel-hide"><span style="color:white; font-size: x-large; display: inline-block;">&gt;</span></div>
<div id="actions-extras">
<div class="mediumscale action-menu-pullout">
<div id="defaultScale" class="execAction new-menu-option coloured-menu-option" onClick="setDefaultScale()">
<p>1.0x (Default)</p>
</div>
<div id="mediumScale" class="execAction new-menu-option coloured-menu-option" onClick="setMediumScale()">
<p>0.5x (Minimal Details)</p>
</div>
<div id="mediumscale-err" class="err" style="float: left;"></div>
</div>
<div class="draw action-menu-pullout">
<div id="draw-err" class="err" style="float: left;"></div>
</div>
<div class="examples action-menu-pullout">
<div id="example-unweighted" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;examples&#039;, &#039;example-unweighted&#039;)">
<p>Unweighted</p>
<div id="example-unweighted-third-tier" class="example-unweighted-third-tier new-menu-option" style="display: none;">
<div id="example-unweighted-5" class="execAction coloured-menu-option" style="float: right;" onClick="example(HOUSE_OF_CARDS)">
<p>House of Cards D/U</p>
</div>
<div id="example-unweighted-4" class="execAction coloured-menu-option" style="float: right;" onClick="example(CP3_4_9)">
<p>CP4 4.7 D/U</p>
</div>
<div id="example-unweighted-3" class="execAction coloured-menu-option" style="float: right;" onClick="example(CP3_4_4)">
<p>CP4 4.3 D/U (DAG)</p>
</div>
<div id="example-unweighted-2" class="execAction coloured-menu-option" style="float: right;" onClick="example(CP3_4_3)">
<p>CP4 4.2 U/U</p>
</div>
<div id="example-unweighted-1" class="execAction coloured-menu-option" style="float: right;" onClick="example(CP3_4_1)">
<p>CP4 4.1 U/U</p>
</div>
</div>
</div>
<div id="example-weighted" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;examples&#039;, &#039;example-weighted&#039;)">
<p>Weighted</p>
<div id="example-weighted-third-tier" class="example-weighted-third-tier new-menu-option" style="display: none;">
<div id="example-weighted-6" class="execAction coloured-menu-option" style="float: right;" onClick="example(WHEEL)">
<p>Wheel Graph</p>
</div>
<div id="example-weighted-4" class="execAction coloured-menu-option" style="float: right;" onClick="example(CP3_4_24)">
<p>Zig-Zag</p>
</div>
<div id="example-weighted-5" class="execAction coloured-menu-option" style="float: right;" onClick="example(TESSELLATION)">
<p>Big</p>
</div>
<div id="example-weighted-3" class="execAction coloured-menu-option" style="float: right;" onClick="example(CP3_4_17)">
<p>CP4 4.16 D/W (DAG)</p>
</div>
<div id="example-weighted-2" class="execAction coloured-menu-option" style="float: right;" onClick="example(CP3_4_14)">
<p>CP4 4.14 D/W</p>
</div>
<div id="example-weighted-1" class="execAction coloured-menu-option" style="float: right;" onClick="example(CP3_4_10)">
<p>CP4 4.10 D/W</p>
</div>
<div id="example-weighted-large" class="execAction coloured-menu-option" style="float: right;" onClick="example(SSSPLARGE)">
<p>Large</p>
</div>
<div id="example-weighted-mrt" class="execAction coloured-menu-option" style="float: right;" onClick="example(SSSPMRT)">
<p>MRT</p>
</div>
</div>
</div>
<div id="example-negative-weight" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;examples&#039;, &#039;example-negative-weight&#039;)">
<p>Negative Weight</p>
<div id="example-negative-weight-third-tier" class="example-negative-weight-third-tier new-menu-option" style="display: none;">
<div id="example-negative-weight-2" class="execAction coloured-menu-option" style="float: right;" onClick="example(CP3_4_19)">
<p>CP4 4.22 -ve cycle</p>
</div>
<div id="example-negative-weight-1" class="execAction coloured-menu-option" style="float: right;" onClick="example(CP3_4_18)">
<p>CP4 4.20 -ve weight (DAG)</p>
</div>
</div>
</div>
<div id="example-corner-case" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;examples&#039;, &#039;example-corner-case&#039;)">
<p>Corner Case</p>
<div id="example-corner-case-third-tier" class="example-corner-case-third-tier new-menu-option" style="display: none;">
<div id="example-corner-case-2" class="execAction coloured-menu-option" style="float: right;" onClick="example(BELLMANFORD_KILLER)">
<p>Bellman-Ford Killer</p>
</div>
<div id="example-corner-case-1" class="execAction coloured-menu-option" style="float: right;" onClick="example(DIJKSTRA_KILLER)">
<p>CP4 4.21 (Dijkstra's Killer)</p>
</div>
</div>
</div>
<div id="example-special-case" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;examples&#039;, &#039;example-special-case&#039;)">
<p>Special Case</p>
<div id="example-special-case-third-tier" class="example-special-case-third-tier new-menu-option" style="display: none;">
<div id="example-special-case-tree" class="execAction coloured-menu-option" style="float: right;" onClick="example(CP3_4_40)">
<p>CP4 4.36 Tree</p>
</div>
<div id="example-special-case-dag-2" class="execAction coloured-menu-option" style="float: right;" onClick="example(DAG)">
<p>Another DAG</p>
</div>
<div id="example-special-case-dag-1" class="execAction coloured-menu-option" style="float: right;" onClick="example(RAIL)">
<p>RAIL (DAG)</p>
</div>
</div>
</div>
<div id="examples-err" class="err" style="float: left;"></div>
</div>
<div class="bellmanford action-menu-pullout">
<div id="bellmanford-input" class="new-menu-option">
s = <input id="bellmanford-v" type="number" title="Enter the source vertex" autocomplete="off" min="0" max="99" value="0"> </div>
<div id="bellmanford-go" class="execAction new-menu-option coloured-menu-option" onClick="bellmanford()">
<p>Go</p>
</div>
<div id="bellmanford-err" class="err" style="float: left;"></div>
</div>
<div class="bfs action-menu-pullout">
<div id="bfs-input" class="new-menu-option">
s = <input id="bfs-v" type="number" title="Enter the source vertex" autocomplete="off" min="0" max="99" value="0"> </div>
<div id="bfs-go" class="execAction new-menu-option coloured-menu-option" onClick="bfs()">
<p>Go</p>
</div>
<div id="bfs-err" class="err" style="float: left;"></div>
</div>
<div class="dijkstra action-menu-pullout">
<div id="dijkstra-input" class="new-menu-option">
s = <input id="dijkstra-v" type="number" title="Enter the source vertex" autocomplete="off" min="0" max="99" value="0"> </div>
<div id="dijkstra-go-1" class="execAction new-menu-option coloured-menu-option" onClick="dijkstra(1)">
<p>Original</p>
</div>
<div id="dijkstra-go-2" class="execAction new-menu-option coloured-menu-option" onClick="dijkstra(2)">
<p>Modified</p>
</div>
<div id="dijkstra-err" class="err" style="float: left;"></div>
</div>
<div class="dfs action-menu-pullout">
<div id="dfs-input" class="new-menu-option">
s = <input id="dfs-v" type="number" title="Enter the source vertex" autocomplete="off" min="0" max="99" value="0"> </div>
<div id="dfs-go" class="execAction new-menu-option coloured-menu-option" onClick="dfs()">
<p>Go</p>
</div>
<div id="dfs-err" class="err" style="float: left;"></div>
</div>
<div class="dp action-menu-pullout">
<div id="dp-input" class="new-menu-option">
s = <input id="dp-v" type="number" title="Enter the source vertex" autocomplete="off" min="0" max="99" value="0"> </div>
<div id="dp-go" class="execAction new-menu-option coloured-menu-option" onClick="dp()">
<p>Go</p>
</div>
<div id="dp-err" class="err" style="float: left;"></div>
</div>
</div>

<div id="drawgraph" class="overlays"></div>
</div>

<div id="bottom-bar">
<a id="scale" style="display: none;">1.0x</a>
<a id="trigger-about">About</a>
<a id="trigger-team">Team</a>
<a id="trigger-terms">Terms of use</a>
<a id="trigger-privacy">Privacy Policy</a>
</div>
<div id="about" class="overlays">
<h4>About</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.</p><p>Featuring numerous advanced algorithms discussed in Dr. Steven Halim&#39;s book, &#39;Competitive Programming&#39; — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.</p><p>While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.</p><p>Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.</p><p>VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.</p><p>Equipped with a built-in question generator and answer verifier, VisuAlgo&#39;s "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students&#39; answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students&#39; mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.</p><p>VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:</p>
<a href="https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689" target="_blank"><u>id</u></a>,
<a href="http://blog.naver.com/visualgo_nus" target="_blank"><u>kr</u></a>,
<a href="https://www.facebook.com/groups/163215593699283/permalink/824003417620494/" target="_blank"><u>vn</u></a>,
<a href="http://pantip.com/topic/32736343" target="_blank"><u>th</u></a>.
</div>
</div>
<div id="team" class="overlays">
<h4>Team</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>
<strong><span style="line-height: 150%;">Project Leader &amp; Advisor (Jul 2011-present)</span></strong><br>
<a href="https://www.comp.nus.edu.sg/~stevenha/" target="_blank">Associate Professor Steven Halim</a>, School of Computing (SoC), National University of Singapore (NUS)<br>
<a href="https://www.linkedin.com/in/felixhalim/" target="_blank">Dr Felix Halim</a>, Senior Software Engineer, Google (Mountain View)
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 1</span></strong><br>
<b>CDTL TEG 1: Jul 2011-Apr 2012</b>: Koh Zi Chun, Victor Loh Bo Huai
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 1</span></strong><br>
<b>Jul 2012-Dec 2013</b>: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang Duy<br>
<b>Jun 2013-Apr 2014</b> <a href="https://www.rosemarietan.com/" target="_blank">Rose Marie Tan Zhao Yun</a>, Ivan Reinaldo
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 2</span></strong><br>
<b>CDTL TEG 2: May 2014-Jul 2014</b>: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 2</span></strong><br>
<b>Jun 2014-Apr 2015</b>: Erin Teo Yi Ling, Wang Zi<br>
<b>Jun 2016-Dec 2017</b>: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin Mudzakir<br>
<b>Aug 2021-Apr 2023</b>: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius<br>
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 3</span></strong><br>
<b>Optiver: Aug 2023-Oct 2023</b>: Bui Hong Duc, Oleh Naver, Tay Ngan Lin<br>
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 3</span></strong><br>
<b>Aug 2023-Apr 2024</b>: Xiong Jingya, Radian Krisno, Ng Wee Han<br>
</p>
<p>
List of translators who have contributed &ge; 100 translations can be found at <a href="https://visualgo.net/statistics">statistics</a> page.
</p>
<p>
<strong><span style="line-height: 150%;">Acknowledgements</span></strong><br>
NUS <a href="https://nus.edu.sg/cdtl" target="_blank"><u>CDTL</u></a> gave Teaching Enhancement Grant to kickstart this project.<div>For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.</div>
</p>
</div>
</div>
<div id="termsofuse" class="overlays">
<h4>Terms of use</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that you <b>spread the word about its existence to fellow Computer Science students and instructors</b>. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.</p><p>Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (<a href="https://visualgo.net/">https://visualgo.net</a>) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo&#39;s client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.</p><p>Please note that VisuAlgo&#39;s online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the &#39;training mode.&#39; The &#39;test mode&#39; offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.</p><p><strong><span style="line-height: 200%;">List of Publications</span></strong></p> <p>This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can click <a href="https://ioinformatics.org/journal/INFOL099.pdf" target="_blank">this link</a> to read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) and <a href="https://ioinformatics.org/journal/v9_2015_243_245.pdf" target="_blank">this link</a> for the short update in 2015 (to link VisuAlgo name with the previous project).</p><p><strong><span style="line-height: 200%;">Bug Reports or Request for New Features</span></strong></p> <p>VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.</p>
</div>
</div>
<div id="privacy-policy" class="overlays">
<h4>Privacy Policy</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p><b>Version 1.2 (Updated Fri, 18 Aug 2023).</b></p><p>Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.</p><p>Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).</p><p>Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.</p><p>For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.<br></p><p>For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.</p>
</div>
</div>
</div>


<script src="../../code.jquery.com/jquery-3.7.0.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
<script src="../../cdn.jsdelivr.net/npm/bootstrap%405.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<script src="../../unpkg.com/d3-force-boundary%400.0.1/dist/d3-force-boundary.min.js"></script>
<script>
  $(function () {
    // overlays stuffs
    $('#trigger-about').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#about').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-team').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#team').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-terms').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#termsofuse').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-privacy').click(function () {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#privacy-policy').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    })

    $('.close-overlay').click(function() {
      $('.overlays').fadeOut(function() {
        $('#dark-overlay').fadeOut();
      });
    });

    $('#dark-overlay').click(function() {
      $('.overlays').fadeOut();
      $('#dark-overlay').fadeOut();
      if (typeof GeometryWidget !== 'undefined') {
        GeometryWidget.stopLoop();
      }
    });
  })
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-1566631-4"></script>
<script>
      $.ajaxSetup({
        headers: {
          'X-CSRF-TOKEN': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H"
        }
      });

      // handles account dropdown menu
      $(function () {
        $('#language-dropdown-btn').click(function (e) {
          $('#language-dropdown-menu').css('display', 'block');
          $('#account-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function () {
          $('#language-dropdown-menu').css('display', 'none')
        })
      })

      $(function () {
        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        })
      })

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        if (retval) {
          $('#current-action').show();
          $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
          $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
          triggerRightPanels();
          isPlaying = true;
        }
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; ++i) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      const MOBILE_WIDTH = 1000;
      const matchMediaMobile = window.matchMedia(`only screen and (max-width: ${MOBILE_WIDTH}px)`);
      const matchMediaNarrow = window.matchMedia(`only screen and (max-width: 500px)`);
      function isMobile() {
        return matchMediaMobile.matches;
      }
      //To fix the issue of a narrow desktop window being asked to rotate, I am now checking for it based on the navigator.userAgent to see if its mobile or not.
      //This may change in the future if browsers decide to change the naming of userAgent for mobile browsers so may need to keep an eye on this.
      function isMobileOS() {
        return /Mobi/i.test(navigator.userAgent) && !/ipad/i.test(navigator.userAgent);
      }
      let portraitMatcher = window.matchMedia("(orientation:portrait)");
      function isPortrait() {
        return portraitMatcher.matches;
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.colour').css("color", surpriseColour);
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
        });
      });

/*
      // GA dropped 26 Jun 2023 and then made official on 18 Aug 2023
/*
      // the sunset-ed GA, commented on 26 Jun 2023, and Prof Halim doesn't bother to use anymore
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
*/

      // function setCookie(cname, cvalue, exdays) {
      //   const d = new Date();
      //   d.setTime(d.getTime() + (exdays*24*60*60*1000));
      //   let expires = "expires="+ d.toUTCString();
      //   document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
      // }

//       //         $(function() {
//           $('#gdpr-accept').click(function () {
// /*
//             // added on 26 Jun 2023
//             window.dataLayer = window.dataLayer || [];
//             function gtag(){dataLayer.push(arguments);}
//             gtag('js', new Date());

//             gtag('config', 'UA-1566631-4');
// */
// //            ga('create', 'UA-1566631-4', 'auto');
// //            ga('send', 'pageview');
//             setCookie('use_google_analytics', 'true', 365)
//             $('#gdpr-popup').hide()
//           });
//           $('#gdpr-reject').click(function () {
//             setCookie('use_google_analytics', 'false', 365)
//             $('#gdpr-popup').hide()
//           });
//         });
//       
      $('#gdpr-privacy-policy').click(function () {
        if ($(window).width() > 600) {
          $('#dark-overlay').fadeIn(function() {
            $('#privacy-policy').fadeIn();
          });
        }
        else
          alert('Sorry, this dialog is too big. Please load it on bigger screen');
      })
    </script>

<script src="../js/jquery-ui.min.js"></script>

<script src="../js/d3.min.js"></script>
<script src="../js/viz-1.0.10.js"></script>

<script src="../js/graph_library/constant.js"></script>
<script src="../js/graph_library/drawgraph.js"></script>
<script src="../js/graph_library/GraphEdgeWidget.js"></script>
<script src="../js/graph_library/GraphPolygonWidget.js"></script>
<script src="../js/graph_library/GraphVertexWidget.js"></script>
<script src="../js/graph_library/GraphWidget.js"></script>
<script src="../js/graph_library/helperObjects89db.js?refresh22aug9pm"></script> 
<script src="../js/graph_library/misc.js"></script>
<script src="../js/graph_library/properties.js"></script>
<script src="../js/graph_library/Widget.js"></script>
<script src="../js/graph_library/force_directed_library.js"></script>

<script>
      $(function () {
        let defaultPlaybackSpeed = 1;
                createPlaybackSpeedSlider(defaultPlaybackSpeed);


        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        });
        //Mobile Design Related DOM Manipulations
        if (isMobile()) {
          $("#status").css({
            "bottom": "10%",
            "height": "12%",
            "max-height": "54px"
          });
          $("#current-action").css("bottom", "22%");
          $('#status-hide').remove();
          $('#left-bar').remove();
          $('#right-bar').remove();
          $("#mode-menu").remove();
          $("#codetrace").css("z-index", 1);
          $("#bottom-bar a").hide();
          $("#bottom-bar").css("height", $("#topbar").css("height"));
          $(".speed-dropup-btn").show();
          $("#go-to-beginning").remove();
          $("#go-to-end").remove();
          $("#pause").remove();
          $("#play").remove();
          $("#previous").remove();
          $("#next").remove();

          //make progress bar longer
          $("#progress-bar").css({
            left: "30%",
            width: "60%",
            'margin-left': 0
          })
        }
      })

      let mobilePlaybackOverlayTimeout;
      $(function() {
        $("#viz").on("click", () => {
          if (isMobile()) {
            if ($("#mobile-playback-overlay").is(":hidden") && isPlaying) {
              $("#mobile-playback-overlay").fadeIn();
              hideMobilePlaybackOverlay(6000);
            } else {
              $("#mobile-playback-overlay").fadeOut();
            }
          }
        });
        $("#mobile-playback-overlay").on("click", (event) => {
          if (event.target === event.currentTarget) //to ensure clicks on the controls dont fade the overlay
            $("#mobile-playback-overlay").fadeOut();
          else
            hideMobilePlaybackOverlay(5000);
        })
      });
      function hideMobilePlaybackOverlay(timeOut) {
        if (mobilePlaybackOverlayTimeout)
          clearTimeout(mobilePlaybackOverlayTimeout);
        mobilePlaybackOverlayTimeout = setTimeout(() => {
            $("#mobile-playback-overlay").fadeOut();
        }, timeOut);
      }
      function mobilePlaybackPauseOrPlay() {
        if ($("#mobile-playback-overlay").hasClass("playing")) {
          pause();
          hideMobilePlaybackOverlay(5000);
        } else {
          play();
          hideMobilePlaybackOverlay(3000);
        }
      }
      let rewindLabelTimeout, forwardLabelTimeout;
      function mobilePlaybackRewind() {
        $("#mobile-playback-rewind-label").css("opacity", 1);
        if (rewindLabelTimeout)
          clearTimeout(rewindLabelTimeout);
        rewindLabelTimeout = setTimeout(() => {
          $("#mobile-playback-rewind-label").css("opacity", 0);
        }, 800);
        stepBackward(7);
      }
      function mobilePlaybackForward() {
        $("#mobile-playback-forward-label").css("opacity", 1);
        if (forwardLabelTimeout)
          clearTimeout(forwardLabelTimeout);
        forwardLabelTimeout = setTimeout(() => {
          $("#mobile-playback-forward-label").css("opacity", 0);
        }, 800);
        stepForward(7);
      }

      //let eLectureSessionHistory = {};
      const sectorColors = ['#05a4d0', '#f1c706', '#fa0202'];
      function setSlideTimelineColor(slideNo) {
        const sectionNo = slideNo.split('-')[0];
        $(`[slideNo="${slideNo}"]`).css('background', sectorColors[(parseInt(sectionNo) % 3)]);
      }

      let currSlideTimer = null; //global so that we can clear the timeout when required

      const lectureIds = [{"id":49,"category":"sssp","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:10:48","updated_at":"2023-11-09 08:34:12","section":-1,"code":"","section_order":-1,"value":"1","text":"<p>In the <strong>Single-Source Shortest Paths (SSSP)<\/strong> problem, we aim to find the shortest paths weights (and the actual paths) from a particular single-source vertex to all other vertices in a directed weighted graph (if such paths exist).<\/p><br><p>The SSSP problem is a(nother) very <b>well-known<\/b> Computer Science (CS) problem that <b>every<\/b> CS students worldwide need to be aware of and hopefully master.<\/p><br><p>The SSSP problem has several different efficient (polynomial) algorithms (e.g., Bellman-Ford, BFS, DFS, Dijkstra \u2014 2 versions, and\/or Dynamic Programming) that can be used depending on the nature of the input directed weighted graph, i.e. weighted\/unweighted, with\/without (negative weight) cycle, or structurally special (a tree\/a DAG).<\/p>","title":"Single-Source Shortest Paths (SSSP)"},{"id":433,"category":"sssp","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-18 13:38:22","updated_at":"2023-11-09 08:34:16","section":49,"code":"","section_order":1,"value":"1-1","text":"<p>SSSP is one of the most frequent graph problem encountered in real-life. Every time we want to move from one place (usually our current location) to another (our destination), we will try to pick a short \u2014 if not the shortest \u2014 path.<\/p><br><p>SSSP algorithm(s) is embedded inside various map software like <a href=\"https:\/\/map.google.com\" target=\"_blank\"><u>Google Maps<\/u><\/a> and in various Global Positioning System (GPS) tool.<\/p>","title":"Motivation"},{"id":432,"category":"sssp","order":2,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-18 13:38:08","updated_at":"2023-11-09 08:34:18","section":49,"code":"","section_order":1,"value":"1-2","text":"<p>Input 1: A directed weighted graph G(V, E), not necessarily connected, where <b>V<\/b>\/vertices can be used to describe intersections, junctions, houses, landmarks, etc and <b>E<\/b>\/edges can be used to describe streets, roads, avenues with proper direction and weight\/cost.<\/p><br><p>Input 2: As the name implies, the SSSP problem has another input: A source vertex <b>s<\/b> \u2208 <b>V<\/b>.<\/p>","title":"SSSP Problem - Two Inputs"},{"id":451,"category":"sssp","order":3,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-22 13:55:07","updated_at":"2023-11-09 08:34:21","section":49,"code":"","section_order":1,"value":"1-3","text":"<p>The objective of the SSSP problem is to find the shortest path weight from <b>s<\/b> to each vertex <b>u<\/b> \u2208 <b>V<\/b>, denoted as <b>\u03b4(s, u)<\/b> (\u03b4 is pronounced as &#39;delta&#39;) and also the actual shortest path from <b>s<\/b> to <b>u<\/b>.<\/p><br><p>The path weight of a path <b>p<\/b> is simply the summation of edge weights along that path.<\/p><br><p>The weight of the shortest path from <b>s<\/b> to <b>s<\/b> is trivial: 0.<br>The weight of the shortest path from <b>s<\/b> to any unreachable vertex is also trivial: +\u221e.<\/p><br><p>PS: The weight of the shortest path from <b>s<\/b> to <b>v<\/b> where <b>(s, v) \u2208 E<\/b> does not necessarily the weight of <b>w(s, v)<\/b>. See the next few slides to realise this.<\/p>","title":"SSSP Problem - Output"},{"id":434,"category":"sssp","order":4,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-18 14:04:06","updated_at":"2023-11-09 08:34:23","section":49,"code":"","section_order":1,"value":"1-4","text":"<p>The outputs of all six (6) SSSP algorithms for the SSSP problem discussed in this visualization are these two arrays\/Vectors:<\/p><ol><li>An array\/Vector <b>D<\/b> of size <b>V<\/b> (<b>D<\/b> stands for &#39;distance&#39;)<br>Initially, <b>D[u]<\/b> = 0 if <b>u<\/b> = <b>s<\/b>; otherwise <b>D[u]<\/b> = +\u221e (a large number, e.g. 10<sup>9<\/sup>)<br><b>D[u]<\/b> decreases as we find better (shorter) paths<br><b>D[u]<\/b> \u2265 <b>\u03b4(s, u)<\/b> throughout the execution of SSSP algorithm<br><b>D[u]<\/b> = <b>\u03b4(s, u)<\/b> at the end of SSSP algorithm<\/li><li>An array\/Vector <b>p<\/b> of size <b>V<\/b> (p stands for &#39;parent&#39;\/&#39;predecessor&#39;\/&#39;previous&#39;)<br><b>p[u]<\/b> = the predecessor on best path from source <b>s<\/b> to <b>u<\/b><br><b>p[u]<\/b> = NULL (not defined, we can use a value like -1 for this)<br>This array\/Vector <b>p<\/b> describes the resulting SSSP spanning tree<\/li><\/ol>","title":"SSSP Problem - Output Variables"},{"id":435,"category":"sssp","order":5,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-18 14:13:40","updated_at":"2022-11-20 10:45:25","section":49,"code":"example(CP3_4_17);","section_order":1,"value":"1-5","text":"<p>Initially, <b>D[u]<\/b> = +\u221e (practically, a large value like 10<sup>9<\/sup>) \u2200<b>u<\/b> \u2208 <b>V&bsol;{s}<\/b>, but <b>D[s]<\/b> = <b>D[0]<\/b> = 0.<br>Initially, <b>p[u]<\/b> = -1 (to say &#39;no predecessor&#39;) \u2200<b>u<\/b> \u2208 <b>V<\/b>.<\/p><br><p>Now click <span class=\"slide-actions\" onclick=\"doButtonAction70()\">Dijkstra(0)<\/span> \u2014 don&#39;t worry about the details as they will be explained later \u2014 and wait until it is over (approximately 10s on this small graph).<\/p><br><p>At the end of that SSSP algorithm, <b>D[s]<\/b> = <b>D[0]<\/b> = 0 (unchanged) and <b>D[u]<\/b> = <b>\u03b4(s, u)<\/b> \u2200<b>u<\/b> \u2208 <b>V<\/b><br>e.g. <b>D[2]<\/b> = 6, <b>D[4]<\/b> = 7 (these values are stored as <span style=\"color: red;\">red text<\/span> under each vertex).<br>At the end of that SSSP algorithm, <b>p[s]<\/b> = <b>p[0]<\/b> = -1 (the source has no predecessor), but <b>p[v]<\/b> = the origin of the <span style=\"color: red;\">red edges<\/span> for the rest, e.g. <b>p[2]<\/b> = 0, <b>p[4] = 2<\/b>.<\/p><br><p>Thus, if we are at <b>s<\/b> = 0 and want to go to vertex 4, we will use shortest path 0 \u2192 2 \u2192 4 with path weight 7.<\/p>","title":"Example with s = 0"},{"id":441,"category":"sssp","order":6,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-22 01:51:43","updated_at":"2017-05-22 13:55:12","section":49,"code":"example(CP3_4_19);","section_order":1,"value":"1-6","text":"<p>Some graphs contain <b>negative weight edge(s)<\/b> (not necessarily cyclic) and\/or <b>negative weight cycle(s)<\/b>. For example (fictional): Suppose you can travel forward in time (normal, edges with positive weight) or back in time by passing through time tunnel (special wormhole edges with negative weight), as the example shown above.<\/p><br><p>On that graph, the shortest paths from the source vertex <b>s<\/b> = 0 to vertices {1, 2, 3} are all <b>ill-defined<\/b>. For example 1 &rarr; 2 &rarr; 1 is a negative weight <b>cycle<\/b> as it has negative total path (cycle) weight of 15-42 = -27. Thus we can cycle around that negative weight cycle 0 &rarr; <u>1 &rarr; 2 &rarr; 1 &rarr; 2 <\/u> &rarr; ... forever to get overall ill-defined shortest path weight of -&#x221e;.<\/p><br><p>However, notice that the shortest path from the source vertex <b>s<\/b> = 0 to vertex 4 is ok with &delta;(0, 4) = -99. So the presence of negative weight <b>edge(s)<\/b> is not the <b>main<\/b> issue. The main issue is the presence of negative weight <b>cycle(s)<\/b> reachable from source vertex <b>s<\/b>.<\/p>","title":"Ill-Defined Case"},{"id":453,"category":"sssp","order":7,"top":"230px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-23 03:07:22","updated_at":"2017-05-23 03:12:45","section":49,"code":"loadGraph({\n  'vl': {\n    0: { \"x\": 300, \"y\": 100 },\n    1: { \"x\": 400, \"y\": 50 },\n    2: { \"x\": 500, \"y\": 100 }\n  },\n  'el': {\n    0: { \"u\": 0, \"v\": 1, \"w\": 4 },\n    1: { \"u\": 0, \"v\": 2, \"w\": 9 },\n    2: { \"u\": 1, \"v\": 2, \"w\": 4 }\n  }\n});","section_order":1,"value":"1-7","text":"<p>The main operation for all SSSP algorithms discussed in this visualization is the <samp>relax(u, v, w(u, v))<\/samp> operation with the following pseudo-code:<\/p><pre>relax(u, v, w_u_v)<br>  if D[v] &gt; D[u]+w_u_v \/\/ if the path can be shortened<br>    D[v] = D[u]+w_u_v \/\/ we &#39;relax&#39; this edge<br>    p[v] = u \/\/ remember\/update the predecessor<br>    \/\/ update some other data structure(s) as necessary<\/pre><p>For example, see <samp>relax(1,2,4)<\/samp> operation on the figure below: <img src=\"https:\/\/visualgo.net\/img\/relax.png\" width=\"500\" alt=\"relax operation example\"><\/p>","title":"Main Operation: relax(u, v, w(u, v))"},{"id":51,"category":"sssp","order":2,"top":"","right":"","bottom":"330px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:12:19","updated_at":"2023-11-09 08:36:21","section":-1,"code":"$(\"#draw\").addClass(\"menu-highlighted\");\n$(\"#examples\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"2","text":"<p>There are two different sources for specifying an input graph:<\/p><ol><li><b>Edit Graph<\/b>: You can draw, edit, or import&nbsp;<strong>any<\/strong> directed weighted graph as the input graph.<\/li><li><b>Example Graphs<\/b>: You can select from the list of our selected example graphs to get you started. These example graphs have different characteristics.<\/li><\/ol>","title":"Input Graph"},{"id":436,"category":"sssp","order":3,"top":"","right":"","bottom":"330px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-18 14:48:07","updated_at":"2023-11-09 08:36:36","section":-1,"code":"$(\"#bellmanford\").click().addClass(\"menu-highlighted\");\n$(\"#bfs\").addClass(\"menu-highlighted\");\n$(\"#dijkstra\").addClass(\"menu-highlighted\");\n$(\"#dfs\").addClass(\"menu-highlighted\");\n$(\"#dp\").addClass(\"menu-highlighted\");","section_order":-1,"value":"3","text":"<p>In this visualization, we will discuss 6 (SIX) SSSP algorithms.<\/p><br><p>We will start with the O(<b>V\u00d7E<\/b>) Bellman-Ford algorithm first as it is the most versatile (but also the slowest) SSSP algorithm. We will then discuss 5 (FIVE) other algorithms (including two variants of Dijkstra&#39;s algorithm) that solve <b>special-cases<\/b> of SSSP problem in a much faster manner.<\/p>","title":"SSSP Algorithms"},{"id":52,"category":"sssp","order":4,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:12:47","updated_at":"2017-05-22 15:12:37","section":-1,"code":"$(\"#bellmanford\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_17);","section_order":-1,"value":"4","text":"<p>The general purpose <b>Bellman-Ford algorithm<\/b> can solve <b>all kinds<\/b> of valid SSSP problem variants (expect one \u2014 the one that is ill-defined anyway, to be discussed soon), albeit with a <b>rather slow<\/b> O(<b>V\u00d7E<\/b>) running time. It also has an extremely simple pseudo-code:<\/p><pre>for i = 1 to |V|-1 \/\/ O(V) here, so O(V\u00d7E\u00d71) = O(V\u00d7E)<br>  for each edge(u, v) \u2208 E \/\/ O(E) here, e.g. by using an Edge List<br>    relax(u, v, w(u, v)) \/\/ O(1) here<\/pre><p>Without further ado, let&#39;s see a preview of how it works on the example graph above by clicking <span class=\"slide-actions\" onclick=\"doButtonAction71()\">BellmanFord(0)<\/span> (\u224830s, and for now, please ignore the additional loop at the bottom of the pseudo-code).<\/p>","title":"O(V&times;E) Bellman-Ford Algorithm"},{"id":442,"category":"sssp","order":1,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-22 02:08:31","updated_at":"2017-10-27 06:26:03","section":52,"code":"$(\"#bellmanford\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_17);","section_order":4,"value":"4-1","text":"<p>Bellman-Ford algorithm can be made to run slightly faster on normal input graph, from the worst case of O(<b>V\u00d7E<\/b>) to just O(<b>k\u00d7E<\/b>) where <b>k<\/b> is the number of iterations of the outer loop of Bellman-Ford.<\/p><br><p>Discussion: How to do this? Is the speed-up significant?<\/p>","title":"Optimized Form: O(k&times;E)"},{"id":448,"category":"sssp","order":2,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-22 02:51:12","updated_at":"2017-10-27 06:26:35","section":52,"code":"$(\"#bellmanford\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_17);","section_order":4,"value":"4-2","text":"<p>The answer is actually already included inside the visualization. On the example graph, if we run <span class=\"slide-actions\" onclick=\"doButtonAction71()\">BellmanFord(0)<\/span>, notice that only the first two passes change some <b>D<\/b> values and at the third pass (<b>k = 3<\/b>) nothing changes. So we can actually stop there as nothing else will change in the subsequent passes until the |<b>V<\/b>|-1-th pass.<\/p><br><p>However, on worst case input graph (see <a href=\"?slide=4-8\"><u>this<\/u><\/a>, the worst case time complexity remains O(<b>V\u00d7E<\/b>)).<\/p>","title":"The Answer"},{"id":444,"category":"sssp","order":3,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-22 02:14:57","updated_at":"2017-10-27 06:26:35","section":52,"code":"$(\"#bellmanford\").click().addClass(\"menu-highlighted\");","section_order":4,"value":"4-3","text":"<p>To convince the worldwide audience that Bellman-Ford algorithm works, let&#39;s temporarily move from visualization mode to proof mode for a few slides.<\/p><br><p>Theorem 1: If G = (V, E) contains <b>no negative weight cycle<\/b>, then the shortest path <b>p<\/b> from source vertex <b>s<\/b> to a vertex <b>v<\/b> must be a <b>simple path<\/b>.<\/p><br><p>Recall: A simple path is a path <b>p = {v<sub>0<\/sub>, v<sub>1<\/sub>, v<sub>2<\/sub>, ..., v<sub>k<\/sub>}<\/b>, (<b>v<sub>i<\/sub><\/b>, <b>v<sub>i+1<\/sub><\/b>) \u2208 <b>E<\/b>, \u2200 0 \u2264 <b>i<\/b> \u2264 (<b>k<\/b>-1) and there is <b>no<\/b> repeated vertex along this path.<\/p>","title":"T.1: Shortest Paths are Simple Paths*"},{"id":445,"category":"sssp","order":4,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-22 02:19:09","updated_at":"2018-04-04 03:47:40","section":52,"code":"$(\"#bellmanford\").click().addClass(\"menu-highlighted\");","section_order":4,"value":"4-4","text":"<ol><li>Suppose the shortest path <b>p<\/b> is <b>not<\/b> a simple path<\/li><li>Then <b>p<\/b> must contains one (or more) cycle(s) (by definition of non-simple path)<\/li><li>Suppose there is a cycle <b>c<\/b> in <b>p<\/b> with <b>positive weight<\/b> (e.g.,&nbsp;<span style=\"color: green;\">green<\/span> \u2192 <span style=\"color: lightblue;\">blue<\/span> \u2192 <span style=\"color: green;\">green<\/span> on the left image) <img src=\"https:\/\/visualgo.net\/img\/cycle.png\" alt=\"cycle\" width=\"400&quot;\"><\/li><li>If we remove <b>c<\/b> from <b>p<\/b>, then we will have a shorter &#39;shortest path&#39; than our shortest path <b>p<\/b><\/li><li>A glaring contradiction, so <b>p<\/b> must be a simple path<\/li><\/ol>","title":"Proof by Contradiction - Part 1"},{"id":450,"category":"sssp","order":5,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-22 13:12:31","updated_at":"2018-04-04 03:47:43","section":52,"code":"$(\"#bellmanford\").click().addClass(\"menu-highlighted\");\nexample(BELLMANFORD_KILLER);","section_order":4,"value":"4-5","text":"<ol start=\"6\"><li>Even if <b>c<\/b> is actually a cycle with <b>zero (0) total weight<\/b> \u2014 it is possible according to our Theorem 1 assumption: no negative weight cycle (see the same <span style=\"color: green;\">green<\/span> \u2192 <span style=\"color: lightblue;\">blue<\/span> \u2192 <span style=\"color: green;\">green<\/span> but on the right image), we can still remove <b>c<\/b> from <b>p<\/b> without increasing the shortest path weight of <b>p<\/b> <img src=\"https:\/\/visualgo.net\/img\/cycle.png\" alt=\"cycle\" width=\"400&quot;\"><\/li><li>In conclusion, <b>p<\/b> is a simple path (from point 5) or can always be made into a simple path (from point 6)<\/li><\/ol><p>In another word, shortest path <b>p<\/b> has at most |<b>V<\/b>|-1 edges from the source vertex <b>s<\/b> to the &#39;furthest possible&#39; vertex <b>v<\/b> in <b>G<\/b> (in terms of number of edges in the shortest path \u2014 see the Bellman-Ford Killer example above).<\/p>","title":"Proof by Contradiction - Part 2"},{"id":446,"category":"sssp","order":6,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-22 02:33:34","updated_at":"2017-10-27 06:26:35","section":52,"code":"$(\"#bellmanford\").click().addClass(\"menu-highlighted\");","section_order":4,"value":"4-6","text":"<p>Theorem 2: If G = (V, E) contains <b>no negative weight cycle<\/b>, then after Bellman-Ford algorithm terminates, we will have <b>D[u]<\/b> = <b>\u03b4(s, u)<\/b>, \u2200 <b>u<\/b> \u2208 <b>V<\/b>.<\/p><br><p>For this, we will use <b>Proof by Induction<\/b> and here are the starting points:<\/p><br><p>Consider the shortest path <b>p<\/b> from source vertex <b>s<\/b> to vertex <b>v<sub>i<\/sub><\/b> where <b>v<sub>i<\/sub><\/b> is defined as a vertex which the actual shortest path to reach it requires <b>i<\/b> hops (edges) from source vertex <b>s<\/b>. Recall from Theorem 1 that <b>p<\/b> will be simple path as we have the same assumption of <b>no negative weight cycle<\/b>.<\/p>","title":"T.2: Bellman-Ford Algorithm is Correct"},{"id":447,"category":"sssp","order":7,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-22 02:38:06","updated_at":"2018-04-04 03:47:45","section":52,"code":"$(\"#bellmanford\").click().addClass(\"menu-highlighted\");\nexample(BELLMANFORD_KILLER);","section_order":4,"value":"4-7","text":"<ol><li>Initially, <b>D[v<sub>0<\/sub>] = \u03b4(s, v<sub>0<\/sub>) = 0<\/b>, as v<sub>0<\/sub> is just the source vertex <b>s<\/b><\/li><li>After <b>1<\/b> pass through <b>E<\/b>, we have <b>D[v<sub>1<\/sub>] = \u03b4(s, v<sub>1<\/sub>)<\/b><\/li><li>After <b>2<\/b> pass through <b>E<\/b>, we have <b>D[v<sub>2<\/sub>] = \u03b4(s, v<sub>2<\/sub>)<\/b><\/li><li>...<\/li><li>After <b>k<\/b> pass through <b>E<\/b>, we have <b>D[v<sub>k<\/sub>] = \u03b4(s, v<sub>k<\/sub>)<\/b><\/li><li>When there is no negative weight cycle, the shortest path <b>p<\/b> is a simple path (see Theorem 1), thus the last iteration should be iteration |<b>V<\/b>|-1<\/li><li>After |<b>V<\/b>|-1 pass through <b>E<\/b>, we have <b>D[v<sub>|V|-1<\/sub>] = \u03b4(s, v<sub>|V|-1<\/sub>)<\/b>, regardless the ordering of edges in <b>E<\/b> \u2014 see the Bellman-Ford Killer example above<\/li><\/ol>","title":"Proof by Induction"},{"id":443,"category":"sssp","order":8,"top":"180px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-22 02:08:43","updated_at":"2017-10-27 06:26:34","section":52,"code":"$(\"#bellmanford\").click().addClass(\"menu-highlighted\");\nexample(BELLMANFORD_KILLER);","section_order":4,"value":"4-8","text":"<p>Try running <span class=\"slide-actions\" onclick=\"doButtonAction71()\">BellmanFord(0)<\/span> on the &#39;Bellman-Ford Killer&#39; example above. There are <b>V<\/b> = 7 vertices and <b>E<\/b> = 6 edges but the edge list <b>E<\/b> is configured to be at its worst possible order. Notice that after (<b>V<\/b>-1)\u00d7<b>E<\/b> = (7-1)*6 = 36 operations (~40s, be patient), Bellman-Ford will terminate with the correct answer and there is no way we can terminate Bellman-Ford algorithm earlier.<\/p>","title":"Worst Case Behavior"},{"id":438,"category":"sssp","order":9,"top":"250px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-22 01:02:56","updated_at":"2017-05-22 13:12:33","section":52,"code":"$(\"#bellmanford\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_19);","section_order":4,"value":"4-9","text":"<p>The only input graph that Bellman-Ford algorithm has issue is the input graph with negative weight cycle reachable from the source vertex <b>s<\/b>.<\/p><br><p>However, Bellman-Ford can be used to detect if the input graph contains at least one negative weight cycle reachable from the source vertex <b>s<\/b> by using the corollary of Theorem 2: If at least one value <b>D[u]<\/b> fails to converge after |<b>V<\/b>|-1 passes, then there exists a negative-weight cycle reachable from the source vertex <b>s<\/b>.<\/p><br><p>Now run <span class=\"slide-actions\" onclick=\"doButtonAction71()\">BellmanFord(0)<\/span> on the example graph that contains negative edges and a negative weight cycle. Please concentrate on the loop at the bottom of the pseudo-code.<\/p>","title":"On Graph with -ve Weight Cycle"},{"id":439,"category":"sssp","order":5,"top":"","right":"","bottom":"330px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-22 01:07:06","updated_at":"2023-11-09 08:37:57","section":-1,"code":"$(\"#bfs\").addClass(\"menu-highlighted\");\n$(\"#dijkstra\").addClass(\"menu-highlighted\");\n$(\"#dfs\").addClass(\"menu-highlighted\");\n$(\"#dp\").addClass(\"menu-highlighted\");","section_order":-1,"value":"5","text":"<p>Sometimes, the actual problem that we face is <b>not the general form<\/b> of the original problem. Therefore in this e-Lecture, we want to highlight five (5) special cases involving the SSSP problem. When we encounter any one of them, we can solve it with <b>different<\/b> and <b>(much) faster<\/b> algorithm than the generic O(<b>V\u00d7E<\/b>) Bellman-Ford algorithm. They are:<\/p><ol><li>On Unweighted Graphs: O(<b>V<\/b>+<b>E<\/b>) BFS,<\/li><li>On Graphs without negative weight: O((<b>V<\/b>+<b>E<\/b>) log <b>V<\/b>) Dijkstra&#39;s algorithm,<\/li><li>On Graphs without negative weight cycle: O((<b>V<\/b>+<b>E<\/b>) log <b>V<\/b>) Modified Dijkstra&#39;s,<\/li><li>On Tree: O(<b>V<\/b>+<b>E<\/b>) DFS\/BFS,<\/li><li>On Directed Acyclic Graphs (DAG): O(<b>V<\/b>+<b>E<\/b>) Dynamic Programming (DP)<\/li><\/ol>","title":"Five Simplifying Assumptions"},{"id":54,"category":"sssp","order":6,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:13:30","updated_at":"2017-05-23 03:38:12","section":-1,"code":"$(\"#bfs\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_3);","section_order":-1,"value":"6","text":"<p>The O(<b>V<\/b>+<b>E<\/b>) <strong>Breadth-First Search (BFS)<\/strong> algorithm can solve <b>special case<\/b> of SSSP problem when the input graph is <b>unweighted<\/b> (all edges have unit weight 1, try <span class=\"slide-actions\" onclick=\"doButtonAction72()\">BFS(5)<\/span> on example: &#39;CP3 4.3&#39; above) or <b>positive constant weighted<\/b> (all edges have the same constant weight, e.g. you can change <b>all<\/b> edge weights of the example graph above with any positive constant weight of your choice).<\/p>","title":"Breadth-First Search"},{"id":454,"category":"sssp","order":1,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-23 03:35:04","updated_at":"2017-05-23 03:38:18","section":54,"code":"$(\"#bfs\").click().addClass(\"menu-highlighted\");\n","section_order":6,"value":"6-1","text":"<p>When the graph is <b>unweighted<\/b> \u2014 this appears quite frequently in real life \u2014 the SSSP problem can be viewed as a problem of finding the <b>least number of edges<\/b> traversed from the source vertex <b>s<\/b> to other vertices.<\/p><br><p>The BFS spanning tree from source vertex <b>s<\/b> produced by the fast O(<b>V<\/b>+<b>E<\/b>) BFS algorithm \u2014 notice the + sign \u2014 precisely fits the requirement.<\/p><br><p>Compared with the O(<b>V<\/b>\u00d7<b>E<\/b>) of Bellman-Ford \u2014 notice the \u00d7 sign \u2014 it is a no-brainer to use BFS for this special case of SSSP problem.<\/p>","title":"The Explanation"},{"id":455,"category":"sssp","order":2,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-23 03:42:43","updated_at":"2017-05-23 03:42:58","section":54,"code":"","section_order":6,"value":"6-2","text":"<p>Compared to the standard BFS in <a href=\".\/dfsbfs\"><u>Graph Traversal<\/u><\/a> module, we need to perform simple modifications to make BFS able to solve the unweighted version of the SSSP problem:<\/p><ol><li>First, we change the Boolean array <samp>visited<\/samp> into an Integer array <b>D<\/b>.<\/li><li>At the start of BFS, instead of setting <samp>visited[u] = false<\/samp>, we set <samp>D[u] = 1e9<\/samp> (a large number to symbolise +&#x221e; or even -1 to symbolise &#39;unvisited&#39; state, but we cannot use 0 as <samp>D[0] = 0<\/samp>) &forall;<b>u<\/b> &in; <b>V&#92;{s}<\/b>; Then we set <samp>D[s] = 0<\/samp><\/li><li>We change the BFS main loop from<br><samp>if (visited[v] = 0) { visited[v] = 1 ... } \/\/ v is unvisited<\/samp><br>to <br><samp>if (D[v] = 1e9) { D[v] = D[u]+1 ... } \/\/ v is 1 step away from u<\/samp><\/li><\/ol>","title":"Minor Implementation Tweak"},{"id":449,"category":"sssp","order":3,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-22 03:18:40","updated_at":"2017-05-23 03:42:46","section":54,"code":"$(\"#bfs\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_17);","section_order":6,"value":"6-3","text":"<p>However, BFS will very likely produce wrong answer when run on weighted graphs as BFS is not actually designed for to solve the weighted version of SSSP problem. There may be a case that taking a path with more number of edges used produces lower total overall path weight than taking a path with minimum number of edges used \u2014 which is the output of BFS algorithm.<\/p><br><p>In this visualization, we will allow you to run BFS even on &#39;wrong&#39; input graph for pedagogical purpose, but we will display a <b>warning message<\/b> at the end of the algorithm. For example, try <span class=\"slide-actions\" onclick=\"doButtonAction75()\">BFS(0)<\/span> on the general graph above and you will see that vertices {3,4} will have wrong D[3] and D[4] values (and also p[3] and p[4] values).<\/p><br><p>We will soon see Dijkstra&#39;s algorithm (2 implementation variants) for solving certain weighted SSSP problems in a faster way than the general Bellman-Ford algorithm.<\/p>","title":"Wrong Answer on General Graphs"},{"id":53,"category":"sssp","order":7,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:13:08","updated_at":"2022-11-20 10:47:36","section":-1,"code":"$(\"#dijkstra\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_17);","section_order":-1,"value":"7","text":"<p>The O((<b>V<\/b>+<b>E<\/b>) log <b>V<\/b>) <b>Dijkstra&#39;s algorithm<\/b> is the most frequently used SSSP algorithm for typical input: Directed weighted graph that has <b>no negative weight edge at all<\/b>, formally: <b>\u2200 edge(u, v) \u2208 E<\/b>, <b>w(u, v) \u2265 0<\/b>. Such weighted graph is very common in real life as travelling from one place to another always use positive time unit(s). Try <span class=\"slide-actions\" onclick=\"doButtonAction70()\">Dijkstra(0)<\/span> on one of the Example Graphs: CP4 4.16 shown above.<\/p>","title":"Dijkstra&#39;s Algorithm (Original Implementation)"},{"id":460,"category":"sssp","order":1,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-23 06:08:01","updated_at":"2017-05-23 06:26:37","section":53,"code":"$(\"#dijkstra\").click().addClass(\"menu-highlighted\");","section_order":7,"value":"7-1","text":"<p>Dijkstra&#39;s algorithm maintains a set <b>S<\/b> (Solved) of vertices whose final shortest path weights have been determined. Initially <b>S<\/b> = <b>{s}<\/b>, the source vertex <b>s<\/b> only.<\/p><br><p>Then, it repeatedly selects vertex <b>u<\/b> in <b>{V&#92;S}<\/b> with the minimum shortest path estimate, adds <b>u<\/b> to <b>S<\/b>, and relaxes all outgoing edges of <b>u<\/b>. Detailed proof of correctness of this Dijkstra&#39;s algorithm is usually written in typical Computer Science algorithm textbooks. For a simpler intuitive visual explanation on why this greedy strategy works, see <a href=\"https:\/\/www.quora.com\/What-is-the-simplest-intuitive-proof-of-Dijkstra%E2%80%99s-shortest-path-algorithm\" target=\"_blank\"><u>this<\/u><\/a>.<p><br><p>This entails the use of a Priority Queue as the shortest path estimates keep changing as more edges are processed. The choice of relaxing edges emanating from vertex with the minimum shortest path estimate first is <b>greedy<\/b>, i.e. use the \"best so far\", but we will see later that it can be proven that it will eventually ends up with an optimal result &mdash; if the graph has no negative weight edge.<\/p>","title":"Key Ideas"},{"id":461,"category":"sssp","order":2,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-23 06:15:35","updated_at":"2017-11-02 05:07:46","section":53,"code":"$(\"#dijkstra\").click().addClass(\"menu-highlighted\");","section_order":7,"value":"7-2","text":"<p>In Dijkstra&#39;s algorithm, each vertex will only be extracted from the Priority Queue (PQ) once. As there are <b>V<\/b> vertices, we will do this maximum O(<b>V<\/b>) times.<\/p><br><p>ExtractMin() operation runs in O(log <b>V<\/b>) whether the PQ is implemented using a <a href=\".\/heap\"><u>Binary Min Heap<\/u><\/a> or using a <a href=\".\/avl\"><u>balanced BST like AVL Tree<\/u><\/a>.<\/p><br><p>Therefore this part is O(<b>V<\/b> log <b>V<\/b>).<\/p>","title":"O((V+E) log V) Time Complexity - Part 1"},{"id":462,"category":"sssp","order":3,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-23 06:21:10","updated_at":"2017-11-02 05:07:46","section":53,"code":"$(\"#dijkstra\").click().addClass(\"menu-highlighted\");","section_order":7,"value":"7-3","text":"<p>Every time a vertex is processed, we relax its neighbors. In total, <b>E<\/b> edges are processed.<\/p><br><p>If by relaxing <b>edge(u, v)<\/b>, we have to decrease <b>D[v]<\/b>, we call the O(log <b>V<\/b>) DecreaseKey() operation in <a href=\".\/heap\"><u>Binary Min Heap<\/u><\/a> (harder to implement as C++ STL priority_queue\/Python heapq\/Java PriorityQueue does not support this operation efficiently <i>yet<\/i>) or simply delete the old entry and then re-insert a new entry in <a href=\".\/avl\"><u>balanced BST like AVL Tree<\/u><\/a> (which also runs in O(log <b>V<\/b>), but this is much easier to implement, just use C++ STL set\/Java TreeSet &mdash; unfortunately not natively supported in Python).<\/p><br><p>Therefore, this part is O(<b>E<\/b> log <b>V<\/b>).<\/p><br><p>Thus in overall, Dijkstra&#39;s algorithm runs in O(<b>V<\/b> log <b>V<\/b> + <b>E<\/b> log <b>V<\/b>) = O((<b>V<\/b>+<b>E<\/b>) log <b>V<\/b>) time, which is much faster than the O(<b>V&times;E<\/b>) Bellman-Ford algorithm.<\/p>","title":"O((V+E) log V) Time Complexity - Part 2"},{"id":463,"category":"sssp","order":4,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-23 06:25:43","updated_at":"2017-11-02 05:27:55","section":53,"code":"$(\"#dijkstra\").click().addClass(\"menu-highlighted\");","section_order":7,"value":"7-4","text":"<p>Details omitted for CS2040\/C\/S level but it will be added in the future.<\/p><br><p>Rely on <a href=\"https:\/\/www.quora.com\/What-is-the-simplest-intuitive-proof-of-Dijkstra%E2%80%99s-shortest-path-algorithm\" target=\"_blank\"><u>this<\/u><\/a> until then.<\/p><br><p>For now, try to solve <a href=\"https:\/\/open.kattis.com\/problems\/shortestpath1\" target=\"_blank\"><u>Kattis - shortestpath1<\/u><\/a> for a &#39;weak&#39; proof: Get an Accepted verdict in an online judge.<\/p>","title":"Proof of Correctness"},{"id":456,"category":"sssp","order":5,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-23 04:17:26","updated_at":"2017-05-23 06:25:47","section":53,"code":"$(\"#dijkstra\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_18);","section_order":7,"value":"7-5","text":"<p>When the input graph contains at least one negative weight edge &mdash; not necessarily negative weight cycle &mdash; Dijkstra&#39;s algorithm can produce wrong answer.<\/p><br><p>Try <span class=\"slide-actions\" onclick=\"doButtonAction70()\">Dijkstra(0)<\/span> on one of the Example Graphs: CP3 4.18.<\/p><br><p>At the end of the execution of Dijkstra&#39;s algorithm, vertex 4 has wrong D[4] value as the algorithm started &#39;wrongly&#39; thinking that subpath 0 &rarr; 1 &rarr; 3 is the better subpath of weight 1+2 = 3, thus making D[4] = 6 after calling <samp>relax(3,4,3)<\/samp>. However, the presence of negative weight -10 at edge 2 &rarr; 3 makes the other subpath 0 &rarr; 2 &rarr; 3 eventually the better subpath of weight 10-10 = 0 although it started worse with path weight 10 after the first edge 0 &rarr; 2. This better D[3] = 0 is never propagated further due to the greedy nature of Dijkstra&#39;s algorithm, hence D[4] is wrong.<\/p>","title":"Wrong Answer on Graph with -ve Weight"},{"id":440,"category":"sssp","order":8,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-22 01:13:38","updated_at":"2017-05-23 07:26:50","section":-1,"code":"$(\"#dijkstra\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_18);","section_order":-1,"value":"8","text":"<p>Dijkstra&#39;s algorithm can also be implemented differently. The O((<b>V<\/b>+<b>E<\/b>) log <b>V<\/b>) <b>Modified Dijkstra&#39;s algorithm<\/b> can be used for directed weighted graphs that may have negative weight edges but no negative weight cycle.<\/p><br><p>Such input graph appears in some practical cases, e.g., travelling using an <b>electric car<\/b> that has battery and our objective is to find a path from source vertex <b>s<\/b> to another vertex that minimizes overall <b>battery usage<\/b>. As usual, during acceleration (or driving on flat\/uphill road), the electric car <b>uses<\/b> (positive) energy from the battery. However, during braking (or driving on downhill road), the electric car <b>recharges<\/b> (or use negative) energy to the battery. There is no negative weight cycle due to kinetic energy loss.<\/p><br><p>For example, try <span class=\"slide-actions\" onclick=\"doButtonAction76()\">ModifiedDijkstra(0)<\/span> on one of the Example Graphs: CP3 4.18 that has troubled the original version of Dijkstra&#39;s algorithm (see <a href=\"?slide=7-5\"><u>previous slide<\/u><\/a>).<\/p>","title":"Modified Dijkstra&#39;s Algorithm"},{"id":469,"category":"sssp","order":1,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-23 07:25:21","updated_at":"2018-04-12 06:58:40","section":440,"code":"$(\"#dijkstra\").click().addClass(\"menu-highlighted\");","section_order":8,"value":"8-1","text":"<p>The key idea is the &#39;usage modification&#39; done to C++ STL priority_queue\/Python heapq\/Java PriorityQueue to allow it to perform the required &#39;DecreaseKey&#39; operation efficiently, i.e., in O(log <b>V<\/b>) time.<\/p><br><p>The technique is called &#39;Lazy Update&#39; where we leave the &#39;outdated\/weaker\/bigger-valued information&#39; in the Min Priority Queue instead of deleting it straight-away. As the items are ordered from smaller values to bigger values in a Min PQ, we are guaranteeing ourself that we will encounter the smallest\/most-up-to-date item first before encountering the weaker\/outdated item(s) later - which by then can be easily ignored.<\/p>","title":"Key Ideas"},{"id":468,"category":"sssp","order":2,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-23 07:22:54","updated_at":"2018-04-12 06:58:57","section":440,"code":"$(\"#dijkstra\").click().addClass(\"menu-highlighted\");","section_order":8,"value":"8-2","text":"<p>On non-negative weighted graphs, the behavior of Modified Dijkstra&#39;s implementation is exactly the same as the Original Dijkstra&#39;s so we can use the same time complexity analysis of O((<b>V<\/b>+<b>E<\/b>) log <b>V<\/b>).<\/p><br><p>PS: We note that when we use the Modified Dijkstra&#39;s algorithm, there can be more items (up to <b>E<\/b>) in the Priority Queue than if we use the Original Dijkstra&#39;s algorithm (up to <b>V<\/b>). However, since O(log E) = O(log V^2) = O(2 log V) = O(log V), we still treat the Priority Queue operations as O(log V).<\/p><br><p>However, if the graph has at least one negative weight edge, the analysis is harder.<\/p>","title":"O((V+E) log V) Time Complexity?"},{"id":457,"category":"sssp","order":3,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-23 04:28:28","updated_at":"2017-05-23 07:25:25","section":440,"code":"$(\"#dijkstra\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_18);","section_order":8,"value":"8-3","text":"<p>When the input graph contains at least one negative weight edge but no negative weight cycle &mdash; the modified Dijkstra&#39;s algorithm produces correct answer.<\/p><br><p>Try <span class=\"slide-actions\" onclick=\"doButtonAction76()\">ModifiedDijkstra(0)<\/span> on one of the Example Graphs: CP3 4.18 that causes problem for <span class=\"slide-actions\" onclick=\"doButtonAction70()\">Dijkstra(0)<\/span>.<\/p><br><p>At the end of the execution of ModifiedDijkstra&#39;s algorithm, vertex 4 has correct D[4] value as although the modified Dijkstra&#39;s algorithm also started &#39;wrongly&#39; thinking that subpath 0 &rarr; 1 &rarr; 3 is the better subpath of weight 1+2 = 3, thus making D[4] = 6 after calling <samp>relax(3,4,3)<\/samp>. Here, the modified Dijkstra&#39;s algorithm <b>continues<\/b> propagating D[3] = 0 after it founds out that the other subpath 0 &rarr; 2 &rarr; 3 is eventually the better subpath of weight 10-10 = 0. Hence D[4] is eventually correct again. However, this is at the expense of potentially running (much more) operations than O((<b>V<\/b>+<b>E<\/b>) log <b>V<\/b>).<\/p>","title":"Correct on Graph without -ve Weight Cycle"},{"id":458,"category":"sssp","order":4,"top":"250px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-23 04:33:33","updated_at":"2017-05-23 07:25:25","section":440,"code":"$(\"#dijkstra\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_19);","section_order":8,"value":"8-4","text":"<p>Unfortunately, running <span class=\"slide-actions\" onclick=\"doButtonAction76()\">ModifiedDijkstra(0)<\/span> on the graph with negative weight cycle as shown on one of the Example Graphs: CP3 4.17 above will cause an endless loop (the animation is very long but we limit the number of loop to be 100 edges processed so your web browser will not hang).<\/p>","title":"Problem with Graph with -ve Weight Cycle"},{"id":459,"category":"sssp","order":5,"top":"250px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-23 04:36:57","updated_at":"2017-05-23 07:25:24","section":440,"code":"$(\"#dijkstra\").click().addClass(\"menu-highlighted\");\nexample(DIJKSTRA_KILLER);","section_order":8,"value":"8-5","text":"<p>Try <span class=\"slide-actions\" onclick=\"doButtonAction76()\">ModifiedDijkstra(0)<\/span> on the extreme corner case above that is very hard to derive without proper understanding of this algorithm and was part of Asia Pacific Informatics Olympiad (APIO) 2013 task set by Steven.<\/p><br><p>The Modified Dijkstra&#39;s algorithm will terminate with correct answer, but only after running exponential number of operations (each carefully constructed triangle raises the number of required operations by another power of two). Thus we cannot prematurely terminate Modified Dijkstra&#39;s in this worst case input situation.<\/p><br><p>However, such extreme corner case is rare and thus in practice, Modified Dijkstra&#39;s algorithm can be used on directed graphs that have <i>some<\/i> negative weighted edges as long as the graph has no negative weight cycle reachable from the source vertex <b>s<\/b>.<\/p>","title":"Worst Case Input"},{"id":55,"category":"sssp","order":9,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:13:51","updated_at":"2017-05-23 06:54:18","section":-1,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_40);","section_order":-1,"value":"9","text":"<p>The O(<b>V<\/b>) <b>Depth-First Search (DFS)<\/b> algorithm can solve <b>special case<\/b> of SSSP problem, i.e. when the input graph is a (weighted) <b>Tree<\/b>.<\/p><br><p>In a Tree, there is only one unique and acylic path that connects two distinct vertices. Thus the unique path that connects the source vertex <b>s<\/b> to any another vertex <b>u<\/b> &in; <b>V<\/b> is actually also the shortest path. For example, try <span class=\"slide-actions\" onclick=\"doButtonAction78()\">DFS(0)<\/span> on the Tree above.<\/p><br><p>Notice that for a (weighted) Tree, we can also use BFS. For example, try <span class=\"slide-actions\" onclick=\"doButtonAction75()\">BFS(0)<\/span> on the same Tree above.<\/p><br><p>Discussion: Why DFS (and also BFS) runs in O(<b>V<\/b>) instead of O(<b>V<\/b>+<b>E<\/b>) if the input is a (weighted) Tree?<\/p>","title":"Depth-First Search"},{"id":467,"category":"sssp","order":1,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":1,"created_at":"2017-05-23 06:58:25","updated_at":"2017-11-02 05:37:10","section":55,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_40);","section_order":9,"value":"9-1","text":"<p>Because in a Tree, <b>E<\/b> = <b>V<\/b>-1, hence O(<b>V<\/b>+<b>E<\/b>) = O(<b>V<\/b>+<b>V<\/b>-1) = O(2<b>V<\/b>-1) = O(<b>V<\/b>).<\/p>","title":"The Answer"},{"id":466,"category":"sssp","order":2,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-23 06:46:40","updated_at":"2017-05-23 06:58:28","section":55,"code":"$(\"#dfs\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_17);","section_order":9,"value":"9-2","text":"<p>DFS will very likely produce wrong answer when run on any other graph that is not a Tree. We will display a <b>warning message<\/b> for such cases although we do not prevent you from trying this feature for pedagogical purpose.<\/p><br><p>For example, try <span class=\"slide-actions\" onclick=\"doButtonAction78()\">DFS(0)<\/span> on the general graph above and you will see that vertex {4} will have wrong D[4] value (and also wrong p[4] value) as DFS(0) goes deep 0 &rarr; 1 &rarr; 3 &rarr; 4 first, backtrack all the way to vertex 0 and eventually visit 0 &rarr; 2 but edge 2 &rarr; 4 cannot be processed as vertex 4 has been visited by DFS earlier.<\/p>","title":"Wrong Answer on Non Tree Graphs"},{"id":56,"category":"sssp","order":10,"top":"380px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:14:16","updated_at":"2017-05-23 06:43:23","section":-1,"code":"$(\"#dp\").click().addClass(\"menu-highlighted\");\nexample(DAG);","section_order":-1,"value":"10","text":"<p>The O(<b>V<\/b>+<b>E<\/b>) <b>Dynamic Programming<\/b> algorithm can solve <b>special case<\/b> of SSSP problem, i.e. when the input graph is a <b>Directed Acyclic Graph (DAG)<\/b> thus we can find at least one topological order of the DAG and process the edge relaxation according to this topological order.<\/p><br><p>For example, try <span class=\"slide-actions\" onclick=\"doButtonAction77()\">DP(0)<\/span> on the example DAG above. First, it computes one (there are other) possible topological order using either the O(<b>V<\/b>+<b>E<\/b>) DFS or the BFS\/Kahn&#39;s algorithm outlined in <a href=\".\/dfsbfs\"><u>Graph Traversal<\/u><\/a> module. For example, assume one topological order is {0,2,1,3,4,5}. Then, it relaxes the outgoing edges of vertices listed in that topological order. After just one O(<b>V<\/b>+<b>E<\/b>) pass, we will have correct <b>D[u]<\/b> values &forall;<b>u<\/b> &in; <b>V<\/b>.<\/p>","title":"Dynamic Programming (DP)"},{"id":464,"category":"sssp","order":1,"top":"280px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-23 06:28:17","updated_at":"2017-05-23 06:38:42","section":56,"code":"$(\"#dp\").click().addClass(\"menu-highlighted\");\nexample(DIJKSTRA_KILLER);","section_order":10,"value":"10-1","text":"<p>On the Modified Dijkstra&#39;s killer example shown above, <span class=\"slide-actions\" onclick=\"doButtonAction77()\">DP(0)<\/span> works fast as the graph is actually a DAG, albeit having negative weight edge. As the graph is a DAG, there will not be any negative weight cycle to worry about.<\/p><br><p>However, DP will not work for any non DAG as non DAG contains at least one cycle and thus no topological order can be found within that cycle.<\/p>","title":"Strength and Weakness"},{"id":465,"category":"sssp","order":2,"top":"","right":"","bottom":"70px","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-23 06:39:41","updated_at":"2017-05-23 06:44:40","section":56,"code":"$(\"#dp\").click().addClass(\"menu-highlighted\");\nexample(CP3_4_17);","section_order":10,"value":"10-2","text":"<p>DP algorithm for solving SSSP on DAG is also called <b>one-pass<\/b> Bellman-Ford algorithm as it replaces the outermost <b>V<\/b>-1 loop (we do not know the correct order so we just repeat until the maximum possible) with just one topological order pass (we know that this is (one of) the correct order(s) of this DAG).<\/p><br><p>Compare <span class=\"slide-actions\" onclick=\"doButtonAction77()\">DP(0)<\/span> (relax <b>E<\/b> edges just once \u2014 according to topological order of its vertices) versus <span class=\"slide-actions\" onclick=\"doButtonAction71()\">BellmanFord(0)<\/span> (relax <b>E<\/b> edges in random order, <b>V<\/b>-1 times) on the same example DAG above.<\/p>","title":"Similarities with Bellman-Ford Algorithm"},{"id":437,"category":"sssp","order":11,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-05-18 15:08:47","updated_at":"2023-11-09 08:51:49","section":-1,"code":"","section_order":-1,"value":"11","text":"<p>We have lots of other stuffs on top of this basic explanation of SSSP algorithms for SSSP problems.<\/p><br><p>Meanwhile, you are allowed to use\/modify our implementation code for Bellman-Ford\/Bellman-Ford-Moore\/Dijkstra&#39;s Algorithms:<br><a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/sssp\/bellman_ford.cpp\" target=\"_blank\"><u>bellman_ford.cpp<\/u><\/a>\/<a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/sssp\/bellman_ford_moore.cpp\" target=\"_blank\"><u>bellman_ford_moore.cpp<\/u><\/a>\/<a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/sssp\/dijkstra.cpp\" target=\"_blank\"><u>dijkstra.cpp<\/u><\/a><br><a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/sssp\/bellman_ford.java\" target=\"_blank\"><u>bellman_ford.java<\/u><\/a>\/<a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/sssp\/bellman_ford_moore.java\" target=\"_blank\"><u>bellman_ford_moore.java<\/u><\/a>\/<a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/sssp\/dijkstra.java\" target=\"_blank\"><u>dijkstra.java<\/u><\/a><br><a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/sssp\/bellman_ford.py\" target=\"_blank\"><u>bellman_ford.py<\/u><\/a>\/<a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/sssp\/bellman_ford_moore.py\" target=\"_blank\"><u>bellman_ford_moore.py<\/u><\/a>\/<a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/sssp\/dijkstra.py\" target=\"_blank\"><u>dijkstra.py<\/u><\/a><br><a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/sssp\/bellman_ford.ml\" target=\"_blank\"><u>bellman_ford.ml<\/u><\/a>\/<a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/sssp\/bellman_ford_moore.ml\" target=\"_blank\"><u>bellman_ford_moore.ml<\/u><\/a>\/<a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch4\/sssp\/dijkstra.ml\" target=\"_blank\"><u>dijkstra.ml<\/u><\/a><br><\/p>","title":"Extras"},{"id":665,"category":"sssp","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-11-02 05:42:23","updated_at":"2023-11-09 08:51:52","section":437,"code":"","section_order":11,"value":"11-1","text":"<p>For a few more interesting questions about this SSSP problem and its various algorithms, please practice on <a href=\"https:\/\/visualgo.net\/training?diff=Medium&amp;n=7&amp;tl=0&amp;module=sssp\"><u>SSSP<\/u><\/a> training module (no login is required).<\/p><br><p>However, for registered users, you should login and then go to the <a href=\"https:\/\/visualgo.net\/training\"><u>Main Training Page<\/u><\/a> to officially clear this module (after clearing the other pre-requisites modules) and such achievement will be recorded in your user account.<\/p>","title":"Online Quiz"},{"id":666,"category":"sssp","order":2,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-11-02 05:45:01","updated_at":"2023-11-09 08:51:56","section":437,"code":"","section_order":11,"value":"11-2","text":"<p>We also have a few programming problems that somewhat requires the usage of the correct SSSP algorithm: <a href=\"https:\/\/open.kattis.com\/problems\/hidingplaces\" target=\"_blank\"><u>Kattis - hidingplaces<\/u><\/a> and <a href=\"https:\/\/open.kattis.com\/problems\/shortestpath1\" target=\"_blank\"><u>Kattis - shortestpath1<\/u><\/a>.<\/p><br><p>Try to solve them and then try the <b>many more<\/b> interesting twists\/variants of this interesting SSSP problem.<\/p><hr><p>Advertisement: <a href=\"https:\/\/cpbook.net\" target=\"_blank\"><u>Buy Competitive Programming textbook<\/u><\/a> to read more on this interesting problem.<\/p>","title":"Online Judge Exercises"}];
      const numSlides = lectureIds.length;
      var sectorJunction12Section = 0, sectorJunction12Slide = 0;
      var sectorJunction23Section = 0, sectorJunction23Slide = 0;
      var sector1Count = 0, sector2Count = 0, sector3Count = 0;
      const sectorLength = Math.floor(numSlides / 3);
      function createELectureTimelineDisplay() {
        for (let j = 0; j < numSlides; ++j) {
          const currLecture = lectureIds[j].value;
          if (currLecture.includes('-')) {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-slide" slideNo=${lectureIds[j].value}></div>`)
            );
          } else {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-checkpoint" slideNo=${lectureIds[j].value}></div>`)
            );
          }
        }
      }

      function setSectorJunctionInfo() {
          //setting the sector junction slide numbers
          const j12 = sectorLength !== 0 ? (sectorLength - 1): 0;
          const j23 = sectorLength !== 0 ? (2 * sectorLength - 1) : 0;

          const sectorJunction12 = lectureIds[j12].value.split('-');
          sectorJunction12Section = parseInt(sectorJunction12[0]);
          sectorJunction12Slide = sectorJunction12.length > 1 ? parseInt(sectorJunction12[1]) : sectorJunction12Slide;

          const sectorJunction23 = lectureIds[j23].value.split('-');
          sectorJunction23Section = parseInt(sectorJunction23[0]);
          sectorJunction23Slide = sectorJunction23.length > 1 ? parseInt(sectorJunction23[1]) : sectorJunction23Slide;
      }

      function runSlide(slide) { // Steven's patch on 28 Jan 2022: Properly remove slide 99, 99-1, 99-2, 99-3, integrate with the earlier slides
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 2 + "%)");
          
        }
        if (slide == '1-1') {
          $("#e-lecture").html("slide " + slide + " (" + 4 + "%)");
          
        }
        if (slide == '1-2') {
          $("#e-lecture").html("slide " + slide + " (" + 6 + "%)");
          
        }
        if (slide == '1-3') {
          $("#e-lecture").html("slide " + slide + " (" + 8 + "%)");
          
        }
        if (slide == '1-4') {
          $("#e-lecture").html("slide " + slide + " (" + 10 + "%)");
          
        }
        if (slide == '1-5') {
          $("#e-lecture").html("slide " + slide + " (" + 13 + "%)");
          example(CP3_4_17);
        }
        if (slide == '1-6') {
          $("#e-lecture").html("slide " + slide + " (" + 15 + "%)");
          example(CP3_4_19);
        }
        if (slide == '1-7') {
          $("#e-lecture").html("slide " + slide + " (" + 17 + "%)");
          loadGraph({
  'vl': {
    0: { "x": 300, "y": 100 },
    1: { "x": 400, "y": 50 },
    2: { "x": 500, "y": 100 }
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 4 },
    1: { "u": 0, "v": 2, "w": 9 },
    2: { "u": 1, "v": 2, "w": 4 }
  }
});
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 19 + "%)");
          $("#draw").addClass("menu-highlighted");
$("#examples").click().addClass("menu-highlighted");
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 21 + "%)");
          $("#bellmanford").click().addClass("menu-highlighted");
$("#bfs").addClass("menu-highlighted");
$("#dijkstra").addClass("menu-highlighted");
$("#dfs").addClass("menu-highlighted");
$("#dp").addClass("menu-highlighted");
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 23 + "%)");
          $("#bellmanford").click().addClass("menu-highlighted");
example(CP3_4_17);
        }
        if (slide == '4-1') {
          $("#e-lecture").html("slide " + slide + " (" + 26 + "%)");
          $("#bellmanford").click().addClass("menu-highlighted");
example(CP3_4_17);
        }
        if (slide == '4-2') {
          $("#e-lecture").html("slide " + slide + " (" + 28 + "%)");
          $("#bellmanford").click().addClass("menu-highlighted");
example(CP3_4_17);
        }
        if (slide == '4-3') {
          $("#e-lecture").html("slide " + slide + " (" + 30 + "%)");
          $("#bellmanford").click().addClass("menu-highlighted");
        }
        if (slide == '4-4') {
          $("#e-lecture").html("slide " + slide + " (" + 32 + "%)");
          $("#bellmanford").click().addClass("menu-highlighted");
        }
        if (slide == '4-5') {
          $("#e-lecture").html("slide " + slide + " (" + 34 + "%)");
          $("#bellmanford").click().addClass("menu-highlighted");
example(BELLMANFORD_KILLER);
        }
        if (slide == '4-6') {
          $("#e-lecture").html("slide " + slide + " (" + 36 + "%)");
          $("#bellmanford").click().addClass("menu-highlighted");
        }
        if (slide == '4-7') {
          $("#e-lecture").html("slide " + slide + " (" + 39 + "%)");
          $("#bellmanford").click().addClass("menu-highlighted");
example(BELLMANFORD_KILLER);
        }
        if (slide == '4-8') {
          $("#e-lecture").html("slide " + slide + " (" + 41 + "%)");
          $("#bellmanford").click().addClass("menu-highlighted");
example(BELLMANFORD_KILLER);
        }
        if (slide == '4-9') {
          $("#e-lecture").html("slide " + slide + " (" + 43 + "%)");
          $("#bellmanford").click().addClass("menu-highlighted");
example(CP3_4_19);
        }
        if (slide == '5') {
          $("#e-lecture").html("slide " + slide + " (" + 45 + "%)");
          $("#bfs").addClass("menu-highlighted");
$("#dijkstra").addClass("menu-highlighted");
$("#dfs").addClass("menu-highlighted");
$("#dp").addClass("menu-highlighted");
        }
        if (slide == '6') {
          $("#e-lecture").html("slide " + slide + " (" + 47 + "%)");
          $("#bfs").click().addClass("menu-highlighted");
example(CP3_4_3);
        }
        if (slide == '6-1') {
          $("#e-lecture").html("slide " + slide + " (" + 50 + "%)");
          $("#bfs").click().addClass("menu-highlighted");

        }
        if (slide == '6-2') {
          $("#e-lecture").html("slide " + slide + " (" + 52 + "%)");
          
        }
        if (slide == '6-3') {
          $("#e-lecture").html("slide " + slide + " (" + 54 + "%)");
          $("#bfs").click().addClass("menu-highlighted");
example(CP3_4_17);
        }
        if (slide == '7') {
          $("#e-lecture").html("slide " + slide + " (" + 56 + "%)");
          $("#dijkstra").click().addClass("menu-highlighted");
example(CP3_4_17);
        }
        if (slide == '7-1') {
          $("#e-lecture").html("slide " + slide + " (" + 58 + "%)");
          $("#dijkstra").click().addClass("menu-highlighted");
        }
        if (slide == '7-2') {
          $("#e-lecture").html("slide " + slide + " (" + 60 + "%)");
          $("#dijkstra").click().addClass("menu-highlighted");
        }
        if (slide == '7-3') {
          $("#e-lecture").html("slide " + slide + " (" + 63 + "%)");
          $("#dijkstra").click().addClass("menu-highlighted");
        }
        if (slide == '7-4') {
          $("#e-lecture").html("slide " + slide + " (" + 65 + "%)");
          $("#dijkstra").click().addClass("menu-highlighted");
        }
        if (slide == '7-5') {
          $("#e-lecture").html("slide " + slide + " (" + 67 + "%)");
          $("#dijkstra").click().addClass("menu-highlighted");
example(CP3_4_18);
        }
        if (slide == '8') {
          $("#e-lecture").html("slide " + slide + " (" + 69 + "%)");
          $("#dijkstra").click().addClass("menu-highlighted");
example(CP3_4_18);
        }
        if (slide == '8-1') {
          $("#e-lecture").html("slide " + slide + " (" + 71 + "%)");
          $("#dijkstra").click().addClass("menu-highlighted");
        }
        if (slide == '8-2') {
          $("#e-lecture").html("slide " + slide + " (" + 73 + "%)");
          $("#dijkstra").click().addClass("menu-highlighted");
        }
        if (slide == '8-3') {
          $("#e-lecture").html("slide " + slide + " (" + 76 + "%)");
          $("#dijkstra").click().addClass("menu-highlighted");
example(CP3_4_18);
        }
        if (slide == '8-4') {
          $("#e-lecture").html("slide " + slide + " (" + 78 + "%)");
          $("#dijkstra").click().addClass("menu-highlighted");
example(CP3_4_19);
        }
        if (slide == '8-5') {
          $("#e-lecture").html("slide " + slide + " (" + 80 + "%)");
          $("#dijkstra").click().addClass("menu-highlighted");
example(DIJKSTRA_KILLER);
        }
        if (slide == '9') {
          $("#e-lecture").html("slide " + slide + " (" + 82 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
example(CP3_4_40);
        }
        if (slide == '9-1') {
          $("#e-lecture").html("slide " + slide + " (" + 84 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
example(CP3_4_40);
        }
        if (slide == '9-2') {
          $("#e-lecture").html("slide " + slide + " (" + 86 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
example(CP3_4_17);
        }
        if (slide == '10') {
          $("#e-lecture").html("slide " + slide + " (" + 89 + "%)");
          $("#dp").click().addClass("menu-highlighted");
example(DAG);
        }
        if (slide == '10-1') {
          $("#e-lecture").html("slide " + slide + " (" + 91 + "%)");
          $("#dp").click().addClass("menu-highlighted");
example(DIJKSTRA_KILLER);
        }
        if (slide == '10-2') {
          $("#e-lecture").html("slide " + slide + " (" + 93 + "%)");
          $("#dp").click().addClass("menu-highlighted");
example(CP3_4_17);
        }
        if (slide == '11') {
          $("#e-lecture").html("slide " + slide + " (" + 95 + "%)");
          
        }
        if (slide == '11-1') {
          $("#e-lecture").html("slide " + slide + " (" + 97 + "%)");
          
        }
        if (slide == '11-2') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
        }
        clearTimeout(currSlideTimer);
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };
      var slideTimeline = {};

      //reads all visited slides in the slideTimeline and gives them their sector color
      function setVisitedSlideTimelineColors() {
        for(const [sectionNo, visitedSlides] of Object.entries(slideTimeline)) {
          const visitedSlides = slideTimeline[sectionNo];
          for(const visitedSlideNo of visitedSlides) {
            setSlideTimelineColor(visitedSlideNo);
          }
        }
      }

      //only called on load if there is nothing in session
      function setTimelineForCompletedSector(sectorNum) {
        let len = sectorLength;
        switch (sectorNum) {
          case 1 : len = sectorLength; break;
          case 2 : len = 2 * sectorLength; break;
          default: len = numSlides;
        }
        let i = 0;
        switch (sectorNum) {
          case 1 : i = 0; break;
          case 2 : i = sectorLength; break;
          default: i = 2 * sectorLength;
        }
        for (; i < len; i++) {
          saveELectureTimeline(lectureIds[i].value, true);
        }
      }

      function getUserSectorHistory(callback) {
        $.ajax({
          type: 'GET',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            topic: "/sssp".substring(1)
          }
        }
        ).done(function (data) {
            if (data.data[0] === 1) {
              setF1SectorColor(1);
              setTimelineForCompletedSector(1);
            }
            if (data.data[1] === 1) {
              setF1SectorColor(2);
              setTimelineForCompletedSector(2);
            }
            if (data.data[2] === 1) {
              setF1SectorColor(3);
              setTimelineForCompletedSector(3);
            }
            callback();
        }).fail(function (data) {
            console.log('get user sector history failed!');
        });
      }

      function getELectureTimelineFromSession() {
        const page = "/sssp".substring(1);
        const timelineKey = page + '-slide-timeline';
        const storedTimeline = window.sessionStorage.getItem(timelineKey);
        if (storedTimeline) {
          slideTimeline = JSON.parse(storedTimeline);
        } else {
          return false;
        }
        let slideInfo = [];
        for (const [sectionNum, slides] of Object.entries(slideTimeline)) {
          for (const slide of slides) {
            indicateSlideCompletedUI(slide);
            slideInfo = slide.split('-');
            incrementSectorVisits(parseInt(sectionNum), slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0);
          }
        }
        return true;
      }

      async function initializeELectureTimeline() {
        setSectorJunctionInfo();
        if (!getELectureTimelineFromSession())
          getUserSectorHistory(sectorBasedModeSelection);
        else
          sectorBasedModeSelection();

        createELectureTimelineDisplay();
        setVisitedSlideTimelineColors();
      }

      function setF1SectorColor(sectorNum) {
        $(`[sectorNo="${sectorNum}"]`).css('background', sectorColors[(parseInt(sectorNum) % 3)]);
      }

      function updateSectorInDB(sectorNum) {
        $.ajax({
          type: 'POST',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            section: (sectorNum - 1),
            topic: "/sssp".substring(1)
          }
        }
        ).done(function (data) {
            //console.log("Saved the sector " + sectorNum + " as done " + JSON.stringify(data));
        }).fail(function (data) {
            console.log("Setting sector done failed new attempt! "+ JSON.stringify(data));
        });
      }

      //If 87.5% or more of the slides in sector are done
      function setF1SectorCompleted(sectorNum, isInitializationCall) {
        setF1SectorColor(sectorNum);
        //avoid api call on initialization
        if (!isInitializationCall) {
          updateSectorInDB(sectorNum);
          $(`[sectorNo="${sectorNum}"]`).css("animation", "green-pulse 2s 4");
          setTimeout(() => {
            $(`[sectorNo="${sectorNum}"]`).css("animation", "");
          }, 8000);
        }
      }

      function incrementSectorVisits(sectionNum, slideNumWithinSection, isInitializationCall) {
        //updating sector count
        if (sectionNum < sectorJunction12Section
          || (sectionNum === sectorJunction12Section && slideNumWithinSection <= sectorJunction12Slide)) {
          ++sector1Count;
          if (sector1Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(1, isInitializationCall);
        } else if (sectionNum < sectorJunction23Section
          || (sectionNum === sectorJunction23Section && slideNumWithinSection <= sectorJunction23Slide)) {
          ++sector2Count;
          if (sector2Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(2, isInitializationCall);
        } else {
          ++sector3Count;
          if (sector3Count >= Math.ceil(0.875 * (numSlides - 2 * sectorLength)))
            setF1SectorCompleted(3, isInitializationCall);
        }
      }

      function saveELectureTimeline(slideNo, isInitialization) {
        const slideInfo = slideNo.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        if (slideTimeline[sectionNo]) {
          if (!slideTimeline[sectionNo].includes(slideNo)) {
            slideTimeline[sectionNo].push(slideNo);
            const sectionNum = parseInt(sectionNo);
            incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
          }
        } else {
          slideTimeline[sectionNo] = [];
          slideTimeline[sectionNo].push(slideNo);
          const sectionNum = parseInt(sectionNo);
          incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
        }
        setSlideTimelineColor(slideNo);
        indicateSlideCompletedUI(slideNo);
      }

      function saveELectureTimelineToSession() {
        const page = "/sssp".substring(1);
        const timelineKey = page + '-slide-timeline';
        window.sessionStorage.setItem(timelineKey, JSON.stringify(slideTimeline));
      }

      function handleTimelineOnRunSlide(slideValue) {
        const slideInfo = slideValue.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        //start timer only if the slide isnt already done
        if (!slideTimeline[sectionNo] || !slideTimeline[sectionNo].includes(slideValue)) {
          const slideTextLength = $('#electure-'+slideValue + " p").text().length + $('#electure-'+slideValue + " li").text().length;
          const CHARS_READ_PER_MS = 0.05; //when fast, 50 characters a second
          //setting max reading time as 10 seconds for around 500 character slide
          const minSlideReadingTime = Math.min(Math.max(2000, (slideTextLength / CHARS_READ_PER_MS) +  + (2000 * $('#electure-'+slideValue + " img").length)), 10000);
          currSlideTimer = setTimeout(() => {
            saveELectureTimeline(slideValue);
          }, minSlideReadingTime);
        }
      }

      function indicateSlideCompletedUI(slide) {
        $('#electure-'+slide).css("box-shadow", "3px 3px 8px green"); //set green shadow for completed slides
        $('#electure-'+slide + ' .electure-read-status').html("&#10004;");
        $('#electure-'+slide + ' .electure-read-status').attr("title", "Slide Completed!");
        $('#electure-'+slide + ' .electure-read-status').css("font-size", "17px");
      }

      function pushState(slideValue) {
        var url = '/en/sssp';
        if (typeof slideValue != 'undefined' && slideValue != null) {
          url += '?slide=' + slideValue;
                  }
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5);
        $('#overlay').show();

        $("#e-lecture-timeline").show();
        $("#e-lecture-f1map").show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
        $("#e-lecture-timeline").hide();
        $("#e-lecture-f1map").hide();
        clearTimeout(currSlideTimer);
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      function sectorBasedModeSelection() {
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        //check params are empty and then that all sectors are completed or not
        if (!Object.keys(params).length
          && sector1Count === sectorLength && sector2Count === sectorLength && sector3Count === (numSlides - 2 * sectorLength)) {
            hideOverlay();
        }
        else
          $('#mode-menu a').click();
      }

      $(function() {
        if (isMobileOS() && portraitMatcher.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').show();
          $('#widenDeviceText').hide();
          $('#topbar').css("z-index", 10001);
        } else if (matchMediaNarrow.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').hide();
          $('#widenDeviceText').show();
          $('#topbar').css("z-index", 10001);
        } else {
          $('#rotateDeviceOverlay').hide();
          $('#topbar').css("z-index", "");
        }

        matchMediaNarrow.addEventListener('change', e => {
          //screws up for square device! NEED RESIZE EVENT
          if (e.matches) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').hide();
              $('#widenDeviceText').show();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        portraitMatcher.addEventListener('change', e => {
          if (e.matches && isMobileOS()) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').show();
              $('#widenDeviceText').hide();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        let slide = getUrlParameter('slide');
        if (typeof slide !== undefined && slide != null) {
          cur_slide = slide;
        }
        //do all timeline and slide stuff only if specific params not provided
        if (!Object.keys(params).length || params["slide"]) {
          if (!isMobile()) {
                            $('#mode-menu a').click();
                      }
        }
        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
        $('#electure-1-1 .electure-next').click(function() {
          hidePopup();
          runSlide('1-2');
          pushState('1-2');
        });
        $('#electure-1-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
        $('#electure-1-2 .electure-next').click(function() {
          hidePopup();
          runSlide('1-3');
          pushState('1-3');
        });
        $('#electure-1-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
        $('#electure-1-3 .electure-next').click(function() {
          hidePopup();
          runSlide('1-4');
          pushState('1-4');
        });
        $('#electure-1-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-2');
          pushState('1-2');
        });
        $('#electure-1-4 .electure-next').click(function() {
          hidePopup();
          runSlide('1-5');
          pushState('1-5');
        });
        $('#electure-1-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-3');
          pushState('1-3');
        });
        $('#electure-1-5 .electure-next').click(function() {
          hidePopup();
          runSlide('1-6');
          pushState('1-6');
        });
        $('#electure-1-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-4');
          pushState('1-4');
        });
        $('#electure-1-6 .electure-next').click(function() {
          hidePopup();
          runSlide('1-7');
          pushState('1-7');
        });
        $('#electure-1-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-5');
          pushState('1-5');
        });
        $('#electure-1-7 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-1-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-6');
          pushState('1-6');
        });
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-7');
          pushState('1-7');
        });
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-4-1 .electure-next').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-4-2 .electure-next').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
        $('#electure-4-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
        $('#electure-4-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
        $('#electure-4-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
        $('#electure-4-5 .electure-next').click(function() {
          hidePopup();
          runSlide('4-6');
          pushState('4-6');
        });
        $('#electure-4-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
        $('#electure-4-6 .electure-next').click(function() {
          hidePopup();
          runSlide('4-7');
          pushState('4-7');
        });
        $('#electure-4-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
        $('#electure-4-7 .electure-next').click(function() {
          hidePopup();
          runSlide('4-8');
          pushState('4-8');
        });
        $('#electure-4-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-6');
          pushState('4-6');
        });
        $('#electure-4-8 .electure-next').click(function() {
          hidePopup();
          runSlide('4-9');
          pushState('4-9');
        });
        $('#electure-4-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-7');
          pushState('4-7');
        });
        $('#electure-4-9 .electure-next').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-4-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-8');
          pushState('4-8');
        });
        $('#electure-5 .electure-next').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-9');
          pushState('4-9');
        });
        $('#electure-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-6-1 .electure-next').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-6-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-6-2 .electure-next').click(function() {
          hidePopup();
          runSlide('6-3');
          pushState('6-3');
        });
        $('#electure-6-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6-3 .electure-next').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-6-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-7 .electure-next').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-3');
          pushState('6-3');
        });
        $('#electure-7-1 .electure-next').click(function() {
          hidePopup();
          runSlide('7-2');
          pushState('7-2');
        });
        $('#electure-7-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-7-2 .electure-next').click(function() {
          hidePopup();
          runSlide('7-3');
          pushState('7-3');
        });
        $('#electure-7-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-7-3 .electure-next').click(function() {
          hidePopup();
          runSlide('7-4');
          pushState('7-4');
        });
        $('#electure-7-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-2');
          pushState('7-2');
        });
        $('#electure-7-4 .electure-next').click(function() {
          hidePopup();
          runSlide('7-5');
          pushState('7-5');
        });
        $('#electure-7-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-3');
          pushState('7-3');
        });
        $('#electure-7-5 .electure-next').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
        $('#electure-7-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-4');
          pushState('7-4');
        });
        $('#electure-8 .electure-next').click(function() {
          hidePopup();
          runSlide('8-1');
          pushState('8-1');
        });
        $('#electure-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-5');
          pushState('7-5');
        });
        $('#electure-8-1 .electure-next').click(function() {
          hidePopup();
          runSlide('8-2');
          pushState('8-2');
        });
        $('#electure-8-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
        $('#electure-8-2 .electure-next').click(function() {
          hidePopup();
          runSlide('8-3');
          pushState('8-3');
        });
        $('#electure-8-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-1');
          pushState('8-1');
        });
        $('#electure-8-3 .electure-next').click(function() {
          hidePopup();
          runSlide('8-4');
          pushState('8-4');
        });
        $('#electure-8-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-2');
          pushState('8-2');
        });
        $('#electure-8-4 .electure-next').click(function() {
          hidePopup();
          runSlide('8-5');
          pushState('8-5');
        });
        $('#electure-8-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-3');
          pushState('8-3');
        });
        $('#electure-8-5 .electure-next').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
        $('#electure-8-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-4');
          pushState('8-4');
        });
        $('#electure-9 .electure-next').click(function() {
          hidePopup();
          runSlide('9-1');
          pushState('9-1');
        });
        $('#electure-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-5');
          pushState('8-5');
        });
        $('#electure-9-1 .electure-next').click(function() {
          hidePopup();
          runSlide('9-2');
          pushState('9-2');
        });
        $('#electure-9-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
        $('#electure-9-2 .electure-next').click(function() {
          hidePopup();
          runSlide('10');
          pushState('10');
        });
        $('#electure-9-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-1');
          pushState('9-1');
        });
        $('#electure-10 .electure-next').click(function() {
          hidePopup();
          runSlide('10-1');
          pushState('10-1');
        });
        $('#electure-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-2');
          pushState('9-2');
        });
        $('#electure-10-1 .electure-next').click(function() {
          hidePopup();
          runSlide('10-2');
          pushState('10-2');
        });
        $('#electure-10-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('10');
          pushState('10');
        });
        $('#electure-10-2 .electure-next').click(function() {
          hidePopup();
          runSlide('11');
          pushState('11');
        });
        $('#electure-10-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('10-1');
          pushState('10-1');
        });
        $('#electure-11 .electure-next').click(function() {
          hidePopup();
          runSlide('11-1');
          pushState('11-1');
        });
        $('#electure-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('10-2');
          pushState('10-2');
        });
        $('#electure-11-1 .electure-next').click(function() {
          hidePopup();
          runSlide('11-2');
          pushState('11-2');
        });
        $('#electure-11-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('11');
          pushState('11');
        });
        $('#electure-11-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('11-1');
          pushState('11-1');
        });
      });

      function doButtonAction70() {
        CUSTOM_ACTION('dijkstra', 0);
      }
      function doButtonAction71() {
        CUSTOM_ACTION('bellmanford', 0);
      }
      function doButtonAction72() {
        CUSTOM_ACTION('bfs', 5);
      }
      function doButtonAction75() {
        CUSTOM_ACTION('bfs', 0);
      }
      function doButtonAction76() {
        CUSTOM_ACTION('dijkstra_modified', 0);
      }
      function doButtonAction77() {
        CUSTOM_ACTION('dp', 0);
      }
      function doButtonAction78() {
        CUSTOM_ACTION('dfs', 0);
      }

      $('.electure-print').click(() => {
        window.open(`/en/sssp/print`);
      });
      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url.html) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}

      // This function will be called everytime 1.0x is changed to 0.5x or vice versa
      function redraw() {}

      $(document).ready(function () {
        setTimeout(function () {
          $('#change-lang-popup').fadeOut('slow')
        }, 5000)
      })
    </script>
<script type="text/javascript">
    var extraCSS = {"dp":"65px","dfs":"92px","dijkstra":"119px","bfs":"146px","bellmanford":"173px","examples":"200px","draw":"227px","vertexnumber":"254px","mediumscale":"281px"};
    var actionsIds = {"mediumscale":{"p":"Visualisation Scale"},"vertexnumber":{"p":"Toggle V. Number for 0.5x","onClick":"toggleVertexNumber()"},"draw":{"p":"Edit Graph","onClick":"drawGraph()"},"examples":{"p":"Example Graphs","parents":["example-unweighted","example-weighted","example-negative-weight","example-corner-case","example-special-case"]},"bellmanford":{"p":"BellmanFord(s)"},"bfs":{"p":"BFS(s)"},"dijkstra":{"p":"Dijkstra(s)"},"dfs":{"p":"DFS(s)"},"dp":{"p":"DP(s)"}};
    var isOpens = {};
    var len = 9;
    var keys = ["mediumscale","vertexnumber","draw","examples","bellmanford","bfs","dijkstra","dfs","dp"]; 
    for (i = 0; i < len; i++) {
        var actionDetails = keys[i];
        isOpens[actionDetails] = false;
    }
    function openAction(id) {
        hideThirdTiers(id);
        $("." + id).css("bottom", extraCSS[id]);
        if (!isOpens[id]) {
            $('.' + id).fadeIn('fast');
            isOpens[id] = true;
        }
    }
    function closeAction(id) {
        hideThirdTiers(id);
        if (isOpens[id]) {
            $('.' + id).fadeOut('fast');
            $('#' + id + '-err').html("");
            isOpens[id] = false;
        }
    }

    function hideEntireActionsPanel() {
        //hideAllThirdTiers();
                    closeAction('mediumscale');
                    closeAction('vertexnumber');
                    closeAction('draw');
                    closeAction('examples');
                    closeAction('bellmanford');
                    closeAction('bfs');
                    closeAction('dijkstra');
                    closeAction('dfs');
                    closeAction('dp');
                hideActionsPanel();
    }

    function hideThirdTiers(tier1Action) {
        if ("parents" in actionsIds[tier1Action]) {
            for (const secondTierAction of actionsIds[tier1Action]["parents"]) {
                $('#' + secondTierAction + '-third-tier').fadeOut('fast');
            }
        }
    }

    function hideAllThirdTiers() {
        for (const tier1Action in actionsIds) {
            hideThirdTiers(tier1Action);
        }
    }

    function toggleChildExtras(tier1, selectedParentTier2) {
        hideThirdTiers(tier1);
        //this actionId must have childExtras
        var style = extraCSS[tier1];
        $("." + tier1).css("bottom", (parseInt(style.substring(0, style.length - 2)) - 27));
        //fade ins and outs are done on the ID whereas css class is set on the class
        //fade in the third tier of the selected 2nd tier parent
        $('#' + selectedParentTier2 + '-third-tier').fadeIn('fast');

        // //fade out all other third tiers of that 'action'
        // for (const parent of actions[tier1]["parents"]) {
        //     console.log("parent is " + parent + " for " + selectedParentTier2);
        //     if (parent != selectedParentTier2) {
        //         $('#' + parent + '-third-tier').fadeOut('fast');
        //     }
        // }
    }

    function setActionHeightOriginal(tier1Action) {
        $("." + tier1Action).css("bottom", extraCSS[tier1Action]);
    }

            $('#' + 'mediumscale').click(function() {
            openAction('mediumscale');
                                                                            closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('bellmanford');
                                                                closeAction('bfs');
                                                                closeAction('dijkstra');
                                                                closeAction('dfs');
                                                                closeAction('dp');
                                    });
            $('#' + 'vertexnumber').click(function() {
            openAction('vertexnumber');
                                                closeAction('mediumscale');
                                                                                            closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('bellmanford');
                                                                closeAction('bfs');
                                                                closeAction('dijkstra');
                                                                closeAction('dfs');
                                                                closeAction('dp');
                                    });
            $('#' + 'draw').click(function() {
            openAction('draw');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                                            closeAction('examples');
                                                                closeAction('bellmanford');
                                                                closeAction('bfs');
                                                                closeAction('dijkstra');
                                                                closeAction('dfs');
                                                                closeAction('dp');
                                    });
            $('#' + 'examples').click(function() {
            openAction('examples');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                                            closeAction('bellmanford');
                                                                closeAction('bfs');
                                                                closeAction('dijkstra');
                                                                closeAction('dfs');
                                                                closeAction('dp');
                                    });
            $('#' + 'bellmanford').click(function() {
            openAction('bellmanford');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('examples');
                                                                                            closeAction('bfs');
                                                                closeAction('dijkstra');
                                                                closeAction('dfs');
                                                                closeAction('dp');
                                    });
            $('#' + 'bfs').click(function() {
            openAction('bfs');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('bellmanford');
                                                                                            closeAction('dijkstra');
                                                                closeAction('dfs');
                                                                closeAction('dp');
                                    });
            $('#' + 'dijkstra').click(function() {
            openAction('dijkstra');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('bellmanford');
                                                                closeAction('bfs');
                                                                                            closeAction('dfs');
                                                                closeAction('dp');
                                    });
            $('#' + 'dfs').click(function() {
            openAction('dfs');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('bellmanford');
                                                                closeAction('bfs');
                                                                closeAction('dijkstra');
                                                                                            closeAction('dp');
                                    });
            $('#' + 'dp').click(function() {
            openAction('dp');
                                                closeAction('mediumscale');
                                                                closeAction('vertexnumber');
                                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('bellmanford');
                                                                closeAction('bfs');
                                                                closeAction('dijkstra');
                                                                closeAction('dfs');
                                                                });
    
    //important to have all the input fields in actions menu take an id containing '-input'
    $("[id*='-input']").on("keypress keydown keyup", (event) => {
        event.stopPropagation();
    });
</script>
<script type="text/javascript">
// SSSP Widget
// author: Steven Halim

var scale = false;
var SSSP = function() {
  var self = this;
  var gw = new GraphWidget();

  var iVL = {};
  var iEL = {};
  var amountVertex = 0;
  var amountEdge = 0;

  this.getiVL = function() {
    return iVL;
  }

  this.getiEL = function() {
    return iEL;
  }

  this.getgw = function() { return gw; }

  fixJSON = function() {
    amountVertex = 0;
    amountEdge = 0;
    for (var key in iVL) ++amountVertex;
    for (var key in iEL) ++amountEdge;

    for (var key in iEL) iEL[key]["w"] = parseInt(iEL[key]["w"]); // integer
  }

  takeJSON = function(graph) {
    if (graph == null) return;
    graph = JSON.parse(graph);
    iVL = graph["vl"];
    iEL = graph["el"];
    fixJSON();
  }

  statusChecking = function() {
    $("#draw-status p").html('Please draw a <b>directed weighted graph</b> where <b>vertex 0 is the source</b>. Please <b>create many paths</b> to make it <b>challenging for various SSSP algorithms</b>.');
  }

  warnChecking = function() {
    var warn = "";
    if (currentGraphVisu.amountVertex() >= 10) warn += 'Too much vertex on screen, consider drawing smaller graph. ';
    const [curiVL, curiEL] = parseCurrentJSONresult()
    var visited = [];
    var stack = [];
    stack.push(0);
    visited[0] = true;
    while (stack.length > 0) {
      var now = stack.pop();
      for (var key2 in curiEL)
        if (curiEL[key2]["u"] == now)
          if (!visited[curiEL[key2]["v"]]) {
            visited[curiEL[key2]["v"]] = true;
            stack.push(+curiEL[key2]["v"]);
          }
    }
    for (var i = 0; i < currentGraphVisu.amountVertex(); ++i)
      if (!visited[i])
        warn += 'Vertex {i} is not reachable from vertex 0. ';

    if (warn == "") $("#draw-warn p").html('No Warning.');
    else            $("#draw-warn p").html(warn);
  }

  errorChecking = function() {
    var error = "";
    if (currentGraphVisu.amountVertex() == 0) {
      $("#draw-err p").html('Graph cannot be empty.');
      return;
    }

    if (error == "") $("#draw-err p").html('No Error');
    else             $("#draw-err p").html(error);
  }

  var intervalID;

  this.startLoop = function() {
    intervalID = setInterval(function() {
      warnChecking();
      errorChecking();
      statusChecking();
    }, 100);
  }

  this.stopLoop = function() { clearInterval(intervalID); }

  this.draw = function() {
    if ($("#draw-err p").html() != 'No Error')
      return false;
    takeJSON(JSONresult);
    if ($("#submit").is(':checked'))
      this.submit(JSONresult);
    if ($("#copy").is(':checked'))
      window.prompt('Copy to clipboard:', JSONresult);

    gw.removeAll();
    graph = createState(iVL, iEL);
    gw.updateGraph(graph, 500);
    return true;
  }

  this.importjson = function(JSON) {
    takeJSON(JSON);
    graph = createState(iVL, iEL);
    gw.updateGraph(graph, 500);
  }

  this.getGraph = function() {
    return {
      'vl': iVL,
      'el': iEL
    };
  }

  this.getV = function() {
    return amountVertex;
  }

  this.bellmanford = function(sourceVertex, callback) {
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, edgeGrey = {};
    var stateList = [];
    var key, i, cs;

    // error checks
    if (amountVertex == 0) { // no graph
      $('#bellmanford-err').html('There is no graph to run this on. Please select an example graph first.');
      return false;
    }

    if (sourceVertex >= amountVertex || sourceVertex < 0) { // source vertex not in range
      $('#bellmanford-err').html('This vertex does not exist in the graph. Please select another source vertex.');
      return false;
    }

    var d = {}, p = {};
    for (var i = 0; i < amountVertex; ++i) {
      d[i] = 999;
      p[i] = -1;
      iVL[i]["state"] = VERTEX_DEFAULT;
      iVL[i]["extratext"] = "Inf";
    }
    d[sourceVertex] = 0;

    //vertexTraversed[sourceVertex] = true;
    iVL[sourceVertex]["extratext"] = "source, 0";
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed);
    cs["status"] = sourceVertex + ' is the source vertex.<br>Set p[v] = -1, d[v] = Inf, but d[" + sourceVertex + "] = 0.';
    cs["lineNo"] = 1;
    stateList.push(cs);

    delete vertexHighlighted[sourceVertex];
    var EdgeProcessed = 0;
    var NextStatus = 'This is the first pass.';

    for (var i = 1; i < amountVertex; ++i) { // V-1 passes of Bellman Ford's
      var NumChange = 0;

      for (key in iEL) {
        delete edgeHighlighted[key];
        delete edgeGrey[key];
      }

      for (key in iEL)
        if (p[iEL[key]["v"]] == iEL[key]["u"]) edgeHighlighted[key] = true;
        else                                   edgeGrey[key] = true;

      for (var key in iVL) vertexHighlighted[key] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
      cs["status"] = NextStatus + '<br>The highlighted edges are the current SSSP spanning tree so far.';
      for (var key in iVL) delete vertexHighlighted[key];

      cs["lineNo"] = 2;
      stateList.push(cs);

      for (key in iEL) { // start afresh for next round
        delete edgeHighlighted[key];
        delete edgeGrey[key];
      }
      for (var key in iVL) delete vertexHighlighted[key];
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
      cs["status"] = 'Prepare all edges for this #pass: ' + i + ".";
      cs["lineNo"] = 2;
      stateList.push(cs);

      for (var j = 0; j < amountEdge; ++j) {
        ++EdgeProcessed;
        var u = iEL[j]["u"], v = iEL[j]["v"], w = iEL[j]["w"];
        var thisStatus = "#pass: " + i + ", relax(" + u + "," + v + "," + w + "), #edge_processed = " + EdgeProcessed + ".";

        for (var key in iVL) delete vertexHighlighted[key]; // turn off all vertex highlights first
        vertexTraversed[u] = vertexTraversed[v] = true;
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
        cs["vl"][u]["state"] = cs["vl"][v]["state"] = VERTEX_BLUE_FILL; // GREEN_FILL;
        cs["status"] = thisStatus;
        cs["lineNo"] = [3, 4];
        cs["el"][j]["animateHighlighted"] = true;
        stateList.push(cs);

        // if we can relax vertex B, do updates and some more highlights
        if ((d[u] != 999) && (w != 999) && (d[u]+w < d[v])) {
          d[v] = d[u]+w;
          p[v] = u;
          iVL[v]["extratext"] = d[v];
          thisStatus = thisStatus + "<br>d[" + v + "] = " + d[v] + ", p[" + v + "] = " + p[v] + ".";
          edgeHighlighted[j] = true;
          // for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) edgeHighlighted[key] = true;
          ++NumChange;
        }
        else {
          thisStatus = thisStatus + "<br>No change.";
          edgeGrey[j] = true;
        }

        // highlight the edge being relaxed in the input graph
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
        cs["lineNo"] = [3, 4];
        cs["status"] = thisStatus;
        stateList.push(cs);
      }

      if (NumChange == 0) NextStatus = 'There is no change in the last pass, we can stop Bellman-Ford now.'; // optimized Bellman Ford's
      else                NextStatus = NumChange + ' <font color="orange">orange</font> edge relaxation(s) in the last pass, we will continue.';
    }

    for (var k = 0; k < amountVertex; ++k) vertexHighlighted[k] = true;
    for (var key in iEL) {
      delete edgeHighlighted[key];
      delete edgeGrey[key];
    }
    for (var l = 0; l < amountEdge; ++l)
      if (p[iEL[l]["v"]] == iEL[l]["u"]) edgeHighlighted[l] = true;
      else                               edgeGrey[l] = true;

    cs = processEnding(iVL, iEL, sourceVertex, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey, "#edge_processed = " + EdgeProcessed + ", V*E = " + amountVertex + "*" + amountEdge + " = " + (amountVertex*amountEdge) + ".<br>", d);
    cs["lineNo"] = [5, 6];
    stateList.push(cs);

    populatePseudocode(0);
    gw.startAnimation(stateList, callback);
    return true;
  }

  function processEnding(iVL, iEL, sourceVertex, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey, baseStatus, d) {
    actual_d = RunBellmanFord(iVL, iEL, sourceVertex);
    var GotWA = false;
    for (var key in iVL)
      if (d[key] != actual_d[key])
        GotWA = true;
    var last_cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
    for (var key in iVL)
      if (d[key] != actual_d[key]) {
        last_cs["vl"][key]["extratext"] = last_cs["vl"][key]["extratext"] + " => " + actual_d[key];
        last_cs["vl"][key]["state"] = VERTEX_RED_FILL;
        for (var key2 in iEL) {
          var u = iEL[key2]["u"], v = iEL[key2]["v"];
          if (v == key)
            last_cs["el"][key2]["state"] = EDGE_GREY; // the predecessor information is also invalid
        }
      }
    last_cs["status"] = baseStatus;
    if (!GotWA) last_cs["status"] += 'This is the SSSP spanning tree from source vertex ' + sourceVertex + ".";
    else        last_cs["status"] += "<span style='color: red; background-color: white;'>" + 'ERROR: Vertex with red color has WRONG shortest path value</span>.';
    return last_cs;
  }

  this.dijkstra = function(sourceVertex, versionType, callback) {
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, edgeGrey = {};
    var stateList = [];
    var key, i, cs;

    // error checks
    if (amountVertex == 0) { // no graph
      $('#dijkstra-err').html('There is no graph to run this on. Please select an example graph first.');
      return false;
    }

    if (sourceVertex >= amountVertex || sourceVertex < 0) { // source vertex not in range
      $('#dijkstra-err').html('This vertex does not exist in the graph. Please select another source vertex.');
      return false;
    }

    if (versionType == 1) { // original
      isCorrect = !HasNegativeWeight(iVL, iEL);
      if (!isCorrect) {
        cs = createState(iVL, iEL);
        cs["status"] = "<span style='color: yellow; background-color: black;'>" + '&exist; &ge; 1 edge(s) with <b>negative weight</b>.<br>The Original Dijkstra&#39;s algorithm will likely yield wrong answer</span>.';
        cs["lineNo"] = 1;
        stateList.push(cs);
      }
    }
    else { // Modified
      isCorrect = !HasNegativeWeightCycle(iVL, iEL, sourceVertex);
      if (!isCorrect) {
        cs = createState(iVL, iEL);
        cs["status"] = "<span style='color: yellow; background-color: black;'>" + '∃ ≥ 1 <b>negative weight cycle(s) reachable from the source vertex</b>.<br>The Modified Dijkstra&#39;s algorithm will be trapped in an infinite loop</span>.';
        cs["lineNo"] = 1;
        stateList.push(cs);
      }
    }

    var d = {}, p = {};
    for (var i = 0; i < amountVertex; ++i) {
      d[i] = 999;
      p[i] = -1;
      iVL[i]["state"] = VERTEX_DEFAULT;
      iVL[i]["extratext"] = "Inf";
    }
    d[sourceVertex] = 0;

    vertexTraversed[sourceVertex] = true;
    iVL[sourceVertex]["extratext"] = "source, 0";

    var pq = [], done = [];
    var EdgeProcessed = 0;

    if (versionType == 1) { // original
      for (var i = 0; i < amountVertex; ++i)
        if (i == sourceVertex) pq.push(new ObjectPair(0, i));
        else                   pq.push(new ObjectPair(999, i));
    }
    else // modified
      pq.push(new ObjectPair(0, sourceVertex)); // only push one

    function ShowPQ() {
      if (pq.length == 0) return "{}";
      var result = "{<span style='color: green; background-color: pink;'>(" + pq[0].getFirst() + "," + pq[0].getSecond() + ")</span>";
      if (pq.length > 1) result += ", (" + pq[1].getFirst() + "," + pq[1].getSecond() + ")";
      if (pq.length > 2) result += ", (" + pq[2].getFirst() + "," + pq[2].getSecond() + ")";
      if (pq.length > 3) result += ", ...";
      return result + "}";
    }

    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
    cs["status"] = sourceVertex + ' is the source vertex.<br>Set p[v] = -1, d[v] = Inf, but d[' + sourceVertex + '] = 0, PQ = ' + ShowPQ() + ".";
    cs["lineNo"] = 2;
    stateList.push(cs);

    while (pq.length > 0) {
      pq.sort(ObjectPair.compare); // sort by distance, then by vertex number, lousy O(n log n) PQ update
      if (versionType == 2 && (EdgeProcessed >= 100 && HasNegativeWeightCycle(iVL, iEL, sourceVertex))) { // to prevent infinite loop in Modified Dijkstra on negative cycle
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
        cs["status"] = "#edge_processed = " + EdgeProcessed + '... Modified Dijkstra&#39;s algorithm is stopped prematurely in order to prevent infinite loop.';
        stateList.push(cs);
        break;
      }

      var curFront = pq[0].getSecond();
      done.push(curFront);

      var newStatus = 'The current priority queue ' + ShowPQ();
      var frontitem = pq.shift(); // front most item
      var dist = frontitem.getFirst(); // not used in original dijkstra
      var f = frontitem.getSecond();
      vertexHighlighted[f] = true;

      if (versionType == 2 && dist > d[f]) {
        newStatus += ".<br>(" + dist + "," + f + ") "+'is an old information and skipped.';
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
        cs["vl"][f]["state"] = VERTEX_BLUE_FILL; // GREEN_FILL;
        cs["lineNo"] = [3, 4];
        cs["status"] = newStatus;
        stateList.push(cs);
        continue; // do not do anything else...
      }
      else {
        newStatus += '.<br>Exploring neighbors of vertex u = ' + f + ", d[u] = " + d[f] + ".";
        vertexTraversed[curFront] = true; // only re-highlight here
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
        cs["vl"][f]["state"] = VERTEX_BLUE_FILL; // GREEN_FILL;
        cs["lineNo"] = 3;
        cs["status"] = newStatus;
        stateList.push(cs);
      }

      var neighbors = [];
      for (var j = 0; j < amountEdge; ++j) if (iEL[j]["u"] == f) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var u = iEL[j]["u"], v = iEL[j]["v"], w = iEL[j]["w"];

        vertexTraversed[v] = true;
        ++EdgeProcessed;
        var thisStatus = 'relax(' + u + ',' + v + ',' + w + '), #edge_processed = ' + EdgeProcessed;

        if ((d[u] != 999) && (w != 999) && (d[u]+w < d[v])) {
          d[v] = d[u]+w;
          if (versionType == 1)
            for (var k = 0; k < pq.length; ++k) // lousy O(n) PQ update, but it works for this animation (only for version 1)
              if (pq[k].getSecond() == v) {
                pq.splice(k, 1);
                break;
              }

          edgeHighlighted[j] = true;
          // for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) edgeHighlighted[key] = true;

          if ((p[v] != -1) && (p[v] != u))  { // it has a parent before and its parent is not u
            for (var k = 0; k < amountEdge; ++k)
              if (iEL[k]["u"] == p[v] && iEL[k]["v"] == v) {
                delete edgeHighlighted[k];
                edgeGrey[k] = true; // now make it "grey"
              }
              else if (iEL[k]["u"] == v && iEL[k]["v"] == p[v] && edgeHighlighted[k])
                delete edgeHighlighted[k];
          }

//          delete edgeGrey[j]; // just in case the update is on the same edge
          p[v] = u; // now update parent information
          iVL[v]["extratext"] = d[v];

          var canRelaxThis = true;
          for (var k = 0; k < done.length; ++k)
            if (done[k] == v) {
              canRelaxThis = false;
              break;
            }

          if (versionType == 2 || canRelaxThis) // for standard dijkstra
            pq.push(new ObjectPair(d[v], parseInt(v)));

          pq.sort(ObjectPair.compare);
          thisStatus = thisStatus + ".<br>d[" + v + "] = d[" + u + "]+w(" + u + "," + v + ") = " + d[u] + "+" + w + " = " + d[v] + ", p[" + v + "] = " + p[v] + ", PQ = " + ShowPQ() + ".";
        }
        else {
          thisStatus = thisStatus + ".<br>d[" + u + "]+w(" + u + "," + v + ") > d[" + v + "], i.e. " + (d[u] == 999 ? "Inf" : d[u]) + "+" + w + " &gt; " + (d[v] == 999 ? "Inf" : d[v]) + ", so there is no change.";
          edgeGrey[j] = true; // make this grey
        }

        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
        cs["status"] = thisStatus;
        if (versionType == 1) cs["lineNo"] = [4, 5];
        else                  cs["lineNo"] = [5, 6];
        cs["vl"][u]["state"] = VERTEX_BLUE_FILL; // GREEN_FILL;
        cs["el"][j]["animateHighlighted"] = true;
        stateList.push(cs);
      }

      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
      if (versionType == 1) {
        cs["status"] = 'd[' + f + '] = ' + d[f] + ' is final as all outgoing edges of this vertex has been processed.';
        cs["lineNo"] = [4, 5];
      }
      else {
        cs["status"] = 'd[' + f + '] = ' + d[f] + ' can still be re-updated in the future as necessary as this vertex is only &#39;temporarily&#39; completed.';
        cs["lineNo"] = [5, 6];
      }
      stateList.push(cs);
    }

    if (versionType == 1 || (versionType == 2 && EdgeProcessed < 100)) // to prevent infinite loop in Modified Dijkstra on negative cycle
      stateList.push(processEnding(iVL, iEL, sourceVertex, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey, "#edge_processed = " + EdgeProcessed + ", O((V+E) log V) = " + Math.ceil((amountVertex+amountEdge) * Math.log(amountVertex)/Math.log(2.0)) + ".<br>", d));

    if (versionType == 1) populatePseudocode(1);
    else                  populatePseudocode(2);

    gw.startAnimation(stateList, callback);
    return true;
  }

  this.bfs = function(sourceVertex, callback) {
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, edgeGrey = {};
    var stateList = [];
    var key, i, cs, isCorrect;

    // error checks
    if (amountVertex == 0) { // no graph
      $('#bfs-err').html('There is no graph to run this on. Please select an example graph first.');
      return false;
    }

    if (sourceVertex >= amountVertex || sourceVertex < 0) { // source vertex not in range
      $('#bfs-err').html('This vertex does not exist in the graph. Please select another source vertex.');
      return false;
    }

    isCorrect = IsConstantWeighted(iVL, iEL);
    if (!isCorrect) {
      cs = createState(iVL, iEL);
      cs["status"] = "<span style='color: yellow; background-color: black;'>" + 'WARNING: The graph is not an <b>unweighted/constant-weighted graph</b>.<br>BFS will likely yield wrong SSSP answer</span>.';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }

    var d = {}, p = {};
    for (var i = 0; i < amountVertex; ++i) {
      d[i] = 999;
      p[i] = -1;
      iVL[i]["state"] = VERTEX_DEFAULT;
      iVL[i]["extratext"] = "Inf";
    }
    d[sourceVertex] = 0;

    vertexTraversed[sourceVertex] = true;
    iVL[sourceVertex]["extratext"] = "source, 0";
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
    cs["status"] = sourceVertex + ' is the source vertex.<br>Set p[v] = -1, d[v] = Inf, but d[' + sourceVertex + '] = 0 and push this vertex to queue.';
    cs["lineNo"] = 2;
    stateList.push(cs);

    var q = [];
    q.push(sourceVertex);
    var EdgeProcessed = 0;

    function ShowQ() {
      var result = "{" + q[0];
      if (q.length > 1) result += ", " + q[1];
      if (q.length > 2) result += ", " + q[2];
      if (q.length > 3) result += ", " + q[3];
      if (q.length > 4) result += ", ...";
      return result + "}";
    }

    while (q.length > 0) {
      vertexHighlighted[q[0]] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
      newStatus = 'The queue is now ' + ShowQ() + ".<br><span style='color: green; background-color: pink;'>" + 'Exploring neighbors of vertex u = ' + q[0] + "</span>.";
      cs["vl"][q[0]]["state"] = VERTEX_BLUE_FILL; // GREEN_FILL;
      cs["status"] = newStatus;
      cs["lineNo"] = 3;
      stateList.push(cs);

      var f = q.shift(); // front most item

      var neighbors = [];
      for (var j = 0; j < amountEdge; ++j) if (iEL[j]["u"] == f) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var u = iEL[j]["u"], v = iEL[j]["v"], w = iEL[j]["w"]; // w not necessarily 1, we make it more flexible

        vertexTraversed[v] = true;
        ++EdgeProcessed;
        var thisStatus = "relax(" + u + "," + v + "," + w + "), #edge_processed = " + EdgeProcessed;

        if ((d[u] != 999) && (d[v] == 999)) { // only if the destination has not been visited yet (most likely lead to Wrong Answer for unweighted graphs)
          d[v] = d[u]+w;

          edgeHighlighted[j] = true;
          // for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) edgeHighlighted[key] = true;

          if (p[v] != -1) { // it has a parent before
            for (var k = 0; k < amountEdge; ++k)
              if (iEL[k]["u"] == p[v] && iEL[k]["v"] == v) {
                delete edgeHighlighted[k];
                edgeGrey[k] = true; // now make it "grey"
              }
              else if (iEL[k]["u"] == v && iEL[k]["v"] == p[v] && edgeHighlighted[k])
                delete edgeHighlighted[k];
          }

          q.push(v);
//          delete edgeGrey[j]; // just in case the update is on the same edge
          p[v] = u;
          iVL[v]["extratext"] = d[v];
          thisStatus = thisStatus + ".<br>d[" + v + "] = " + d[v] + ", p[" + v + "] = " + p[v] + ", Q = " + ShowQ() + ".";
          vertexTraversed[v] = true;
        }
        else {
          thisStatus = thisStatus + ".<br>Destination vertex is already visited, so no change.";
          edgeGrey[j] = true;
        }

        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
        cs["status"] = thisStatus;
        if (edgeGrey[j]) cs["lineNo"] = [4, 5];
        else             cs["lineNo"] = [4, 5, 6];
        cs["vl"][u]["state"] = VERTEX_BLUE_FILL; // GREEN_FILL;
        cs["el"][j]["animateHighlighted"] = true;
        stateList.push(cs);
      }
    }

    stateList.push(processEnding(iVL, iEL, sourceVertex, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey, "#edge_processed = " + EdgeProcessed + ", O(V+E) = " + amountVertex + "+" + amountEdge + " = " + (amountVertex+amountEdge) + ".<br>", d));

    populatePseudocode(3);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.dfs = function(sourceVertex, callback) {
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, edgeGrey = {};
    var stateList = [];
    var key, i, cs, isCorrect = true;

    // error checks
    if (amountVertex == 0) { // no graph
      $('#dfs-err').html('There is no graph to run this on. Please select an example graph first.');
      return false;
    }

    if (sourceVertex >= amountVertex || sourceVertex < 0) { // source vertex not in range
      $('#dfs-err').html('This vertex does not exist in the graph. Please select another source vertex.');
      return false;
    }

    isCorrect = IsTree(iVL, iEL);
    if (!isCorrect) {
      cs = createState(iVL, iEL);
      cs["status"] = "<span style='color: yellow; background-color: black;'>" + 'WARNING: The input graph is not an <b>undirected tree</b>.<br>DFS will likely yield wrong answer.</span>"';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }

    var d = {}, p = {};
    for (var i = 0; i < amountVertex; ++i) {
      d[i] = 999;
      p[i] = -1;
      iVL[i]["state"] = VERTEX_DEFAULT;
      iVL[i]["extratext"] = "Inf";
    }
    d[sourceVertex] = 0;

    vertexTraversed[sourceVertex] = true;
    iVL[sourceVertex]["extratext"] = "source, 0";
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
    cs["status"] = sourceVertex + ' is the source vertex.<br>Set p[v] = -1, d[v] = Inf, but d[" + sourceVertex + "] = 0.';
    cs["lineNo"] = 2;
    stateList.push(cs);

    var EdgeProcessed = 0;

    function dfsRecur(u) {
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
      cs["status"] = "DFS(" + u + ")";
      cs["vl"][u]["state"] = VERTEX_BLUE_FILL; // GREEN_FILL;
      cs["lineNo"] = 3;
      stateList.push(cs);

      var neighbors = [];
      for (var j = 0; j < amountEdge; ++j) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var u = iEL[j]["u"], v = iEL[j]["v"], w = iEL[j]["w"];

        ++EdgeProcessed;
        var thisStatus = "relax(" + u + "," + v + "," + w + "), #edge_processed = " + EdgeProcessed;

        if ((d[u] != 999) && (d[v] == 999)) {
          d[v] = d[u]+w;

          edgeHighlighted[j] = true;
          // for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) edgeHighlighted[key] = true;

          if (p[v] != -1) { // it has a parent before
            for (var k = 0; k < amountEdge; ++k)
              if (iEL[k]["u"] == p[v] && iEL[k]["v"] == v) {
                delete edgeHighlighted[k];
                edgeGrey[k] = true; // now make it "grey"
              }
              else if (iEL[k]["u"] == v && iEL[k]["v"] == p[v] && edgeHighlighted[k])
                delete edgeHighlighted[k];
          }

          // delete edgeGrey[j]; // just in case the update is on the same edge
          p[v] = u;
          iVL[v]["extratext"] = d[v];
          thisStatus = thisStatus + ".<br>d[" + v + "] = " + d[v] + ", p[" + v + "] = " + p[v] + ".";
          vertexTraversed[v] = true;

          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
          cs["lineNo"] = [4, 5, 6];
          cs["status"] = thisStatus;
          cs["el"][j]["animateHighlighted"] = true;
          stateList.push(cs);

          dfsRecur(v);

          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
          cs["vl"][u]["state"] = VERTEX_BLUE_FILL; // GREEN_FILL;
          cs["vl"][v]["state"] = VERTEX_HIGHLIGHTED;
          cs["status"] = 'Finish DFS(' + v + '), backtrack to DFS(" + u + ").';
          stateList.push(cs);
        }
        else {
          edgeGrey[j] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
          thisStatus = thisStatus + ".<br>Relax not successful.";
          cs["lineNo"] = [4, 5];
          cs["status"] = thisStatus;
          cs["el"][j]["animateHighlighted"] = true;
          stateList.push(cs);
        }
      }
      vertexTraversed[u] = true;
    }
    dfsRecur(sourceVertex);

    stateList.push(processEnding(iVL, iEL, sourceVertex, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey, "#edge_processed = " + EdgeProcessed + ", O(V+E) = " + amountVertex + "+" + amountEdge + " = " + (amountVertex+amountEdge) + ".<br>", d));

    populatePseudocode(4);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.dp = function(sourceVertex, callback) {
    var notVisited = {}, vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, edgeTraversed = {}, edgeGrey = {};
    var stateList = [];
    var key, i, cs, isCorrect = true;

    // error checks
    if (amountVertex == 0) { // no graph
      $('#dp-err').html('There is no graph to run this on. Please select an example graph first.');
      return false;
    }

    if (sourceVertex >= amountVertex || sourceVertex < 0) { // source vertex not in range
      $('#dp-err').html('This vertex does not exist in the graph. Please select another source vertex.');
      return false;
    }

    isCorrect = IsDAG(iVL, iEL);
    if (!isCorrect) {
      $('#dp-err').html('The input graph is not a <b>Directed Acyclic Graph</b>.');
      return false;
    }

    var order = TopoSort(iVL, iEL);
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
    cs["status"] = 'As this is a DAG, it has at least one topological order.<br><span style="color: red; background-color: white;">One of the topological order is: {' + order + "}.</span>";
    for (var i = 0; i < order.length; ++i)
      cs["vl"][order[i]]["extratext"] = i;
    cs["lineNo"] = 1;
    stateList.push(cs);

    var d = {};
    var p = {};
    for (var i = 0; i < amountVertex; ++i) {
      d[i] = 999;
      p[i] = -1;
    }
    d[sourceVertex] = 0;

    for (key in iVL) {
      iVL[key]["state"] = VERTEX_DEFAULT;
      iVL[key]["extratext"] = "Inf";
    }

    vertexHighlighted[sourceVertex] = true;
    iVL[sourceVertex]["extratext"] = "source, 0";
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
    cs["status"] = sourceVertex + ' is the source vertex.<br>Set p[v] = -1, d[v] = Inf, but d[" + sourceVertex + "] = 0.';
    cs["lineNo"] = 2;
    stateList.push(cs);

    delete vertexHighlighted[sourceVertex];
    for (key in iEL) delete edgeTraversed[key];

    var EdgeProcessed = 0;

    while (order.length > 0) {
      var u = order[0];
      order.shift();
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
      cs["vl"][u]["state"] = VERTEX_BLUE_FILL; // GREEN_FILL;
      cs["status"] = 'Current topological order:' + " {<span style='color: green; background-color: pink;'>" + u + "</span>" + (order.length > 0 ? "," : "") + order + '}.<br>So, we process the outgoing edges of vertex ' + u + ".";
      cs["lineNo"] = [3, 4];
      stateList.push(cs);

      var neighbors = [];
      for (var j = 0; j < amountEdge; ++j) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var u = iEL[j]["u"], v = iEL[j]["v"], w = iEL[j]["w"];

        ++EdgeProcessed;
        var thisStatus = "relax(" + u + "," + v + "," + w + "), #edge_processed = " + EdgeProcessed;

        if ((d[u] != 999) && (d[u]+w < d[v])) {
          d[v] = d[u]+w;

          edgeHighlighted[j] = true;
          // for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) edgeHighlighted[key] = true;

          if (p[v] != -1) { // it has a parent before
            for (var k = 0; k < amountEdge; ++k)
              if (iEL[k]["u"] == p[v] && iEL[k]["v"] == v) {
                delete edgeHighlighted[k];
                edgeGrey[k] = true; // now make it "grey"
              }
              else if (iEL[k]["u"] == v && iEL[k]["v"] == p[v] && edgeHighlighted[k])
                delete edgeHighlighted[k];
          }

          // delete edgeGrey[j]; // just in case the update is on the same edge
          p[v] = u;
          iVL[v]["extratext"] = d[v];
          thisStatus = thisStatus + ".<br>d[" + v + "] = " + d[v] + ", p[" + v + "] = " + p[v] + ".";
          vertexTraversed[v] = true;
        }
        else {
          edgeGrey[j] = true;
          thisStatus = thisStatus + ".<br>Relax not successful.";
        }
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
        cs["lineNo"] = 5;
        cs["status"] = thisStatus;
        cs["vl"][u]["state"] = VERTEX_BLUE_FILL; // GREEN_FILL;
        cs["el"][j]["animateHighlighted"] = true;
        stateList.push(cs);
      }
      vertexTraversed[u] = true;
    }

    for (key in iVL) delete vertexTraversed[key];
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey);
    cs["status"] = "#edge_processed = " + EdgeProcessed + ", O(V+E) = " + amountVertex + "+" + amountEdge + " = " + (amountVertex+amountEdge) + '.<br>This is the SSSP spanning tree from source vertex = ' + sourceVertex + ".";
    stateList.push(cs);

    populatePseudocode(5);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.examples = function(id) {
    iVL = getExampleGraph(id, VL);
    iEL = getExampleGraph(id, EL);
    fixJSON();
    var newState = createState(iVL, iEL);
    if (id == SSSPLARGE || id == SSSPMRT) {
        setMediumScale();
    }
    gw.removeAll();
    gw.updateGraph(newState, 500);
    return true;
  }

  this.loadGraph = function(vertexList, edgeList) {
    iVL = vertexList;
    iEL = edgeList;
    fixJSON();
    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
  }

  function createState(iVLObject, iELObject, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeGrey) {
    if (vertexHighlighted == null) vertexHighlighted = {};
    if (edgeHighlighted == null) edgeHighlighted = {};
    if (vertexTraversed == null) vertexTraversed = {};
    if (edgeGrey == null) edgeGrey = {};

    var key;
    var state = {
      "vl": {},
      "el": {}
    };

    for (key in iVLObject) {
      state["vl"][key] = {};
      state["vl"][key]["cx"] = iVLObject[key]["x"];
      state["vl"][key]["cy"] = iVLObject[key]["y"];
      state["vl"][key]["text"] = key;
      state["vl"][key]["extratext"] = iVLObject[key]["extratext"];
      if (iVLObject[key]["state"] == OBJ_HIDDEN)
        state["vl"][key]["state"] = OBJ_HIDDEN;
      else
        state["vl"][key]["state"] = VERTEX_DEFAULT;
    }

    for (key in iELObject) {
      state["el"][key] = {};
      state["el"][key]["vertexA"] = iELObject[key]["u"];
      state["el"][key]["vertexB"] = iELObject[key]["v"];
      state["el"][key]["type"] = EDGE_TYPE_DE;
      state["el"][key]["weight"] = iELObject[key]["w"];
      if (iELObject[key]["state"] == OBJ_HIDDEN)
        state["el"][key]["state"] = OBJ_HIDDEN;
      else
        state["el"][key]["state"] = EDGE_DEFAULT;
      state["el"][key]["displayWeight"] = true;
      state["el"][key]["animateHighlighted"] = false;
    }

    for (key in vertexTraversed) state["vl"][key]["state"] = VERTEX_BLUE_OUTLINE; // TRAVERSED;
    for (key in vertexHighlighted) state["vl"][key]["state"] = VERTEX_HIGHLIGHTED;

    for (key in edgeHighlighted) {
      state["el"][key]["state"] = EDGE_RED; // EDGE_HIGHLIGHTED;
      // for (var keyR in iEL) if ((iEL[key]["u"] == iEL[keyR]["v"]) && (iEL[key]["v"] == iEL[keyR]["u"])) edgeHighlighted[keyR] = true;
    }

    for (key in edgeGrey) {
/*
      var hasComplement = false, complementHighlighted = false;
      for (key2 in iELObject)
        if ((iELObject[key]["u"] == iELObject[key2]["v"]) && (iELObject[key]["v"] == iELObject[key2]["u"])) { // if one on top another...
          hasComplement = true;
          for (key3 in edgeHighlighted)
            if (key3 == key2)
              complementHighlighted = true;
        }
      if (hasComplement && complementHighlighted) // one on top of the other, and the other side is highlighted... hide this
        state["el"][key]["state"] = OBJ_HIDDEN;
      else // if not overlapping, grey it
*/
      // now can be simplified (25 Oct)
        state["el"][key]["state"] = EDGE_GREY;
    }

    return state;
  }

  function populatePseudocode(act) {
    switch (act) {
      case 0: // Bellman Ford's
        $('#code1').html('initSSSP');
        $('#code2').html('for i = 1 to |V|-1');
        $('#code3').html('&nbsp;&nbsp;for each edge(u, v) in E // in Edge List order');
        $('#code4').html('&nbsp;&nbsp;&nbsp;&nbsp;relax(u, v, w(u, v))');
        $('#code5').html('for each edge(u, v) in E');
        $('#code6').html('&nbsp;&nbsp;if can still relax that edge, -&infin; cycle found');
        $('#code7').html('// <b><a href="https://github.com/stevenhalim/cpbook-code/tree/master/ch4/sssp" target="_blank">bellman_ford.cpp/py/java/ml</a></b>');
        break;
      case 1: // Original Dijkstra's
        $('#code1').html('show warning if the graph has -ve weight edge');
        $('#code2').html('initSSSP, pre-populate PQ');
        $('#code3').html('while !PQ.empty() // PQ is a Priority Queue');
        $('#code4').html('&nbsp;&nbsp;for each neighbor v of u = PQ.front(), PQ.pop()');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;relax(u, v, w(u, v)) + update PQ');
        $('#code6').html('&nbsp;');
        $('#code7').html('// <b><a href="https://github.com/stevenhalim/cpbook-code/tree/master/ch4/sssp" target="_blank">dijkstra.cpp/py/java/ml</a></b>');
        break;
      case 2: // Modified Dijkstra's
        $('#code1').html('show warning if the graph has -ve weight cycle');
        $('#code2').html('initSSSP, PQ.push((0,sourceVertex))');
        $('#code3').html('while !PQ.empty() // PQ is a Priority Queue');
        $('#code4').html('&nbsp;&nbsp;u = PQ.front(), PQ.pop()');
        $('#code5').html('&nbsp;&nbsp;for each neighbor v of u if u is valid');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;relax(u, v, w(u, v)) + insert new pair to PQ');
        $('#code7').html('// <b><a href="https://github.com/stevenhalim/cpbook-code/tree/master/ch4/sssp" target="_blank">dijkstra.cpp/py/java/ml</a></b>');
        break;
      case 3: // BFS
        $('#code1').html('show warning if the graph is weighted');
        $('#code2').html('initSSSP, Q.push(sourceVertex)');
        $('#code3').html('while !Q.empty() // Q is a normal Queue');
        $('#code4').html('&nbsp;&nbsp;for each neighbor v of u = Q.front(), Q.pop()');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;if !visited[v]');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;relax(u, v, w(u, v)), Q.push(v)');
        $('#code7').html('// <b><a href="https://github.com/stevenhalim/cpbook-code/tree/master/ch4/sssp" target="_blank">bfs.cpp/py/java/ml</a></b>');
        break;
      case 4: // DFS
        $('#code1').html('show warning if the graph is not a tree');
        $('#code2').html('initSSSP, then DFS(sourceVertex)');
        $('#code3').html('DFS(u)');
        $('#code4').html('&nbsp;&nbsp;for each neighbor v of u');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;if !visited[v]');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;relax(u, v, w(u, v)), DFS(v)');
        $('#code7').html('&nbsp;');
        break;
      case 5: // DP
        $('#code1').html('order = Topological Sort the input DAG');
        $('#code2').html('initSSSP');
        $('#code3').html('while !order.empty()');
        $('#code4').html('&nbsp;&nbsp;u = order.front()');
        $('#code5').html('&nbsp;&nbsp;relax all outgoing edges of vertex u');
        $('#code6').html('&nbsp;');
        $('#code7').html('&nbsp;');
        break;
    }
  }
}



// SSSP_action.js
var actionsWidth = 180;
var statusCodetraceWidth = 410;

// local
write(false, false);
var ssspWidget, gw, randomGraphID;

$(function() {
  $('#play').hide();
  ssspWidget = new SSSP();
  gw = ssspWidget.getgw();
  gw.setAnimationDuration(700 / speedVal);
  var options = [CP3_4_1, CP3_4_3, CP3_4_4, CP3_4_9, HOUSE_OF_CARDS,
                 CP3_4_10, CP3_4_14, CP3_4_17, TESSELLATION, CP3_4_24,
                 WHEEL, CP3_4_18, CP3_4_19, DIJKSTRA_KILLER, BELLMANFORD_KILLER,
                 RAIL, DAG, CP3_4_40];
  ssspWidget.examples(options[Math.floor(Math.random()*18)]);
  randomGraphID = -1;

  var graphJSON = getQueryVariable("create");
  if (graphJSON.length > 0) {
    ssspWidget.importjson(graphJSON);
    window.history.pushState("object or string", "Title", window.location.href.split('?')[0]);
  }

  userGraph = ssspWidget.getGraph(); // save the current graph
});

// function importjson() {
//   if (isPlaying) stop();
//   if (mode == "exploration") {
//     ssspWidget.importjson();
//     closeExamples();
//     isPlaying = false;
//   }
// }
function setDefaultScale() {
    if (isPlaying) stop();
    isPlaying = false;
    if (scale) {
        scale = !scale;
        gw.redrawAllForMediumScale();
        gw.setMediumScale(false);

        userGraph = ssspWidget.getGraph();
    } 
}

function setMediumScale() {
    if (isPlaying) stop();
    isPlaying = false;
    if (!scale) {
        scale = !scale;
        gw.redrawAllForMediumScale();
        gw.setMediumScale(true);

        userGraph = ssspWidget.getGraph();
    }
}

function toggleVertexNumber() {
    if (isPlaying) stop();
    isPlaying = false;
    if (scale) {
        gw.toggleVertexNumber();
    }
}

function drawGraph() {
  if (isPlaying) stop();
  if (mode == "exploration") {
    const [newiVL, newiEL] = representationConvert(ssspWidget.getiVL(), ssspWidget.getiEL())
    currentGraphVisu = new GraphVisu(false, false, true, newiVL, newiEL, true)
    $('#dark-overlay').fadeIn(function() {
      $('#drawgraph').fadeIn();
    });
    ssspWidget.startLoop();
    isPlaying = false;
  }
}

function drawDone() {
  if (!ssspWidget.draw()) return false;
  ssspWidget.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

function drawCancel() {
  ssspWidget.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

function createRandom() {
  if (isPlaying) stop();
  if (mode == "exploration") {
    $.ajax({
      url: PHP_DOMAIN + "/php/Graph.php?mode=" + MODE_GET_RANDOM_SUBMITTED_GRAPH + "&directed=" + 1 + "&connected=" + 1
    }).done(function(data) {
      data = JSON.parse(data);
      var graph = extractQnGraph(data.graph);
      if (data.graphID == randomGraphID) // make sure it is different, make sure #graph > 1
        createRandom();
      randomGraphID = data.graphID;
      ssspWidget.initRandom(graph);
      $('#rate-sample-graph').show();
    })
    $('#progress-bar').slider("option", "max", 0);
    //closeExamples();
    closeAction('examples');
    isPlaying = false;
  }
}

function example(id) {
  if (isPlaying) stop();
  if (ssspWidget.examples(id)) { // not 100% the same as commonAction
    $('#progress-bar').slider("option", "max", 0);
    isPlaying = false;
  }
}

function bellmanford(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#bellmanford-v').val());
  commonAction(ssspWidget.bellmanford(input, callback), "BellmanFord(" + input + ")");
  setTimeout(function() { $("#bellmanford-v").val(1 + Math.floor(Math.random()*ssspWidget.getV())); }, 500); // randomized for next click between [0..V-1]
}

function dijkstra(versionType, callback) {
  if (isPlaying) stop();
  var input = parseInt($('#dijkstra-v').val());
  commonAction(ssspWidget.dijkstra(input, versionType, callback), (versionType == 1) ? ("OriginalDijkstra(" + input + ")") : ("ModifiedDijkstra(" + input + ")"));
  setTimeout(function() { $("#dijkstra-v").val(1 + Math.floor(Math.random()*ssspWidget.getV())); }, 500);
}

function bfs(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#bfs-v').val());
  commonAction(ssspWidget.bfs(input, callback), "BFS(" + input + ")");
  setTimeout(function() { $("#bfs-v").val(1 + Math.floor(Math.random()*ssspWidget.getV())); }, 500);
}

function dfs(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#dfs-v').val());
  commonAction(ssspWidget.dfs(input, callback), "DFS(" + input + ")");
  setTimeout(function() { $("#dfs-v").val(1 + Math.floor(Math.random()*ssspWidget.getV())); }, 500);
}

function dp(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#dp-v').val());
  commonAction(ssspWidget.dp(input, callback), "DP(" + input + ")");
  setTimeout(function() { $("#dp-v").val(1 + Math.floor(Math.random()*ssspWidget.getV())); }, 500);
}

function loadGraph(graph) {
  if (ssspWidget) {
    ssspWidget.loadGraph(graph['vl'], graph['el']);
  }
}

// Implement these functions in each visualisation
var userGraph = {
  'vl': {},
  'el': {},
};

// This function will be called before entering E-Lecture Mode
function ENTER_LECTURE_MODE() {
  if (ssspWidget) userGraph = ssspWidget.getGraph();
}

// This function will be called before returning to Explore Mode
function ENTER_EXPLORE_MODE() {
  loadGraph(userGraph);
}

// Lecture action functions
function CUSTOM_ACTION(action, data, mode) {
  if (action == 'bellmanford') {
    hideSlide(function() {
      $('#bellmanford-v').val(data); // force
      bellmanford(showSlide);
    });
  }
  else if (action == 'dijkstra') {
    hideSlide(function() {
      $('#dijkstra-v').val(data); // force
      dijkstra(1, showSlide);
    });
  }
  else if (action == 'dijkstra_modified') {
    hideSlide(function() {
      $('#dijkstra-v').val(data); // force
      dijkstra(2, showSlide);
    });
  }
  else if (action == 'bfs') {
    hideSlide(function() {
      $('#bfs-v').val(data); // force
      bfs(showSlide);
    });
  }
  else if (action == 'dfs') {
    hideSlide(function() {
      $('#dfs-v').val(data); // force
      dfs(showSlide);
    });
  }
  else if (action == 'dp') {
    hideSlide(function() {
      $('#dp-v').val(data); // force
      dp(showSlide);
    });
  }
}
</script>
</body>

<!-- Mirrored from visualgo.net/en/sssp?slide=7-5 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:17:59 GMT -->
</html>
