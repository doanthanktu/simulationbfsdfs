<!--
  All IDs are given -weighted or -unweighted based on whether they should be displayed upon click of sub-menu
-->



<!DOCTYPE html>
<html lang="en">

<!-- Mirrored from visualgo.net/en/mvc by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:18:00 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="description" content="A Vertex Cover (VC) of a connected undirected (un)weighted graph G is a subset of vertices V of G such that for every edge in G, at least one of its endpoints is in V. A Minimum Vertex Cover (MVC) (Minimum Weight Vertex Cover (MWVC) for the weighted variant) of G is a VC that has the smallest cardinality (if unweighted) or total weight (if weighted) among all possible VCs. A graph can have multiple VCs but the cardinality/total weight of its MVC/MWVC is unique.There is another problem called Maximum Independent Set (MIS) that attempts to find the largest subset of vertices in a (un)weighted graph G without any adjacent vertices in the subset. Interestingly, the complement of an MVC of a graph is an MIS.At the end of every visualization, when an algorithm highlights an MVC solution of the currently displayed graph in orange color. For non-approximation solutions, the visualization will also highlight the MIS solution (which is V &amp;bsol; MVC) with light blue color.MVC, MWVC, MIS, (and MWIS) are all NP-hard combinatorial optimization problems.">
<meta name="keywords" content="Approximation, DP, Greedy, Bruteforce">
 
<meta name="csrf-token" content="dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../img/png/mvc.png">
<title>Minimum Vertex Cover (Bruteforce, Approximation, DP, Greedy) - VisuAlgo</title>
<link rel="icon" href="../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../img/favicon.png">
<link rel="stylesheet" href="../css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../css/common-1.0.2.css">
<link rel="stylesheet" href="../css/viz-1.0.4.css">
<link rel="stylesheet" href="../css/visual.css">
<link rel="stylesheet" href="../css/drawgraph-1.0.2.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
        z-index: 8001;
      }
      #e-lecture-timeline {
        top: 80px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }
      .e-lecture-timeline-slide {
        height: 5px;
        width: 2px;
        background: black;
        float: left;
      }
      .e-lecture-timeline-checkpoint {
        height: 20px;
        width: 3px;
        margin-left: 2px;
        margin-top: -7.5px;
        background: black;
        float: left;
      }

      #e-lecture-f1map {
        top: 102.5px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }

      .e-lecture-f1map-sector {
        flex-grow: 1;
        background: black;
        float: left;
        height: 5px;
        margin-right: 1px;
      }

      .e-lecture-f1map-sector:last-child {
        margin-right: 0px;
      }

      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }

      .electure-read-status {
        position: absolute;
        bottom: 4px;
        right: 4px;
        font-size: 14px;
        cursor: default;
        color: #00FF7F;
        display: none;
      }

      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
      .electure-print, .electure-end {
        position: fixed;
        top: 45px;
        height: 20px;
        width: 17px;
        right: 80px;
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
        text-align: center;
      }
      .electure-end {
        right: 45px; /* beside the X */
      }

      #change-lang-popup {
        position: fixed;
        background: green;
        left: 40px;
        top: 50px;
        width: 250px;
        height: 125px;
        border: transparent;
        border-radius: 10px;
        padding: 10px 20px;
        z-index: 9000;
      }

      #change-lang-popup p {
        font-size: medium;
        color: white;
        line-height: 2;
        font-family: "PT Sans", sans-serif;
      }

      #change-lang-popup-btn {
        text-decoration: underline;
        margin-left: 50px;
      }

      #change-lang-popup-btn:hover {
        cursor: pointer;
      }

      #rotateDeviceOverlay {
        z-index: 10000;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        background-color: white;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        overflow: hidden;
      }

      #mobile-playback-overlay {
        z-index: 9600;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        gap: 100px;
        background-color: black;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        opacity: 0.3;
        overflow: hidden;
      }
      .mobile-playback-item {
        min-width: 2.5%;
        max-width: 35px;
      }
      .mobile-playback-item img {
        width: 100%
      }
      .mobile-playback-label {
        opacity: 0;
        color: white;
        font-size: 25px;
        font-weight: bold;
        min-width: 1.5%;
        max-width: 25px;
        transition: opacity 0.25s ease-out;
        -webkit-backface-visibility: hidden;
      }
      #mobile-playback-rewind-label {
        margin-right: -70px;
      }
      #mobile-playback-forward-label {
        margin-left: -70px;
      }
      #viz-speed-value {
          font-size: 15px;
          width: 10%;
      }

      #scale {
        position: fixed;
        left: 5px;
      }
    </style>
<style>
/* copied here from common.css (perhaps need to use version numbering) until caches worldwide settles */
#reload-mobile-popup, #message-popup { /* #gdpr-popup, */
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  min-width: 320px;
  bottom: 62px;
  height: 300px;
  background-color: #0275d8;
  border-radius: 15px;
  padding: 30px 40px;
  z-index: 9500;
}
#reload-mobile-popup {
  background-color: green;
  height: 200px;
}
#message-popup {
  z-index: 9000;
  width: 40%;
  height: 130px;
  background-color: #d9534f;
}

#reload-mobile-popup p, #message-popup p { /* #gdpr-popup p, */
  font-size: large;
  color: white;
  line-height: 2;
  font-family: "PT Sans", sans-serif;
}

#reload-mobile-popup .inner-button, #message-popup .inner-button { /* #gdpr-popup .gdpr-button, */
  border: white solid 2px;
  border-radius: 4px;
  font-weight: bold;
  font-size: x-large;
  padding: 2px 8px;
  color: white;
  width: 90px;
  text-align: center;
  position: absolute;
  letter-spacing: 1px;
  text-decoration: none;
  cursor: pointer;
}

#gdpr-accept, #reload-mobile-button, #dismiss-message-btn {
  bottom: 30px;
  right: 40px;
}

#gdpr-reject, #cancel-reload-mobile-button {
  bottom: 30px;
  right: 170px;
}
    </style>
</head>
<body>
<div id="body-container" style="display: flex; flex-direction: column; min-height: 100vh;">
<style>
  #topbar {
    background-color: rgb(0,0,0);
    font-family: "PT Sans", sans-serif;
    font-size: 13px;
    height: 40px;

    padding-left: 40px;
    padding-right: 40px;

    display: flex;
    flex-wrap: wrap;
    align-items: center;
    position: relative;
    justify-content: flex-start;
  }

  #topbar a:hover {
    text-decoration: none;
  }

  #account-dropdown-btn {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;
    height: 24px;
    line-height: 1.5;
  }

  #account-dropdown-btn:hover {
    color: #0a58ca!important;
    border-color: #198754;
    text-decoration: none;
  }

  #login-button {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;

    height: 24px;
    line-height: 1.5;
  }

  #login-button a:hover {
    color: #0a58ca!important;
    text-decoration: none;
  }

  #account-dropdown-menu {
    display: none;
    position: absolute;
    background-color: white;
    z-index: 1000;
    min-width: 10rem;
    padding: 0.5rem 0;
    margin: 0;
    font-size: 1rem;
    color: rgb(0,0,0);
    text-align: left;
    list-style: none;
    background-clip: padding-box;
    border: 1px solid rgba(0,0,0,.15);
    border-radius: 0.25rem;
    top: 45px;
    right: 40px;
    line-height: 1.5;
  }

  .account-dropdown-item {
    display: block;
    width: auto;
    padding: 0.25rem 1rem;
    clear: both;
    font-weight: 400;
    color: rgb(0,0,0);
    text-align: inherit;
    text-decoration: none;
    white-space: nowrap;
    background-color: transparent;
    border: 0;
    height: 24px;
    font-family: SilkscreenNormal, sans-serif;
  }

  .account-dropdown-item:hover {
    background-color: #e9ecef;
    color: #0a58ca;
    text-decoration: none;
  }
</style>
<nav id="topbar">
<span style="margin-right: 0.25rem">
<a href="https://www.comp.nus.edu.sg/~stevenha" style="text-decoration: none; color: white">
<span class="colour" style="border: 1px solid; border-color: #198754!important; border-radius: .25rem!important">7</span>
</a>
<a href="https://visualgo.net/" style="font-family: SilkscreenNormal,sans-serif; font-size: 20px; margin-left: 4px;">
<span style="color: white">Visu</span><span class="colour">Algo</span><span style="font-size: 40%; color: white">.net</span>
</a>
<span style="color: white">/</span>
<select id="Language" class="select2-dropdown" onchange="changeURL()">
<option value="en" selected>en</option>
<option value="zh">zh</option>
<option value="id">id</option>
</select>
<span style="color: white; font-family: monospace">/mvc</span>
</span>
<span style="max-height: 30px">
<span id="title">
<a id="menu-unweighted" class="selected-viz">Unweighted Minimum Vertex Cover</a>
<a id="menu-weighted">Weighted MVC</a>
</span>
</span>
<span style="max-height: 30px; background-color:rgb(0,0,0)!important; color: white; margin-left: auto">
<div id="mode-menu">
<div id="mode-button" style="background-color: rgb(0,0,0)!important;" title="exploration">Exploration Mode &#9663;</div>
<div id="other-modes" style="background-color: rgb(0,0,0)!important; padding-top: 11px">
<a title="e-Lecture" style="background-color: rgb(0,0,0)!important;">e-Lecture Mode</a>
</div>
</div>
</span>
<span id="login-button" style="font-family: SilkscreenNormal,sans-serif">
<a href="https://visualgo.net/login">Login</a>
</span>
</nav>
<ul id="account-dropdown-menu">
<li><a class="account-dropdown-item" href="https://visualgo.net/profile">Profile</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/training">Training</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/tests">Tests</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/logout">Log Out</a></li>
</ul>
<script>
  function changeURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    URL[3] = document.getElementById("Language").value;
    window.location.assign(URL.join('https://visualgo.net/'));
  }

  function changeDefaultLanguageAndURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    let val = document.getElementById("Language").value;
    URL[3] = val;

    let data = {
      '_token': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
      'lang'  : val
    }
    $.post('https://visualgo.net/changeLanguage', data, function (res, status) {
      if(res['status'] === 'success') {
        window.location.assign(URL.join('https://visualgo.net/'));
      } else if (res['status'] === 'failed') {
        alert(res['message']);
      } else {
        alert('An unknown error occurred');
      }
    })
  }
</script>
<div id="dark-overlay"></div>
<div id="main-content-container" style="flex: 1">

<div id="mobile-playback-overlay" class="playing" style="display: none;">
<span id="mobile-playback-rewind-label" class="mobile-playback-label">-7</span>
<span id="mobile-playback-rewind" class="mobile-playback-item" onclick="mobilePlaybackRewind()"><img src="../img/prevFrame.png" alt="rewind 7 frames"></span>
<span id="mobile-playback-pause" class="mobile-playback-item" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/pause.png" alt="pause"></span>
<span id="mobile-playback-play" class="mobile-playback-item" style="display: none;" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/play.png" alt="play"></span>
<span id="mobile-playback-forward" class="mobile-playback-item" onclick="mobilePlaybackForward()"><img src="../img/nextFrame.png" alt="forward 7 frames"></span>
<span id="mobile-playback-forward-label" class="mobile-playback-label">+7</span>
</div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id="speed-control"><div id="speed-input"></div><div id="viz-speed-value">1x</div></div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick="goToBeginning()"><img src="../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick="stepBackward()"><img src="../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick="pause()"><img src="../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick="play()"><img src="../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick="stepForward()"><img src="../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick="goToEnd()"><img src="../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id="viz">
<p id="info" "></p>
</div>
<div id="current-action" class="panel"></div>
<div id="e-lecture" class="panel"></div> 
<div id="e-lecture-timeline"></div>
<div id="e-lecture-f1map">
<div class="e-lecture-f1map-sector" sectorNo="1"></div>
<div class="e-lecture-f1map-sector" sectorNo="2"></div>
<div class="e-lecture-f1map-sector" sectorNo="3"></div>
</div>
<div id="overlay" hidden onclick="end_eLecture()"> 
<div id="electure-dropdown">
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. Vertex Cover</option>
<option value="1-1">&nbsp;&nbsp;&nbsp;1-1. Two Modes</option>
<option value="2">2. Visualization</option>
<option value="3">3. Input</option>
<option value="4">4. Bruteforce</option>
<option value="4-1">&nbsp;&nbsp;&nbsp;4-1. Parameterized Solution</option>
<option value="5">5. DP on Tree</option>
<option value="6">6. Greedy MVC on Tree</option>
<option value="7">7. Kőnig&#39;s Theorem</option>
<option value="8">8. Approximation Algorithms</option>
<option value="8-1">&nbsp;&nbsp;&nbsp;8-1. Approximation Ratio Proofs</option>
</select>
</div>
<div class="electure-print" title="Print the e-Lecture note" style="z-index=8001;">&#9997;</div>
<div class="electure-end" title="Close the e-Lecture mode" style="z-index=8001;">&#10008;</div>
</div>
<div id="dropdown-temp-holder" hidden></div>

<div id="electure-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>A <b>Vertex Cover</b> (VC) of a connected undirected (un)weighted graph <b>G</b> is a <b>subset of vertices V</b> of <b>G</b> such that <b>for every edge</b> in <b>G</b>, <b>at least one of its endpoints is in V</b>. A <b>Minimum Vertex Cover (MVC)</b> (<b>Minimum Weight Vertex Cover (MWVC)</b> for the weighted variant) of <b>G</b> is a VC that has the smallest cardinality (if unweighted) or total weight (if weighted) among all possible VCs. A graph can have multiple VCs but the cardinality/total weight of its MVC/MWVC is unique.</p><br><p>There is another problem called <b>Maximum Independent Set</b> (MIS) that attempts to find the <b>largest</b> subset of vertices in a (un)weighted graph <b>G</b> without any adjacent vertices in the subset. Interestingly, the <b>complement of an MVC of a graph is an MIS</b>.</p><br><p>At the end of every visualization, when an algorithm highlights an MVC solution of the currently displayed graph in <font color="orange">orange color</font>. For non-approximation solutions, the visualization will also highlight the MIS solution (which is V &bsol; MVC) with <font color="lightblue">light blue color</font>.</p><br><p>MVC, MWVC, MIS, (and MWIS) are all NP-hard combinatorial optimization problems.</p>
<div class="electure-addition">
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
If you are an NUS student and a repeat visitor, please <a href="https://visualgo.net/login"><u>login</u></a>.</p>
</div>
<div class="electure-next" data-nextid="1-1" title="Go to the next slide 1-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-1-1" class="electure-dialog" style="top:70px;left:250px;width:500px;">
<p>There are two available modes: Unweighted (default) and Weighted. You can switch between the two modes by clicking the respective tab.</p><br><p>There are algorithms that work in both modes and there are algorithms that only work in a certain mode.</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 1: Since you are not <a href="https://visualgo.net/login"><u>logged-in</u></a>, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b>/<b>[PageUp]</b> to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use <b>[&rarr; or &darr;/&larr; or &uarr;]</b> to do the same),and <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
</div>
<div class="electure-prev" data-nextid="1" title="Go to the previous slide 1">&larr;</div>
<div class="electure-next" data-nextid="2" title="Go to the next slide 2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2" class="electure-dialog" style="top:320px;left:50%;margin-left:-250px;width:500px;">
<p>View the visualisation of the selected MVC algorithms here.</p><br><p>Originally, all vertices and edges in the input graph are colored with the standard black outline. As the visualization goes on, the color <font color="lightblue">light blue</font> will be used to denote covered edges and the color <span style="color: rgb(255, 165, 0);">orange</span> on edge will be used to show traversed edges.</p><br><p>At the end of the selected MVC algorithm, if it finds a <b>minimum</b> VC, it will highlight the MVC vertices with <font color="orange">orange</font> color and the non MVC vertices (a.k.a. the MIS vertices) with <font color="lightblue">light blue</font> color. Otherwise, if the found vertex cover is not proven to be the minimal one (e.g., the algorithm used is an approximation algorithm), it will highlight the vertices that belong to the found vertex cover with <span style="color: rgb(255, 165, 0);">orange</span> color without highlighting the MIS vertices.</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
</div>
<div class="electure-prev" data-nextid="1-1" title="Go to the previous slide 1-1">&larr;</div>
<div class="electure-next" data-nextid="3" title="Go to the next slide 3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3" class="electure-dialog" style="bottom:240px;left:60px;width:500px;">
<p>There are two different ways to specify an input graph:</p><ol><li><b>Edit Graph</b>: You can edit the currently displayed undirected (weighted for MWVC mode) graph into any other undirected (weighted for MWVC mode) graph.</li><li><b>Example Graphs</b>: You can select from the list of example undirected (weighted for MWVC mode) graphs to get you started.</li></ol>
<div class="electure-addition">
<hr>
<p>Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode): <b>Spacebar</b> to play/pause/replay the animation, <b>&larr;</b>/<b>&rarr;</b> to step the animation backwards/forwards, respectively, and <b>-</b>/<b>+</b> to decrease/increase the animation speed, respectively.</p>
</div>
<div class="electure-prev" data-nextid="2" title="Go to the previous slide 2">&larr;</div>
<div class="electure-next" data-nextid="4" title="Go to the next slide 4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4" class="electure-dialog" style="bottom:240px;left:60px;width:500px;">
<p><b>Bruteforce</b>: It tries all possible 2^<b>V</b> subsets of vertices. In every iteration, it checks whether the currently selected subset of vertices is a valid vertex cover by iterating over all <b>E</b> edges in O(<b>E</b>) and checking whether all edges are covered by the vertices in the currently selected subset. This bruteforce algorithm keeps the smallest size of the valid vertex cover as the answer.</p><br><p>This bruteforce algorithm is available in both weighted and unweighted version.</p><br><p>Its time complexity is O(2^<b>V</b> × <b>E</b>), i.e., extremely slow. We are in the process to improve the visualization so that the &#39;boring&#39; non-improving parts are cut-out and only the important &#39;candidate VC&#39; subsets are highlighted.</p><br><p>Discussion: But there is an alternative O(2^<b>k</b> × <b>E</b>) parameterized solution if we are told that <b>k</b> is &#39;not-that-large&#39;.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3" title="Go to the previous slide 3">&larr;</div>
<div class="electure-next" data-nextid="4-1" title="Go to the next slide 4-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Unfortunately this part has not been digitized/visualized yet and is in the pipeline.</p><br><p>Please see CS4234 lecture note for the details.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4" title="Go to the previous slide 4">&larr;</div>
<div class="electure-next" data-nextid="5" title="Go to the next slide 5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-5" class="electure-dialog" style="bottom:240px;left:60px;width:500px;">
<p><b>DP on Tree</b>: If the graph is a <b>tree</b>, the MVC problem can be formulated as a Dynamic Programming problem where the states are (position, take_current_vertex).</p><br><p>Then, it can be seen that:<br>DP(u, take) = cost[u] + sum(min(DP(v, take), DP(v, not_take))) &forall;child v of u, and<br>DP(u, not take) = sum(DP(v, take)) &forall;child v of u</p><br><p>This DP algorithm is available in both weighted and unweighted version.</p><br><p>Its time complexity is O(<b>V</b>), i.e., very fast, but only if the input graph is a tree.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="4-1" title="Go to the previous slide 4-1">&larr;</div>
<div class="electure-next" data-nextid="6" title="Go to the next slide 6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-6" class="electure-dialog" style="bottom:240px;left:60px;width:500px;">
<p><b>Greedy MVC on Tree</b>: Again, if the graph is an <b>unweighted</b> <b>tree</b>, it can be solved greedily by observing that if there is any MVC solution that takes a leaf vertex, we can obtain a "not worse" solution by taking the parent of that leaf vertex instead. After removing all covered vertices, we can apply the same observation and repeat it until every vertex is covered.</p><br><p>This greedy MVC algorithm is only available in unweighted mode.</p><br><p>Its time complexity is O(<b>V</b>), i.e., very fast, but only if the input graph is an unweighted tree.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="5" title="Go to the previous slide 5">&larr;</div>
<div class="electure-next" data-nextid="7" title="Go to the next slide 7">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-7" class="electure-dialog" style="bottom:240px;left:60px;width:500px;">
<p><b>Kőnig&#39;s Theorem</b>: From Kőnig&#39;s Theorem, the size of MVC in an <b>unweighted bipartite</b> graph is equal to the cardinality of the maximum matching of the bipartite graph. In the case of <b>weighted bipartite</b> graph, we can see that this theorem also holds true, with a tweak in how we construct the graph. In this visualization, we use a reduction to max flow problem to get the value of the MVC.</p><br><p>This algorithm is available in both weighted and unweighted version.</p><br><p>Its time complexity is O(<b>V</b> &times; <b>E</b>) (for unweighted version; can be smaller with pre-processing) or O(<b>E</b>^2 &times; <b>V</b>)/O(<b>V</b>^2 &times; <b>E</b>) (for weighted version, depending on the max flow algorithm used).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="6" title="Go to the previous slide 6">&larr;</div>
<div class="electure-next" data-nextid="8" title="Go to the next slide 8">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8" class="electure-dialog" style="bottom:240px;left:60px;width:500px;">
<p>There are several known approximation algorithms for MVC:</p><ol><li>For unweighted version, we have either the deterministic 2-approximation or probabilistic 2-approximation (in expectation),</li><li>For weighted version we have the Bar-Yehuda and Even&#39;s 2-approximation algorithm.</li></ol><p>Note that these algorithms only yield an "approximated" MVC, meaning that they are not a true <b>minimum</b> vertex cover, but a good enough one.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="7" title="Go to the previous slide 7">&larr;</div>
<div class="electure-next" data-nextid="8-1" title="Go to the next slide 8-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-8-1" class="electure-dialog" style="top:70px;left:60px;width:500px;">
<p>Unfortunately this part has not been digitized yet and is in the pipeline.</p><br><p>Please see CS4234 lecture note for the details.</p>
<div class="electure-addition">
<hr>
<p>You have reached the last slide. Return to 'Exploration Mode' to start exploring!</p>
<p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
</div>
<div class="electure-prev" data-nextid="8" title="Go to the previous slide 8">&larr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>Close</u></span>
</div>
<div id="rotateDeviceOverlay" style="display: none;">
<div id="rotateDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please rotate your device to landscape mode for a better user experience</div>
<div id="widenDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please make the window wider for a better user experience</div>
</div>

<style>
        .draw {
            bottom: 227px
        }
    </style>
<style>
        .examples {
            bottom: 200px
        }
    </style>
<style>
        .bruteforce {
            bottom: 173px
        }
    </style>
<style>
        .on_tree {
            bottom: 146px
        }
    </style>
<style>
        .on_bipartite {
            bottom: 119px
        }
    </style>
<style>
        .approximations {
            bottom: 92px
        }
    </style>
<style>
        .parameterized {
            bottom: 65px
        }
    </style>
<div id="actions" class="panel">
<p class="execAction" id="draw" onClick="drawGraph()">Edit Graph</p>
<p id="examples">Example Graphs</p>
<p class="execAction" id="bruteforce" onClick="bruteforce()">Bruteforce</p>
<p id="on_tree">MVC on Tree</p>
<p id="on_bipartite">MVC on Bipartite Graph</p>
<p id="approximations">Approximation</p>
<p id="parameterized">Parameterized MVC</p>
</div>
<div id="actions-hide" class="panel-hide"><span style="color:white; font-size: x-large; display: inline-block;">&gt;</span></div>
<div id="actions-extras">
<div class="draw action-menu-pullout">
<div id="draw-err" class="err" style="float: left;"></div>
</div>
<div class="bruteforce action-menu-pullout">
<div id="bruteforce-err" class="err" style="float: left;"></div>
</div>
<div class="examples action-menu-pullout">
<div id="example-general" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;examples&#039;, &#039;example-general&#039;)">
<p>General Graph</p>
<div id="example-general-third-tier" class="example-general-third-tier new-menu-option" style="display: none;">
<div id="example-general-8" class="execAction coloured-menu-option" style="float: right;" onClick="example(MVC_BRUTEFORCE_LARGE_GRAPH_1)">
<p>Medium Graph</p>
</div>
<div id="example-general-7" class="execAction coloured-menu-option" style="float: right;" onClick="example(CS4234_SAMPLE)">
<p>CS4234 Sample</p>
</div>
<div id="example-general-6" class="execAction coloured-menu-option" style="float: right;" onClick="example(CP3_4_26_2)">
<p>Flow Graph</p>
</div>
<div id="example-general-5" class="execAction coloured-menu-option" style="float: right;" onClick="example(HOUSE_OF_CARDS)">
<p>House of Cards</p>
</div>
<div id="example-general-4" class="execAction coloured-menu-option" style="float: right;" onClick="example(CP3_4_9)">
<p>CP4 4.7</p>
</div>
<div id="example-general-3" class="execAction coloured-menu-option" style="float: right;" onClick="example(CP3_4_4)">
<p>CP4 4.3</p>
</div>
<div id="example-general-2" class="execAction coloured-menu-option" style="float: right;" onClick="example(CP3_4_3)">
<p>CP4 4.2</p>
</div>
<div id="example-general-1" class="execAction coloured-menu-option" style="float: right;" onClick="example(CP3_4_1)">
<p>CP4 4.1</p>
</div>
</div>
</div>
<div id="example-corner-case" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;examples&#039;, &#039;example-corner-case&#039;)">
<p>Corner Case</p>
<div id="example-corner-case-third-tier" class="example-corner-case-third-tier new-menu-option" style="display: none;">
<div id="example-corner-case-5" class="execAction coloured-menu-option" style="float: right;" onClick="example(UNCONNECTED_GRAPH)">
<p>Unconnected Graph</p>
</div>
<div id="example-corner-case-4" class="execAction coloured-menu-option" style="float: right;" onClick="example(MVC_W_TWO_APPROX_KILLER)">
<p>Weighted Det 2-approx Killer</p>
</div>
<div id="example-corner-case-3" class="execAction coloured-menu-option" style="float: right;" onClick="example(STAR2)">
<p>Star (Tree) - Center</p>
</div>
<div id="example-corner-case-2" class="execAction coloured-menu-option" style="float: right;" onClick="example(STAR)">
<p>Star (Tree) - Leaves</p>
</div>
<div id="example-corner-case-1" class="execAction coloured-menu-option" style="float: right;" onClick="example(MVC_U_TWO_APPROX_KILLER)">
<p>Unweighted Det 2-approx Killer (K Edges)</p>
</div>
</div>
</div>
<div id="example-special-case" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;examples&#039;, &#039;example-special-case&#039;)">
<p>Special Case</p>
<div id="example-special-case-third-tier" class="example-special-case-third-tier new-menu-option" style="display: none;">
<div id="example-special-case-pseudoforest" class="execAction coloured-menu-option" style="float: right;" onClick="example(MVC_PSEUDOFOREST)">
<p>Pseudoforest</p>
</div>
<div id="example-special-case-bipartite-2" class="execAction coloured-menu-option" style="float: right;" onClick="example(BIPARTITE2)">
<p>Bipartite Graph</p>
</div>
<div id="example-special-case-bipartite-1" class="execAction coloured-menu-option" style="float: right;" onClick="example(INTERESTING_BIPARTITE)">
<p>Bipartite (Tree)</p>
</div>
<div id="example-special-case-tree-2" class="execAction coloured-menu-option" style="float: right;" onClick="example(EXAMPLE_VERTEX_WEIGHTED_TREE)">
<p>Tree (Large)</p>
</div>
<div id="example-special-case-tree-1" class="execAction coloured-menu-option" style="float: right;" onClick="example(CP3_4_40)">
<p>Tree (Small)</p>
</div>
<div id="example-special-case-line-2" class="execAction coloured-menu-option" style="float: right;" onClick="example(LINEAR_CHAIN)">
<p>Line (odd)</p>
</div>
<div id="example-special-case-line-1" class="execAction coloured-menu-option" style="float: right;" onClick="example(BELLMANFORD_KILLER)">
<p>Line (even)</p>
</div>
</div>
</div>
<div id="example-max-clique" class="execAction new-menu-option coloured-menu-option" onClick="toggleChildExtras(&#039;examples&#039;, &#039;example-max-clique&#039;)">
<p>Max Clique</p>
<div id="example-max-clique-third-tier" class="example-max-clique-third-tier new-menu-option" style="display: none;">
<div id="example-max-clique-graph-bar" class="execAction coloured-menu-option" style="float: right;" onClick="example(MVC_MAX_CLIQUE_EXAMPLE_BAR)">
<p>Dense Graph Bar</p>
</div>
<div id="example-max-clique-complete-bar-2" class="execAction coloured-menu-option" style="float: right;" onClick="example(K5_BAR)">
<p>K&#x0305;5</p>
</div>
<div id="example-max-clique-complete-bar-1" class="execAction coloured-menu-option" style="float: right;" onClick="example(K4_BAR)">
<p>K&#x0305;4</p>
</div>
<div id="example-max-clique-graph" class="execAction coloured-menu-option" style="float: right;" onClick="example(MVC_MAX_CLIQUE_EXAMPLE)">
<p>Dense Graph</p>
</div>
<div id="example-special-case-complete-2" class="execAction coloured-menu-option" style="float: right;" onClick="example(K5)">
<p>K5</p>
</div>
<div id="example-special-case-complete-1" class="execAction coloured-menu-option" style="float: right;" onClick="example(K4)">
<p>K4</p>
</div>
</div>
</div>
<div id="examples-err" class="err" style="float: left;"></div>
</div>
<div class="on_tree action-menu-pullout">
<div id="dp_on_tree_go-weighted-unweighted" class="execAction new-menu-option coloured-menu-option" onClick="dp_on_tree()">
<p>DP on Tree</p>
</div>
<div id="greedy_on_tree-go-unweighted" class="execAction new-menu-option coloured-menu-option" onClick="greedy()">
<p>Greedy MVC on Tree</p>
</div>
<div id="on_tree-err" class="err" style="float: left;"></div>
</div>
<div class="on_bipartite action-menu-pullout">
<div id="konig-go-weighted-unweighted" class="execAction new-menu-option coloured-menu-option" onClick="konig()">
<p>Kőnig&#39;s Theorem</p>
</div>
<div id="on_bipartite-err" class="err" style="float: left;"></div>
</div>
<div class="approximations action-menu-pullout">
<div id="deterministic_two_opt-go-weighted-unweighted" class="execAction new-menu-option coloured-menu-option" onClick="deterministic_two_opt()">
<p>Deterministic 2-opt</p>
</div>
<div id="probabilistic_two_opt-go-unweighted" class="execAction new-menu-option coloured-menu-option" onClick="probabilistic_two_opt()">
<p>Probabilistic 2-opt</p>
</div>
<div id="approximations-err" class="err" style="float: left;"></div>
</div>
<div class="parameterized action-menu-pullout">
<div id="parameterized_input" class="new-menu-option">
k = <input id="parameterized-k" type="number" title="Enter size of vertex cover" autocomplete="off" min="0" max="99" value="0"> </div>
<div id="parameterized_mvc" class="execAction new-menu-option coloured-menu-option" onClick="parameterized()">
<p>Parameterized MVC</p>
</div>
<div id="parameterized-err" class="err" style="float: left;"></div>
</div>
</div>

<div id="drawgraph" class="overlays"></div>
</div>

<div id="bottom-bar">
<a id="scale" style="display: none;">1.0x</a>
<a id="trigger-about">About</a>
<a id="trigger-team">Team</a>
<a id="trigger-terms">Terms of use</a>
<a id="trigger-privacy">Privacy Policy</a>
</div>
<div id="about" class="overlays">
<h4>About</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.</p><p>Featuring numerous advanced algorithms discussed in Dr. Steven Halim&#39;s book, &#39;Competitive Programming&#39; — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.</p><p>While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.</p><p>Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.</p><p>VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.</p><p>Equipped with a built-in question generator and answer verifier, VisuAlgo&#39;s "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students&#39; answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students&#39; mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.</p><p>VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:</p>
<a href="https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689" target="_blank"><u>id</u></a>,
<a href="http://blog.naver.com/visualgo_nus" target="_blank"><u>kr</u></a>,
<a href="https://www.facebook.com/groups/163215593699283/permalink/824003417620494/" target="_blank"><u>vn</u></a>,
<a href="http://pantip.com/topic/32736343" target="_blank"><u>th</u></a>.
</div>
</div>
<div id="team" class="overlays">
<h4>Team</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>
<strong><span style="line-height: 150%;">Project Leader &amp; Advisor (Jul 2011-present)</span></strong><br>
<a href="https://www.comp.nus.edu.sg/~stevenha/" target="_blank">Associate Professor Steven Halim</a>, School of Computing (SoC), National University of Singapore (NUS)<br>
<a href="https://www.linkedin.com/in/felixhalim/" target="_blank">Dr Felix Halim</a>, Senior Software Engineer, Google (Mountain View)
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 1</span></strong><br>
<b>CDTL TEG 1: Jul 2011-Apr 2012</b>: Koh Zi Chun, Victor Loh Bo Huai
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 1</span></strong><br>
<b>Jul 2012-Dec 2013</b>: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang Duy<br>
<b>Jun 2013-Apr 2014</b> <a href="https://www.rosemarietan.com/" target="_blank">Rose Marie Tan Zhao Yun</a>, Ivan Reinaldo
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 2</span></strong><br>
<b>CDTL TEG 2: May 2014-Jul 2014</b>: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 2</span></strong><br>
<b>Jun 2014-Apr 2015</b>: Erin Teo Yi Ling, Wang Zi<br>
<b>Jun 2016-Dec 2017</b>: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin Mudzakir<br>
<b>Aug 2021-Apr 2023</b>: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius<br>
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 3</span></strong><br>
<b>Optiver: Aug 2023-Oct 2023</b>: Bui Hong Duc, Oleh Naver, Tay Ngan Lin<br>
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 3</span></strong><br>
<b>Aug 2023-Apr 2024</b>: Xiong Jingya, Radian Krisno, Ng Wee Han<br>
</p>
<p>
List of translators who have contributed &ge; 100 translations can be found at <a href="https://visualgo.net/statistics">statistics</a> page.
</p>
<p>
<strong><span style="line-height: 150%;">Acknowledgements</span></strong><br>
NUS <a href="https://nus.edu.sg/cdtl" target="_blank"><u>CDTL</u></a> gave Teaching Enhancement Grant to kickstart this project.<div>For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.</div>
</p>
</div>
</div>
<div id="termsofuse" class="overlays">
<h4>Terms of use</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that you <b>spread the word about its existence to fellow Computer Science students and instructors</b>. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.</p><p>Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (<a href="https://visualgo.net/">https://visualgo.net</a>) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo&#39;s client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.</p><p>Please note that VisuAlgo&#39;s online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the &#39;training mode.&#39; The &#39;test mode&#39; offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.</p><p><strong><span style="line-height: 200%;">List of Publications</span></strong></p> <p>This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can click <a href="https://ioinformatics.org/journal/INFOL099.pdf" target="_blank">this link</a> to read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) and <a href="https://ioinformatics.org/journal/v9_2015_243_245.pdf" target="_blank">this link</a> for the short update in 2015 (to link VisuAlgo name with the previous project).</p><p><strong><span style="line-height: 200%;">Bug Reports or Request for New Features</span></strong></p> <p>VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.</p>
</div>
</div>
<div id="privacy-policy" class="overlays">
<h4>Privacy Policy</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p><b>Version 1.2 (Updated Fri, 18 Aug 2023).</b></p><p>Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.</p><p>Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).</p><p>Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.</p><p>For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.<br></p><p>For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.</p>
</div>
</div>
</div>


<script src="../../code.jquery.com/jquery-3.7.0.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
<script src="../../cdn.jsdelivr.net/npm/bootstrap%405.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<script src="../../unpkg.com/d3-force-boundary%400.0.1/dist/d3-force-boundary.min.js"></script>
<script>
  $(function () {
    // overlays stuffs
    $('#trigger-about').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#about').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-team').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#team').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-terms').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#termsofuse').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-privacy').click(function () {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#privacy-policy').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    })

    $('.close-overlay').click(function() {
      $('.overlays').fadeOut(function() {
        $('#dark-overlay').fadeOut();
      });
    });

    $('#dark-overlay').click(function() {
      $('.overlays').fadeOut();
      $('#dark-overlay').fadeOut();
      if (typeof GeometryWidget !== 'undefined') {
        GeometryWidget.stopLoop();
      }
    });
  })
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-1566631-4"></script>
<script>
      $.ajaxSetup({
        headers: {
          'X-CSRF-TOKEN': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H"
        }
      });

      // handles account dropdown menu
      $(function () {
        $('#language-dropdown-btn').click(function (e) {
          $('#language-dropdown-menu').css('display', 'block');
          $('#account-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function () {
          $('#language-dropdown-menu').css('display', 'none')
        })
      })

      $(function () {
        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        })
      })

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        if (retval) {
          $('#current-action').show();
          $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
          $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
          triggerRightPanels();
          isPlaying = true;
        }
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; ++i) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      const MOBILE_WIDTH = 1000;
      const matchMediaMobile = window.matchMedia(`only screen and (max-width: ${MOBILE_WIDTH}px)`);
      const matchMediaNarrow = window.matchMedia(`only screen and (max-width: 500px)`);
      function isMobile() {
        return matchMediaMobile.matches;
      }
      //To fix the issue of a narrow desktop window being asked to rotate, I am now checking for it based on the navigator.userAgent to see if its mobile or not.
      //This may change in the future if browsers decide to change the naming of userAgent for mobile browsers so may need to keep an eye on this.
      function isMobileOS() {
        return /Mobi/i.test(navigator.userAgent) && !/ipad/i.test(navigator.userAgent);
      }
      let portraitMatcher = window.matchMedia("(orientation:portrait)");
      function isPortrait() {
        return portraitMatcher.matches;
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.colour').css("color", surpriseColour);
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
        });
      });

/*
      // GA dropped 26 Jun 2023 and then made official on 18 Aug 2023
/*
      // the sunset-ed GA, commented on 26 Jun 2023, and Prof Halim doesn't bother to use anymore
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
*/

      // function setCookie(cname, cvalue, exdays) {
      //   const d = new Date();
      //   d.setTime(d.getTime() + (exdays*24*60*60*1000));
      //   let expires = "expires="+ d.toUTCString();
      //   document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
      // }

//       //         $(function() {
//           $('#gdpr-accept').click(function () {
// /*
//             // added on 26 Jun 2023
//             window.dataLayer = window.dataLayer || [];
//             function gtag(){dataLayer.push(arguments);}
//             gtag('js', new Date());

//             gtag('config', 'UA-1566631-4');
// */
// //            ga('create', 'UA-1566631-4', 'auto');
// //            ga('send', 'pageview');
//             setCookie('use_google_analytics', 'true', 365)
//             $('#gdpr-popup').hide()
//           });
//           $('#gdpr-reject').click(function () {
//             setCookie('use_google_analytics', 'false', 365)
//             $('#gdpr-popup').hide()
//           });
//         });
//       
      $('#gdpr-privacy-policy').click(function () {
        if ($(window).width() > 600) {
          $('#dark-overlay').fadeIn(function() {
            $('#privacy-policy').fadeIn();
          });
        }
        else
          alert('Sorry, this dialog is too big. Please load it on bigger screen');
      })
    </script>

<script src="../js/jquery-ui.min.js"></script>

<script src="../js/d3.min.js"></script>
<script src="../js/viz-1.0.10.js"></script>

<script src="../js/graph_library/constant.js"></script>
<script src="../js/graph_library/drawgraph.js"></script>
<script src="../js/graph_library/GraphEdgeWidget.js"></script>
<script src="../js/graph_library/GraphPolygonWidget.js"></script>
<script src="../js/graph_library/GraphVertexWidget.js"></script>
<script src="../js/graph_library/GraphWidget.js"></script>
<script src="../js/graph_library/helperObjects89db.js?refresh22aug9pm"></script> 
<script src="../js/graph_library/misc.js"></script>
<script src="../js/graph_library/properties.js"></script>
<script src="../js/graph_library/Widget.js"></script>
<script src="../js/graph_library/force_directed_library.js"></script>

<script>
      $(function () {
        let defaultPlaybackSpeed = 1;
                createPlaybackSpeedSlider(defaultPlaybackSpeed);


        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        });
        //Mobile Design Related DOM Manipulations
        if (isMobile()) {
          $("#status").css({
            "bottom": "10%",
            "height": "12%",
            "max-height": "54px"
          });
          $("#current-action").css("bottom", "22%");
          $('#status-hide').remove();
          $('#left-bar').remove();
          $('#right-bar').remove();
          $("#mode-menu").remove();
          $("#codetrace").css("z-index", 1);
          $("#bottom-bar a").hide();
          $("#bottom-bar").css("height", $("#topbar").css("height"));
          $(".speed-dropup-btn").show();
          $("#go-to-beginning").remove();
          $("#go-to-end").remove();
          $("#pause").remove();
          $("#play").remove();
          $("#previous").remove();
          $("#next").remove();

          //make progress bar longer
          $("#progress-bar").css({
            left: "30%",
            width: "60%",
            'margin-left': 0
          })
        }
      })

      let mobilePlaybackOverlayTimeout;
      $(function() {
        $("#viz").on("click", () => {
          if (isMobile()) {
            if ($("#mobile-playback-overlay").is(":hidden") && isPlaying) {
              $("#mobile-playback-overlay").fadeIn();
              hideMobilePlaybackOverlay(6000);
            } else {
              $("#mobile-playback-overlay").fadeOut();
            }
          }
        });
        $("#mobile-playback-overlay").on("click", (event) => {
          if (event.target === event.currentTarget) //to ensure clicks on the controls dont fade the overlay
            $("#mobile-playback-overlay").fadeOut();
          else
            hideMobilePlaybackOverlay(5000);
        })
      });
      function hideMobilePlaybackOverlay(timeOut) {
        if (mobilePlaybackOverlayTimeout)
          clearTimeout(mobilePlaybackOverlayTimeout);
        mobilePlaybackOverlayTimeout = setTimeout(() => {
            $("#mobile-playback-overlay").fadeOut();
        }, timeOut);
      }
      function mobilePlaybackPauseOrPlay() {
        if ($("#mobile-playback-overlay").hasClass("playing")) {
          pause();
          hideMobilePlaybackOverlay(5000);
        } else {
          play();
          hideMobilePlaybackOverlay(3000);
        }
      }
      let rewindLabelTimeout, forwardLabelTimeout;
      function mobilePlaybackRewind() {
        $("#mobile-playback-rewind-label").css("opacity", 1);
        if (rewindLabelTimeout)
          clearTimeout(rewindLabelTimeout);
        rewindLabelTimeout = setTimeout(() => {
          $("#mobile-playback-rewind-label").css("opacity", 0);
        }, 800);
        stepBackward(7);
      }
      function mobilePlaybackForward() {
        $("#mobile-playback-forward-label").css("opacity", 1);
        if (forwardLabelTimeout)
          clearTimeout(forwardLabelTimeout);
        forwardLabelTimeout = setTimeout(() => {
          $("#mobile-playback-forward-label").css("opacity", 0);
        }, 800);
        stepForward(7);
      }

      //let eLectureSessionHistory = {};
      const sectorColors = ['#05a4d0', '#f1c706', '#fa0202'];
      function setSlideTimelineColor(slideNo) {
        const sectionNo = slideNo.split('-')[0];
        $(`[slideNo="${slideNo}"]`).css('background', sectorColors[(parseInt(sectionNo) % 3)]);
      }

      let currSlideTimer = null; //global so that we can clear the timeout when required

      const lectureIds = [{"id":188,"category":"mvc","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-27 03:08:26","updated_at":"2023-08-22 10:39:46","section":-1,"code":"","section_order":-1,"value":"1","text":"<p>A <b>Vertex Cover<\/b> (VC) of a connected undirected (un)weighted graph <b>G<\/b> is a <b>subset of vertices V<\/b> of <b>G<\/b> such that <b>for every edge<\/b> in <b>G<\/b>, <b>at least one of its endpoints is in V<\/b>. A <b>Minimum Vertex Cover (MVC)<\/b> (<b>Minimum Weight Vertex Cover (MWVC)<\/b> for the weighted variant) of <b>G<\/b> is a VC that has the smallest cardinality (if unweighted) or total weight (if weighted) among all possible VCs. A graph can have multiple VCs but the cardinality\/total weight of its MVC\/MWVC is unique.<\/p><br><p>There is another problem called <b>Maximum Independent Set<\/b> (MIS) that attempts to find the <b>largest<\/b> subset of vertices in a (un)weighted graph <b>G<\/b> without any adjacent vertices in the subset. Interestingly, the <b>complement of an MVC of a graph is an MIS<\/b>.<\/p><br><p>At the end of every visualization, when an algorithm highlights an MVC solution of the currently displayed graph in <font color=\"orange\">orange color<\/font>. For non-approximation solutions, the visualization will also highlight the MIS solution (which is V &bsol; MVC) with <font color=\"lightblue\">light blue color<\/font>.<\/p><br><p>MVC, MWVC, MIS, (and MWIS) are all NP-hard combinatorial optimization problems.<\/p>","title":"Vertex Cover"},{"id":678,"category":"mvc","order":1,"top":"70px","right":"","bottom":"","left":"250px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2018-02-14 07:37:15","updated_at":"2023-08-16 09:30:01","section":188,"code":"","section_order":1,"value":"1-1","text":"<p>There are two available modes: Unweighted (default) and Weighted. You can switch between the two modes by clicking the respective tab.<\/p><br><p>There are algorithms that work in both modes and there are algorithms that only work in a certain mode.<\/p>","title":"Two Modes"},{"id":189,"category":"mvc","order":2,"top":"320px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-27 03:08:49","updated_at":"2023-08-16 09:32:40","section":-1,"code":"","section_order":-1,"value":"2","text":"<p>View the visualisation of the selected MVC algorithms here.<\/p><br><p>Originally, all vertices and edges in the input graph are colored with the standard black outline. As the visualization goes on, the color <font color=\"lightblue\">light blue<\/font> will be used to denote covered edges and the color <span style=\"color: rgb(255, 165, 0);\">orange<\/span> on edge will be used to show traversed edges.<\/p><br><p>At the end of the selected MVC algorithm, if it finds a <b>minimum<\/b> VC, it will highlight the MVC vertices with <font color=\"orange\">orange<\/font> color and the non MVC vertices (a.k.a. the MIS vertices) with <font color=\"lightblue\">light blue<\/font> color. Otherwise, if the found vertex cover is not proven to be the minimal one (e.g., the algorithm used is an approximation algorithm), it will highlight the vertices that belong to the found vertex cover with <span style=\"color: rgb(255, 165, 0);\">orange<\/span> color without highlighting the MIS vertices.<\/p>","title":"Visualization"},{"id":190,"category":"mvc","order":3,"top":"","right":"","bottom":"240px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-27 03:13:45","updated_at":"2023-08-16 09:35:44","section":-1,"code":"closeAll();\n$(\"#draw\").addClass(\"menu-highlighted\");\n$(\"#examples\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"3","text":"<p>There are two different ways to specify an input graph:<\/p><ol><li><b>Edit Graph<\/b>: You can edit the currently displayed undirected (weighted for MWVC mode) graph into any other undirected (weighted for MWVC mode) graph.<\/li><li><b>Example Graphs<\/b>: You can select from the list of example undirected (weighted for MWVC mode) graphs to get you started.<\/li><\/ol>","title":"Input"},{"id":191,"category":"mvc","order":4,"top":"","right":"","bottom":"240px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-27 03:21:22","updated_at":"2023-08-16 09:39:23","section":-1,"code":"closeAll();\n$(\"#bruteforce\").addClass(\"menu-highlighted\");","section_order":-1,"value":"4","text":"<p><b>Bruteforce<\/b>: It tries all possible 2^<b>V<\/b> subsets of vertices. In every iteration, it checks whether the currently selected subset of vertices is a valid vertex cover by iterating over all <b>E<\/b> edges in O(<b>E<\/b>) and checking whether all edges are covered by the vertices in the currently selected subset. This bruteforce algorithm keeps the smallest size of the valid vertex cover as the answer.<\/p><br><p>This bruteforce algorithm is available in both weighted and unweighted version.<\/p><br><p>Its time complexity is O(2^<b>V<\/b> \u00d7 <b>E<\/b>), i.e., extremely slow. We are in the process to improve the visualization so that the &#39;boring&#39; non-improving parts are cut-out and only the important &#39;candidate VC&#39; subsets are highlighted.<\/p><br><p>Discussion: But there is an alternative O(2^<b>k<\/b> \u00d7 <b>E<\/b>) parameterized solution if we are told that <b>k<\/b> is &#39;not-that-large&#39;.<\/p>","title":"Bruteforce"},{"id":780,"category":"mvc","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-03-14 05:41:30","updated_at":"2023-08-16 09:40:12","section":191,"code":"","section_order":4,"value":"4-1","text":"<p>Unfortunately this part has not been digitized\/visualized yet and is in the pipeline.<\/p><br><p>Please see CS4234 lecture note for the details.<\/p>","title":"Parameterized Solution"},{"id":192,"category":"mvc","order":5,"top":"","right":"","bottom":"240px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-27 03:25:35","updated_at":"2023-08-16 09:40:29","section":-1,"code":"closeAll();\n$(\"#on_tree\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"5","text":"<p><b>DP on Tree<\/b>: If the graph is a <b>tree<\/b>, the MVC problem can be formulated as a Dynamic Programming problem where the states are (position, take_current_vertex).<\/p><br><p>Then, it can be seen that:<br>DP(u, take) = cost[u] + sum(min(DP(v, take), DP(v, not_take))) &forall;child v of u, and<br>DP(u, not take) = sum(DP(v, take)) &forall;child v of u<\/p><br><p>This DP algorithm is available in both weighted and unweighted version.<\/p><br><p>Its time complexity is O(<b>V<\/b>), i.e., very fast, but only if the input graph is a tree.<\/p>","title":"DP on Tree"},{"id":193,"category":"mvc","order":6,"top":"","right":"","bottom":"240px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-27 03:39:50","updated_at":"2023-08-16 09:41:08","section":-1,"code":"closeAll();\n$(\"#on_tree\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"6","text":"<p><b>Greedy MVC on Tree<\/b>: Again, if the graph is an <b>unweighted<\/b> <b>tree<\/b>, it can be solved greedily by observing that if there is any MVC solution that takes a leaf vertex, we can obtain a \"not worse\" solution by taking the parent of that leaf vertex instead. After removing all covered vertices, we can apply the same observation and repeat it until every vertex is covered.<\/p><br><p>This greedy MVC algorithm is only available in unweighted mode.<\/p><br><p>Its time complexity is O(<b>V<\/b>), i.e., very fast, but only if the input graph is an unweighted tree.<\/p>","title":"Greedy MVC on Tree"},{"id":194,"category":"mvc","order":7,"top":"","right":"","bottom":"240px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-27 03:46:43","updated_at":"2018-02-12 09:48:45","section":-1,"code":"closeAll();\n$(\"#on_bipartite\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"7","text":"<p><b>K\u0151nig&#39;s Theorem<\/b>: From K\u0151nig&#39;s Theorem, the size of MVC in an <b>unweighted bipartite<\/b> graph is equal to the cardinality of the maximum matching of the bipartite graph. In the case of <b>weighted bipartite<\/b> graph, we can see that this theorem also holds true, with a tweak in how we construct the graph. In this visualization, we use a reduction to max flow problem to get the value of the MVC.<\/p><br><p>This algorithm is available in both weighted and unweighted version.<\/p><br><p>Its time complexity is O(<b>V<\/b> &times; <b>E<\/b>) (for unweighted version; can be smaller with pre-processing) or O(<b>E<\/b>^2 &times; <b>V<\/b>)\/O(<b>V<\/b>^2 &times; <b>E<\/b>) (for weighted version, depending on the max flow algorithm used).<\/p>","title":"K\u0151nig&#39;s Theorem"},{"id":195,"category":"mvc","order":8,"top":"","right":"","bottom":"240px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-03-27 03:51:56","updated_at":"2022-03-13 16:28:58","section":-1,"code":"closeAll();\n$(\"#approximations\").click().addClass(\"menu-highlighted\");","section_order":-1,"value":"8","text":"<p>There are several known approximation algorithms for MVC:<\/p><ol><li>For unweighted version, we have either the deterministic 2-approximation or probabilistic 2-approximation (in expectation),<\/li><li>For weighted version we have the Bar-Yehuda and Even&#39;s 2-approximation algorithm.<\/li><\/ol><p>Note that these algorithms only yield an \"approximated\" MVC, meaning that they are not a true <b>minimum<\/b> vertex cover, but a good enough one.<\/p>","title":"Approximation Algorithms"},{"id":857,"category":"mvc","order":1,"top":"70px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2023-08-16 09:41:40","updated_at":"2023-08-16 09:42:08","section":195,"code":"","section_order":8,"value":"8-1","text":"<p>Unfortunately this part has not been digitized yet and is in the pipeline.<\/p><br><p>Please see CS4234 lecture note for the details.<\/p>","title":"Approximation Ratio Proofs"}];
      const numSlides = lectureIds.length;
      var sectorJunction12Section = 0, sectorJunction12Slide = 0;
      var sectorJunction23Section = 0, sectorJunction23Slide = 0;
      var sector1Count = 0, sector2Count = 0, sector3Count = 0;
      const sectorLength = Math.floor(numSlides / 3);
      function createELectureTimelineDisplay() {
        for (let j = 0; j < numSlides; ++j) {
          const currLecture = lectureIds[j].value;
          if (currLecture.includes('-')) {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-slide" slideNo=${lectureIds[j].value}></div>`)
            );
          } else {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-checkpoint" slideNo=${lectureIds[j].value}></div>`)
            );
          }
        }
      }

      function setSectorJunctionInfo() {
          //setting the sector junction slide numbers
          const j12 = sectorLength !== 0 ? (sectorLength - 1): 0;
          const j23 = sectorLength !== 0 ? (2 * sectorLength - 1) : 0;

          const sectorJunction12 = lectureIds[j12].value.split('-');
          sectorJunction12Section = parseInt(sectorJunction12[0]);
          sectorJunction12Slide = sectorJunction12.length > 1 ? parseInt(sectorJunction12[1]) : sectorJunction12Slide;

          const sectorJunction23 = lectureIds[j23].value.split('-');
          sectorJunction23Section = parseInt(sectorJunction23[0]);
          sectorJunction23Slide = sectorJunction23.length > 1 ? parseInt(sectorJunction23[1]) : sectorJunction23Slide;
      }

      function runSlide(slide) { // Steven's patch on 28 Jan 2022: Properly remove slide 99, 99-1, 99-2, 99-3, integrate with the earlier slides
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 9 + "%)");
          
        }
        if (slide == '1-1') {
          $("#e-lecture").html("slide " + slide + " (" + 18 + "%)");
          
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 27 + "%)");
          
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 36 + "%)");
          closeAll();
$("#draw").addClass("menu-highlighted");
$("#examples").click().addClass("menu-highlighted");
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 45 + "%)");
          closeAll();
$("#bruteforce").addClass("menu-highlighted");
        }
        if (slide == '4-1') {
          $("#e-lecture").html("slide " + slide + " (" + 54 + "%)");
          
        }
        if (slide == '5') {
          $("#e-lecture").html("slide " + slide + " (" + 63 + "%)");
          closeAll();
$("#on_tree").click().addClass("menu-highlighted");
        }
        if (slide == '6') {
          $("#e-lecture").html("slide " + slide + " (" + 72 + "%)");
          closeAll();
$("#on_tree").click().addClass("menu-highlighted");
        }
        if (slide == '7') {
          $("#e-lecture").html("slide " + slide + " (" + 81 + "%)");
          closeAll();
$("#on_bipartite").click().addClass("menu-highlighted");
        }
        if (slide == '8') {
          $("#e-lecture").html("slide " + slide + " (" + 90 + "%)");
          closeAll();
$("#approximations").click().addClass("menu-highlighted");
        }
        if (slide == '8-1') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
        }
        clearTimeout(currSlideTimer);
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };
      var slideTimeline = {};

      //reads all visited slides in the slideTimeline and gives them their sector color
      function setVisitedSlideTimelineColors() {
        for(const [sectionNo, visitedSlides] of Object.entries(slideTimeline)) {
          const visitedSlides = slideTimeline[sectionNo];
          for(const visitedSlideNo of visitedSlides) {
            setSlideTimelineColor(visitedSlideNo);
          }
        }
      }

      //only called on load if there is nothing in session
      function setTimelineForCompletedSector(sectorNum) {
        let len = sectorLength;
        switch (sectorNum) {
          case 1 : len = sectorLength; break;
          case 2 : len = 2 * sectorLength; break;
          default: len = numSlides;
        }
        let i = 0;
        switch (sectorNum) {
          case 1 : i = 0; break;
          case 2 : i = sectorLength; break;
          default: i = 2 * sectorLength;
        }
        for (; i < len; i++) {
          saveELectureTimeline(lectureIds[i].value, true);
        }
      }

      function getUserSectorHistory(callback) {
        $.ajax({
          type: 'GET',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            topic: "/mvc".substring(1)
          }
        }
        ).done(function (data) {
            if (data.data[0] === 1) {
              setF1SectorColor(1);
              setTimelineForCompletedSector(1);
            }
            if (data.data[1] === 1) {
              setF1SectorColor(2);
              setTimelineForCompletedSector(2);
            }
            if (data.data[2] === 1) {
              setF1SectorColor(3);
              setTimelineForCompletedSector(3);
            }
            callback();
        }).fail(function (data) {
            console.log('get user sector history failed!');
        });
      }

      function getELectureTimelineFromSession() {
        const page = "/mvc".substring(1);
        const timelineKey = page + '-slide-timeline';
        const storedTimeline = window.sessionStorage.getItem(timelineKey);
        if (storedTimeline) {
          slideTimeline = JSON.parse(storedTimeline);
        } else {
          return false;
        }
        let slideInfo = [];
        for (const [sectionNum, slides] of Object.entries(slideTimeline)) {
          for (const slide of slides) {
            indicateSlideCompletedUI(slide);
            slideInfo = slide.split('-');
            incrementSectorVisits(parseInt(sectionNum), slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0);
          }
        }
        return true;
      }

      async function initializeELectureTimeline() {
        setSectorJunctionInfo();
        if (!getELectureTimelineFromSession())
          getUserSectorHistory(sectorBasedModeSelection);
        else
          sectorBasedModeSelection();

        createELectureTimelineDisplay();
        setVisitedSlideTimelineColors();
      }

      function setF1SectorColor(sectorNum) {
        $(`[sectorNo="${sectorNum}"]`).css('background', sectorColors[(parseInt(sectorNum) % 3)]);
      }

      function updateSectorInDB(sectorNum) {
        $.ajax({
          type: 'POST',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            section: (sectorNum - 1),
            topic: "/mvc".substring(1)
          }
        }
        ).done(function (data) {
            //console.log("Saved the sector " + sectorNum + " as done " + JSON.stringify(data));
        }).fail(function (data) {
            console.log("Setting sector done failed new attempt! "+ JSON.stringify(data));
        });
      }

      //If 87.5% or more of the slides in sector are done
      function setF1SectorCompleted(sectorNum, isInitializationCall) {
        setF1SectorColor(sectorNum);
        //avoid api call on initialization
        if (!isInitializationCall) {
          updateSectorInDB(sectorNum);
          $(`[sectorNo="${sectorNum}"]`).css("animation", "green-pulse 2s 4");
          setTimeout(() => {
            $(`[sectorNo="${sectorNum}"]`).css("animation", "");
          }, 8000);
        }
      }

      function incrementSectorVisits(sectionNum, slideNumWithinSection, isInitializationCall) {
        //updating sector count
        if (sectionNum < sectorJunction12Section
          || (sectionNum === sectorJunction12Section && slideNumWithinSection <= sectorJunction12Slide)) {
          ++sector1Count;
          if (sector1Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(1, isInitializationCall);
        } else if (sectionNum < sectorJunction23Section
          || (sectionNum === sectorJunction23Section && slideNumWithinSection <= sectorJunction23Slide)) {
          ++sector2Count;
          if (sector2Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(2, isInitializationCall);
        } else {
          ++sector3Count;
          if (sector3Count >= Math.ceil(0.875 * (numSlides - 2 * sectorLength)))
            setF1SectorCompleted(3, isInitializationCall);
        }
      }

      function saveELectureTimeline(slideNo, isInitialization) {
        const slideInfo = slideNo.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        if (slideTimeline[sectionNo]) {
          if (!slideTimeline[sectionNo].includes(slideNo)) {
            slideTimeline[sectionNo].push(slideNo);
            const sectionNum = parseInt(sectionNo);
            incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
          }
        } else {
          slideTimeline[sectionNo] = [];
          slideTimeline[sectionNo].push(slideNo);
          const sectionNum = parseInt(sectionNo);
          incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
        }
        setSlideTimelineColor(slideNo);
        indicateSlideCompletedUI(slideNo);
      }

      function saveELectureTimelineToSession() {
        const page = "/mvc".substring(1);
        const timelineKey = page + '-slide-timeline';
        window.sessionStorage.setItem(timelineKey, JSON.stringify(slideTimeline));
      }

      function handleTimelineOnRunSlide(slideValue) {
        const slideInfo = slideValue.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        //start timer only if the slide isnt already done
        if (!slideTimeline[sectionNo] || !slideTimeline[sectionNo].includes(slideValue)) {
          const slideTextLength = $('#electure-'+slideValue + " p").text().length + $('#electure-'+slideValue + " li").text().length;
          const CHARS_READ_PER_MS = 0.05; //when fast, 50 characters a second
          //setting max reading time as 10 seconds for around 500 character slide
          const minSlideReadingTime = Math.min(Math.max(2000, (slideTextLength / CHARS_READ_PER_MS) +  + (2000 * $('#electure-'+slideValue + " img").length)), 10000);
          currSlideTimer = setTimeout(() => {
            saveELectureTimeline(slideValue);
          }, minSlideReadingTime);
        }
      }

      function indicateSlideCompletedUI(slide) {
        $('#electure-'+slide).css("box-shadow", "3px 3px 8px green"); //set green shadow for completed slides
        $('#electure-'+slide + ' .electure-read-status').html("&#10004;");
        $('#electure-'+slide + ' .electure-read-status').attr("title", "Slide Completed!");
        $('#electure-'+slide + ' .electure-read-status').css("font-size", "17px");
      }

      function pushState(slideValue) {
        var url = '/en/mvc';
        if (typeof slideValue != 'undefined' && slideValue != null) {
          url += '?slide=' + slideValue;
                  }
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5);
        $('#overlay').show();

        $("#e-lecture-timeline").show();
        $("#e-lecture-f1map").show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
        $("#e-lecture-timeline").hide();
        $("#e-lecture-f1map").hide();
        clearTimeout(currSlideTimer);
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      function sectorBasedModeSelection() {
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        //check params are empty and then that all sectors are completed or not
        if (!Object.keys(params).length
          && sector1Count === sectorLength && sector2Count === sectorLength && sector3Count === (numSlides - 2 * sectorLength)) {
            hideOverlay();
        }
        else
          $('#mode-menu a').click();
      }

      $(function() {
        if (isMobileOS() && portraitMatcher.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').show();
          $('#widenDeviceText').hide();
          $('#topbar').css("z-index", 10001);
        } else if (matchMediaNarrow.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').hide();
          $('#widenDeviceText').show();
          $('#topbar').css("z-index", 10001);
        } else {
          $('#rotateDeviceOverlay').hide();
          $('#topbar').css("z-index", "");
        }

        matchMediaNarrow.addEventListener('change', e => {
          //screws up for square device! NEED RESIZE EVENT
          if (e.matches) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').hide();
              $('#widenDeviceText').show();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        portraitMatcher.addEventListener('change', e => {
          if (e.matches && isMobileOS()) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').show();
              $('#widenDeviceText').hide();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        let slide = getUrlParameter('slide');
        if (typeof slide !== undefined && slide != null) {
          cur_slide = slide;
        }
        //do all timeline and slide stuff only if specific params not provided
        if (!Object.keys(params).length || params["slide"]) {
          if (!isMobile()) {
                            $('#mode-menu a').click();
                      }
        }
        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
        $('#electure-1-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-1-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-4-1 .electure-next').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-4-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-5 .electure-next').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-6 .electure-next').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-7 .electure-next').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
        $('#electure-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-8 .electure-next').click(function() {
          hidePopup();
          runSlide('8-1');
          pushState('8-1');
        });
        $('#electure-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-8-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
      });


      $('.electure-print').click(() => {
        window.open(`/en/mvc/print`);
      });
      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url.html) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}

      // This function will be called everytime 1.0x is changed to 0.5x or vice versa
      function redraw() {}

      $(document).ready(function () {
        setTimeout(function () {
          $('#change-lang-popup').fadeOut('slow')
        }, 5000)
      })
    </script>
<script type="text/javascript">
    var extraCSS = {"parameterized":"65px","approximations":"92px","on_bipartite":"119px","on_tree":"146px","bruteforce":"173px","examples":"200px","draw":"227px"};
    var actionsIds = {"draw":{"p":"Edit Graph","onClick":"drawGraph()"},"examples":{"p":"Example Graphs","parents":["example-general","example-corner-case","example-special-case","example-max-clique"]},"bruteforce":{"p":"Bruteforce","onClick":"bruteforce()"},"on_tree":{"p":"MVC on Tree"},"on_bipartite":{"p":"MVC on Bipartite Graph"},"approximations":{"p":"Approximation"},"parameterized":{"p":"Parameterized MVC"}};
    var isOpens = {};
    var len = 7;
    var keys = ["draw","examples","bruteforce","on_tree","on_bipartite","approximations","parameterized"]; 
    for (i = 0; i < len; i++) {
        var actionDetails = keys[i];
        isOpens[actionDetails] = false;
    }
    function openAction(id) {
        hideThirdTiers(id);
        $("." + id).css("bottom", extraCSS[id]);
        if (!isOpens[id]) {
            $('.' + id).fadeIn('fast');
            isOpens[id] = true;
        }
    }
    function closeAction(id) {
        hideThirdTiers(id);
        if (isOpens[id]) {
            $('.' + id).fadeOut('fast');
            $('#' + id + '-err').html("");
            isOpens[id] = false;
        }
    }

    function hideEntireActionsPanel() {
        //hideAllThirdTiers();
                    closeAction('draw');
                    closeAction('examples');
                    closeAction('bruteforce');
                    closeAction('on_tree');
                    closeAction('on_bipartite');
                    closeAction('approximations');
                    closeAction('parameterized');
                hideActionsPanel();
    }

    function hideThirdTiers(tier1Action) {
        if ("parents" in actionsIds[tier1Action]) {
            for (const secondTierAction of actionsIds[tier1Action]["parents"]) {
                $('#' + secondTierAction + '-third-tier').fadeOut('fast');
            }
        }
    }

    function hideAllThirdTiers() {
        for (const tier1Action in actionsIds) {
            hideThirdTiers(tier1Action);
        }
    }

    function toggleChildExtras(tier1, selectedParentTier2) {
        hideThirdTiers(tier1);
        //this actionId must have childExtras
        var style = extraCSS[tier1];
        $("." + tier1).css("bottom", (parseInt(style.substring(0, style.length - 2)) - 27));
        //fade ins and outs are done on the ID whereas css class is set on the class
        //fade in the third tier of the selected 2nd tier parent
        $('#' + selectedParentTier2 + '-third-tier').fadeIn('fast');

        // //fade out all other third tiers of that 'action'
        // for (const parent of actions[tier1]["parents"]) {
        //     console.log("parent is " + parent + " for " + selectedParentTier2);
        //     if (parent != selectedParentTier2) {
        //         $('#' + parent + '-third-tier').fadeOut('fast');
        //     }
        // }
    }

    function setActionHeightOriginal(tier1Action) {
        $("." + tier1Action).css("bottom", extraCSS[tier1Action]);
    }

            $('#' + 'draw').click(function() {
            openAction('draw');
                                                                            closeAction('examples');
                                                                closeAction('bruteforce');
                                                                closeAction('on_tree');
                                                                closeAction('on_bipartite');
                                                                closeAction('approximations');
                                                                closeAction('parameterized');
                                    });
            $('#' + 'examples').click(function() {
            openAction('examples');
                                                closeAction('draw');
                                                                                            closeAction('bruteforce');
                                                                closeAction('on_tree');
                                                                closeAction('on_bipartite');
                                                                closeAction('approximations');
                                                                closeAction('parameterized');
                                    });
            $('#' + 'bruteforce').click(function() {
            openAction('bruteforce');
                                                closeAction('draw');
                                                                closeAction('examples');
                                                                                            closeAction('on_tree');
                                                                closeAction('on_bipartite');
                                                                closeAction('approximations');
                                                                closeAction('parameterized');
                                    });
            $('#' + 'on_tree').click(function() {
            openAction('on_tree');
                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('bruteforce');
                                                                                            closeAction('on_bipartite');
                                                                closeAction('approximations');
                                                                closeAction('parameterized');
                                    });
            $('#' + 'on_bipartite').click(function() {
            openAction('on_bipartite');
                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('bruteforce');
                                                                closeAction('on_tree');
                                                                                            closeAction('approximations');
                                                                closeAction('parameterized');
                                    });
            $('#' + 'approximations').click(function() {
            openAction('approximations');
                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('bruteforce');
                                                                closeAction('on_tree');
                                                                closeAction('on_bipartite');
                                                                                            closeAction('parameterized');
                                    });
            $('#' + 'parameterized').click(function() {
            openAction('parameterized');
                                                closeAction('draw');
                                                                closeAction('examples');
                                                                closeAction('bruteforce');
                                                                closeAction('on_tree');
                                                                closeAction('on_bipartite');
                                                                closeAction('approximations');
                                                                });
    
    //important to have all the input fields in actions menu take an id containing '-input'
    $("[id*='-input']").on("keypress keydown keyup", (event) => {
        event.stopPropagation();
    });
</script>
<script type="text/javascript">
// MVC Widget
// original author: Muhammad Rais Fathin Mudzakir
// to be maintained by: Ng Wee Han
// later maintained by: A/Prof Steven Halim

var MVC = function() {
  var self = this;
  var gw = new GraphWidget();

  var iVL = {};
  var iEL = {};
  var amountVertex = 0;
  var amountEdge = 0;

  this.getGraphWidget = function() { return gw; }
  this.getiVL = function() {
    return iVL;
  }
  this.getiEL = function() {
    return iEL;
  }
  fixJSON = function() {
    amountVertex = 0;
    amountEdge = 0;
    for (var key in iVL) amountVertex++;
    for (var key in iEL) amountEdge++;
    if (isWeighted) {
      for (var key in iVL) {
        if (iVL[key]["w"] === undefined) {
          iVL[key]["w"] = 1;
        }
      }
    }
  }

  takeJSON = function(graph) {
    if (graph == null) return;
    graph = JSON.parse(graph);
    iVL = graph["vl"];
    iEL = graph["el"];
    fixJSON();
  }

  statusChecking = function() {
    $("#draw-status p").html("Draw an <b>undirected (weighted for MWVC mode)</b> graph");
  }

  warnChecking = function() {
    var warn = "";
    if (currentGraphVisu.amountVertex() >= 17) warn += "Too much vertex on screen, consider drawing smaller graph. ";
    if (warn == "") $("#draw-warn p").html("No Warning");
    else            $("#draw-warn p").html(warn);
  }

  errorChecking = function() {
    if (currentGraphVisu.amountVertex() == 0) {
      $("#draw-err p").html("Graph cannot be empty. ");
      return;
    }

    $("#draw-err p").html("No Error");
  }

  var intervalID;

  this.startLoop = function() {
    intervalID = setInterval(function() {
      //takeJSON(JSONresult);
      warnChecking();
      errorChecking();
      statusChecking();
    }, 100);
  }

  this.stopLoop = function() {
    clearInterval(intervalID);
  }

  this.draw = function() {
    if ($("#draw-err p").html() != "No Error")
      return false;
    takeJSON(JSONresult);
    if ($("#submit").is(':checked'))
      this.submit(JSONresult);
    if ($("#copy").is(':checked'))
      window.prompt("Copy to clipboard:", JSONresult);

    graph = createState({iVL: iVL, iEL: iEL});
    gw.updateGraph(graph, 500);
    return true;
  }

  this.importjson = function(text) {
    takeJSON(text);
    statusChecking();
    graph = createState({iVL: iVL, iEL: iEL});
    gw.updateGraph(graph, 500);
  }

  this.getV = function() {
    return amountVertex;
  }

  this.refreshView = function() {
    fixJSON();
    var newState = createState({iVL: iVL, iEL: iEL});
    gw.updateGraph(newState, 500);
  }

  this.examples = function(id) {
    // console.log(id);
    vertices = getExampleGraph(id, VL);
    var hasWeight = false;
    for (var key in vertices) {
      if (vertices[key]["w"] !== undefined) {
        hasWeight = true;
      }
    }
    iVL = getExampleGraph(id, VL);
    iEL = getExampleGraph(id, EL);
    fixJSON();
    var newState = createState({iVL: iVL, iEL: iEL});
    gw.updateGraph(newState, 500);
    return true;
  }

  this.getIVL = function() { return iVL; }

  var amountLeftSet = -1;
  biColor = function(iVL, iEL) {
    if (iVL.length === 0) return [];
    var V = 0;
    for (var key in iVL) V++;
    var AdjList = [];
    for (var i in iVL) {
      AdjList[i] = [];
    }
    for (var key in iEL) {
      var u = iEL[key]["u"], v = iEL[key]["v"];
      AdjList[u].push(v);
      // add the reverse to check directed graph
      AdjList[v].push(u);
    }
    var stack = [];
    var colors = {};
    for (var i = 0; i < V; i++) {
      if (colors[i] !== undefined) {
        continue;
      }
      colors[i] = 0;
      stack.push(i);
      while (stack.length > 0) {
        var u = stack.pop();
        for (var i in AdjList[u]) {
          var v = AdjList[u][i];
          if (colors[v] === undefined) {
            colors[v] = 1 - colors[u];
            stack.push(v);
          } else if (colors[v] === colors[u]) {
            return undefined;
          }
        }
      }
    }
    var result = [[], []];
    amountLeftSet = 0;
    for (var i = 0; i < V; i++) {
      result[colors[i]].push(i);
      if (colors[i] === 0) {
        amountLeftSet++;
      }
    }
    return result;
  }

  relayoutBipartite = function(colors) {
    var colors = biColor(iVL, iEL);
    if (colors === undefined) {
      alert("PANIC PANIC PANIC");
      alert("WHY IS COLOR = UNDEFINED?");
      return;
    }
    var amountRightSet = amountVertex - amountLeftSet;
    for (var i = 1; i <= amountLeftSet; i++) {
      iVL[colors[0][i - 1]]["x"] = 200;
      iVL[colors[0][i - 1]]["y"] = (300 + (i - (amountLeftSet+1) / 2) * (amountLeftSet == 1 ? 0 : 200 / (amountLeftSet-1)));
    }

    for (var i = 1; i <= amountRightSet; ++i) {
      iVL[colors[1][i - 1]]["x"] = 400;
      iVL[colors[1][i - 1]]["y"] = (300 + (i - (amountRightSet+1) / 2) * (amountRightSet == 1 ? 0 : 200 / (amountRightSet-1)));
    }
  }

  this.konig = function() {
    if (isWeighted) {
      return konigWeighted();
    } else {
      return konigUnweighted();
    }
  }

  // returns a 'hashmap' / javascript object containing the amount of flow that goes through each edge
  function edmondsKarp(flowGraph, source, sink) {
    // figure out the number of vertices
    var n = 0;
    for (var key in flowGraph['vl']) n++;

    // create 2D array containing the residual capacity
    var res = [];
    for (var i = 0; i < n; i++) {
      res[i] = [];
      for (var j = 0; j < n; j++) {
        res[i][j] = 0;
      }
    }

    for (var key in flowGraph['el']) {
      var u = flowGraph['el'][key]['u'];
      var v = flowGraph['el'][key]['v'];
      res[u][v] = +flowGraph['el'][key]['w'];
    }

    var q = [];
    var dist = [];
    var mf = 0;
    while (true) {
      for (var i = 0; i < n; i++) dist[i] = 1000;
      var bfsParent = [];
      var qh = 0, qt = 0;
      q[qt++] = 0;
      dist[0] = 0;
      while (qh < qt) {
        var u = q[qh++];
        for (var v = 0; v < n; v++) {
          if (res[u][v] > 0 && dist[v] > dist[u] + 1) {
            bfsParent[v] = u;
            dist[v] = dist[u] + 1;
            q[qt++] = v;
          }
        }
      }
      if (bfsParent[n - 1] === undefined) {
        break;
      }
      var curFlow = 1000;
      for (var i = n - 1; i !== 0; i = bfsParent[i]) {
        var par = bfsParent[i];
        if (res[par][i] < curFlow) {
          curFlow = res[par][i];
        }
      }
      for (var i = n - 1; i !== 0; i = bfsParent[i]) {
        var par = bfsParent[i];
        res[par][i] -= curFlow;
        res[i][par] += curFlow;
      }
      mf += curFlow;
    }

    var flows = {};
    for (var key in flowGraph['el']) {
      var u = flowGraph['el'][key]['u'];
      var v = flowGraph['el'][key]['v'];
      flows[key] = res[v][u];
    }

    return flows;
  }

  function findSComponent(flowGraph, flows) {
    // figure out the number of vertices
    var n = 0;
    for (var key in flowGraph['vl']) n++;

    // create 2D array containing the residual capacity
    var res = [];
    for (var i = 0; i < n; i++) {
      res[i] = [];
      for (var j = 0; j < n; j++) {
        res[i][j] = 0;
      }
    }

    for (var key in flowGraph['el']) {
      var u = +flowGraph['el'][key]['u'];
      var v = +flowGraph['el'][key]['v'];
      var flow = +flows[key];
      res[u][v] = (+flowGraph['el'][key]['w']) - flow;
      res[v][u] = flow;
    }

    var visited = {};
    var q = [];
    var qh = 0, qt = 0;
    q[qt++] = 0;
    visited[0] = true;
    while (qh < qt) {
      var u = q[qh++];
      for (var v = 0; v < n; v++) {
        if (res[u][v] > 0 && visited[v] === undefined) {
          visited[v] = true;
          q[qt++] = v;
        }
      }
    }

    var sComponent = [];
    for (var key in visited) {
      sComponent.push(+key);
    }

    return sComponent;
  }

  function konigWeighted() {
    var colors = biColor(iVL, iEL);
    if (colors === undefined) {
      $('#on_bipartite-err').html('ERROR: Not a bipartite graph');
      return false;
    }
    relayoutBipartite(colors);

    function convertToFlowGraph() {
      var flowGraph = {'vl': {}, 'el': {}};
      var source = 0, sink = amountVertex + 1;
      flowGraph['vl'][source] = {};
      flowGraph['vl'][source]['x'] = 100;
      flowGraph['vl'][source]['y'] = 300;
      for (var i = 0; i < amountVertex; i++) {
        flowGraph['vl'][i + 1] = {};
        flowGraph['vl'][i + 1]['x'] = iVL[i]['x'];
        flowGraph['vl'][i + 1]['y'] = iVL[i]['y'];
      }
      flowGraph['vl'][sink] = {};
      flowGraph['vl'][sink]['x'] = 500;
      flowGraph['vl'][sink]['y'] = 300;
      var edgeCounter = 0;
      var isZero = {};
      for (var i = 0; i < colors[0].length; i++) {
        isZero[colors[0][i]] = true;
      }
      for (var i in iEL) {
        var u = iEL[i]['u'];
        var v = iEL[i]['v'];
        if (isZero[u] === undefined) {
          var tmp = u;
          u = v;
          v = tmp;
        }
        flowGraph['el'][edgeCounter] = {};
        flowGraph['el'][edgeCounter]['u'] = u + 1;
        flowGraph['el'][edgeCounter]['v'] = v + 1;
        flowGraph['el'][edgeCounter]['w'] = 1000;
        edgeCounter++;
      }
      for (var i = 0; i < colors[0].length; i++) {
        flowGraph['el'][edgeCounter] = {};
        flowGraph['el'][edgeCounter]['u'] = source;
        flowGraph['el'][edgeCounter]['v'] = colors[0][i] + 1;
        flowGraph['el'][edgeCounter]['w'] = iVL[colors[0][i]]['w'];
        edgeCounter++;
      }
      for (var i = 0; i < colors[1].length; i++) {
        flowGraph['el'][edgeCounter] = {};
        flowGraph['el'][edgeCounter]['u'] = colors[1][i] + 1;
        flowGraph['el'][edgeCounter]['v'] = sink;
        flowGraph['el'][edgeCounter]['w'] = iVL[colors[1][i]]['w'];
        edgeCounter++;
      }
      return flowGraph;
    }

    var stateList = [], cs;
    cs = createState({
      iVL: iVL,
      iEL: iEL
    });
    cs['status'] = 'Construct the flow graph (note that the indices are shifted by one so that source is always vertex 0).';
    cs['lineNo'] = 1;
    stateList.push(cs);

    var flowGraph = convertToFlowGraph();

    cs = createState({
      iVL: flowGraph['vl'],
      iEL: flowGraph['el'],
      displayVertexWeight: false,
      displayEdgeWeight: true,
    });
    cs['status'] = 'Construct the flow graph (note that the indices are shifted by one so that source is always vertex 0).';
    cs['lineNo'] = 1;
    stateList.push(cs);

    var flows = edmondsKarp(flowGraph);
    var sComponent = findSComponent(flowGraph, flows);

    var isInSComponent = {};
    for (var i in sComponent) {
      var realId = sComponent[i] - 1;
      if (realId >= 0 && realId < amountVertex) {
        isInSComponent[realId] = true;
      }
    }

    var isInMVC = {};
    for (var i in colors[0]) {
      var vertex = colors[0][i];
      if (isInSComponent[vertex] === undefined) {
        isInMVC[vertex] = true;
      }
    }
    for (var i in colors[1]) {
      var vertex = colors[1][i];
      if (isInSComponent[vertex] !== undefined) {
        isInMVC[vertex] = true;
      }
    }

    var flowGraphJSON = JSON.stringify(flowGraph);

    for (var key in flowGraph['el']) {
      var flow = flows[key];
      flowGraph['el'][key]['w'] = flow + '/' + flowGraph['el'][key]['w'];
    }

    cs = createState({
      iVL: flowGraph['vl'],
      iEL: flowGraph['el'],
      displayVertexWeight: false,
      displayEdgeWeight: true,
    });
    cs['status'] = 'Calculate the max flow and find S component ';
    cs['lineNo'] = 1;
    stateList.push(cs);

    var vertexTraversed = {};
    for (var key in sComponent) {
      vertexTraversed[sComponent[key]] = true;
    }

    cs = createState({
      iVL: flowGraph['vl'],
      iEL: flowGraph['el'],
      displayVertexWeight: false,
      displayEdgeWeight: true,
      vertexTraversed: vertexTraversed
    });
    cs['status'] = 'The S component of the flow graph is {s_comp}.'.replace('{s_comp}', JSON.stringify(sComponent));
    cs['lineNo'] = 1;
    stateList.push(cs);

    var vertexHighlighted = {};
    var vertexCovered = {};

    var mvc = [], mis = [];
    var mvcCost = 0, misCost = 0;
    for (var i = 0; i < amountVertex; i++) {
      if (isInMVC[i] !== undefined) {
        vertexHighlighted[i] = true;
        mvc.push(i);
        mvcCost += +iVL[i]['w'];
      } else {
        vertexCovered[i] = true;
        mis.push(i);
        misCost += +iVL[i]['w'];
      }
    }

    cs = createState({
      iVL: iVL,
      iEL: iEL,
      vertexHighlighted: vertexHighlighted,
      vertexCovered: vertexCovered
    });
    cs['status'] = '{vertices} form an MVC with cost = {cost}'.replace('{vertices}', JSON.stringify(mvc)).replace('{cost}', mvcCost) + '.' +
                   '{vertices} form a MIS with cost = {cost}'.replace('{vertices}', JSON.stringify(mis)).replace('{cost}', misCost) + '.' +
                   ' (Click <a target="_blank" href="maxflow?create={json}"><b><u>here</u></b></a> to see the flow graph construction and flow animation).'.replace('{json}', encodeURIComponent(flowGraphJSON));
    cs['lineNo'] = [2, 3];
    stateList.push(cs);

    gw.startAnimation(stateList);
    populatePseudocode('konig_weighted');
    return true;
  }

  function konigUnweighted() {
    var colors = biColor(iVL, iEL);
    if (colors === undefined) {
      $('#on_bipartite-err').html('ERROR: Not a bipartite graph');
      return false;
    }
    var maxLeftSetLabel = -1;
    for (var key in colors[0]) {
      var v = colors[0][key];
      if (+v > maxLeftSetLabel) {
        maxLeftSetLabel = +v;
      }
    }
    if (maxLeftSetLabel === -1) alert("GRAPH MUST NOT BE EMPTY");
    /*
    (21 Oct 2023: Remove this check, instead iterate through members of left and right set directly
    from `colors`)
    if (maxLeftSetLabel + 1 !== amountLeftSet) {
      // left set is not of the form 0..amountLeftSet-1
      // -> not bipartite!
      $('#on_bipartite-err').html('ERROR: A bipartite graph but there is no x such that the left side consists of [0, x]');
      return false;
    }
    */
    // relayoutBipartite(colors); // to disable to relayout

    var stateList = [], cs;

    var AdjList = [];
    for (var key in iVL) {
      AdjList.push([]);
    }
    for (var key in iEL) {
      var u = iEL[key]["u"], v = iEL[key]["v"];
      AdjList[u].push(v);
      AdjList[v].push(u);
    }

    var leftMatch = {};
    var rightMatch = {};

    for (var key in colors[0]) {
      var left = colors[0][key];
      var visited = {};

      function aug(u) {
        if (visited[u] !== undefined) {
          return 0;
        }
        visited[u] = true;
        for (var key in AdjList[u]) {
          var v = AdjList[u][key];
          if (leftMatch[v] === undefined || aug(leftMatch[v])) {
            leftMatch[v] = u;
            rightMatch[u] = v;
            return 1;
          }
        }
        return 0;
      }

      var found = aug(left);
    }

    var matchingCount = 0;
    var edgeHighlighted = {};
    for (var key in iEL) {
      var u = iEL[key]["u"], v = iEL[key]["v"];
      if (leftMatch[u] === v || leftMatch[v] === u) {
        edgeHighlighted[key] = true;
        matchingCount++;
      }
    }

    cs = createState({
      iVL: iVL,
      iEL: iEL,
      edgeHighlighted: edgeHighlighted
    });
    var bipartiteGraphObject = {"vl": iVL, "el": iEL, "amountLeftSet": amountLeftSet};
    cs['status'] = 'Found a matching of size {size}. '.replace('{size}', matchingCount)
      + "\nL = [" + colors[0] + "], R = [" + colors[1] + "]";
    cs['lineNo'] = 1;
    stateList.push(cs);

    var U = [];
    var vertexHighlighted = {};
    for (var i of colors[0]) {
      if (rightMatch[i] === undefined) {
        U.push(i);
        vertexHighlighted[i] = true;
      }
    }
    cs = createState({
      iVL: iVL,
      iEL: iEL,
      vertexHighlighted: vertexHighlighted,
      edgeHighlighted: edgeHighlighted
    });
    cs['status'] = 'Found U = ' + JSON.stringify(U) + '.';
    cs['lineNo'] = 2;
    stateList.push(cs);

    var Z = [];
    {
      var visited = {};
      for (var key in colors[0]) {
        var left = colors[0][key];
        if (rightMatch[left] !== undefined) {
          continue;
        }
        var stack = [];
        stack.push(left);
        visited[left] = true;
        while (stack.length > 0) {
          var u = stack.pop();
          Z.push(u);
          for (var k in AdjList[u]) {
            var v = AdjList[u][k];
            if (leftMatch[v] !== undefined && visited[leftMatch[v]] === undefined) {
              // v's leftMatch can only be pushed once to the stack
              // when v's leftMatch is pushed, we can push v also
              Z.push(v);
              visited[leftMatch[v]] = true;
              stack.push(leftMatch[v]);
            }
          }
        }
      }
    }

    vertexHighlighted = {};
    for (var key in Z) {
      vertexHighlighted[Z[key]] = true;
    }
    cs = createState({
      iVL: iVL,
      iEL: iEL,
      vertexHighlighted: vertexHighlighted,
    });
    cs["status"] = 'Found Z = ' + JSON.stringify(Z) + '.';
    cs["lineNo"] = [3, 4];
    stateList.push(cs);

    var MVC = [];
    var MIS = [];

    for (var key in colors[0]) {
      var u = colors[0][key];
      var isInZ = false;
      for (var i in Z) {
        if (Z[i] === u) {
          isInZ = true;
          break;
        }
      }
      if (!isInZ) {
        MVC.push(u);
      } else {
        MIS.push(u);
      }
    }

    for (var key in colors[1]) {
      var u = colors[1][key];
      var isInZ = false;
      for (var i in Z) {
        if (Z[i] === u) {
          isInZ = true;
          break;
        }
      }
      if (isInZ) {
        MVC.push(u);
      } else {
        MIS.push(u);
      }
    }

    var vertexHighlighted = {};
    var vertexCovered = {};
    var mvcCost = 0, misCost = 0;
    for (var key in MVC) {
      vertexHighlighted[MVC[key]] = true;
      if (isWeighted) mvcCost += iVL[key]["w"];
      else mvcCost++;
    }
    for (var key in MIS) {
      vertexCovered[MIS[key]] = true;
      if (isWeighted) misCost += iVL[key]["w"];
      else misCost++;
    }
    cs = createState({
      iVL: iVL,
      iEL: iEL,
      vertexHighlighted: vertexHighlighted,
      vertexCovered: vertexCovered
    });
    cs['status'] = '{vertices} form an MVC with cost = {cost}'.replace('{vertices}', JSON.stringify(MVC)).replace('{cost}', mvcCost) + '. ' +
                   '{vertices} form a MIS with cost = {cost}'.replace('{vertices}', JSON.stringify(MIS)).replace('{cost}', misCost) + '. ' +
                   'Click <a target="_blank" href="matching?create={json}"><b><u>here</u></b></a> for matching animation.'.replace('{json}', encodeURIComponent(JSON.stringify(bipartiteGraphObject)))
    cs["lineNo"] = 5;
    stateList.push(cs);

    gw.startAnimation(stateList);
    populatePseudocode("konig_unweighted");

    return true;
  }

  this.bruteforce = function() {
    var stateList = [];

    if (amountVertex === 0) {
      $('#bruteforce-err').html('ERROR: Graph cannot be empty.');
      return;
    }

    if (amountVertex > 8) {
      $('#bruteforce-err').html('ERROR: There are too many vertices. Consider drawing smaller graph.');
      return;
    }

    var current_best = amountVertex;
    var best_mask = (1<<amountVertex) - 1;

    var cs = createState({iVL: iVL, iEL: iEL});
    cs['status'] = 'The value of current_best is {current_best}.'.replace('{current_best}', amountVertex);
    cs["lineNo"] = 1;
    stateList.push(cs);

    for (var mask = 0; mask < (1 << amountVertex); mask++) {
      var valid = true;
      var cost = 0;
      var vertexHighlighted = {};
      var takenVertices = [];
      for (var i = 0; i < amountVertex; i++) {
        if (mask & (1 << i)) {
          takenVertices.push(i);
          if (isWeighted) cost += iVL[i]["w"];
          else cost++;
          vertexHighlighted[i] = true;
        }
      }
      cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: vertexHighlighted
      });
      cs['status'] = 'Trying another subset of vertices with bitmask = {bitmask}. '.replace('{bitmask}', mask) +
                     'The value of current_best is {current_best}.'.replace('{current_best}', current_best);
      cs['lineNo'] = 2;
      stateList.push(cs);
      var edgeCovered = {};
      for (var key in iEL) {
        var u = parseInt(iEL[key]["u"]);
        var v = parseInt(iEL[key]["v"]);
        if ((mask & (1 << u)) == 0 && (mask & (1 << v)) == 0) {
          valid = false;
        } else {
          edgeCovered[key] = true;
        }
      }
      cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: vertexHighlighted,
        edgeCovered: edgeCovered
      });
      if (valid) {
        cs['status'] = '{{vertex_set}} is a valid vertex cover with cost = {cost}.'.replace('{vertex_set}', takenVertices).replace('{cost}', cost);
        if (cost < current_best) {
          cs['status'] += ' Updating current_best to &#39;{cost}&#39;.'.replace('{cost}', cost);
        }
        cs["lineNo"] = [3, 4];
      } else {
        cs["status"] = '{{vertex_set}} is not a valid vertex cover as there is an edge not incident to any vertex in S..'.replace('{vertex_set}', takenVertices);
        cs["lineNo"] = 3;
      }
      stateList.push(cs);
      if (valid && cost < current_best) {
        current_best = cost;
        best_mask = mask;
        for (var key in iVL) {
          var u = parseInt(key);
          if ((best_mask & (1 << u)) !== 0) {
            iVL[key]["extratext"] = "opt";
          } else {
            iVL[key]["extratext"] = "";
          }
        }
      }
    }

    //clear opt extratext
    for (var key in iVL) {
      iVL[key]["extratext"] = "";
    }

    var edgeCovered = {};
    var vertexHighlighted = {};
    var vertexCovered = {};
    var MVC = [], MIS = [];
    for (var i = 0; i < amountVertex; i++) {
      if (best_mask & (1 << i)) {
        vertexHighlighted[i] = true;
        MVC.push(i);
      } else {
        vertexCovered[i] = true;
        MIS.push(i);
      }
    }
    var mvcCost = 0, misCost = 0;
    for (var key in MVC) {
      if (isWeighted) mvcCost += iVL[key]["w"];
      else mvcCost++;
    }
    for (var key in MIS) {
      if (isWeighted) misCost += iVL[key]["w"];
      else misCost++;
    }
    cs = createState({
      iVL: iVL,
      iEL: iEL,
      vertexHighlighted: vertexHighlighted,
      edgeCovered: edgeCovered,
      vertexCovered: vertexCovered
    });
    cs['status'] = '{vertices} form an MVC with cost = {cost}'.replace('{vertices}', JSON.stringify(MVC)).replace('{cost}', mvcCost) + '.' +
                   '<br />' +
                   '{vertices} form a MIS with cost = {cost}'.replace('{vertices}', JSON.stringify(MIS)).replace('{cost}', misCost) + '.';
    cs["lineNo"] = 5;
    stateList.push(cs);

    populatePseudocode("bruteforce");

    gw.startAnimation(stateList);
    return true;
  }

  this.bruteforceDisplayShortVersion = function() {
    /*
    Number of states displayed have been cut down to reduce length of animation with high number of vertices
    A state is only added if:
    - It is the first few states (for user to understand the first few steps of the approach)
    - It is a valid vertex cover ()
    - If the next valid vertex cover is too far away and too many iterations are skipped
    */
    function createInitialState() {
      // initial graph
      var cs = createState({iVL: iVL, iEL: iEL});
      cs['status'] = 'The value of current_best is {current_best}.'.replace('{current_best}', amountVertex);
      cs["lineNo"] = 1;
      return cs;
    }

    function createSkippedIterationsExplanatoryState(iterationNumber) {
      if (isValidVertexCover) {
        var currentVertexSelectionState = createState({
          iVL: iVL,
          iEL: iEL,
          vertexHighlighted: vertexHighlighted,
        });
        var iterationsSkipped = (iterationNumber - lastAddedIteration);
        var message = "Skipping ahead " + iterationsSkipped + " iterations to next valid vertex cover";
        currentVertexSelectionState['status'] = message;
        currentVertexSelectionState['lineNo'] = 2;
        return currentVertexSelectionState;
      } else {
        var currentVertexSelectionState = createState({
          iVL: iVL,
          iEL: iEL,
          vertexHighlighted: vertexHighlighted,
        });
        var iterationsSkipped = (iterationNumber - lastAddedIteration);
        var message = "Skipping " + iterationsSkipped + " iterations to iteration " + iterationNumber + ".";
        currentVertexSelectionState['status'] = message;
        currentVertexSelectionState['lineNo'] = 2;
        return currentVertexSelectionState;
      }
    }

    function createVertexSelectionState(iterationNumber) {
      // this state shows the selection of vertices
      var currentVertexSelectionState = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: vertexHighlighted,
      });

      // use bitmask as iteration number for subsets
      currentVertexSelectionState['status'] = 'Trying another subset of vertices with bitmask = {bitmask}. '.replace('{bitmask}', iterationNumber) +
      'The value of current_best is {current_best}.'.replace('{current_best}', current_best);
      currentVertexSelectionState['lineNo'] = 2;
      return currentVertexSelectionState;
    }

    function createVertexCoverState(iterationNumber) {
      var currentVertexCoverState = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: vertexHighlighted,
        edgeCovered: edgeCovered,
      });
      if (isValidVertexCover) {
        currentVertexCoverState['status'] = '{{vertex_set}} is a valid vertex cover with cost = {cost}.'.replace('{vertex_set}', takenVertices).replace('{cost}', cost);
        if (cost < current_best) {
          currentVertexCoverState['status'] += ' Updating current_best to &#39;{cost}&#39;.'.replace('{cost}', cost);
        }
        currentVertexCoverState["lineNo"] = 3;
        return currentVertexCoverState;
      } else {
        currentVertexCoverState["status"] = '{{vertex_set}} is not a valid vertex cover as there is an edge not incident to any vertex in S..'.replace('{vertex_set}', takenVertices);
        currentVertexCoverState["lineNo"] = 3;
        return currentVertexCoverState;
      }
    }

    function updateOptVertexText(extraText) {
      // update best vertex cover
      if (isValidVertexCover && cost < current_best) {
        current_best = cost;
        best_mask = mask;
        for (var key in iVL) {
          var u = parseInt(key);
          if ((best_mask & (1 << u)) !== 0) {
            iVL[key]["extratext"] = extraText;
          } else {
            iVL[key]["extratext"] = "";
          }
        }
      }
    }

    function createUpdateBestVCState(iterationNumber) {
      updateOptVertexText("cur");  // update global iVL state to have extra text then push
      var currentVertexCoverState = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: vertexHighlighted,
        edgeCovered: edgeCovered,
      });
      if (isValidVertexCover) {
        currentVertexCoverState['status'] = '{{vertex_set}} is a valid vertex cover with cost = {cost}.'.replace('{vertex_set}', takenVertices).replace('{cost}', cost);
        if (cost < current_best) {
          currentVertexCoverState['status'] += ' Updating current_best to &#39;{cost}&#39;.'.replace('{cost}', cost);
        }
        currentVertexCoverState["lineNo"] = 4;
        return currentVertexCoverState;
      }
    }

    function addValidVertexCoverSlides(iterationNumber) {
      skippingState = createSkippedIterationsExplanatoryState(iterationNumber);
      selectionState = createVertexSelectionState(iterationNumber);
      vertexCoverState = createVertexCoverState(iterationNumber);
      updateBestCoverState = createUpdateBestVCState(iterationNumber);
      shortenedStateList.push(skippingState);
      shortenedStateList.push(skippingState); // push twice to let state stay on screen longer
      shortenedStateList.push(selectionState);
      shortenedStateList.push(vertexCoverState);
      shortenedStateList.push(updateBestCoverState);
    }
    // Tested upper limit where there is no lag between clicking the button for bruteforce and animation start
    const MAX_NUM_BRUTEFORCEABLE_VERTICES = 15;

    for (let key in iVL) {
      // clear extra text before proceeding
      iVL[key]["extratext"] = "";
    }

    var stateList = [];
    var shortenedStateList = []
    var lastAddedIteration = 0;
    var NUM_INTRO_SLIDES = 7;

    var numCoversFound = 0;
    var NUM_VALID_COVERS_TO_SHOW_BEFORE_SKIPPING = 3;
    var MAX_NON_IMPROVING_VALID_COVERS_TO_SHOW = 7;
    var MAX_SKIPS_TO_INVALID_COVER = 3;

    // sets the max gap to be a percentage of the total number of subsets (especially for large n = 20)
    const PERCENT_PROGRESS_BETWEEN_ITERATIONS = 10;
    const MAX_GAP_ALLOWED_BETWEEN_ITERATIONS = Math.round((1 << amountVertex) * PERCENT_PROGRESS_BETWEEN_ITERATIONS / 100);

    if (amountVertex === 0) {
      $('#bruteforce-err').html('ERROR: Graph cannot be empty.');
      return;
    }

    if (amountVertex > MAX_NUM_BRUTEFORCEABLE_VERTICES) {
      $('#bruteforce-err').html('ERROR: There are too many vertices. Consider drawing smaller graph.');
      return;
    }

    var current_best = 0;  // best cost so far
    var best_mask = (1<<amountVertex) - 1;

    // calculate total sum of weights / number of vertices = max weight
    for (var i = 0; i < amountVertex; i++) {
      if (best_mask & (1 << i)) { // bit i in mask is 1, vertex i should be taken
        if (isWeighted) current_best += iVL[i]["w"];
        else current_best++;  // correctly calculate weighted cost
      }
    }
    shortenedStateList.push(createInitialState());

    for (var mask = 0; mask < (1 << amountVertex); mask++) { // iterate through all valid subsets
      var isValidVertexCover = true;
      var cost = 0;
      var vertexHighlighted = {};
      var takenVertices = [];
      for (var i = 0; i < amountVertex; i++) {
        if (mask & (1 << i)) { // bit i in mask is 1, vertex i should be taken
          takenVertices.push(i);
          if (isWeighted) cost += iVL[i]["w"];
          else cost++;
          vertexHighlighted[i] = true;
        }
      }

      // checks if current selection is a valid vertex cover;
      var edgeCovered = {};
      for (var key in iEL) {
        var u = parseInt(iEL[key]["u"]);
        var v = parseInt(iEL[key]["v"]);
        if ((mask & (1 << u)) == 0 && (mask & (1 << v)) == 0) {
          isValidVertexCover = false;
        } else {
          edgeCovered[key] = true;
        }
      }

      if (mask < NUM_INTRO_SLIDES) {
        selectionState = createVertexSelectionState(mask);
        vertexCoverState = createVertexCoverState(mask);
        shortenedStateList.push(selectionState);
        shortenedStateList.push(vertexCoverState);
        lastAddedIteration = mask;
        if (isValidVertexCover) {
          updateBestCoverState = createUpdateBestVCState(mask);
          shortenedStateList.push(updateBestCoverState);
          MAX_NON_IMPROVING_VALID_COVERS_TO_SHOW--;
          lastAddedIteration = mask;
        }
      } else if (isValidVertexCover) {
        if ((cost < current_best) || (mask == (1<<amountVertex) - 1)) {
          // improving vertex cover is always shown; final selection also always shown;
          // these conditions must be checked first;
          addValidVertexCoverSlides(mask);
          lastAddedIteration = mask;
        } else if (cost >= current_best) {
          if (MAX_NON_IMPROVING_VALID_COVERS_TO_SHOW > 0) {
            addValidVertexCoverSlides(mask);
            lastAddedIteration = mask;
            MAX_NON_IMPROVING_VALID_COVERS_TO_SHOW--;
          }
        }
      }
    }

    //clear opt extratext
    for (var key in iVL) {
      iVL[key]["extratext"] = "";
    }

    // calculate best mask + its cost
    var edgeCovered = {};
    var vertexHighlighted = {};
    var vertexCovered = {};
    var MVC = [], MIS = [];
    for (var i = 0; i < amountVertex; i++) {
      if (best_mask & (1 << i)) {
        vertexHighlighted[i] = true;
        MVC.push(i);
      } else {
        vertexCovered[i] = true;
        MIS.push(i);
      }
    }
    var mvcCost = 0, misCost = 0;
    for (var key in MVC) {
      if (isWeighted) mvcCost += iVL[key]["w"];
      else mvcCost++;
    }
    for (var key in MIS) {
      if (isWeighted) misCost += iVL[key]["w"];
      else misCost++;
    }

    // this is the final resulting state
    for (var key in iVL) {
      var u = parseInt(key);
      if ((best_mask & (1 << u)) !== 0) {
        iVL[key]["extratext"] = "opt";
      } else {
        iVL[key]["extratext"] = "";
      }
    }

    var finalResultState = createState({
      iVL: iVL,
      iEL: iEL,
      vertexHighlighted: vertexHighlighted,
      edgeCovered: edgeCovered,
      vertexCovered: vertexCovered
    });
    finalResultState['status'] = '{vertices} form an MVC with cost = {cost}'.replace('{vertices}', JSON.stringify(MVC)).replace('{cost}', mvcCost) + '.' +
    '<br />' +
    '{vertices} form a MIS with cost = {cost}'.replace('{vertices}', JSON.stringify(MIS)).replace('{cost}', misCost) + '.';
    finalResultState["lineNo"] = 5;
    shortenedStateList.push(finalResultState);

    populatePseudocode("bruteforce");

    gw.startAnimation(shortenedStateList);
    return true;
  }

  relayoutTree = function() {
    var depth = {};
    var visited = {};
    var stack = [0];
    var parent = {};
    depth[0] = 0;
    var maxDepth = 0;
    var processedVertex = 0;

    function getChildren(u) {
      // the edge list is not guaranteed to be unique
      // put it to a 'hashmap' (isChildren) first to obtain unique children
      var isChildren = {};
      for (var key in iEL) {
        var a = iEL[key]['u'];
        var b = iEL[key]['v'];
        if (a === u && b !== parent[u]) {
          isChildren[b] = true;
        }
        if (b === u && a !== parent[u]) {
          isChildren[a] = true;
        }
      }
      var children = [];
      for (var key in isChildren) {
        children.push(+key);
        parent[+key] = u;
      }
      return children;
    }

    while (stack.length > 0) {
      var u = stack.pop();
      if (visited[u] === true) {
        return false; // cycle found
      }
      visited[u] = true;
      depth[u] = u == 0 ? 0 : depth[parent[u]] + 1;
      processedVertex++;
      if (depth[u] > maxDepth) {
        maxDepth = depth[u];
      }
      let children = getChildren(u);
      for (child of children) {
        stack.push(child);
      }
    }

    if (processedVertex < amountVertex) {
      return false;
    }

    for (var d = 0; d <= maxDepth; d++) {
      var vertices = [];
      for (var i = 0; i < amountVertex; i++) {
        if (depth[i] === d) {
          vertices.push(i);
        }
      }
      vertices.sort(function(a, b) {
        if (iVL[parent[a]]["x"] != iVL[parent[b]]["x"]) {
          return iVL[parent[a]]["x"] - iVL[parent[b]]["x"];
        }
        return a - b;
      });
      for (var i = 0; i < vertices.length; i++) {
        var v = vertices[i];
        // iVL[v]["x"] = 50 + 100 * i;
        // iVL[v]["y"] = 50 + 100 * d;
        var distFromMid = i - Math.floor(vertices.length / 2);
        iVL[v]["x"] = MAIN_SVG_WIDTH / 2 + 100 * distFromMid + (i < 0 ? -50 : +50) * (d % 2);
        iVL[v]["y"] = 50 + 50 * d;
      }
    }
    return true;
  }

  this.greedy = function() {
    if (relayoutTree() === false) {
      $('#on_tree-err').html('ERROR: Not a tree');
      return;
    }

    var stateList = [], cs;

    cs = createState({
      iVL: iVL,
      iEL: iEL
    });
    cs["status"] = 'Rooting the tree at vertex 0';
    cs["lineNo"] = 1;
    stateList.push(cs);

    var vertexParent = [];  // vertexParent[i] is the parent of vertex i
    var isInMVC = {};
    var vertexTraversed = {};
    var vertexCovered = {};
    var edgeCovered = {};

    function cover(u) {
      isInMVC[u] = true;
      vertexCovered[u] = true;
      iVL[u]['extratext'] = 'Taken';
      for (var key in iEL) {
        var a = iEL[key]['u'];
        var b = iEL[key]['v'];
        if (a === u) {
          vertexCovered[b] = true;
          edgeCovered[key] = true;
        }
        if (b === u) {
          vertexCovered[a] = true;
          edgeCovered[key] = true;
        }
      }
    }

    function dfs(u) {
      // the edge list is not guaranteed to be unique...
      // put it to a 'hashmap' first to obtain unique children
      vertexTraversed[u] = true;
      cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexTraversed: vertexTraversed,
        edgeCovered: edgeCovered
      });
      cs['status'] = 'Visiting vertex {vertex}.'.replace('{vertex}', u);
      cs['lineNo'] = 2;
      stateList.push(cs);

      var isChildren = {};
      for (var key in iEL) {
        var a = iEL[key]['u'];
        var b = iEL[key]['v'];
        if (a === u && b !== vertexParent[u]) {
          isChildren[b] = true;
        }
        if (b === u && a !== vertexParent[u]) {
          isChildren[a] = true;
        }
      }
      var children = [];
      for (var key in isChildren) {
        children.push(+key);
      }
      var hasUncoveredEdgeToChildren = false;
      for (var i in children) {
        var child = children[i];
        vertexParent[child] = u;
        cs = createState({
          iVL: iVL,
          iEL: iEL,
          vertexTraversed: vertexTraversed,
          edgeCovered: edgeCovered
        });
        cs['status'] = 'Processing edge {u} -> {v}.'.replace('{u}', u).replace('{v}', child);
        cs['lineNo'] = 3;
        stateList.push(cs);
        dfs(child);
        if (isInMVC[child] === undefined) {
          hasUncoveredEdgeToChildren = true;
        }
      }
      cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexTraversed: vertexTraversed,
        edgeCovered: edgeCovered
      });
      cs['status'] = 'Finished exploring the children of {vertex}.'.replace('{vertex}', u);
      cs['lineNo'] = 3; //TODO
      stateList.push(cs);
      if (vertexCovered[u] === undefined) {
        cs = createState({
          iVL: iVL,
          iEL: iEL,
          vertexTraversed: vertexTraversed,
          edgeCovered: edgeCovered
        });
        cs['status'] = '{vertex} is not covered.'.replace('{vertex}', u);
        cs['lineNo'] = 4;
        stateList.push(cs);
        if (vertexParent[u] != -1 && !hasUncoveredEdgeToChildren) {
          cover(vertexParent[u]);
          cs = createState({
            iVL: iVL,
            iEL: iEL,
            vertexTraversed: vertexTraversed,
            edgeCovered: edgeCovered
          });
          cs['status'] = 'Taking vertex {vertex}.'.replace('{vertex}', vertexParent[u]);
          cs['lineNo'] = 5;
          stateList.push(cs);
        } else {
          cover(u);
          cs = createState({
            iVL: iVL,
            iEL: iEL,
            vertexTraversed: vertexTraversed,
            edgeCovered: edgeCovered
          });
          cs['status'] = 'Taking vertex {vertex}.'.replace('{vertex}', u);
          cs['lineNo'] = 6;
          stateList.push(cs);
        }
      } else {
        var coveredAdjacent = [];
        for (var i in children) {
          var child = children[i];
          if (isInMVC[child]) {
            coveredAdjacent.push(child);
            break;
          }
        }
        cs = createState({
          iVL: iVL,
          iEL: iEL,
          vertexTraversed: vertexTraversed,
          edgeCovered: edgeCovered
        });
        if (isInMVC[u] === undefined) {
          cs['status'] = '{vertex} is covered. '.replace('{vertex}', u) +
                        '{vertex} is adjacent to the following taken vertices : {vertex_set}.'.replace('{vertex}', u).replace('{vertex_set}', JSON.stringify(coveredAdjacent));
        } else {
          cs['status'] = '{vertex} is covered.'.replace('{vertex}', u);
        }
        stateList.push(cs);
      }
      cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexTraversed: vertexTraversed,
        edgeCovered: edgeCovered
      });
      cs['status'] = 'Done with vertex {vertex}.'.replace('{vertex}', u);
      stateList.push(cs);
      delete vertexTraversed[u];
    }

    cs = createState({
      iVL: iVL,
      iEL: iEL,
      vertexTraversed: vertexTraversed,
      vertexCovered: vertexCovered,
      edgeCovered: edgeCovered
    });
    cs['lineNo'] = 7;
    stateList.push(cs);

    vertexParent[0] = -1;
    dfs(0);

    var isInMIS = {};
    var mvc = [];
    var mis = [];
    for (var i = 0; i < amountVertex; i++) {
      if (isInMVC[i] !== undefined) {
        mvc.push(i);
      } else {
        mis.push(i);
        isInMIS[i] = true;
      }
    }

    for (var key in iVL) {
      iVL[key]['extratext'] = '';
    }

    cs = createState({
      iVL: iVL,
      iEL: iEL,
      vertexHighlighted: isInMVC,
      vertexCovered: isInMIS
    });
    cs['status'] = '{vertices} form an MVC with cost = {cost}'.replace('{vertices}', JSON.stringify(mvc)).replace('{cost}', mvc.length) + '.' +
                   '<br />' +
                   '{vertices} form a MIS with cost = {cost}'.replace('{vertices}', JSON.stringify(mis)).replace('{cost}', mis.length) + '.';
    stateList.push(cs);

    populatePseudocode("greedy");

    gw.startAnimation(stateList);
    return true;
  }

  this.correctGreedy = function() {
    if (relayoutTree() === false) {
      $('#on_tree-err').html('ERROR: Not a tree');
      return;
    }

    var stateList = [], cs;

    cs = createState({
      iVL: iVL,
      iEL: iEL
    });
    cs["status"] = 'Rooting the tree at vertex 0';
    cs["lineNo"] = 1;
    stateList.push(cs);

    var vertexParent = [];  // vertexParent[i] is the parent of vertex i
    var isInMVC = {};
    var vertexTraversed = {};
    var edgeCovered = {};

    function cover(u) {
      isInMVC[u] = true;
      iVL[u]['extratext'] = 'Taken';
      for (var key in iEL) {
        var a = iEL[key]['u'];
        var b = iEL[key]['v'];
        if (a === u) {
          edgeCovered[key] = true;
        }
        if (b === u) {
          edgeCovered[key] = true;
        }
      }
    }

    function getChildren(u) {
      // the edge list is not guaranteed to be unique
      // put it to a 'hashmap' (isChildren) first to obtain unique children
      var isChildren = {};
      for (var key in iEL) {
        var a = iEL[key]['u'];
        var b = iEL[key]['v'];
        if (a === u && b !== vertexParent[u]) {
          isChildren[b] = true;
        }
        if (b === u && a !== vertexParent[u]) {
          isChildren[a] = true;
        }
      }
      var children = [];
      for (var key in isChildren) {
        children.push(+key);
        vertexParent[+key] = u;
      }
      return children;
    }

    function dfs(u) {
      // the edge list is not guaranteed to be unique...
      // put it to a 'hashmap' first to obtain unique children
      if (vertexTraversed[u] === true) {
        return;
      }
      vertexTraversed[u] = true;
      cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexTraversed: vertexTraversed,
        edgeCovered: edgeCovered
      });
      cs['status'] = 'Visiting vertex {vertex}.'.replace('{vertex}', u);
      cs['lineNo'] = 2;
      stateList.push(cs);

      var children = getChildren(u);
      if (children.length === 0) {
        // empty array: base case = leaf node
        // create "vertex is not in cover" state
        cs = createState({
          iVL: iVL,
          iEL: iEL,
          vertexTraversed: vertexTraversed,
          edgeCovered: edgeCovered
        });
        cs['status'] = '{vertex} is not covered.'.replace('{vertex}', u);
        cs['lineNo'] = 4;
        stateList.push(cs);

        // take parent of leaf node
        var takenVertex = vertexParent[u];
        if (takenVertex === -1) {
          // leaf node has no parent, nothing to do
          return;
        }
        var parentAlreadyTaken = isInMVC[takenVertex];
        if (!parentAlreadyTaken) {
          cover(takenVertex);
        }
        var message = parentAlreadyTaken ? "Vertex " + takenVertex + " has already been taken." : 'Taking vertex {vertex}.'.replace('{vertex}', takenVertex);

        cs = createState({
          iVL: iVL,
          iEL: iEL,
          vertexTraversed: vertexTraversed,
          edgeCovered: edgeCovered
        });
        cs['status'] = message;
        cs['lineNo'] = 5;
        stateList.push(cs);
      }

      // has children, not a leaf node
      for (var i in children) {
        var child = children[i];
        cs = createState({
          iVL: iVL,
          iEL: iEL,
          vertexTraversed: vertexTraversed,
          edgeCovered: edgeCovered
        });
        cs['status'] = 'Processing edge {u} -> {v}.'.replace('{u}', u).replace('{v}', child);
        cs['lineNo'] = 3;
        stateList.push(cs);
        dfs(child);
      }

      // done with all children
      cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexTraversed: vertexTraversed,
        edgeCovered: edgeCovered
      });
      cs['status'] = 'Finished exploring the children of {vertex}.'.replace('{vertex}', u);
      cs['lineNo'] = 3; //TODO
      stateList.push(cs);

      // find any children left uncovered
      var hasUncoveredChildren = false;
      for (var i of children) {
        if (!isInMVC[i]) {
          // some child is not in the cover
          hasUncoveredChildren = true;
        }
      }
      if (hasUncoveredChildren && !isInMVC[u]) {
        cover(u);
        cs = createState({
            iVL: iVL,
            iEL: iEL,
            vertexTraversed: vertexTraversed,
            edgeCovered: edgeCovered
          });
        cs['status'] = "Vertex " + u + " has a child that is not in the vertex cover.\n" + 'Taking vertex {vertex}.'.replace('{vertex}', u);
        cs['lineNo'] = 6;
        stateList.push(cs);
      }
    }

    cs = createState({
      iVL: iVL,
      iEL: iEL,
      vertexTraversed: vertexTraversed,
      edgeCovered: edgeCovered
    });
    cs['lineNo'] = 7;
    stateList.push(cs);

    vertexParent[0] = -1;
    dfs(0);

    var isInMIS = {};
    var mvc = [];
    var mis = [];
    for (var i = 0; i < amountVertex; i++) {
      if (isInMVC[i] !== undefined) {
        mvc.push(i);
      } else {
        mis.push(i);
        isInMIS[i] = true;
      }
    }

    for (var key in iVL) {
      iVL[key]['extratext'] = '';
    }

    cs = createState({
      iVL: iVL,
      iEL: iEL,
      vertexHighlighted: isInMVC,
      vertexCovered: isInMIS
    });
    cs['status'] = '{vertices} form an MVC with cost = {cost}'.replace('{vertices}', JSON.stringify(mvc)).replace('{cost}', mvc.length) + '.' +
                   '<br />' +
                   '{vertices} form a MIS with cost = {cost}'.replace('{vertices}', JSON.stringify(mis)).replace('{cost}', mis.length) + '.';
    stateList.push(cs);

    populatePseudocode("greedy");

    gw.startAnimation(stateList);
    return true;
  }

  this.dp_on_tree = function() {
    if (relayoutTree() === false) {
      $('#on_tree-err').html('ERROR: Not a tree');
      return;
    }

    var stateList = [], cs;

    cs = createState({
      iVL: iVL,
      iEL: iEL
    });
    cs["status"] = 'Rooting the tree at vertex 0';
    cs["lineNo"] = 1;
    stateList.push(cs);

    var processOrder = [];

    function dfs(u, par) {
      var isChildren = {};
      for (var key in iEL) {
        var a = iEL[key]['u'];
        var b = iEL[key]['v'];
        if (a === u && b !== par) {
          isChildren[b] = true;
        }
        if (b === u && a !== par) {
          isChildren[a] = true;
        }
      }
      var children = [];
      for (var key in isChildren) {
        children.push(+key);
      }
      for (var i in children) {
        var child = children[i];
        dfs(child, u);
      }
      processOrder.push(u);
    }

    dfs(0, -1);

    cs = createState({
      iVL: iVL,
      iEL: iEL
    });
    cs['status'] = 'The postorder traversal of the tree is {postorder}.'.replace('{postorder}', JSON.stringify(processOrder));
    cs['lineNo'] = 2;
    stateList.push(cs);

    var positionAtProcessOrder = [];
    var dp = []; // array to store mvc DP values
    var dpActions = [];
    for (var i = 0; i < amountVertex; i++) {
      positionAtProcessOrder.push(0);
      dp.push([0, 0]);
      dpActions.push([[], []]);
    }

    for (var i = 0; i < amountVertex; i++) {
      positionAtProcessOrder[processOrder[i]] = i;
    }

    for (var i = 0; i < amountVertex; i++) {
      var currentVertex = processOrder[i];
      var edgeHighlighted = {};
      var edgeQueued = {};
      var vertexHighlighted = {};
      var childrenMarked = {};
      var children = [];

      vertexHighlighted[currentVertex] = true;

      // highlight edges
      var childEdgeToEdgeKey = {};
      for (var key in iEL) {
        var u = iEL[key]["u"], v = iEL[key]["v"];
        if (u === currentVertex || v === currentVertex) {
          var otherVertex = u === currentVertex ? v : u;
          if (positionAtProcessOrder[otherVertex] < positionAtProcessOrder[currentVertex]) {
            // There could be more than one edge pointing to the same vertex :(
            if (childrenMarked[otherVertex] === undefined) {
              children.push(otherVertex);
              childEdgeToEdgeKey[otherVertex] = key;
              childrenMarked[otherVertex] = true;
            }
          } else {
            // edgeQueued[key] = true;
          }
        } else {
          // edgeQueued[key] = true;
        }
      }

      cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: vertexHighlighted,
        edgeHighlighted: edgeHighlighted,
        edgeQueued: edgeQueued
      });
      cs['status'] = 'Visiting vertex {vertex}.'.replace('{vertex}', processOrder[i]);
      cs["lineNo"] = 3;
      stateList.push(cs);

      edgeQueued = {};

      var valueTake = isWeighted ? (+iVL[currentVertex]["w"]) : 1;
      var takeStatus = 'Taking vertex {vertex}'.replace('{vertex}', processOrder[i]) +
                       ' with cost = {cost}.'.replace('{cost}', (isWeighted ? (+iVL[currentVertex]["w"]) : 1));
      for (var j = 0; j < children.length; j++) {
        var child = children[j];
        edgeHighlighted[childEdgeToEdgeKey[child]] = true;
        if (dp[child][0] < dp[child][1]) {
          dpActions[currentVertex][1].push([child, 0]);
          valueTake += dp[child][0];
          takeStatus += "Taking dp[" + child + "][0] with cost " + dp[child][0] + ". ";
        } else {
          dpActions[currentVertex][1].push([child, 1]);
          valueTake += dp[child][1];
          takeStatus += "Taking dp[" + child + "][1] with cost " + dp[child][1] + ". ";
        }
        iVL[currentVertex]["extratext"] = valueTake + ", -";
        dp[currentVertex][1] = valueTake;

        cs = createState({
          iVL: iVL,
          iEL: iEL,
          vertexHighlighted: vertexHighlighted,
          edgeQueued: edgeQueued,
          edgeHighlighted: edgeHighlighted
        });
        cs["status"] = takeStatus + "dp[" + currentVertex + "][1] = " + valueTake + ".";
        cs["lineNo"] = 4;
        stateList.push(cs);
      }
      dp[currentVertex][1] = valueTake;
      takeStatus += "dp[" + currentVertex + "][1] = " + valueTake + ".";
      iVL[currentVertex]["extratext"] = valueTake + ", -";
      edgeHighlighted = {};

      cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: vertexHighlighted,
        edgeQueued: edgeQueued,
        edgeHighlighted: edgeHighlighted
      });
      cs["status"] = takeStatus;
      cs["lineNo"] = 4;
      stateList.push(cs);


      var valueNotTake = 0;
      var notTakeStatus = "";
      for (var j = 0; j < children.length; j++) {
        var child = children[j];
        edgeHighlighted[childEdgeToEdgeKey[child]] = true;
        dpActions[currentVertex][0].push([child, 1]);
        valueNotTake += dp[child][1];
        notTakeStatus += "Taking dp[" + child + "][1] with cost " + dp[child][1] + ". ";

        dp[currentVertex][0] = valueNotTake;
        iVL[currentVertex]["extratext"] = valueTake + ", " + valueNotTake;

        cs = createState({
          iVL: iVL,
          iEL: iEL,
          vertexHighlighted: vertexHighlighted,
          edgeQueued: edgeQueued,
          edgeHighlighted: edgeHighlighted
        });
        cs["status"] = notTakeStatus + "dp[" + currentVertex + "][0] = " + valueNotTake + ".";
        cs["lineNo"] = 5;
        stateList.push(cs);
      }
      dp[currentVertex][0] = valueNotTake;
      notTakeStatus += "dp[" + currentVertex + "][0] = " + valueNotTake + ".";
      iVL[currentVertex]["extratext"] = valueTake + ", " + valueNotTake;
      edgeHighlighted = {};

      cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: vertexHighlighted,
        edgeQueued: edgeQueued,
        edgeHighlighted: edgeHighlighted
      });
      cs["status"] = notTakeStatus;
      cs["lineNo"] = 5;
      stateList.push(cs);
    }

    var shouldTake = {};
    var vertexHighlighted = {}, vertexCovered = {};
    var MVC = [], MIS = [];

    shouldTake[0] = dp[0][1] < dp[0][0] ? 1 : 0;
    var mvcCost = 0, misCost = 0;

    for (var i = amountVertex - 1; i >= 0; i--) {
      var currentVertex = processOrder[i];
      if (shouldTake[currentVertex] === undefined) {
        alert("PANICPANICPANIC, SHOULD WE TAKE " + currentVertex + "?");
        break;
      }
      if (shouldTake[currentVertex]) {
        vertexHighlighted[currentVertex] = true;
        MVC.push(currentVertex);
        if (isWeighted) {
          mvcCost += iVL[currentVertex]["w"];
        } else {
          mvcCost++;
        }
      } else {
        vertexCovered[currentVertex] = true;
        MIS.push(currentVertex);
        if (isWeighted) {
          misCost += iVL[currentVertex]["w"];
        } else {
          misCost++;
        }
      }
      var take = shouldTake[currentVertex];
      for (var j = 0; j < dpActions[currentVertex][take].length; j++) {
        var affected = dpActions[currentVertex][take][j][0];
        var action = dpActions[currentVertex][take][j][1];
        shouldTake[affected] = action;
      }
    }

    cs = createState({
      iVL: iVL,
      iEL: iEL,
      vertexHighlighted: vertexHighlighted,
      vertexCovered: vertexCovered
    });
    cs['status'] = '{vertices} form an MVC with cost = {cost}'.replace('{vertices}', JSON.stringify(MVC)).replace('{cost}', mvcCost) + '.' +
                   '<br />' +
                   '{vertices} form a MIS with cost = {cost}'.replace('{vertices}', JSON.stringify(MIS)).replace('{cost}', misCost) + '.';
    cs["lineNo"] = 5;
    stateList.push(cs);

    // clean extratext
    for (var i = 0; i < amountVertex; i++) {
      iVL[i]["extratext"] = "";
    }

    populatePseudocode("dp_on_tree");

    gw.startAnimation(stateList);
    return true;
  }

  // helper function used in approximation algos
  function getMinVertexCoverCost() {
    var result = -1;
    for (var mask = 0; mask < (1 << amountVertex); mask++) {
      var valid = true;
      var total = 0;
      for (var i = 0; i < amountVertex; i++) {
        if (mask & (1 << i)) {
          if (isWeighted) {
            total += iVL[i]["w"];
          } else {
            total++;
          }
        }
      }
      for (var key in iEL) {
        var u = parseInt(iEL[key]["u"]);
        var v = parseInt(iEL[key]["v"]);
        if ((mask & (1 << u)) == 0 && (mask & (1 << v)) == 0) {
          valid = false;
          break;
        }
      }
      if (valid && (result == -1 || total < result)) {
        result = total;
      }
    }
    return result == -1 ? 0 : result;
  }

  this.deterministic_two_opt = function() {
    if (amountVertex === 0) {
      $('#approximation-err').html('There is no graph to run this on. Please select an example graph first.');
      return;
    }
    if (isWeighted) {
      return deterministic_two_opt_weighted();
    } else {
      return deterministic_two_opt_unweighted();
    }
  }

  function deterministic_two_opt_weighted() {
    var stateList = [];
    var W = {};

    for (var key in iVL) {
      if (isWeighted) {
        W[key] = iVL[key]["w"];
      } else {
        W[key] = 1;
      }
      iVL[key]["extratext"] = parseInt(W[key]);
    }
    cs = createState({iVL: iVL, iEL: iEL});
    cs["status"] = 'Assigning vertices&apos; weight to array W';
    cs["lineNo"] = [1, 2];
    stateList.push(cs);

    for (var key in iEL) {
      var u = iEL[key]["u"], v = iEL[key]["v"];
      var w = iEL[key]["w"];
      var e = W[u] < W[v] ? W[u] : W[v];
      var edgeHighlighted = {};
      edgeHighlighted[key] = true;
      cs = createState({
        iVL: iVL,
        iEL: iEL,
        edgeHighlighted: edgeHighlighted,
      });
      cs['status'] = 'Processing edge {u} -> {v} with e = {e}.'.replace('{u}', u).replace('{v}', v).replace('{e}', e);
      cs['lineNo'] = [3, 4];
      stateList.push(cs);
      W[u] -= e;
      W[v] -= e;
      iVL[u]["extratext"] = parseInt(W[u]);
      iVL[v]["extratext"] = parseInt(W[v]);
      cs = createState({
        iVL: iVL,
        iEL: iEL,
        edgeHighlighted: edgeHighlighted,
      });
      cs['status'] = '{value} has been subtracted from the W entries of the selected edge'.replace('{value}', e) + '. ' +
                     'W array = {w_array}'.replace('{w_array}', JSON.stringify(W));
      cs['lineNo'] = [3, 4, 5, 6];
      stateList.push(cs);
    }

    var MVC = [];
    var mvcCost = 0;
    var vertexHighlighted = {};
    for (var key in iVL) {
      if (W[key] === 0) {
        MVC.push(key);
        vertexHighlighted[key] = true;
        if (isWeighted) {
          mvcCost += iVL[key]["w"];
        } else {
          mvcCost++;
        }
      }
    }

    cs = createState({
      iVL: iVL,
      iEL: iEL,
      vertexHighlighted: vertexHighlighted
    });
    cs['status'] = '{vertex_set} form a vertex cover with cost = {cost}.'.replace('{vertex_set}', JSON.stringify(MVC)).replace('{cost}', mvcCost) + '<br>'
                   ' The cost of the min vertex cover of this graph is {mvc_cost}.'.replace('{mvc_cost}', getMinVertexCoverCost());
    cs["lineNo"] = 7;
    stateList.push(cs);

    for (var key in iVL) iVL[key]["extratext"] = "";

    populatePseudocode("deterministic_two_opt_weighted");

    gw.startAnimation(stateList);
    return true;
  }

  function deterministic_two_opt_unweighted() {
    var i, key, cs;
    var stateList = [];
    var takenVertices = {};
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, edgeTraversed = {}, edgeQueued = {};
    var edgeCovered = {};

    for (var key in iEL) {
      edgeQueued[key] = true;
    }

    function edgeListToString(from, to) {
      var ansStr = "";
      var maxLength = Math.min(to - from + 1, 9);
      for (var i = 0; i < maxLength; i++) {
        var key = (i + from).toString();
        ansStr += "(" + iEL[key]["u"] + ", " + iEL[key]["v"] + ")";
        if (i < (maxLength - 1))
          ansStr += ", ";
      }
      if (to - from + 1 >= 10)
        ansStr += " ...";
      return ansStr;
    }

    cs = createState({
      iVL: iVL,
      iEL: iEL
    });
    cs["status"] = 'Assigning arbitrary order to the edges' + edgeListToString(0, iEL.length - 1) + '.';
    cs["lineNo"] = [1, 2];
    stateList.push(cs);

    var takenVertices = [];

    numTaken = 0;
    for (var i = 0; i < amountEdge; i++) {
      var key = i.toString();
      var u = iEL[key]["u"], v = iEL[key]["v"];

      // this edge is already removed
      if (edgeQueued[key] === undefined) {
        continue;
      }

      cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: vertexHighlighted,
        edgeHighlighted: edgeHighlighted,
        vertexTraversed: vertexTraversed,
        edgeTraversed: edgeTraversed,
        edgeQueued: edgeQueued,
        edgeCovered: edgeCovered
      });
      cs['status'] = 'The remaining edge(s) is/are {edges}.'.replace('{edges}', edgeListToString(i, amountEdge - 1));
      cs['lineNo'] = 3;
      stateList.push(cs);

      vertexHighlighted[u] = true;
      vertexHighlighted[v] = true;
      edgeHighlighted[key] = true;

      cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: vertexHighlighted,
        edgeHighlighted: edgeHighlighted,
        vertexTraversed: vertexTraversed,
        edgeTraversed: edgeTraversed,
        edgeQueued: edgeQueued,
        edgeCovered: edgeCovered
      });
      cs["status"] = 'if both vertices are not taken.';
      cs["lineNo"] = 4;
      stateList.push(cs);

      var shouldTakeVertices = (vertexTraversed[u] === undefined) && (vertexTraversed[v] === undefined);

      delete vertexHighlighted[u];
      delete vertexHighlighted[v];
      delete edgeHighlighted[key];

      if (shouldTakeVertices) {
        vertexTraversed[u] = true;
        vertexTraversed[v] = true;
        takenVertices.push(u);
        takenVertices.push(v);
        numTaken += 2;
        for (var nkey in iEL) {
          if (edgeQueued[nkey] === undefined) {
            continue;
          }
          if (iEL[nkey]["u"] === u || iEL[nkey]["v"] === u ||
              iEL[nkey]["u"] === v || iEL[nkey]["v"] === v) {
              edgeCovered[nkey] = true;
          }
        }
        cs = createState({
          iVL: iVL,
          iEL: iEL,
          vertexHighlighted: vertexHighlighted,
          edgeHighlighted: edgeHighlighted,
          vertexTraversed: vertexTraversed,
          edgeTraversed: edgeTraversed,
          edgeQueued: edgeQueued,
          edgeCovered: edgeCovered
        });
        cs["status"] = 'Taking both vertices and removing edges incident with the chosen vertices';
        cs["lineNo"] = 5;
        stateList.push(cs);
        for (var nkey in iEL) {
          if (edgeQueued[nkey] === undefined) {
            continue;
          }
          if (iEL[nkey]["u"] === u || iEL[nkey]["v"] === u ||
              iEL[nkey]["u"] === v || iEL[nkey]["v"] === v) {
              delete edgeCovered[nkey];
              delete edgeQueued[nkey];
          }
        }
        cs["status"] = 'Taking both vertices and removing edges incident with the chosen vertices';
        cs["lineNo"] = 5;
        stateList.push(cs);
      } else {
        delete edgeQueued[key];
        cs = createState({
          iVL: iVL,
          iEL: iEL,
          vertexHighlighted: vertexHighlighted,
          edgeHighlighted: edgeHighlighted,
          vertexTraversed: vertexTraversed,
          edgeTraversed: edgeTraversed,
          edgeQueued: edgeQueued,
          edgeCovered: edgeCovered
        });
        cs["status"] = 'Not taking both vertices';
        cs["lineNo"] = 6;
        stateList.push(cs);
      }
    }

    cs = createState({
      iVL: iVL,
      iEL: iEL,
      vertexHighlighted: vertexHighlighted,
      edgeHighlighted: edgeHighlighted,
      vertexTraversed: vertexTraversed,
      edgeTraversed: edgeTraversed,
      edgeQueued: edgeQueued,
      edgeCovered: edgeCovered
    });
    cs['status'] = '{vertex_set} form a vertex cover with cost = {cost}. '.replace('{vertex_set}', JSON.stringify(takenVertices)).replace('{cost}', numTaken) + '<br>' +
                   'The cost of the min vertex cover of this graph is {mvc_cost}.'.replace('{mvc_cost}', getMinVertexCoverCost());
    cs['lineNo'] = 7;
    stateList.push(cs);

    populatePseudocode("deterministic_two_opt_unweighted");

    gw.startAnimation(stateList);
    return true;
  }

  this.probabilistic_two_opt = function() {
    if (amountVertex === 0) {
      $('#approximation-err').html('There is no graph to run this on. Please select an example graph first.');
      return;
    }
    if (isWeighted === true) {
      $('#approximation-err').html('Probabilistic 2-opt is not applicable to weighted MVC');
      return;
    }

    var i, key, totalWeight = 0, cs;
    var stateList = [];
    var takenVertices = {};
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, edgeTraversed = {}, edgeQueued = {};
    var edgeCovered = {};

    for (var key in iEL) {
      edgeQueued[key] = true;
    }

    if (amountVertex == 0) { // error check, no graph (maybe via empty JSON or faulty db)
      $('#probabilistic_two_opt-err').html('There is no graph to run this on. Please select an example graph first.');
      return false;
    }

    function queuedEdgeToString() {
      var ansStr = "";
      var isLargerThanTen = false;
      var edges = [];
      for (var key in edgeQueued) {
        if (edges.length == 9) {
          isLargerThanTen = true;
          break;
        }
        edges.push("(" + iEL[key]["u"] + ", " + iEL[key]["v"] + ")");
      }
      var str = edges.join(", ");
      if (isLargerThanTen) {
        str += " ...";
      }
      return str;
    }

    var mvcCost = 0;
    var VC = [];

    cs = createState({
      iVL: iVL,
      iEL: iEL
    });
    cs["status"] = 'Assigning arbitrary order to the edges ' + queuedEdgeToString() + '.';
    cs["lineNo"] = [1, 2];
    stateList.push(cs);

    numTaken = 0;
    for (var i = 0; i < amountEdge; i++) {
      var key = i.toString();
      var u = iEL[key]["u"], v = iEL[key]["v"];

      // ignore removed edge
      if (edgeQueued[key] === undefined) {
        continue;
      }

      cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: vertexHighlighted,
        edgeHighlighted: edgeHighlighted,
        vertexTraversed: vertexTraversed,
        edgeTraversed: edgeTraversed,
        edgeQueued: edgeQueued,
        edgeCovered: edgeCovered
      });
      cs['status'] = 'The remaining edge(s) is/are {edges}.'.replace('{edges}', queuedEdgeToString());
      cs['lineNo'] = 3;
      stateList.push(cs);

      vertexHighlighted[u] = true;
      vertexHighlighted[v] = true;
      edgeHighlighted[key] = true;

      cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: vertexHighlighted,
        edgeHighlighted: edgeHighlighted,
        vertexTraversed: vertexTraversed,
        edgeTraversed: edgeTraversed,
        edgeQueued: edgeQueued,
        edgeCovered: edgeCovered
      });
      cs["status"] = 'Taking one endpoint at random.';
      cs["lineNo"] = 4;
      stateList.push(cs);

      var takenVertex = Math.random() <= 0.5 ? u : v;

      mvcCost++;
      VC.push(takenVertex);

      if (u !== takenVertex) {
        delete vertexHighlighted[u];
      }

      if (v !== takenVertex) {
        delete vertexHighlighted[v];
      }

      delete edgeHighlighted[key];

      cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: vertexHighlighted,
        edgeHighlighted: edgeHighlighted,
        vertexTraversed: vertexTraversed,
        edgeTraversed: edgeTraversed,
        edgeQueued: edgeQueued,
        edgeCovered: edgeCovered
      });
      cs["status"] = 'Taking one endpoint at random.';
      cs["lineNo"] = 4;
      stateList.push(cs);

      for (var j = 0; j < amountEdge; j++) { // need to optimize?
        var curKey = j.toString();
        if (edgeQueued[curKey] !== undefined && (iEL[curKey]["u"] === takenVertex || iEL[curKey]["v"] === takenVertex)) {
          edgeCovered[curKey] = true;
        }
      }

      cs = createState({
      iVL: iVL,
        iEL: iEL,
        vertexHighlighted: vertexHighlighted,
        edgeHighlighted: edgeHighlighted,
        vertexTraversed: vertexTraversed,
        edgeTraversed: edgeTraversed,
        edgeQueued: edgeQueued,
        edgeCovered: edgeCovered
      });
      cs["status"] = 'Remove edges incident to the chosen endpoint.';
      cs["lineNo"] = 5;
      stateList.push(cs);

      for (var j = 0; j < amountEdge; j++) {
        var curKey = j.toString();
        if (edgeQueued[curKey] !== undefined && (iEL[curKey]["u"] === takenVertex || iEL[curKey]["v"] === takenVertex)) {
          delete edgeQueued[curKey];
          delete edgeCovered[curKey];
        }
      }

      delete edgeQueued[key];
      delete vertexHighlighted[takenVertex];
      vertexTraversed[takenVertex] = true;
      numTaken++;

      cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: vertexHighlighted,
        edgeHighlighted: edgeHighlighted,
        vertexTraversed: vertexTraversed,
        edgeTraversed: edgeTraversed,
        edgeQueued: edgeQueued,
        edgeCovered: edgeCovered
      });
      cs["status"] = 'Done removing.';
      cs["lineNo"] = 5;
      stateList.push(cs);
    }

    cs = createState({
      iVL: iVL,
      iEL: iEL,
      vertexHighlighted: vertexHighlighted,
      edgeHighlighted: edgeHighlighted,
      vertexTraversed: vertexTraversed,
      edgeTraversed: edgeTraversed,
      edgeCovered: edgeCovered
    });
    cs['status'] = '{vertex_set} form a vertex cover with cost = {cost}. '.replace('{vertex_set}', JSON.stringify(VC)).replace('{cost}', mvcCost) + '<br>' +
                   'The cost of the min vertex cover of this graph is {mvc_cost}.'.replace('{mvc_cost}', getMinVertexCoverCost());
    cs['lineNo'] = 6;
    stateList.push(cs);

    populatePseudocode("probabilistic_two_opt");

    gw.startAnimation(stateList);
    return true;
  }

  this.parameterizedMVC = function(maxVertices) {
    var stateList = [];
    var cs = createState({iVL: iVL, iEL: iEL});
    cs['status'] = "Starting with k = " + maxVertices + (isWeighted ?  " (max weight of cover)" : " (max number of vertices)");
    stateList.push(cs);

    const MAX_NUM_BRUTEFORCEABLE_VERTICES = 15;
    var NUM_BACKTRACKING_STATES_TO_SHOW = 3;
    var NUM_EDGE_SELECTION_STATES_TO_SHOW = 2 * maxVertices + NUM_BACKTRACKING_STATES_TO_SHOW + 3;
    var NUM_RECURSION_STATES_TO_SHOW = 2 * maxVertices + NUM_BACKTRACKING_STATES_TO_SHOW + 3;
    var NUM_VALID_VERTEX_COVERS_TO_SHOW = 3;
    var NUM_VALID_VERTEX_COVERS_TO_SHOW_AFTER_SKIP = 3;
    var MAX_IMPOSSIBLE_STATES_TO_SHOW = 3;
    var smallestMVCSize = Object.keys(iVL).length;
    var NUM_SKIP_STATES_TO_SHOW = 1;
    var mvcFound = false;

    function removeVertex(u, edgeList) {
      // remove all edges in the edgelist that contain u as one of its endpoints.
      // each key in edgeList is a string of the number
      let remainingEdges = []
      for (edgeKey of edgeList) {
        let edge = iEL[edgeKey];
        if (edge["u"] !== u && edge["v"] !== u) {
          // none of the endpoints are the selected vertex to be removed
          remainingEdges.push(edgeKey);
        }
      }
      return remainingEdges;
    }

    function getCoveredEdges(uncoveredEdges) {
      let coveredEdges = {};
      for (let edgeKey in iEL) {
        if (!uncoveredEdges.includes(edgeKey)) {
          coveredEdges[edgeKey] = true;
        }
      }
      return coveredEdges;
    }

    function parameterizedHelper(k, uncoveredEdges, selectedSoFar) {
      // returns a list of selected vertices that form a vertex cover
      if ((k < 0) || ((k == 0) && (uncoveredEdges.length > 0))) {
        // k < 0 only can happen for weighted version: invalid even if it all edges are covered
        if (!mvcFound && MAX_IMPOSSIBLE_STATES_TO_SHOW > 0) {
          stateList.push(createImpossibleState(uncoveredEdges, selectedSoFar));
          MAX_IMPOSSIBLE_STATES_TO_SHOW--;
        }
        return undefined; // impossible result;
      }

      if (NUM_EDGE_SELECTION_STATES_TO_SHOW == 0 && NUM_RECURSION_STATES_TO_SHOW == 0 && NUM_BACKTRACKING_STATES_TO_SHOW == 0 && NUM_SKIP_STATES_TO_SHOW > 0) {
        let skipState = createSkipState(uncoveredEdges, selectedSoFar, mvcFound)
        stateList.push(skipState);
        stateList.push(skipState);
        NUM_SKIP_STATES_TO_SHOW--;
      }

      if (uncoveredEdges.length === 0) {
        // no edges
        mvcFound = true;
        invalidStateCount = 0;
        if (NUM_VALID_VERTEX_COVERS_TO_SHOW > 0 || maxVertices - k < smallestMVCSize) {
          let earlyFinish = createEarlyFinishState(uncoveredEdges, selectedSoFar, k);
          stateList.push(earlyFinish);
          NUM_VALID_VERTEX_COVERS_TO_SHOW--;
        } else if (NUM_SKIP_STATES_TO_SHOW == 0 && NUM_VALID_VERTEX_COVERS_TO_SHOW_AFTER_SKIP > 0) {
          let earlyFinish = createEarlyFinishState(uncoveredEdges, selectedSoFar, k);
          stateList.push(earlyFinish);
          NUM_VALID_VERTEX_COVERS_TO_SHOW_AFTER_SKIP--;
        }
        if (isWeighted) {
          let currWeight = getWeightOfCover(selectedSoFar);
          if (currWeight < minWeight) {
            minWeight = currWeight
          }
        } else {
          if (maxVertices - k < smallestMVCSize) {
          smallestMVCSize = maxVertices - k;  // maxVertices - k == size of vertex cover found
          }
        }
        return selectedSoFar; // no vertices needed
      }

      let edgeKey = uncoveredEdges[0];
      let edge = iEL[edgeKey];
      let uVertex = edge["u"];
      if (NUM_EDGE_SELECTION_STATES_TO_SHOW > 0) {
        let edgeSelectedState = chooseEdgeState(edgeKey, uncoveredEdges, selectedSoFar);
        stateList.push(edgeSelectedState);
        let vertexUSelectedState = chooseVertexState(uVertex, edgeKey, uncoveredEdges, selectedSoFar);
        stateList.push(vertexUSelectedState);
        NUM_EDGE_SELECTION_STATES_TO_SHOW--;
      }

      let uSelected = {...selectedSoFar};
      uSelected[uVertex] = true;
      let uRemainingEdges = removeVertex(uVertex, uncoveredEdges);
      let uNextK = (isWeighted ? k - iVL[uVertex]["w"] : k - 1);
      if (NUM_RECURSION_STATES_TO_SHOW > 0) {
        let recurseOnUState = createRecursionState(uNextK, uVertex, uRemainingEdges, uSelected, "u");
        stateList.push(recurseOnUState);
        NUM_RECURSION_STATES_TO_SHOW--;
      }

      let uResult = parameterizedHelper(uNextK, uRemainingEdges, uSelected);

      if (NUM_BACKTRACKING_STATES_TO_SHOW > 0) {
        stateList.push(createBacktrackingState(edgeKey, uncoveredEdges, selectedSoFar));
        NUM_BACKTRACKING_STATES_TO_SHOW--;
      }

      let vVertex = edge["v"];
      if (NUM_EDGE_SELECTION_STATES_TO_SHOW > 0) {
        let vertexVSelectedState = chooseVertexState(vVertex, edgeKey, uncoveredEdges, selectedSoFar);
        stateList.push(vertexVSelectedState);
        NUM_EDGE_SELECTION_STATES_TO_SHOW--;
      }

      let vSelected = {...selectedSoFar};
      vSelected[vVertex] = true;
      let vRemainingEdges = removeVertex(vVertex, uncoveredEdges);
      let vNextK = (isWeighted ? k - iVL[vVertex]["w"] : k - 1);
      if (NUM_RECURSION_STATES_TO_SHOW > 0) {
        let recurseOnVState = createRecursionState(vNextK, vVertex, vRemainingEdges, vSelected, "v");
        stateList.push(recurseOnVState);
        NUM_RECURSION_STATES_TO_SHOW--;
      }
      let vResult = parameterizedHelper(vNextK, vRemainingEdges, vSelected);
      if (NUM_RECURSION_STATES_TO_SHOW > 0) {
        let compareResultState = compareRecursionResultState(uVertex, vVertex, uResult, vResult, selectedSoFar, uncoveredEdges, edgeKey);
        stateList.push(compareResultState);
      }

      if (uResult === undefined && vResult === undefined) {
        // no solution
        return undefined
      } else {
        if (uResult === undefined) {
          return vResult;
        } else if (vResult === undefined) {
          return uResult;
        } else {
          uResultSize = isWeighted ? getWeightOfCover(uResult) : Object.keys(uResult).length;
          vResultSize = isWeighted ? getWeightOfCover(vResult) : Object.keys(vResult).length;
          return (uResultSize <= vResultSize) ? uResult : vResult;
        }
      }
    }

    function chooseEdgeState(chosenEdgeKey, uncoveredEdges, selectedVertices) {
      let coveredEdges = getCoveredEdges(uncoveredEdges);
      let chosenEdge = {};
      chosenEdge[chosenEdgeKey] = true;
      let cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: selectedVertices,
        edgeCovered: coveredEdges,
        edgeHighlighted: chosenEdge,
      })
      cs['lineNo'] = 3;
      cs['status'] = "Choosing edge " + chosenEdgeKey + " (" + iEL[chosenEdgeKey]["u"] + ", " + iEL[chosenEdgeKey]["v"] + ")";
      return cs;
    }

    function chooseVertexState(chosenVertex, chosenEdgeKey, uncoveredEdges, selectedVertices) {
      let coveredEdges = getCoveredEdges(uncoveredEdges);
      let selectedVertex = {};
      selectedVertex[chosenVertex] = true;
      let chosenEdge = {};
      chosenEdge[chosenEdgeKey] = true;
      let cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: selectedVertices,
        vertexTraversed: selectedVertex,
        edgeCovered: coveredEdges,
        edgeHighlighted: chosenEdge,
      })
      cs['lineNo'] = 4;
      cs['status'] = "Choosing vertex " + chosenVertex;
      return cs;
    }

    function createImpossibleState(uncoveredEdges, selectedVertices) {
      let coveredEdges = getCoveredEdges(uncoveredEdges);
      let cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: selectedVertices,
        edgeCovered: coveredEdges,
      })
      cs['lineNo'] = [1, 2];
      if (isWeighted) {
        let currWeight = getWeightOfCover(selectedVertices);
        cs['status'] = "Current weight = " + currWeight + ", which exceeds the given limit k";
      } else {
        cs['status'] = "k = 0, but the current selection is not a vertex cover.";
      }
      return cs;
    }

    function createEarlyFinishState(uncoveredEdges, selectedVertices, k) {
      let coveredEdges = getCoveredEdges(uncoveredEdges);
      let cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: selectedVertices,
        edgeCovered: coveredEdges,
      })
      let conditionForOpt = isWeighted ? getWeightOfCover(selectedVertices) < minWeight : maxVertices - k < smallestMVCSize;
      if (conditionForOpt) {
        for (var key in iVL) {
          var u = parseInt(key);
          if (selectedVertices[u] === true) {
            iVL[key]["extratext"] = "cur";
          } else {
            iVL[key]["extratext"] = "";
          }
        }
      }
      cs['lineNo'] = 7;
      cs['status'] = "Vertex cover of size " + (maxVertices - k) + " found";
      return cs;
    }

    function createRecursionState(k, chosenVertex, uncoveredEdges, selectedVertices, selectedSide) {
      let coveredEdges = getCoveredEdges(uncoveredEdges);
      let cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: selectedVertices,
        edgeCovered: coveredEdges,
      })
      cs['lineNo'] = selectedSide === "u" ? 5 : 6;
      cs['status'] = "Removing vertex " + chosenVertex + " and covered edges. Recurse on remaining graph with k = " + k;
      return cs;
    }

    function createBacktrackingState(chosenEdgeKey, uncoveredEdges, selectedVertices) {
      let coveredEdges = getCoveredEdges(uncoveredEdges);
      let chosenEdge = {};
      chosenEdge[chosenEdgeKey] = true;
      let cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: selectedVertices,
        edgeCovered: coveredEdges,
        edgeHighlighted: chosenEdge,
      })
      cs['lineNo'] = 3;
      cs['status'] = "Backtracking to chosen edge = " + chosenEdgeKey + " (" + iEL[chosenEdgeKey]["u"] + ", " + iEL[chosenEdgeKey]["v"] + ")";
      return cs;
    }

    function compareRecursionResultState(vertexU, vertexV, uResult, vResult, selectedVertices, uncoveredEdges, chosenEdgeKey) {
      let coveredEdges = getCoveredEdges(uncoveredEdges);

      // place as objects for createState function
      let vertexChoices = {};
      vertexChoices[vertexU] = true;
      vertexChoices[vertexV] = true;
      let chosenEdge = {};
      chosenEdge[chosenEdgeKey] = true;

      let resultState = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: selectedVertices,
        vertexTraversed: vertexChoices,
        edgeCovered: coveredEdges, // should be covered edges not including u or v
        edgeHighlighted: chosenEdge, // should be current edge chosen
      })
      let message = "";
      let lineNo = 0;
      if (uResult === undefined && vResult === undefined) {
        message = "Both recursed states are invalid, no solution for current selection";
        lineNo = [2, 7];
      } else {
        if (uResult === undefined) {
          message = "Only the selection with vertex " + vertexV + " is valid"
        } else if (vResult === undefined) {
          message = "Only the selection with vertex " + vertexU + " is valid"
        } else {
          uResultSize = isWeighted ? getWeightOfCover(uResult) : Object.keys(uResult).length;
          vResultSize = isWeighted ? getWeightOfCover(vResult) : Object.keys(vResult).length;
          let uIsSmaller = (uResultSize <= vResultSize);
          message = "Both recursed states are valid."
          if (uIsSmaller) {
            message = message + "The selection with vertex " + vertexU + " is the smaller one, so return this selection"
          } else {
            message = message + "The selection with vertex " + vertexV + " is the smaller one, so return this selection"
          }
        }
        lineNo = 7;
      }
      resultState["status"] = message;
      resultState["lineNo"] = lineNo;
      return resultState;
    }

    function createFinalState(vertexCover) {
      if (vertexCover === undefined) {
        let noSolutionState = createState({
          "iVL": iVL,
          "iEL": iEL,
        })
        noSolutionState['lineNo'] = 2;
        noSolutionState['status'] = "Impossible to find a vertex cover of size k = " + maxVertices + ", try a larger number.";
        return noSolutionState;
      } else {
        let vertices = [];
        let MIS = {};
        let mis_list = [];
        for (let key in iVL) {
          if (key in vertexCover) {
            vertices.push(key);
            iVL[key]["extratext"] = "opt"
          } else {
            MIS[key] = true;
            mis_list.push(key);
            iVL[key]["extratext"] = ""
          }
        }
        let cs = createState({
          iVL: iVL,
          iEL: iEL,
          vertexHighlighted: vertexCover,
          vertexCovered: MIS,
          edgeCovered: iEL,
        });
        cs['lineNo'] = 7
        cs['status'] = "Final vertex cover returned: [" + vertices + "], with MIS: [" + mis_list + "]";
        return cs;
      }
    }

    function createSkipState(uncoveredEdges, selectedVertices, isMVCFound) {
      let coveredEdges = getCoveredEdges(uncoveredEdges);
      let cs = createState({
        iVL: iVL,
        iEL: iEL,
        vertexHighlighted: selectedVertices,
        edgeCovered: coveredEdges,
      })
      cs['lineNo'] = 3;
      cs['status'] = isMVCFound ? "Skipping to showing other valid vertex covers if any, up to " + NUM_VALID_VERTEX_COVERS_TO_SHOW_AFTER_SKIP
                                : "Skipping to first valid MVC found";
      return cs;
    }

    function getWeightOfCover(vertexCover) {
      let weight = 0;
      for (let vertex in vertexCover) {
        weight += iVL[vertex]["w"];
      }
      return weight;
    }

    let minWeight = 0;
    for (let key in iVL) {
      // clear extra text before proceeding
      iVL[key]["extratext"] = "";
      if (isWeighted) {
        minWeight += iVL[key]["w"]; // start with weight = sum of all vertices
      }
    }

    if (amountVertex > MAX_NUM_BRUTEFORCEABLE_VERTICES) {
      $('#bruteforce-err').html('ERROR: There are too many vertices. Consider drawing smaller graph.');
      return;
    }

    let initialSelectedVertices = {};
    let initialUncoveredEdges = [];
    for (let edgeKey in iEL) { // iEL = {key: {u: ..., v: ..., w: ...}}
      // edgeKey is a string
      initialUncoveredEdges.push(edgeKey);
    }

    let vertexCover = parameterizedHelper(maxVertices, initialUncoveredEdges, initialSelectedVertices);
    let finalState = createFinalState(vertexCover);
    stateList.push(finalState);

    populatePseudocode('parameterized');
    // for (s of stateList) {
    //   console.log(s);
    // }
    gw.startAnimation(stateList);
    return true;
  }

  function createState(options) {
    var iVLObject = options["iVL"];
    var iELObject = options["iEL"];
    var vertexHighlighted = options["vertexHighlighted"];
    var edgeHighlighted = options["edgeHighlighted"];
    var vertexTraversed = options["vertexTraversed"];
    var edgeTraversed = options["edgeTraversed"];
    var edgeQueued = options["edgeQueued"];
    var edgeCovered = options["edgeCovered"];
    var vertexCovered = options["vertexCovered"];
    var vertexGreyed = options["vertexGreyed"];
    var displayVertexWeight = options["displayVertexWeight"];
    var displayEdgeWeight = options["displayEdgeWeight"];

    var isDefaultGrey = true;
    if ((vertexHighlighted == null) && (edgeHighlighted == null) && (vertexTraversed == null) && (edgeTraversed == null) && (edgeQueued == null) && (vertexGreyed == null))
      isDefaultGrey = false;
    if (vertexHighlighted == null) vertexHighlighted = {};
    if (edgeHighlighted == null) edgeHighlighted = {};
    if (vertexTraversed == null) vertexTraversed = {};
    if (edgeTraversed == null) edgeTraversed = {};
    if (edgeQueued == null) edgeQueued = {};
    if (vertexGreyed == null) vertexGreyed = {};
    if (displayVertexWeight == null) displayVertexWeight = isWeighted;
    if (displayEdgeWeight == null) displayEdgeWeight = false;

    var key;
    var state = {
      "vl": {},
      "el": {}
    };

    if (isDefaultGrey) {
      for (key in iVLObject) {
        state["vl"][key] = {};
        state["vl"][key]["cx"] = iVLObject[key]["x"];
        state["vl"][key]["cy"] = iVLObject[key]["y"];
        state["vl"][key]["text"] = key;
        if (displayVertexWeight) {
          if (iVLObject[key]["w"] !== undefined) {
            state["vl"][key]["text"] += "/" + iVLObject[key]["w"];
          } else {
            state["vl"][key]["text"] += "/1";
          }
        }
        state["vl"][key]["state"] = VERTEX_GREY_OUTLINE;
        state["vl"][key]["extratext"] = iVLObject[key]["extratext"];
      }
      for (key in iELObject) {
        state["el"][key] = {};
        state["el"][key]["vertexA"] = iELObject[key]["u"];
        state["el"][key]["vertexB"] = iELObject[key]["v"];
        state["el"][key]["type"] = EDGE_TYPE_UDE;
        state["el"][key]["weight"] = iELObject[key]["w"];
        state["el"][key]["state"] = EDGE_GREY;
        state["el"][key]["displayWeight"] = displayEdgeWeight;
        state["el"][key]["animateHighlighted"] = false;
      }
    }
    else {
      for (key in iVLObject) {
        state["vl"][key] = {};
        state["vl"][key]["cx"] = iVLObject[key]["x"];
        state["vl"][key]["cy"] = iVLObject[key]["y"];
        state["vl"][key]["text"] = key;
        if (displayVertexWeight) {
          if (iVLObject[key]["w"] !== undefined) {
            state["vl"][key]["text"] += "/" + iVLObject[key]["w"];
          } else {
            state["vl"][key]["text"] += "/1";
          }
        }
        state["vl"][key]["state"] = VERTEX_DEFAULT;
        state["vl"][key]["extratext"] = iVLObject[key]["extratext"];
      }
      for (key in iELObject) {
        state["el"][key] = {};
        state["el"][key]["vertexA"] = iELObject[key]["u"];
        state["el"][key]["vertexB"] = iELObject[key]["v"];
        state["el"][key]["type"] = EDGE_TYPE_UDE;
        state["el"][key]["weight"] = iELObject[key]["w"];
        state["el"][key]["state"] = EDGE_DEFAULT;
        state["el"][key]["displayWeight"] = displayEdgeWeight;
        state["el"][key]["animateHighlighted"] = false;
      }
    }

    for (key in edgeQueued) {
      key1 = state["el"][key]["vertexA"];
      key2 = state["el"][key]["vertexB"]
      state["vl"][key1]["state"] = VERTEX_DEFAULT;
      state["vl"][key2]["state"] = VERTEX_DEFAULT;
      state["el"][key]["state"] = EDGE_DEFAULT;
    }

    for (key in iVLObject) {
      if (vertexGreyed[key] === undefined) {
        state["vl"][key]["state"] = VERTEX_DEFAULT;
      }
    }

    for (key in edgeCovered) state["el"][key]["state"] = EDGE_BLUE;
    for (key in vertexCovered) state["vl"][key]["state"] = VERTEX_BLUE_FILL;
    for (key in vertexHighlighted) state["vl"][key]["state"] = VERTEX_HIGHLIGHTED; // VERTEX_BLUE_FILL;
    for (key in edgeHighlighted) state["el"][key]["state"] = EDGE_HIGHLIGHTED; // EDGE_BLUE;
    for (key in vertexTraversed) state["vl"][key]["state"] = VERTEX_TRAVERSED; // VERTEX_GREEN_FILL;
    for (key in edgeTraversed) state["el"][key]["state"] = EDGE_TRAVERSED; // EDGE_GREEN;

    return state;
  }

  function populatePseudocode(act) {
    var codes = [];
    switch (act) {
    case "deterministic_two_opt_unweighted":
      codes.push('assign arbitrary order to the edges');
      codes.push('V = {}');
      codes.push('foreach (edge e in edgeList)');
      codes.push('&nbsp;&nbsp;if both vertices are not taken');
      codes.push('&nbsp;&nbsp;&nbsp;&nbsp;take both vertices and remove incident edges');
      codes.push('&nbsp;&nbsp;else ignore both vertices');
      codes.push('VC = V');
      break;
    case 'deterministic_two_opt_weighted':
      codes.push('foreach (vertex v in vertexList)');
      codes.push('&nbsp;W[v] = weight[v]');
      codes.push('foreach (edge e in edgeList)');
      codes.push('&nbsp;e = min(W[edge[0]], W[edge[1]])');
      codes.push('&nbsp;W[edge[0]] -= e');
      codes.push('&nbsp;W[edge[1]] -= e');
      codes.push('Vertex Cover = {v | v ∈ V, W[v] = 0}');
      break;
    case 'probabilistic_two_opt':
      codes.push('assign arbitrary order to the edges');
      codes.push('V = {}');
      codes.push('foreach (edge e in edgeList)');
      codes.push('&nbsp;&nbsp;take one endpoint at random');
      codes.push('&nbsp;&nbsp;Remove edges incident to the chosen endpoint');
      codes.push('VC = V');
      codes.push('');
      break;
    case 'bruteforce':
      codes.push('Initialize current_best = |vertexList|');
      codes.push('For every possible subset S of V');
      codes.push('&nbsp;If S is a vertex cover');
      codes.push('&nbsp;&nbsp;Try to update current_best');
      codes.push('Return current_best');
      codes.push('');
      codes.push('');
      break;
    case 'dp_on_tree':
      codes.push('Root the tree at vertex 0');
      codes.push('Obtain a postorder traversal of the tree');
      codes.push('foreach (vertex v in postorder)');
      codes.push('&nbsp;in(v) = 1 + sum(min(out(u), in(u)) ∀child u of v)');
      codes.push('&nbsp;out(v) = sum(in(u) ∀child u of v)');
      codes.push('Reconstruct solution from the value of dp array');
      codes.push('');
      break;
    case 'konig_unweighted':
      codes.push('Obtain a maximum matching on the graph');
      codes.push('Let U = unmatched vertices on the left');
      codes.push('Let Z = Vertices in U or connected to U via');
      codes.push('        alternating path');
      codes.push('MVC = (L \\\\ Z) ∪ (R ∩ Z)');
      codes.push('');
      codes.push('');
      break;
    case 'konig_weighted':
      codes.push('Construct the flow graph and calculate the maxflow');
      codes.push('MVC = T component from the left set');
      codes.push('&nbsp;&nbsp;&nbsp;&nbsp;∪ S component from the right set');
      codes.push('');
      codes.push('');
      codes.push('');
      codes.push('');
      break;
    case 'greedy':
      codes.push('Root the tree at vertex 0');
      codes.push('function dfs(u)');
      codes.push('&nbsp;foreach (children v of u) dfs(v)');
      codes.push('&nbsp;if u is not in the vertex cover then');
      codes.push('&nbsp;&nbsp;if u has parent then take u&apos;s parent');
      codes.push('&nbsp;&nbsp;else take u');
      codes.push('dfs(0)');
      break;
    case 'parameterized':
      let exitConditionMessage = isWeighted ? "If remaining weight k < 0" : "If k = 0 and graph contains uncovered edges"
      let recurseValueMessage = vertex => isWeighted ? "k - w(" + vertex + ")" : "k--";
      codes.push(exitConditionMessage);
      codes.push("&nbsp;Return inf");
      codes.push("Choose any edge e = (u, v) in graph");
      codes.push("Choose one of its endpoint vertices (u / v)");
      codes.push("&nbsp;Su = Recurse on graph with vertex u removed; " + recurseValueMessage("u"));
      codes.push("&nbsp;Sv = Recurse on graph with vertex v removed; " + recurseValueMessage("v"));
      codes.push("&nbsp;Return smaller of Su, Sv");
      break;
    default:
      alert("ERROR!");
      break;
    }
    for (var i = 0; i < 7; i++) {
      $("#code" + (i + 1)).html(codes[i]);
    }
  }
}

var actionsWidth = 150;
var statusCodetraceWidth = 430;

// local
var mw, gw, randomGraphID;
var isWeighted = false;

$(function() {
  $('#play').hide();
  mw = new MVC();
  gw = mw.getGraphWidget();
  gw.setAnimationDuration(700 / speedVal);
  var unweighted_samples = [CP3_4_26_2, LINEAR_CHAIN, MVC_U_TWO_APPROX_KILLER, K5, INTERESTING_BIPARTITE, CS4234_SAMPLE];
  // var weighted_samples = [MVC_U_TWO_APPROX_KILLER, MVC_W_TWO_APPROX_KILLER, EXAMPLE_VERTEX_WEIGHTED_TREE, INTERESTING_BIPARTITE]; // unused for now, but soon, randomize MVC vs MWVC and randomize the test cases soon
  randomGraphID = -1;

  mw.examples(unweighted_samples[Math.floor(Math.random() * 5)]);

  $("#menu-unweighted").on("click", function() {
    write(true, true);
    isWeighted = false;
    $("[id*='-weighted']:not(#menu-weighted)").hide();
    $("[id*='-unweighted']").show();
    // $(".weighted").hide();
    // $(".unweighted").show();
    //NOTE: the show MUST be after hide
    $("#menu-unweighted").removeClass("selected-viz");
    $("#menu-weighted").removeClass("selected-viz");
    $("#menu-weighted").html("MWVC");
    $("#menu-unweighted").addClass("selected-viz");
    $("#menu-unweighted").html("Min Vertex Cover");
    mw.refreshView();
  });

  $("#menu-weighted").on("click", function() {
    write(true, true, false);
    isWeighted = true;
    // $(".unweighted").hide();
    // $(".weighted").show();
    //NOTE: the show MUST be after hide
    $("[id*='-unweighted']:not(#menu-unweighted)").hide();
    $("[id*='-weighted']").show();

    $("#menu-weighted").removeClass("selected-viz");
    $("#menu-unweighted").removeClass("selected-viz");
    $("#menu-unweighted").html("MVC");
    $("#menu-weighted").addClass("selected-viz");
    $("#menu-weighted").html("Min Weight Vertex Cover");
    mw.refreshView();
  });

  $("#menu-unweighted").click();

  var graphJSON = getQueryVariable("create");
  if (graphJSON.length > 0) {
    importjson(graphJSON);
    window.history.pushState("object or string", "Title", window.location.href.split('?')[0]);
  }
});

function closeAll() {
  closeAction('draw');
  closeAction('bruteforce');
  closeAction('examples');
  closeAction('on_tree');
  closeAction('on_bipartite');
  closeAction('approximations');
}

function importjson(text) {
  if (isPlaying) stop();
  if (mode == "exploration") {
    mw.importjson(text);
    // closeExamples();
    isPlaying = false;
  }
}

function drawGraph() {
  if (isPlaying) stop();
  if (mode == "exploration") {
    const [newiVL, newiEL] = representationConvert(mw.getiVL(), mw.getiEL(), weightedVertex =isWeighted)
  currentGraphVisu = new GraphVisu(true, true, true, newiVL, newiEL, !isWeighted)
    $('#dark-overlay').fadeIn(function() {
      $('#drawgraph').fadeIn();
    });
    mw.startLoop();
    isPlaying = false;
  }
}

function drawDone() {
  if (!mw.draw()) return false;
  mw.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

function drawCancel() {
  mw.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

function example(id) {
  if (isPlaying) stop();
  if (mw.examples(id)) { // not 100% the same as commonAction
    $('#progress-bar').slider("option", "max", 0);
    isPlaying = false;
  }
}

function bruteforce() {
  if (isPlaying) stop();
  commonAction(mw.bruteforceDisplayShortVersion(), 'Bruteforce');
}

function konig() {
  if (isPlaying) stop();
  commonAction(mw.konig(), 'Kőnig&#39;s Theorem');
}

function greedy() {
  if (isPlaying) stop();
  commonAction(mw.correctGreedy(), 'Greedy MVC on Tree');
}

function dp_on_tree() {
  if(isPlaying) stop();
  commonAction(mw.dp_on_tree(), 'DP on Tree');
}

function deterministic_two_opt() {
  if (isPlaying) stop();
  commonAction(mw.deterministic_two_opt(), isWeighted ? 'Bar-Yehuda and Even&#39;s algorithm'
                                                      : 'Deterministic 2-opt');
}

function probabilistic_two_opt() {
  if (isPlaying) stop();
  commonAction(mw.probabilistic_two_opt(), 'Probabilistic 2-opt');
}

function parameterized() {
  if (isPlaying) stop();
  var input = parseInt($('#parameterized-k').val());
  commonAction(mw.parameterizedMVC(input), 'Parameterized MVC with k=' + input);
}
</script>
</body>

<!-- Mirrored from visualgo.net/en/mvc by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:18:00 GMT -->
</html>
