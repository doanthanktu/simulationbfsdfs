<!DOCTYPE html>
<html lang="en">

<!-- Mirrored from visualgo.net/en/suffixarray by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:18:14 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="description" content="Suffix Array is a sorted array of all suffixes of a given (usually long) text string T of length n characters (n can be in order of hundred thousands characters).Suffix Array is a simple, yet powerful data structure which is used, among others, in full text indices, data compression algorithms, and within the field of bioinformatics.This data structure is very related to the Suffix Tree data structure. Both data structures are usually studied together.">
<meta name="keywords" content="Suffix Array Construction Common Prefix LCP String Matching Longest Repeated Substring">
 
<meta name="csrf-token" content="dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../img/png/suffixarray.png">
<title>Suffix Array - VisuAlgo</title>
<link rel="icon" href="../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../img/favicon.png">
<link rel="stylesheet" href="../css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../css/common-1.0.2.css">
<link rel="stylesheet" href="../css/viz-1.0.4.css">
<link rel="stylesheet" href="../css/visual.css">
<link rel="stylesheet" href="../css/drawgraph-1.0.2.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
        z-index: 8001;
      }
      #e-lecture-timeline {
        top: 80px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }
      .e-lecture-timeline-slide {
        height: 5px;
        width: 2px;
        background: black;
        float: left;
      }
      .e-lecture-timeline-checkpoint {
        height: 20px;
        width: 3px;
        margin-left: 2px;
        margin-top: -7.5px;
        background: black;
        float: left;
      }

      #e-lecture-f1map {
        top: 102.5px;
        right: 130px;
        display: flex;
        position: absolute;
        z-index: 10000;
      }

      .e-lecture-f1map-sector {
        flex-grow: 1;
        background: black;
        float: left;
        height: 5px;
        margin-right: 1px;
      }

      .e-lecture-f1map-sector:last-child {
        margin-right: 0px;
      }

      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }

      .electure-read-status {
        position: absolute;
        bottom: 4px;
        right: 4px;
        font-size: 14px;
        cursor: default;
        color: #00FF7F;
        display: none;
      }

      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
      .electure-print, .electure-end {
        position: fixed;
        top: 45px;
        height: 20px;
        width: 17px;
        right: 80px;
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
        text-align: center;
      }
      .electure-end {
        right: 45px; /* beside the X */
      }

      #change-lang-popup {
        position: fixed;
        background: green;
        left: 40px;
        top: 50px;
        width: 250px;
        height: 125px;
        border: transparent;
        border-radius: 10px;
        padding: 10px 20px;
        z-index: 9000;
      }

      #change-lang-popup p {
        font-size: medium;
        color: white;
        line-height: 2;
        font-family: "PT Sans", sans-serif;
      }

      #change-lang-popup-btn {
        text-decoration: underline;
        margin-left: 50px;
      }

      #change-lang-popup-btn:hover {
        cursor: pointer;
      }

      #rotateDeviceOverlay {
        z-index: 10000;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        background-color: white;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        overflow: hidden;
      }

      #mobile-playback-overlay {
        z-index: 9600;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        gap: 100px;
        background-color: black;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        opacity: 0.3;
        overflow: hidden;
      }
      .mobile-playback-item {
        min-width: 2.5%;
        max-width: 35px;
      }
      .mobile-playback-item img {
        width: 100%
      }
      .mobile-playback-label {
        opacity: 0;
        color: white;
        font-size: 25px;
        font-weight: bold;
        min-width: 1.5%;
        max-width: 25px;
        transition: opacity 0.25s ease-out;
        -webkit-backface-visibility: hidden;
      }
      #mobile-playback-rewind-label {
        margin-right: -70px;
      }
      #mobile-playback-forward-label {
        margin-left: -70px;
      }
      #viz-speed-value {
          font-size: 15px;
          width: 10%;
      }

      #scale {
        position: fixed;
        left: 5px;
      }
    </style>
<style>

/*others*/
.background {
  fill: none;
  pointer-events: all;
}

.lcs_first {
  fill: #2ebbd1;
}

.lcs_second {
  fill: #52bc69;
}
</style>
<style>
/* copied here from common.css (perhaps need to use version numbering) until caches worldwide settles */
#reload-mobile-popup, #message-popup { /* #gdpr-popup, */
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  min-width: 320px;
  bottom: 62px;
  height: 300px;
  background-color: #0275d8;
  border-radius: 15px;
  padding: 30px 40px;
  z-index: 9500;
}
#reload-mobile-popup {
  background-color: green;
  height: 200px;
}
#message-popup {
  z-index: 9000;
  width: 40%;
  height: 130px;
  background-color: #d9534f;
}

#reload-mobile-popup p, #message-popup p { /* #gdpr-popup p, */
  font-size: large;
  color: white;
  line-height: 2;
  font-family: "PT Sans", sans-serif;
}

#reload-mobile-popup .inner-button, #message-popup .inner-button { /* #gdpr-popup .gdpr-button, */
  border: white solid 2px;
  border-radius: 4px;
  font-weight: bold;
  font-size: x-large;
  padding: 2px 8px;
  color: white;
  width: 90px;
  text-align: center;
  position: absolute;
  letter-spacing: 1px;
  text-decoration: none;
  cursor: pointer;
}

#gdpr-accept, #reload-mobile-button, #dismiss-message-btn {
  bottom: 30px;
  right: 40px;
}

#gdpr-reject, #cancel-reload-mobile-button {
  bottom: 30px;
  right: 170px;
}
    </style>
</head>
<body>
<div id="body-container" style="display: flex; flex-direction: column; min-height: 100vh;">
<style>
  #topbar {
    background-color: rgb(0,0,0);
    font-family: "PT Sans", sans-serif;
    font-size: 13px;
    height: 40px;

    padding-left: 40px;
    padding-right: 40px;

    display: flex;
    flex-wrap: wrap;
    align-items: center;
    position: relative;
    justify-content: flex-start;
  }

  #topbar a:hover {
    text-decoration: none;
  }

  #account-dropdown-btn {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;
    height: 24px;
    line-height: 1.5;
  }

  #account-dropdown-btn:hover {
    color: #0a58ca!important;
    border-color: #198754;
    text-decoration: none;
  }

  #login-button {
    color: #198754;
    font-size: 1rem;
    padding: 0 0.5rem;
    margin-left: 0.5rem;

    border: 2px solid;
    border-radius: 0.25rem;

    height: 24px;
    line-height: 1.5;
  }

  #login-button a:hover {
    color: #0a58ca!important;
    text-decoration: none;
  }

  #account-dropdown-menu {
    display: none;
    position: absolute;
    background-color: white;
    z-index: 1000;
    min-width: 10rem;
    padding: 0.5rem 0;
    margin: 0;
    font-size: 1rem;
    color: rgb(0,0,0);
    text-align: left;
    list-style: none;
    background-clip: padding-box;
    border: 1px solid rgba(0,0,0,.15);
    border-radius: 0.25rem;
    top: 45px;
    right: 40px;
    line-height: 1.5;
  }

  .account-dropdown-item {
    display: block;
    width: auto;
    padding: 0.25rem 1rem;
    clear: both;
    font-weight: 400;
    color: rgb(0,0,0);
    text-align: inherit;
    text-decoration: none;
    white-space: nowrap;
    background-color: transparent;
    border: 0;
    height: 24px;
    font-family: SilkscreenNormal, sans-serif;
  }

  .account-dropdown-item:hover {
    background-color: #e9ecef;
    color: #0a58ca;
    text-decoration: none;
  }
</style>
<nav id="topbar">
<span style="margin-right: 0.25rem">
<a href="https://www.comp.nus.edu.sg/~stevenha" style="text-decoration: none; color: white">
<span class="colour" style="border: 1px solid; border-color: #198754!important; border-radius: .25rem!important">7</span>
</a>
<a href="https://visualgo.net/" style="font-family: SilkscreenNormal,sans-serif; font-size: 20px; margin-left: 4px;">
<span style="color: white">Visu</span><span class="colour">Algo</span><span style="font-size: 40%; color: white">.net</span>
</a>
<span style="color: white">/</span>
<select id="Language" class="select2-dropdown" onchange="changeURL()">
<option value="en" selected>en</option>
<option value="zh">zh</option>
<option value="id">id</option>
</select>
<span style="color: white; font-family: monospace">/suffixarray</span>
</span>
<span style="max-height: 30px">
<span id="title">
<a id="title-suffixarray" class="selected-viz">Suffix Array</a>
</span>
</span>
<span style="max-height: 30px; background-color:rgb(0,0,0)!important; color: white; margin-left: auto">
<div id="mode-menu">
<div id="mode-button" style="background-color: rgb(0,0,0)!important;" title="exploration">Exploration Mode &#9663;</div>
<div id="other-modes" style="background-color: rgb(0,0,0)!important; padding-top: 11px">
<a title="e-Lecture" style="background-color: rgb(0,0,0)!important;">e-Lecture Mode</a>
</div>
</div>
</span>
<span id="login-button" style="font-family: SilkscreenNormal,sans-serif">
<a href="https://visualgo.net/login">Login</a>
</span>
</nav>
<ul id="account-dropdown-menu">
<li><a class="account-dropdown-item" href="https://visualgo.net/profile">Profile</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/training">Training</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/tests">Tests</a></li>
<li><a class="account-dropdown-item" href="https://visualgo.net/logout">Log Out</a></li>
</ul>
<script>
  function changeURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    URL[3] = document.getElementById("Language").value;
    window.location.assign(URL.join('https://visualgo.net/'));
  }

  function changeDefaultLanguageAndURL() {
    let URL = window.location.href.split('https://visualgo.net/');
    let val = document.getElementById("Language").value;
    URL[3] = val;

    let data = {
      '_token': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
      'lang'  : val
    }
    $.post('https://visualgo.net/changeLanguage', data, function (res, status) {
      if(res['status'] === 'success') {
        window.location.assign(URL.join('https://visualgo.net/'));
      } else if (res['status'] === 'failed') {
        alert(res['message']);
      } else {
        alert('An unknown error occurred');
      }
    })
  }
</script>
<div id="dark-overlay"></div>
<div id="main-content-container" style="flex: 1">

<div id="mobile-playback-overlay" class="playing" style="display: none;">
<span id="mobile-playback-rewind-label" class="mobile-playback-label">-7</span>
<span id="mobile-playback-rewind" class="mobile-playback-item" onclick="mobilePlaybackRewind()"><img src="../img/prevFrame.png" alt="rewind 7 frames"></span>
<span id="mobile-playback-pause" class="mobile-playback-item" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/pause.png" alt="pause"></span>
<span id="mobile-playback-play" class="mobile-playback-item" style="display: none;" onclick="mobilePlaybackPauseOrPlay()"><img src="../img/play.png" alt="play"></span>
<span id="mobile-playback-forward" class="mobile-playback-item" onclick="mobilePlaybackForward()"><img src="../img/nextFrame.png" alt="forward 7 frames"></span>
<span id="mobile-playback-forward-label" class="mobile-playback-label">+7</span>
</div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id="speed-control"><div id="speed-input"></div><div id="viz-speed-value">1x</div></div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick="goToBeginning()"><img src="../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick="stepBackward()"><img src="../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick="pause()"><img src="../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick="play()"><img src="../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick="stepForward()"><img src="../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick="goToEnd()"><img src="../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id="viz">
<p id="info" "></p>
</div>
<div id="current-action" class="panel"></div>
<div id="e-lecture" class="panel"></div> 
<div id="e-lecture-timeline"></div>
<div id="e-lecture-f1map">
<div class="e-lecture-f1map-sector" sectorNo="1"></div>
<div class="e-lecture-f1map-sector" sectorNo="2"></div>
<div class="e-lecture-f1map-sector" sectorNo="3"></div>
</div>
<div id="overlay" hidden onclick="end_eLecture()"> 
<div id="electure-dropdown">
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. Suffix Array</option>
<option value="2">2. Suffix Array Visualization</option>
<option value="3">3. Available Operations</option>
<option value="3-1">&nbsp;&nbsp;&nbsp;3-1. Construct Suffix Array - UI</option>
<option value="3-2">&nbsp;&nbsp;&nbsp;3-2. The Prefix Doubling Algorithm</option>
<option value="3-3">&nbsp;&nbsp;&nbsp;3-3. Search</option>
<option value="3-4">&nbsp;&nbsp;&nbsp;3-4. Longest Common Prefix</option>
<option value="3-5">&nbsp;&nbsp;&nbsp;3-5. Longest Repeated Substring (LRS)</option>
<option value="3-6">&nbsp;&nbsp;&nbsp;3-6. Longest Common Substring (LRS)</option>
<option value="4">4. Implementation</option>
</select>
</div>
<div class="electure-print" title="Print the e-Lecture note" style="z-index=8001;">&#9997;</div>
<div class="electure-end" title="Close the e-Lecture mode" style="z-index=8001;">&#10008;</div>
</div>
<div id="dropdown-temp-holder" hidden></div>

<div id="electure-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p><b>Suffix Array</b> is a sorted array of all suffixes of a given (usually long) text string <b>T</b> of length <b>n</b> characters (<b>n</b> can be in order of hundred thousands characters).</p><br><p>Suffix Array is a simple, yet powerful data structure which is used, among others, in full text indices, data compression algorithms, and within the field of bioinformatics.</p><br><p>This data structure is very related to the <a href="suffixtree.html"><u>Suffix Tree</u></a> data structure. Both data structures are usually studied together.</p>
<div class="electure-addition">
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
If you are an NUS student and a repeat visitor, please <a href="https://visualgo.net/login"><u>login</u></a>.</p>
</div>
<div class="electure-next" data-nextid="2" title="Go to the next slide 2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-2" class="electure-dialog" style="top:70px;left:50%;margin-left:-250px;width:500px;">
<p>The visualization of Suffix Array is simply a table where each row represents a suffix and each column represents the attributes of the suffixes.</p><br><p>The four (basic) attributes of each row <b>i</b> are:</p><ol><li>index i, ranging from 0 to <b>n</b>-1,</li><li>SA[i]: the i-th lexicographically smallest suffix of <b>T</b> is the SA[i]-th suffix,</li><li>LCP[i]: the Longest Common Prefix between the i-th and the (i-1)-th lexicographically smallest suffixes of <b>T</b> is LCP[i] (we will see the application of this attribute later), and</li><li>Suffix T[SA[i]:] - the i-th lexicographically smallest suffix of <b>T</b> is from index SA[i] to the end (index <b>n</b>-1).</li></ol><p>Some operations may add more attributes to each row and are explained when that operations are discussed.</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 1: Since you are not <a href="https://visualgo.net/login"><u>logged-in</u></a>, you may be a first time visitor (or not an NUS student) who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b>/<b>[PageUp]</b> to go to the next/previous slide, respectively, (and if the drop-down box is highlighted, you can also use <b>[&rarr; or &darr;/&larr; or &uarr;]</b> to do the same),and <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
</div>
<div class="electure-prev" data-nextid="1" title="Go to the previous slide 1">&larr;</div>
<div class="electure-next" data-nextid="3" title="Go to the next slide 3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3" class="electure-dialog" style="bottom:220px;left:60px;width:500px;">
<p>All available operations on the Suffix Array are listed below.</p><ol><li><b>Construct Suffix Array (SA)</b> is the O(<b>n</b> log <b>n</b>) Suffix Array construction algorithm based on the idea by Karp, Miller, &amp; Rosenberg (1972) that sort prefixes of the suffix in increasing length (1, 2, 4, 8, ...).</li><li><b>Search</b> utilizes the fact that the suffixes in Suffix Array are sorted and call two binary searches in O(<b>m</b> log <b>n</b>) to find the first and the last occurrence(s) of pattern string <b>P</b> of length <b>m</b>.</li><li><b>Longest Common Prefix (LCP)</b> between two adjacent suffixes (excluding the first suffix) can be computed in O(<b>n</b>) using the Permuted LCP (PLCP) theorem. The name of this algorithm is Kasai&#39;s algorithm.</li><li><b>Longest Repeated Substring (LRS)</b> is a simple O(<b>n</b>) algorithm that finds the suffix with the highest LCP value.</li><li><b>Longest Common Substring (LCS)</b> is a simple O(<b>n</b>) algorithm that finds the suffix with the highest LCP value that comes from two different strings.</li></ol>
<div class="electure-addition">
<hr>
<p>Pro-tip 2: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2021). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
</div>
<div class="electure-prev" data-nextid="2" title="Go to the previous slide 2">&larr;</div>
<div class="electure-next" data-nextid="3-1" title="Go to the next slide 3-1">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-1" class="electure-dialog" style="top:70px;left:50%;margin-left:-250px;width:500px;">
<p>In this visualization, we show the proper O(<b>n log n</b>) construction of Suffix Array based on the idea of Karp, Miller, &amp; Rosenberg (1972) that sort prefixes of the suffix in increasing length (1, 2, 4, 8, ...), a.k.a. the prefix doubling algorithm.</p><br><p>We limit the input to only accept 12 (cannot be too long due to the available drawing space &mdash; but in the real application of Suffix Tree, <b>n</b> can be in order of hundred thousand to million characters) UPPERCASE (we delete your lowercase input) alphabet and the special terminating symbol &#39;$&#39; characters (i.e., [A-Z$]). If you do not write a terminating symbol &#39;$&#39; at the back of your input string, we will automatically do so. If you place a &#39;$&#39; in the middle of the input string, they will be ignored. And if you enter an empty input string, we will resort to the default "GATAGACA$".</p><br><p>For convenience, we provide a few classic test case input strings usually found in Suffix Tree/Array lectures, but to showcase the strength of this visualization tool, you are encouraged to enter any 12-characters string of your choice (ending with character &#39;$&#39;).</p><br><p>Note that the LCP Array column remains empty in this operation. They are to be computed separately via the Longest Common Prefix operation.</p>
<div class="electure-addition">
<hr>
<p>Pro-tip 3: Other than using the typical media UI at the bottom of the page, you can also control the animation playback using keyboard shortcuts (in Exploration Mode): <b>Spacebar</b> to play/pause/replay the animation, <b>&larr;</b>/<b>&rarr;</b> to step the animation backwards/forwards, respectively, and <b>-</b>/<b>+</b> to decrease/increase the animation speed, respectively.</p>
</div>
<div class="electure-prev" data-nextid="3" title="Go to the previous slide 3">&larr;</div>
<div class="electure-next" data-nextid="3-2" title="Go to the next slide 3-2">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-2" class="electure-dialog" style="top:70px;left:50%;margin-left:-250px;width:500px;">
<p>This Prefix Doubling Algorithm runs in O(<b>log n</b>) iterations, where for each iteration, it compares substring T[SA[i]:SA[i+k]] with T[SA[i+k]:SA[i+2*k]], i.e., first compare two pairs of characters, then compare first two characters with the next two, then compare the first four characters with the next four, and so on.</p><br><p>This algorithm is best explored via visualization, see <span class="slide-actions" onclick="doButtonAction141()">ConstructSA("GATAGACA$")</span> in action.</p><br><p>Time complexity: There are O(<b>log n</b>) prefix doubling iterations, and each iteration we call O(<b>n</b>) Radix Sort, thus it runs in O(<b>n log n</b>) &mdash; good enough to handle up to <b>n &le; 200K</b> characters in typical programming competition problems involving long strings.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-1" title="Go to the previous slide 3-1">&larr;</div>
<div class="electure-next" data-nextid="3-3" title="Go to the next slide 3-3">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-3" class="electure-dialog" style="top:70px;left:50%;margin-left:-250px;width:500px;">
<p>After we construct the Suffix Array of <b>T</b> in O(<b>n log n</b>), we can search for the occurrence of Pattern string <b>T</b> in O(<b>m log n</b>) by binary searching the sorted suffixes to find the lower bound (the first occurrence of <b>P</b> as a prefix of any suffix of <b>T</b>) and the upper bound positions (thelast occurrence of <b>P</b> as a prefix of any suffix of <b>T</b>).</p><br><p>Time complexity: O(<b>m log n</b>) and it will return an interval of size <b>k</b> where <b>k</b> is the total number of occurrences.</p><br><p>For example, on the Suffix Array of <b>T</b> = "GATAGACA$" above, try these scenarios:</p><ol><li><b>P</b> returns a range of rows: <span class="slide-actions" onclick="doButtonAction137()">Search("GA")</span>, occurrences = {4, 0}</li><li><b>P</b> returns one row only: <span class="slide-actions" onclick="doButtonAction138()">Search("CA")</span>, occurrences = {2}</li><li><b>P</b> is not found in <b>T</b>: <span class="slide-actions" onclick="doButtonAction139()">Search("WONKA")</span>, occurrences = {NIL}</li></ol>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-2" title="Go to the previous slide 3-2">&larr;</div>
<div class="electure-next" data-nextid="3-4" title="Go to the next slide 3-4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-4" class="electure-dialog" style="top:70px;left:50%;margin-left:-250px;width:500px;">
<p>We can compute the Longest Common Prefix (LCP) of two adjacent suffixes (in Suffix Array order) in O(n) time using three phases of Kasai&#39;s algorithm. This algorithm takes advantage that if we have a long LCP between two adjacent suffixes (in Suffix Array order), that long LCP has lots of overlap with another suffix in positional order when its first character is removed.</p><br><p>The first phase: Compute the value of Phi[], where Phi[SA[i]] = SA[i-1] in O(<b>n</b>). This is to help the algorithm knows in $O(<b>1</b>) time of which Suffix is behind Suffix-SA[i] in Suffix Array order.</p><br><p>The second phase: Compute the PLCP[] values between a Suffix-i in positional order with Suffix-Phi[i] (the one behind Suffix-i in Suffix Array order). When we advance to the next index i+1 in positional order, we will remove the front most character of the suffix, but possibly retain lots of LCP value between Suffix-(i+1) and Suffix-Phi[(i+1)]. PLCP Theorem (not proven) shows that the LCP values can only be incremented up to <b>n</b> times, and thus can only be decremented at most <b>n</b> times too, making the overall complexity of the second phase to be also O(<b>n</b>).</p><br><p>The third phase: We compute the value of LCP[], where LCP[i] = PLCP[SA[i]] in O(<b>n</b>). This LCP values are the one that we use for other Suffix Array applications later.</p><br><p>Time complexity: Kasai&#39;s algorithm utilizes the PLCP theorem where the total number of increase (and decrease) operations of the value of the LCP is at most O(<b>n</b>). Thus Kasai&#39;s algorithm runs in O(<b>n</b>) overall. Thus, the combination of O(<b>n log n</b>) Suffix Array construction (via the Prefix Doubling algorithm) and the O(<b>n</b>) computation of LCP Array using this Kasai&#39;s algorithm is good enough to handle up to <b>n ≤ 200K</b> characters in typical programming competition problems involving long strings.</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-3" title="Go to the previous slide 3-3">&larr;</div>
<div class="electure-next" data-nextid="3-5" title="Go to the next slide 3-5">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-5" class="electure-dialog" style="top:70px;left:50%;margin-left:-250px;width:500px;">
<p>After we construct the Suffix Array of <b>T</b> in O(<b>n log n</b>) and compute its LCP Array in O(<b>n</b>), we can find the Longest Repeated Substring (LRS) in <b>T</b> by simply iterating through all LCP values and reporting the largest one.</p><br><p>This is because each value LCP[i] the LCP Array means the longest common prefix between two lexicographically adjacent suffixes: Suffix-i and Suffix-(i-1). This corresponds to an internal vertex of the equivalent Suffix Tree of <b>T</b> that branches out to at least two (or more) suffixes, thus this common prefix of these adjacent suffixes are <b>repeated</b>.</p><br><p>The longest common (repeated) prefix is the required answer, which can be found in O(<b>n</b>) by going through the LCP array once.</p><br><p>Without further ado, try <span class="slide-actions" onclick="doButtonAction135()">LRS("GATAGACA$")</span>. We have LRS = "GA".</p><br><p>It is possible that <b>T</b> contains more than one LRS, e.g., try <span class="slide-actions" onclick="doButtonAction136()">LRS("BANANABAN$")</span>.<br>We have LRS = "ANA" (actually overlap) or "BAN" (without overlap).</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-4" title="Go to the previous slide 3-4">&larr;</div>
<div class="electure-next" data-nextid="3-6" title="Go to the next slide 3-6">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-3-6" class="electure-dialog" style="top:70px;left:50%;margin-left:-250px;width:500px;">
<p>After we construct the generalized Suffix Array of the concatenation of both strings <b>T1$T2#</b> of length <b>n = n1+n2</b> in O(<b>n log n</b>) and compute its LCP Array in O(<b>n</b>), we can find the Longest Repeated Substring (LRS) in <b>T</b> by simply iterating through all LCP values and reporting the largest one that comes from two different strings.</p><br><p>Without further ado, try <span class="slide-actions" onclick="doButtonAction140()">LCS("GATAGACA$", "CATA#")</span> on the generalized Suffix Array of string <b>T1</b> = "GATAGACA$" and <b>T2</b> = "CATA#". We have LCS = "ATA".</p>
<div class="electure-addition">
</div>
<div class="electure-prev" data-nextid="3-5" title="Go to the previous slide 3-5">&larr;</div>
<div class="electure-next" data-nextid="4" title="Go to the next slide 4">&rarr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="electure-4" class="electure-dialog" style="top:70px;left:50%;margin-left:-250px;width:500px;">
<p>You are allowed to use/modify our implementation code for fast Suffix Array+LCP: <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch6/sa_lcp.cpp" target="_blank"><u>sa_lcp.cpp</u> | <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch6/sa_lcp.py" target="_blank"><u>py</u></a> | <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch6/sa_lcp.java" target="_blank"><u>java</u></a> | <a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch6/sa_lcp.ml" target="_blank"><u>ml</u></a> to solve programming contest problems that need it.</p>
<div class="electure-addition">
<hr>
<p>You have reached the last slide. Return to 'Exploration Mode' to start exploring!</p>
<p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
</div>
<div class="electure-prev" data-nextid="3-6" title="Go to the previous slide 3-6">&larr;</div>
<div class="electure-read-status" title="Spend some more time reading this slide">&#128337;</div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>Close</u></span>
</div>
<div id="rotateDeviceOverlay" style="display: none;">
<div id="rotateDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please rotate your device to landscape mode for a better user experience</div>
<div id="widenDeviceText" style="font-size: 45px; font-weight: bold; text-align: center">Please make the window wider for a better user experience</div>
</div>

<style>
        .construct {
            bottom: 173px
        }
    </style>
<style>
        .search {
            bottom: 146px
        }
    </style>
<style>
        .lcp {
            bottom: 119px
        }
    </style>
<style>
        .lrs {
            bottom: 92px
        }
    </style>
<style>
        .lcs {
            bottom: 65px
        }
    </style>
<div id="actions" class="panel">
<p id="construct">Construct Suffix Array</p>
<p id="search">Search</p>
<p class="execAction" id="lcp" onClick="doLCP()">Longest Common Prefix</p>
<p class="execAction" id="lrs" onClick="doLRS()">Longest Repeated Substring</p>
<p id="lcs">Longest Common Substring</p>
</div>
<div id="actions-hide" class="panel-hide"><span style="color:white; font-size: x-large; display: inline-block;">&gt;</span></div>
<div id="actions-extras">
<div class="construct action-menu-pullout">
<div id="construct-example1" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#T&#039;).val(&#039;GATAGACA$&#039;); constructSuffixArray();">
<p>GATAGACA$</p>
</div>
<div id="construct-example2" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#T&#039;).val(&#039;BANANABAN$&#039;); constructSuffixArray();">
<p>BANANABAN$</p>
</div>
<div id="construct-example3" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#T&#039;).val(&#039;MISSISSIPPI$&#039;); constructSuffixArray();">
<p>MISSISSIPPI$</p>
</div>
<div id="construct-example4" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#T&#039;).val(&#039;ABRACADABRA$&#039;); constructSuffixArray();">
<p>ABRACADABRA$</p>
</div>
<div id="construct-example5" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#T&#039;).val(&#039;RATATAT$&#039;); constructSuffixArray();">
<p>RATATAT$</p>
</div>
<div id="construct-example6" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#T&#039;).val(&#039;AAAAAAA$&#039;); constructSuffixArray();">
<p>AAAAAAA$</p>
</div>
<div id="construct-example7" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#T&#039;).val(&#039;ABCDE$&#039;); constructSuffixArray();">
<p>ABCDE$</p>
</div>
<div id="construct-example8" class="execAction new-menu-option coloured-menu-option" onClick="$(&#039;#T&#039;).val(&#039;AABBCC$&#039;); constructSuffixArray();">
<p>AABBCC$</p>
</div>
<div id="construct-input" class="new-menu-option">
T = <input id="T" type="text" autocomplete="off" onkeyup="this.value = this.value.replace(/[^A-Z$]/, &#039;&#039;)" value="CUSTOMSTR$" maxlength="12" style="width: 120px"> </div>
<div id="construct-go" class="execAction new-menu-option coloured-menu-option" onClick="constructSuffixArray()">
<p>Go</p>
</div>
<div id="construct-err" class="err" style="float: left;"></div>
</div>
<div class="search action-menu-pullout">
<div id="search-input" class="new-menu-option">
P = <input id="search_inp" type="text" autocomplete="off" value="GA" style="width: 120px"> </div>
<div id="search-go" class="execAction new-menu-option coloured-menu-option" onClick="doSearch()">
<p>Go</p>
</div>
<div id="search-err" class="err" style="float: left;"></div>
</div>
<div class="lcp action-menu-pullout">
<div id="lcp-err" class="err" style="float: left;"></div>
</div>
<div class="lrs action-menu-pullout">
<div id="lrs-err" class="err" style="float: left;"></div>
</div>
<div class="lcs action-menu-pullout">
<div id="lcs-input1" class="new-menu-option">
T1 = <input id="s1" type="text" autocomplete="off" onkeyup="this.value = this.value.replace(/[^A-Z$]/, &#039;&#039;)" value="GATAGACA$" maxlength="12" style="width: 120px"> </div>
<div id="lcs-input2" class="new-menu-option">
T2 = <input id="s2" type="text" autocomplete="off" onkeyup="this.value = this.value.replace(/[^A-Z#]/, &#039;&#039;)" value="CATA#" maxlength="12" style="width: 120px"> </div>
<div id="lcs-go" class="execAction new-menu-option coloured-menu-option" onClick="doLCS()">
<p>Go</p>
</div>
<div id="lcs-err" class="err" style="float: left;"></div>
</div>
</div>

</div>

<div id="bottom-bar">
<a id="scale" style="display: none;">1.0x</a>
<a id="trigger-about">About</a>
<a id="trigger-team">Team</a>
<a id="trigger-terms">Terms of use</a>
<a id="trigger-privacy">Privacy Policy</a>
</div>
<div id="about" class="overlays">
<h4>About</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>Initially conceived in 2011 by Associate Professor Steven Halim, VisuAlgo aimed to facilitate a deeper understanding of data structures and algorithms for his students by providing a self-paced, interactive learning platform.</p><p>Featuring numerous advanced algorithms discussed in Dr. Steven Halim&#39;s book, &#39;Competitive Programming&#39; — co-authored with Dr. Felix Halim and Dr. Suhendry Effendy — VisuAlgo remains the exclusive platform for visualizing and animating several of these complex algorithms even after a decade.</p><p>While primarily designed for National University of Singapore (NUS) students enrolled in various data structure and algorithm courses (e.g., CS1010/equivalent, CS2040/equivalent (including IT5003), CS3230, CS3233, and CS4234), VisuAlgo also serves as a valuable resource for inquisitive minds worldwide, promoting online learning.</p><p>Initially, VisuAlgo was not designed for small touch screens like smartphones, as intricate algorithm visualizations required substantial pixel space and click-and-drag interactions. For an optimal user experience, a minimum screen resolution of 1366x768 is recommended. However, since April 2022, a mobile (lite) version of VisuAlgo has been made available, making it possible to use a subset of VisuAlgo features on smartphone screens.</p><p>VisuAlgo remains a work in progress, with the ongoing development of more complex visualizations. At present, the platform features 24 visualization modules.</p><p>Equipped with a built-in question generator and answer verifier, VisuAlgo&#39;s "online quiz system" enables students to test their knowledge of basic data structures and algorithms. Questions are randomly generated based on specific rules, and students&#39; answers are automatically graded upon submission to our grading server. As more CS instructors adopt this online quiz system worldwide, it could effectively eliminate manual basic data structure and algorithm questions from standard Computer Science exams in many universities. By assigning a small (but non-zero) weight to passing the online quiz, CS instructors can significantly enhance their students&#39; mastery of these basic concepts, as they have access to an almost unlimited number of practice questions that can be instantly verified before taking the online quiz. Each VisuAlgo visualization module now includes its own online quiz component.</p><p>VisuAlgo has been translated into three primary languages: English, Chinese, and Indonesian. Additionally, we have authored public notes about VisuAlgo in various languages, including Indonesian, Korean, Vietnamese, and Thai:</p>
<a href="https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689" target="_blank"><u>id</u></a>,
<a href="http://blog.naver.com/visualgo_nus" target="_blank"><u>kr</u></a>,
<a href="https://www.facebook.com/groups/163215593699283/permalink/824003417620494/" target="_blank"><u>vn</u></a>,
<a href="http://pantip.com/topic/32736343" target="_blank"><u>th</u></a>.
</div>
</div>
<div id="team" class="overlays">
<h4>Team</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>
<strong><span style="line-height: 150%;">Project Leader &amp; Advisor (Jul 2011-present)</span></strong><br>
<a href="https://www.comp.nus.edu.sg/~stevenha/" target="_blank">Associate Professor Steven Halim</a>, School of Computing (SoC), National University of Singapore (NUS)<br>
<a href="https://www.linkedin.com/in/felixhalim/" target="_blank">Dr Felix Halim</a>, Senior Software Engineer, Google (Mountain View)
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 1</span></strong><br>
<b>CDTL TEG 1: Jul 2011-Apr 2012</b>: Koh Zi Chun, Victor Loh Bo Huai
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 1</span></strong><br>
<b>Jul 2012-Dec 2013</b>: Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang Duy<br>
<b>Jun 2013-Apr 2014</b> <a href="https://www.rosemarietan.com/" target="_blank">Rose Marie Tan Zhao Yun</a>, Ivan Reinaldo
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 2</span></strong><br>
<b>CDTL TEG 2: May 2014-Jul 2014</b>: Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 2</span></strong><br>
<b>Jun 2014-Apr 2015</b>: Erin Teo Yi Ling, Wang Zi<br>
<b>Jun 2016-Dec 2017</b>: Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin Mudzakir<br>
<b>Aug 2021-Apr 2023</b>: Liu Guangyuan, Manas Vegi, Sha Long, Vuong Hoang Long, Ting Xiao, Lim Dewen Aloysius<br>
</p>
<p>
<strong><span style="line-height: 150%;">Undergraduate Student Researchers 3</span></strong><br>
<b>Optiver: Aug 2023-Oct 2023</b>: Bui Hong Duc, Oleh Naver, Tay Ngan Lin<br>
</p>
<p>
<strong><span style="line-height: 150%;">Final Year Project/UROP students 3</span></strong><br>
<b>Aug 2023-Apr 2024</b>: Xiong Jingya, Radian Krisno, Ng Wee Han<br>
</p>
<p>
List of translators who have contributed &ge; 100 translations can be found at <a href="https://visualgo.net/statistics">statistics</a> page.
</p>
<p>
<strong><span style="line-height: 150%;">Acknowledgements</span></strong><br>
NUS <a href="https://nus.edu.sg/cdtl" target="_blank"><u>CDTL</u></a> gave Teaching Enhancement Grant to kickstart this project.<div>For Academic Year 2023/24, a generous donation from Optiver will be used to further develop VisuAlgo.</div>
</p>
</div>
</div>
<div id="termsofuse" class="overlays">
<h4>Terms of use</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p>VisuAlgo is generously offered at no cost to the global Computer Science community. If you appreciate VisuAlgo, we kindly request that you <b>spread the word about its existence to fellow Computer Science students and instructors</b>. You can share VisuAlgo through social media platforms (e.g., Facebook, YouTube, Instagram, TikTok, Twitter, etc), course webpages, blog reviews, emails, and more.</p><p>Data Structures and Algorithms (DSA) students and instructors are welcome to use this website directly for their classes. If you capture screenshots or videos from this site, feel free to use them elsewhere, provided that you cite the URL of this website (<a href="https://visualgo.net/">https://visualgo.net</a>) and/or the list of publications below as references. However, please refrain from downloading VisuAlgo&#39;s client-side files and hosting them on your website, as this constitutes plagiarism. At this time, we do not permit others to fork this project or create VisuAlgo variants. Personal use of an offline copy of the client-side VisuAlgo is acceptable.</p><p>Please note that VisuAlgo&#39;s online quiz component has a substantial server-side element, and it is not easy to save server-side scripts and databases locally. Currently, the general public can access the online quiz system only through the &#39;training mode.&#39; The &#39;test mode&#39; offers a more controlled environment for using randomly generated questions and automatic verification in real examinations at NUS.</p><p><strong><span style="line-height: 200%;">List of Publications</span></strong></p> <p>This work has been presented at the CLI Workshop at the ICPC World Finals 2012 (Poland, Warsaw) and at the IOI Conference at IOI 2012 (Sirmione-Montichiari, Italy). You can click <a href="https://ioinformatics.org/journal/INFOL099.pdf" target="_blank">this link</a> to read our 2012 paper about this system (it was not yet called VisuAlgo back in 2012) and <a href="https://ioinformatics.org/journal/v9_2015_243_245.pdf" target="_blank">this link</a> for the short update in 2015 (to link VisuAlgo name with the previous project).</p><p><strong><span style="line-height: 200%;">Bug Reports or Request for New Features</span></strong></p> <p>VisuAlgo is not a finished project. Associate Professor Steven Halim is still actively improving VisuAlgo. If you are using VisuAlgo and spot a bug in any of our visualization page/online quiz tool or if you want to request for new features, please contact Associate Professor Steven Halim. His contact is the concatenation of his name and add gmail dot com.</p>
</div>
</div>
<div id="privacy-policy" class="overlays">
<h4>Privacy Policy</h4><span class="close-overlay">&#x2715;</span>
<div class="content">
<p><b>Version 1.2 (Updated Fri, 18 Aug 2023).</b></p><p>Since Fri, 18 Aug 2023, we no longer use Google Analytics. Thus, all cookies that we use now are solely for the operations of this website. The annoying cookie-consent popup is now turned off even for first-time visitors.</p><p>Since Fri, 07 Jun 2023, thanks to a generous donation by Optiver, anyone in the world can self-create a VisuAlgo account to store a few customization settings (e.g., layout mode, default language, playback speed, etc).</p><p>Additionally, for NUS students, by using a VisuAlgo account (a tuple of NUS official email address, student name as in the class roster, and a password that is encrypted on the server side — no other personal data is stored), you are giving a consent for your course lecturer to keep track of your e-lecture slides reading and online quiz training progresses that is needed to run the course smoothly. Your VisuAlgo account will also be needed for taking NUS official VisuAlgo Online Quizzes and thus passing your account credentials to another person to do the Online Quiz on your behalf constitutes an academic offense. Your user account will be purged after the conclusion of the course unless you choose to keep your account (OPT-IN). Access to the full VisuAlgo database (with encrypted passwords) is limited to Prof Halim himself.</p><p>For other CS lecturers worldwide who have written to Steven, a VisuAlgo account (your (non-NUS) email address, you can use any display name, and encrypted password) is needed to distinguish your online credential versus the rest of the world. Your account will have CS lecturer specific features, namely the ability to see the hidden slides that contain (interesting) answers to the questions presented in the preceding slides before the hidden slides. You can also access Hard setting of the VisuAlgo Online Quizzes. You can freely use the material to enhance your data structures and algorithm classes. Note that there can be other CS lecturer specific features in the future.<br></p><p>For anyone with VisuAlgo account, you can remove your own account by yourself should you wish to no longer be associated with VisuAlgo tool.</p>
</div>
</div>
</div>


<script src="../../code.jquery.com/jquery-3.7.0.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
<script src="../../cdn.jsdelivr.net/npm/bootstrap%405.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<script src="../../unpkg.com/d3-force-boundary%400.0.1/dist/d3-force-boundary.min.js"></script>
<script>
  $(function () {
    // overlays stuffs
    $('#trigger-about').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#about').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-team').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#team').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-terms').click(function() {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#termsofuse').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    });

    $('#trigger-privacy').click(function () {
      if ($(window).width() > 600) {
        $('#dark-overlay').fadeIn(function() {
          $('#privacy-policy').fadeIn();
        });
      }
      else
        alert('Sorry, this dialog is too big. Please load it on bigger screen');
    })

    $('.close-overlay').click(function() {
      $('.overlays').fadeOut(function() {
        $('#dark-overlay').fadeOut();
      });
    });

    $('#dark-overlay').click(function() {
      $('.overlays').fadeOut();
      $('#dark-overlay').fadeOut();
      if (typeof GeometryWidget !== 'undefined') {
        GeometryWidget.stopLoop();
      }
    });
  })
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-1566631-4"></script>
<script>
      $.ajaxSetup({
        headers: {
          'X-CSRF-TOKEN': "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H"
        }
      });

      // handles account dropdown menu
      $(function () {
        $('#language-dropdown-btn').click(function (e) {
          $('#language-dropdown-menu').css('display', 'block');
          $('#account-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function () {
          $('#language-dropdown-menu').css('display', 'none')
        })
      })

      $(function () {
        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        })
      })

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        if (retval) {
          $('#current-action').show();
          $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
          $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
          triggerRightPanels();
          isPlaying = true;
        }
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; ++i) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      const MOBILE_WIDTH = 1000;
      const matchMediaMobile = window.matchMedia(`only screen and (max-width: ${MOBILE_WIDTH}px)`);
      const matchMediaNarrow = window.matchMedia(`only screen and (max-width: 500px)`);
      function isMobile() {
        return matchMediaMobile.matches;
      }
      //To fix the issue of a narrow desktop window being asked to rotate, I am now checking for it based on the navigator.userAgent to see if its mobile or not.
      //This may change in the future if browsers decide to change the naming of userAgent for mobile browsers so may need to keep an eye on this.
      function isMobileOS() {
        return /Mobi/i.test(navigator.userAgent) && !/ipad/i.test(navigator.userAgent);
      }
      let portraitMatcher = window.matchMedia("(orientation:portrait)");
      function isPortrait() {
        return portraitMatcher.matches;
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.colour').css("color", surpriseColour);
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
        });
      });

/*
      // GA dropped 26 Jun 2023 and then made official on 18 Aug 2023
/*
      // the sunset-ed GA, commented on 26 Jun 2023, and Prof Halim doesn't bother to use anymore
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
*/

      // function setCookie(cname, cvalue, exdays) {
      //   const d = new Date();
      //   d.setTime(d.getTime() + (exdays*24*60*60*1000));
      //   let expires = "expires="+ d.toUTCString();
      //   document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
      // }

//       //         $(function() {
//           $('#gdpr-accept').click(function () {
// /*
//             // added on 26 Jun 2023
//             window.dataLayer = window.dataLayer || [];
//             function gtag(){dataLayer.push(arguments);}
//             gtag('js', new Date());

//             gtag('config', 'UA-1566631-4');
// */
// //            ga('create', 'UA-1566631-4', 'auto');
// //            ga('send', 'pageview');
//             setCookie('use_google_analytics', 'true', 365)
//             $('#gdpr-popup').hide()
//           });
//           $('#gdpr-reject').click(function () {
//             setCookie('use_google_analytics', 'false', 365)
//             $('#gdpr-popup').hide()
//           });
//         });
//       
      $('#gdpr-privacy-policy').click(function () {
        if ($(window).width() > 600) {
          $('#dark-overlay').fadeIn(function() {
            $('#privacy-policy').fadeIn();
          });
        }
        else
          alert('Sorry, this dialog is too big. Please load it on bigger screen');
      })
    </script>

<script src="../js/jquery-ui.min.js"></script>

<script src="../js/d3.min.js"></script>
<script src="../js/viz-1.0.10.js"></script>

<script src="../js/graph_library/constant.js"></script>
<script src="../js/graph_library/drawgraph.js"></script>
<script src="../js/graph_library/GraphEdgeWidget.js"></script>
<script src="../js/graph_library/GraphPolygonWidget.js"></script>
<script src="../js/graph_library/GraphVertexWidget.js"></script>
<script src="../js/graph_library/GraphWidget.js"></script>
<script src="../js/graph_library/helperObjects89db.js?refresh22aug9pm"></script> 
<script src="../js/graph_library/misc.js"></script>
<script src="../js/graph_library/properties.js"></script>
<script src="../js/graph_library/Widget.js"></script>
<script src="../js/graph_library/force_directed_library.js"></script>

<script>
      $(function () {
        let defaultPlaybackSpeed = 1;
                createPlaybackSpeedSlider(defaultPlaybackSpeed);


        $('#account-dropdown-btn').click(function (e) {
          $('#account-dropdown-menu').css('display', 'block')
          $('#language-dropdown-menu').css('display', 'none')
          e.stopPropagation()
        })
        $(document).click(function (e) {
          $('#account-dropdown-menu').css('display', 'none')
        });
        //Mobile Design Related DOM Manipulations
        if (isMobile()) {
          $("#status").css({
            "bottom": "10%",
            "height": "12%",
            "max-height": "54px"
          });
          $("#current-action").css("bottom", "22%");
          $('#status-hide').remove();
          $('#left-bar').remove();
          $('#right-bar').remove();
          $("#mode-menu").remove();
          $("#codetrace").css("z-index", 1);
          $("#bottom-bar a").hide();
          $("#bottom-bar").css("height", $("#topbar").css("height"));
          $(".speed-dropup-btn").show();
          $("#go-to-beginning").remove();
          $("#go-to-end").remove();
          $("#pause").remove();
          $("#play").remove();
          $("#previous").remove();
          $("#next").remove();

          //make progress bar longer
          $("#progress-bar").css({
            left: "30%",
            width: "60%",
            'margin-left': 0
          })
        }
      })

      let mobilePlaybackOverlayTimeout;
      $(function() {
        $("#viz").on("click", () => {
          if (isMobile()) {
            if ($("#mobile-playback-overlay").is(":hidden") && isPlaying) {
              $("#mobile-playback-overlay").fadeIn();
              hideMobilePlaybackOverlay(6000);
            } else {
              $("#mobile-playback-overlay").fadeOut();
            }
          }
        });
        $("#mobile-playback-overlay").on("click", (event) => {
          if (event.target === event.currentTarget) //to ensure clicks on the controls dont fade the overlay
            $("#mobile-playback-overlay").fadeOut();
          else
            hideMobilePlaybackOverlay(5000);
        })
      });
      function hideMobilePlaybackOverlay(timeOut) {
        if (mobilePlaybackOverlayTimeout)
          clearTimeout(mobilePlaybackOverlayTimeout);
        mobilePlaybackOverlayTimeout = setTimeout(() => {
            $("#mobile-playback-overlay").fadeOut();
        }, timeOut);
      }
      function mobilePlaybackPauseOrPlay() {
        if ($("#mobile-playback-overlay").hasClass("playing")) {
          pause();
          hideMobilePlaybackOverlay(5000);
        } else {
          play();
          hideMobilePlaybackOverlay(3000);
        }
      }
      let rewindLabelTimeout, forwardLabelTimeout;
      function mobilePlaybackRewind() {
        $("#mobile-playback-rewind-label").css("opacity", 1);
        if (rewindLabelTimeout)
          clearTimeout(rewindLabelTimeout);
        rewindLabelTimeout = setTimeout(() => {
          $("#mobile-playback-rewind-label").css("opacity", 0);
        }, 800);
        stepBackward(7);
      }
      function mobilePlaybackForward() {
        $("#mobile-playback-forward-label").css("opacity", 1);
        if (forwardLabelTimeout)
          clearTimeout(forwardLabelTimeout);
        forwardLabelTimeout = setTimeout(() => {
          $("#mobile-playback-forward-label").css("opacity", 0);
        }, 800);
        stepForward(7);
      }

      //let eLectureSessionHistory = {};
      const sectorColors = ['#05a4d0', '#f1c706', '#fa0202'];
      function setSlideTimelineColor(slideNo) {
        const sectionNo = slideNo.split('-')[0];
        $(`[slideNo="${slideNo}"]`).css('background', sectorColors[(parseInt(sectionNo) % 3)]);
      }

      let currSlideTimer = null; //global so that we can clear the timeout when required

      const lectureIds = [{"id":71,"category":"suffixarray","order":1,"top":"60px","right":"","bottom":"","left":"60px","marginLeft":"","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:32:01","updated_at":"2022-03-27 10:10:40","section":-1,"code":"","section_order":-1,"value":"1","text":"<p><b>Suffix Array<\/b> is a sorted array of all suffixes of a given (usually long) text string <b>T<\/b> of length <b>n<\/b> characters (<b>n<\/b> can be in order of hundred thousands characters).<\/p><br><p>Suffix Array is a simple, yet powerful data structure which is used, among others, in full text indices, data compression algorithms, and within the field of bioinformatics.<\/p><br><p>This data structure is very related to the <a href=\".\/suffixtree\"><u>Suffix Tree<\/u><\/a> data structure. Both data structures are usually studied together.<\/p>","title":"Suffix Array"},{"id":72,"category":"suffixarray","order":2,"top":"70px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:32:45","updated_at":"2022-03-27 14:07:56","section":-1,"code":"","section_order":-1,"value":"2","text":"<p>The visualization of Suffix Array is simply a table where each row represents a suffix and each column represents the attributes of the suffixes.<\/p><br><p>The four (basic) attributes of each row <b>i<\/b> are:<\/p><ol><li>index i, ranging from 0 to <b>n<\/b>-1,<\/li><li>SA[i]: the i-th lexicographically smallest suffix of <b>T<\/b> is the SA[i]-th suffix,<\/li><li>LCP[i]: the Longest Common Prefix between the i-th and the (i-1)-th lexicographically smallest suffixes of <b>T<\/b> is LCP[i] (we will see the application of this attribute later), and<\/li><li>Suffix T[SA[i]:] - the i-th lexicographically smallest suffix of <b>T<\/b> is from index SA[i] to the end (index <b>n<\/b>-1).<\/li><\/ol><p>Some operations may add more attributes to each row and are explained when that operations are discussed.<\/p>","title":"Suffix Array Visualization"},{"id":73,"category":"suffixarray","order":3,"top":"","right":"","bottom":"220px","left":"60px","marginLeft":"","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2017-01-12 14:33:14","updated_at":"2022-03-28 05:14:20","section":-1,"code":"","section_order":-1,"value":"3","text":"<p>All available operations on the Suffix Array are listed below.<\/p><ol><li><b>Construct Suffix Array (SA)<\/b> is the O(<b>n<\/b> log <b>n<\/b>) Suffix Array construction algorithm based on the idea by Karp, Miller, &amp; Rosenberg (1972) that sort prefixes of the suffix in increasing length (1, 2, 4, 8, ...).<\/li><li><b>Search<\/b> utilizes the fact that the suffixes in Suffix Array are sorted and call two binary searches in O(<b>m<\/b> log <b>n<\/b>) to find the first and the last occurrence(s) of pattern string <b>P<\/b> of length <b>m<\/b>.<\/li><li><b>Longest Common Prefix (LCP)<\/b> between two adjacent suffixes (excluding the first suffix) can be computed in O(<b>n<\/b>) using the Permuted LCP (PLCP) theorem. The name of this algorithm is Kasai&#39;s algorithm.<\/li><li><b>Longest Repeated Substring (LRS)<\/b> is a simple O(<b>n<\/b>) algorithm that finds the suffix with the highest LCP value.<\/li><li><b>Longest Common Substring (LCS)<\/b> is a simple O(<b>n<\/b>) algorithm that finds the suffix with the highest LCP value that comes from two different strings.<\/li><\/ol>","title":"Available Operations"},{"id":785,"category":"suffixarray","order":1,"top":"70px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-03-27 13:52:16","updated_at":"2022-03-27 14:36:03","section":73,"code":"$(\"#construct\").click().addClass(\"menu-highlighted\");\n$(\"#T\").val(\"GATAGACA$\");\nconstructSuffixArrayInstant();","section_order":3,"value":"3-1","text":"<p>In this visualization, we show the proper O(<b>n log n<\/b>) construction of Suffix Array based on the idea of Karp, Miller, &amp; Rosenberg (1972) that sort prefixes of the suffix in increasing length (1, 2, 4, 8, ...), a.k.a. the prefix doubling algorithm.<\/p><br><p>We limit the input to only accept 12 (cannot be too long due to the available drawing space &mdash; but in the real application of Suffix Tree, <b>n<\/b> can be in order of hundred thousand to million characters) UPPERCASE (we delete your lowercase input) alphabet and the special terminating symbol &#39;$&#39; characters (i.e., [A-Z$]). If you do not write a terminating symbol &#39;$&#39; at the back of your input string, we will automatically do so. If you place a &#39;$&#39; in the middle of the input string, they will be ignored. And if you enter an empty input string, we will resort to the default \"GATAGACA$\".<\/p><br><p>For convenience, we provide a few classic test case input strings usually found in Suffix Tree\/Array lectures, but to showcase the strength of this visualization tool, you are encouraged to enter any 12-characters string of your choice (ending with character &#39;$&#39;).<\/p><br><p>Note that the LCP Array column remains empty in this operation. They are to be computed separately via the Longest Common Prefix operation.<\/p>","title":"Construct Suffix Array - UI"},{"id":786,"category":"suffixarray","order":2,"top":"70px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-03-27 13:56:09","updated_at":"2022-03-28 09:03:09","section":73,"code":"$(\"#construct\").click().addClass(\"menu-highlighted\");\n$(\"#T\").val(\"GATAGACA$\");\nconstructSuffixArrayInstant();","section_order":3,"value":"3-2","text":"<p>This Prefix Doubling Algorithm runs in O(<b>log n<\/b>) iterations, where for each iteration, it compares substring T[SA[i]:SA[i+k]] with T[SA[i+k]:SA[i+2*k]], i.e., first compare two pairs of characters, then compare first two characters with the next two, then compare the first four characters with the next four, and so on.<\/p><br><p>This algorithm is best explored via visualization, see <span class=\"slide-actions\" onclick=\"doButtonAction141()\">ConstructSA(\"GATAGACA$\")<\/span> in action.<\/p><br><p>Time complexity: There are O(<b>log n<\/b>) prefix doubling iterations, and each iteration we call O(<b>n<\/b>) Radix Sort, thus it runs in O(<b>n log n<\/b>) &mdash; good enough to handle up to <b>n &le; 200K<\/b> characters in typical programming competition problems involving long strings.<\/p>","title":"The Prefix Doubling Algorithm"},{"id":783,"category":"suffixarray","order":3,"top":"70px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-03-27 13:15:21","updated_at":"2022-03-27 14:05:18","section":73,"code":"$(\"#search\").click().addClass(\"menu-highlighted\");\n$(\"#T\").val(\"GATAGACA$\");\nconstructSuffixArrayInstant();","section_order":3,"value":"3-3","text":"<p>After we construct the Suffix Array of <b>T<\/b> in O(<b>n log n<\/b>), we can search for the occurrence of Pattern string <b>T<\/b> in O(<b>m log n<\/b>) by binary searching the sorted suffixes to find the lower bound (the first occurrence of <b>P<\/b> as a prefix of any suffix of <b>T<\/b>) and the upper bound positions (thelast occurrence of <b>P<\/b> as a prefix of any suffix of <b>T<\/b>).<\/p><br><p>Time complexity: O(<b>m log n<\/b>) and it will return an interval of size <b>k<\/b> where <b>k<\/b> is the total number of occurrences.<\/p><br><p>For example, on the Suffix Array of <b>T<\/b> = \"GATAGACA$\" above, try these scenarios:<\/p><ol><li><b>P<\/b> returns a range of rows: <span class=\"slide-actions\" onclick=\"doButtonAction137()\">Search(\"GA\")<\/span>, occurrences = {4, 0}<\/li><li><b>P<\/b> returns one row only: <span class=\"slide-actions\" onclick=\"doButtonAction138()\">Search(\"CA\")<\/span>, occurrences = {2}<\/li><li><b>P<\/b> is not found in <b>T<\/b>: <span class=\"slide-actions\" onclick=\"doButtonAction139()\">Search(\"WONKA\")<\/span>, occurrences = {NIL}<\/li><\/ol>","title":"Search"},{"id":787,"category":"suffixarray","order":4,"top":"70px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-03-27 14:08:44","updated_at":"2022-03-28 09:00:13","section":73,"code":"$(\"#lcp\").addClass(\"menu-highlighted\");\n$(\"#T\").val(\"GATAGACA$\");\nconstructSuffixArrayInstant();","section_order":3,"value":"3-4","text":"<p>We can compute the Longest Common Prefix (LCP) of two adjacent suffixes (in Suffix Array order) in O(n) time using three phases of Kasai&#39;s algorithm. This algorithm takes advantage that if we have a long LCP between two adjacent suffixes (in Suffix Array order), that long LCP has lots of overlap with another suffix in positional order when its first character is removed.<\/p><br><p>The first phase: Compute the value of Phi[], where Phi[SA[i]] = SA[i-1] in O(<b>n<\/b>). This is to help the algorithm knows in $O(<b>1<\/b>) time of which Suffix is behind Suffix-SA[i] in Suffix Array order.<\/p><br><p>The second phase: Compute the PLCP[] values between a Suffix-i in positional order with Suffix-Phi[i] (the one behind Suffix-i in Suffix Array order). When we advance to the next index i+1 in positional order, we will remove the front most character of the suffix, but possibly retain lots of LCP value between Suffix-(i+1) and Suffix-Phi[(i+1)]. PLCP Theorem (not proven) shows that the LCP values can only be incremented up to <b>n<\/b> times, and thus can only be decremented at most <b>n<\/b> times too, making the overall complexity of the second phase to be also O(<b>n<\/b>).<\/p><br><p>The third phase: We compute the value of LCP[], where LCP[i] = PLCP[SA[i]] in O(<b>n<\/b>). This LCP values are the one that we use for other Suffix Array applications later.<\/p><br><p>Time complexity: Kasai&#39;s algorithm utilizes the PLCP theorem where the total number of increase (and decrease) operations of the value of the LCP is at most O(<b>n<\/b>). Thus Kasai&#39;s algorithm runs in O(<b>n<\/b>) overall. Thus, the combination of O(<b>n log n<\/b>) Suffix Array construction (via the Prefix Doubling algorithm) and the O(<b>n<\/b>) computation of LCP Array using this Kasai&#39;s algorithm is good enough to handle up to <b>n \u2264 200K<\/b> characters in typical programming competition problems involving long strings.<\/p>","title":"Longest Common Prefix"},{"id":781,"category":"suffixarray","order":5,"top":"70px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-03-27 11:58:02","updated_at":"2022-03-27 14:08:46","section":73,"code":"$(\"#lrs\").addClass(\"menu-highlighted\");\n$(\"#T\").val(\"GATAGACA$\");\nconstructSuffixArrayInstant();","section_order":3,"value":"3-5","text":"<p>After we construct the Suffix Array of <b>T<\/b> in O(<b>n log n<\/b>) and compute its LCP Array in O(<b>n<\/b>), we can find the Longest Repeated Substring (LRS) in <b>T<\/b> by simply iterating through all LCP values and reporting the largest one.<\/p><br><p>This is because each value LCP[i] the LCP Array means the longest common prefix between two lexicographically adjacent suffixes: Suffix-i and Suffix-(i-1). This corresponds to an internal vertex of the equivalent Suffix Tree of <b>T<\/b> that branches out to at least two (or more) suffixes, thus this common prefix of these adjacent suffixes are <b>repeated<\/b>.<\/p><br><p>The longest common (repeated) prefix is the required answer, which can be found in O(<b>n<\/b>) by going through the LCP array once.<\/p><br><p>Without further ado, try <span class=\"slide-actions\" onclick=\"doButtonAction135()\">LRS(\"GATAGACA$\")<\/span>. We have LRS = \"GA\".<\/p><br><p>It is possible that <b>T<\/b> contains more than one LRS, e.g., try <span class=\"slide-actions\" onclick=\"doButtonAction136()\">LRS(\"BANANABAN$\")<\/span>.<br>We have LRS = \"ANA\" (actually overlap) or \"BAN\" (without overlap).<\/p>","title":"Longest Repeated Substring (LRS)"},{"id":784,"category":"suffixarray","order":6,"top":"70px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":1,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2022-03-27 13:45:15","updated_at":"2022-03-27 14:08:46","section":73,"code":"$(\"#lcs\").click().addClass(\"menu-highlighted\");\n$(\"#T\").val(\"GATAGACA$CATA#\");\nconstructSuffixArrayInstant();","section_order":3,"value":"3-6","text":"<p>After we construct the generalized Suffix Array of the concatenation of both strings <b>T1$T2#<\/b> of length <b>n = n1+n2<\/b> in O(<b>n log n<\/b>) and compute its LCP Array in O(<b>n<\/b>), we can find the Longest Repeated Substring (LRS) in <b>T<\/b> by simply iterating through all LCP values and reporting the largest one that comes from two different strings.<\/p><br><p>Without further ado, try <span class=\"slide-actions\" onclick=\"doButtonAction140()\">LCS(\"GATAGACA$\", \"CATA#\")<\/span> on the generalized Suffix Array of string <b>T1<\/b> = \"GATAGACA$\" and <b>T2<\/b> = \"CATA#\". We have LCS = \"ATA\".<\/p>","title":"Longest Common Substring (LRS)"},{"id":734,"category":"suffixarray","order":4,"top":"70px","right":"","bottom":"","left":"50%","marginLeft":"-250px","width":"500px","showActionsPanel":0,"showStatusPanel":0,"showCodetracePanel":0,"created_at":"2020-07-24 05:15:06","updated_at":"2022-03-27 14:05:28","section":-1,"code":"","section_order":-1,"value":"4","text":"<p>You are allowed to use\/modify our implementation code for fast Suffix Array+LCP: <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch6\/sa_lcp.cpp\" target=\"_blank\"><u>sa_lcp.cpp<\/u> | <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch6\/sa_lcp.py\" target=\"_blank\"><u>py<\/u><\/a> | <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch6\/sa_lcp.java\" target=\"_blank\"><u>java<\/u><\/a> | <a href=\"https:\/\/github.com\/stevenhalim\/cpbook-code\/blob\/master\/ch6\/sa_lcp.ml\" target=\"_blank\"><u>ml<\/u><\/a> to solve programming contest problems that need it.<\/p>","title":"Implementation"}];
      const numSlides = lectureIds.length;
      var sectorJunction12Section = 0, sectorJunction12Slide = 0;
      var sectorJunction23Section = 0, sectorJunction23Slide = 0;
      var sector1Count = 0, sector2Count = 0, sector3Count = 0;
      const sectorLength = Math.floor(numSlides / 3);
      function createELectureTimelineDisplay() {
        for (let j = 0; j < numSlides; ++j) {
          const currLecture = lectureIds[j].value;
          if (currLecture.includes('-')) {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-slide" slideNo=${lectureIds[j].value}></div>`)
            );
          } else {
            $('#e-lecture-timeline').append(
              $(`<div class="e-lecture-timeline-checkpoint" slideNo=${lectureIds[j].value}></div>`)
            );
          }
        }
      }

      function setSectorJunctionInfo() {
          //setting the sector junction slide numbers
          const j12 = sectorLength !== 0 ? (sectorLength - 1): 0;
          const j23 = sectorLength !== 0 ? (2 * sectorLength - 1) : 0;

          const sectorJunction12 = lectureIds[j12].value.split('-');
          sectorJunction12Section = parseInt(sectorJunction12[0]);
          sectorJunction12Slide = sectorJunction12.length > 1 ? parseInt(sectorJunction12[1]) : sectorJunction12Slide;

          const sectorJunction23 = lectureIds[j23].value.split('-');
          sectorJunction23Section = parseInt(sectorJunction23[0]);
          sectorJunction23Slide = sectorJunction23.length > 1 ? parseInt(sectorJunction23[1]) : sectorJunction23Slide;
      }

      function runSlide(slide) { // Steven's patch on 28 Jan 2022: Properly remove slide 99, 99-1, 99-2, 99-3, integrate with the earlier slides
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 10 + "%)");
          
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 20 + "%)");
          
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 30 + "%)");
          
        }
        if (slide == '3-1') {
          $("#e-lecture").html("slide " + slide + " (" + 40 + "%)");
          $("#construct").click().addClass("menu-highlighted");
$("#T").val("GATAGACA$");
constructSuffixArrayInstant();
        }
        if (slide == '3-2') {
          $("#e-lecture").html("slide " + slide + " (" + 50 + "%)");
          $("#construct").click().addClass("menu-highlighted");
$("#T").val("GATAGACA$");
constructSuffixArrayInstant();
        }
        if (slide == '3-3') {
          $("#e-lecture").html("slide " + slide + " (" + 60 + "%)");
          $("#search").click().addClass("menu-highlighted");
$("#T").val("GATAGACA$");
constructSuffixArrayInstant();
        }
        if (slide == '3-4') {
          $("#e-lecture").html("slide " + slide + " (" + 70 + "%)");
          $("#lcp").addClass("menu-highlighted");
$("#T").val("GATAGACA$");
constructSuffixArrayInstant();
        }
        if (slide == '3-5') {
          $("#e-lecture").html("slide " + slide + " (" + 80 + "%)");
          $("#lrs").addClass("menu-highlighted");
$("#T").val("GATAGACA$");
constructSuffixArrayInstant();
        }
        if (slide == '3-6') {
          $("#e-lecture").html("slide " + slide + " (" + 90 + "%)");
          $("#lcs").click().addClass("menu-highlighted");
$("#T").val("GATAGACA$CATA#");
constructSuffixArrayInstant();
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
        }
        clearTimeout(currSlideTimer);
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };
      var slideTimeline = {};

      //reads all visited slides in the slideTimeline and gives them their sector color
      function setVisitedSlideTimelineColors() {
        for(const [sectionNo, visitedSlides] of Object.entries(slideTimeline)) {
          const visitedSlides = slideTimeline[sectionNo];
          for(const visitedSlideNo of visitedSlides) {
            setSlideTimelineColor(visitedSlideNo);
          }
        }
      }

      //only called on load if there is nothing in session
      function setTimelineForCompletedSector(sectorNum) {
        let len = sectorLength;
        switch (sectorNum) {
          case 1 : len = sectorLength; break;
          case 2 : len = 2 * sectorLength; break;
          default: len = numSlides;
        }
        let i = 0;
        switch (sectorNum) {
          case 1 : i = 0; break;
          case 2 : i = sectorLength; break;
          default: i = 2 * sectorLength;
        }
        for (; i < len; i++) {
          saveELectureTimeline(lectureIds[i].value, true);
        }
      }

      function getUserSectorHistory(callback) {
        $.ajax({
          type: 'GET',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            topic: "/suffixarray".substring(1)
          }
        }
        ).done(function (data) {
            if (data.data[0] === 1) {
              setF1SectorColor(1);
              setTimelineForCompletedSector(1);
            }
            if (data.data[1] === 1) {
              setF1SectorColor(2);
              setTimelineForCompletedSector(2);
            }
            if (data.data[2] === 1) {
              setF1SectorColor(3);
              setTimelineForCompletedSector(3);
            }
            callback();
        }).fail(function (data) {
            console.log('get user sector history failed!');
        });
      }

      function getELectureTimelineFromSession() {
        const page = "/suffixarray".substring(1);
        const timelineKey = page + '-slide-timeline';
        const storedTimeline = window.sessionStorage.getItem(timelineKey);
        if (storedTimeline) {
          slideTimeline = JSON.parse(storedTimeline);
        } else {
          return false;
        }
        let slideInfo = [];
        for (const [sectionNum, slides] of Object.entries(slideTimeline)) {
          for (const slide of slides) {
            indicateSlideCompletedUI(slide);
            slideInfo = slide.split('-');
            incrementSectorVisits(parseInt(sectionNum), slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0);
          }
        }
        return true;
      }

      async function initializeELectureTimeline() {
        setSectorJunctionInfo();
        if (!getELectureTimelineFromSession())
          getUserSectorHistory(sectorBasedModeSelection);
        else
          sectorBasedModeSelection();

        createELectureTimelineDisplay();
        setVisitedSlideTimelineColors();
      }

      function setF1SectorColor(sectorNum) {
        $(`[sectorNo="${sectorNum}"]`).css('background', sectorColors[(parseInt(sectorNum) % 3)]);
      }

      function updateSectorInDB(sectorNum) {
        $.ajax({
          type: 'POST',
          url: "https://visualgo.net/section-info",
          data: {
            _token: "dOvHLDgQSeBxDYich7PEZml1cYPqAYZaOAN2Xn3H",
            section: (sectorNum - 1),
            topic: "/suffixarray".substring(1)
          }
        }
        ).done(function (data) {
            //console.log("Saved the sector " + sectorNum + " as done " + JSON.stringify(data));
        }).fail(function (data) {
            console.log("Setting sector done failed new attempt! "+ JSON.stringify(data));
        });
      }

      //If 87.5% or more of the slides in sector are done
      function setF1SectorCompleted(sectorNum, isInitializationCall) {
        setF1SectorColor(sectorNum);
        //avoid api call on initialization
        if (!isInitializationCall) {
          updateSectorInDB(sectorNum);
          $(`[sectorNo="${sectorNum}"]`).css("animation", "green-pulse 2s 4");
          setTimeout(() => {
            $(`[sectorNo="${sectorNum}"]`).css("animation", "");
          }, 8000);
        }
      }

      function incrementSectorVisits(sectionNum, slideNumWithinSection, isInitializationCall) {
        //updating sector count
        if (sectionNum < sectorJunction12Section
          || (sectionNum === sectorJunction12Section && slideNumWithinSection <= sectorJunction12Slide)) {
          ++sector1Count;
          if (sector1Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(1, isInitializationCall);
        } else if (sectionNum < sectorJunction23Section
          || (sectionNum === sectorJunction23Section && slideNumWithinSection <= sectorJunction23Slide)) {
          ++sector2Count;
          if (sector2Count >= Math.ceil(0.875 * sectorLength))
            setF1SectorCompleted(2, isInitializationCall);
        } else {
          ++sector3Count;
          if (sector3Count >= Math.ceil(0.875 * (numSlides - 2 * sectorLength)))
            setF1SectorCompleted(3, isInitializationCall);
        }
      }

      function saveELectureTimeline(slideNo, isInitialization) {
        const slideInfo = slideNo.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        if (slideTimeline[sectionNo]) {
          if (!slideTimeline[sectionNo].includes(slideNo)) {
            slideTimeline[sectionNo].push(slideNo);
            const sectionNum = parseInt(sectionNo);
            incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
          }
        } else {
          slideTimeline[sectionNo] = [];
          slideTimeline[sectionNo].push(slideNo);
          const sectionNum = parseInt(sectionNo);
          incrementSectorVisits(sectionNum, slideNumWithinSection, isInitialization);
        }
        setSlideTimelineColor(slideNo);
        indicateSlideCompletedUI(slideNo);
      }

      function saveELectureTimelineToSession() {
        const page = "/suffixarray".substring(1);
        const timelineKey = page + '-slide-timeline';
        window.sessionStorage.setItem(timelineKey, JSON.stringify(slideTimeline));
      }

      function handleTimelineOnRunSlide(slideValue) {
        const slideInfo = slideValue.split('-');
        const sectionNo = slideInfo[0];
        const slideNumWithinSection = slideInfo.length > 1 ? parseInt(slideInfo[1]) : 0;
        //start timer only if the slide isnt already done
        if (!slideTimeline[sectionNo] || !slideTimeline[sectionNo].includes(slideValue)) {
          const slideTextLength = $('#electure-'+slideValue + " p").text().length + $('#electure-'+slideValue + " li").text().length;
          const CHARS_READ_PER_MS = 0.05; //when fast, 50 characters a second
          //setting max reading time as 10 seconds for around 500 character slide
          const minSlideReadingTime = Math.min(Math.max(2000, (slideTextLength / CHARS_READ_PER_MS) +  + (2000 * $('#electure-'+slideValue + " img").length)), 10000);
          currSlideTimer = setTimeout(() => {
            saveELectureTimeline(slideValue);
          }, minSlideReadingTime);
        }
      }

      function indicateSlideCompletedUI(slide) {
        $('#electure-'+slide).css("box-shadow", "3px 3px 8px green"); //set green shadow for completed slides
        $('#electure-'+slide + ' .electure-read-status').html("&#10004;");
        $('#electure-'+slide + ' .electure-read-status').attr("title", "Slide Completed!");
        $('#electure-'+slide + ' .electure-read-status').css("font-size", "17px");
      }

      function pushState(slideValue) {
        var url = '/en/suffixarray';
        if (typeof slideValue != 'undefined' && slideValue != null) {
          url += '?slide=' + slideValue;
                  }
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5);
        $('#overlay').show();

        $("#e-lecture-timeline").show();
        $("#e-lecture-f1map").show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
        $("#e-lecture-timeline").hide();
        $("#e-lecture-f1map").hide();
        clearTimeout(currSlideTimer);
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      function sectorBasedModeSelection() {
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        //check params are empty and then that all sectors are completed or not
        if (!Object.keys(params).length
          && sector1Count === sectorLength && sector2Count === sectorLength && sector3Count === (numSlides - 2 * sectorLength)) {
            hideOverlay();
        }
        else
          $('#mode-menu a').click();
      }

      $(function() {
        if (isMobileOS() && portraitMatcher.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').show();
          $('#widenDeviceText').hide();
          $('#topbar').css("z-index", 10001);
        } else if (matchMediaNarrow.matches) {
          $('#rotateDeviceOverlay').show();
          $('#rotateDeviceText').hide();
          $('#widenDeviceText').show();
          $('#topbar').css("z-index", 10001);
        } else {
          $('#rotateDeviceOverlay').hide();
          $('#topbar').css("z-index", "");
        }

        matchMediaNarrow.addEventListener('change', e => {
          //screws up for square device! NEED RESIZE EVENT
          if (e.matches) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').hide();
              $('#widenDeviceText').show();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        portraitMatcher.addEventListener('change', e => {
          if (e.matches && isMobileOS()) {
            if ($('#rotateDeviceOverlay').is(":hidden")) {
              $('#rotateDeviceOverlay').show();
              $('#rotateDeviceText').show();
              $('#widenDeviceText').hide();
              $('#topbar').css("z-index", 10001);
            }
          } else {
            $('#rotateDeviceOverlay').hide();
            $('#topbar').css("z-index", "");
          }
        });
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        let slide = getUrlParameter('slide');
        if (typeof slide !== undefined && slide != null) {
          cur_slide = slide;
        }
        //do all timeline and slide stuff only if specific params not provided
        if (!Object.keys(params).length || params["slide"]) {
          if (!isMobile()) {
                            $('#mode-menu a').click();
                      }
        }
        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-3-1 .electure-next').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
        $('#electure-3-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-3-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
        $('#electure-3-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
        $('#electure-3-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
        $('#electure-3-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
        $('#electure-3-4 .electure-next').click(function() {
          hidePopup();
          runSlide('3-5');
          pushState('3-5');
        });
        $('#electure-3-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
        $('#electure-3-5 .electure-next').click(function() {
          hidePopup();
          runSlide('3-6');
          pushState('3-6');
        });
        $('#electure-3-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
        $('#electure-3-6 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-5');
          pushState('3-5');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-6');
          pushState('3-6');
        });
      });

      function doButtonAction135() {
        $("#T").val("GATAGACA$");
constructSuffixArrayInstant();
doLRS();
      }
      function doButtonAction136() {
        $("#T").val("BANANABAN$");
constructSuffixArrayInstant();
doLRS();
      }
      function doButtonAction137() {
        $("#T").val("GATAGACA$");
constructSuffixArrayInstant();
$("#search_inp").val("GA")
doSearch();
      }
      function doButtonAction138() {
        $("#T").val("GATAGACA$");
constructSuffixArrayInstant();
$("#search_inp").val("CA")
doSearch();
      }
      function doButtonAction139() {
        $("#T").val("GATAGACA$");
constructSuffixArrayInstant();
$("#search_inp").val("WONKA")
doSearch();
      }
      function doButtonAction140() {
        $("#T1").val("GATAGACA$");
$("#T2").val("CATA#");
doLCS();
      }
      function doButtonAction141() {
        $("#construct").click().addClass("menu-highlighted");
$("#T").val("GATAGACA$");
constructSuffixArray();
      }

      $('.electure-print').click(() => {
        window.open(`/en/suffixarray/print`);
      });
      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url.html) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}

      // This function will be called everytime 1.0x is changed to 0.5x or vice versa
      function redraw() {}

      $(document).ready(function () {
        setTimeout(function () {
          $('#change-lang-popup').fadeOut('slow')
        }, 5000)
      })
    </script>
<script type="text/javascript">
    var extraCSS = {"lcs":"65px","lrs":"92px","lcp":"119px","search":"146px","construct":"173px"};
    var actionsIds = {"construct":{"p":"Construct Suffix Array"},"search":{"p":"Search"},"lcp":{"p":"Longest Common Prefix","onClick":"doLCP()"},"lrs":{"p":"Longest Repeated Substring","onClick":"doLRS()"},"lcs":{"p":"Longest Common Substring"}};
    var isOpens = {};
    var len = 5;
    var keys = ["construct","search","lcp","lrs","lcs"]; 
    for (i = 0; i < len; i++) {
        var actionDetails = keys[i];
        isOpens[actionDetails] = false;
    }
    function openAction(id) {
        hideThirdTiers(id);
        $("." + id).css("bottom", extraCSS[id]);
        if (!isOpens[id]) {
            $('.' + id).fadeIn('fast');
            isOpens[id] = true;
        }
    }
    function closeAction(id) {
        hideThirdTiers(id);
        if (isOpens[id]) {
            $('.' + id).fadeOut('fast');
            $('#' + id + '-err').html("");
            isOpens[id] = false;
        }
    }

    function hideEntireActionsPanel() {
        //hideAllThirdTiers();
                    closeAction('construct');
                    closeAction('search');
                    closeAction('lcp');
                    closeAction('lrs');
                    closeAction('lcs');
                hideActionsPanel();
    }

    function hideThirdTiers(tier1Action) {
        if ("parents" in actionsIds[tier1Action]) {
            for (const secondTierAction of actionsIds[tier1Action]["parents"]) {
                $('#' + secondTierAction + '-third-tier').fadeOut('fast');
            }
        }
    }

    function hideAllThirdTiers() {
        for (const tier1Action in actionsIds) {
            hideThirdTiers(tier1Action);
        }
    }

    function toggleChildExtras(tier1, selectedParentTier2) {
        hideThirdTiers(tier1);
        //this actionId must have childExtras
        var style = extraCSS[tier1];
        $("." + tier1).css("bottom", (parseInt(style.substring(0, style.length - 2)) - 27));
        //fade ins and outs are done on the ID whereas css class is set on the class
        //fade in the third tier of the selected 2nd tier parent
        $('#' + selectedParentTier2 + '-third-tier').fadeIn('fast');

        // //fade out all other third tiers of that 'action'
        // for (const parent of actions[tier1]["parents"]) {
        //     console.log("parent is " + parent + " for " + selectedParentTier2);
        //     if (parent != selectedParentTier2) {
        //         $('#' + parent + '-third-tier').fadeOut('fast');
        //     }
        // }
    }

    function setActionHeightOriginal(tier1Action) {
        $("." + tier1Action).css("bottom", extraCSS[tier1Action]);
    }

            $('#' + 'construct').click(function() {
            openAction('construct');
                                                                            closeAction('search');
                                                                closeAction('lcp');
                                                                closeAction('lrs');
                                                                closeAction('lcs');
                                    });
            $('#' + 'search').click(function() {
            openAction('search');
                                                closeAction('construct');
                                                                                            closeAction('lcp');
                                                                closeAction('lrs');
                                                                closeAction('lcs');
                                    });
            $('#' + 'lcp').click(function() {
            openAction('lcp');
                                                closeAction('construct');
                                                                closeAction('search');
                                                                                            closeAction('lrs');
                                                                closeAction('lcs');
                                    });
            $('#' + 'lrs').click(function() {
            openAction('lrs');
                                                closeAction('construct');
                                                                closeAction('search');
                                                                closeAction('lcp');
                                                                                            closeAction('lcs');
                                    });
            $('#' + 'lcs').click(function() {
            openAction('lcs');
                                                closeAction('construct');
                                                                closeAction('search');
                                                                closeAction('lcp');
                                                                closeAction('lrs');
                                                                });
    
    //important to have all the input fields in actions menu take an id containing '-input'
    $("[id*='-input']").on("keypress keydown keyup", (event) => {
        event.stopPropagation();
    });
</script>
<script type="text/javascript">
// Suffix Array Widget
// original author: Nguyen Hoang Duy, then maintained by Steven Halim

var SuffixArrayWidget = function() {
  var self = this;
  var graphWidget = new GraphWidget();

  var coord = new Array();
  var A = new Array();
  var amountVertex = 0;
  var amountEdge = 0;

  var stateList = [];
  var edgeGenerator = d3.svg.line()
  .x(function(d){return d.x;})
  .y(function(d){return d.y;})
  .interpolate("linear");
  var mousedown_node = null;
  var mousemove_coor = null;
  var edgeList = [];
  var mousedown_in_progress = false, mousemove_in_progress = false, mouseup_in_progress = false;
  var mousedown_event = null, mousemove_event = null, mouseup_event = null;
  var deleted_vertex_list = [];
  var used_alt = -1;
  var adjMatrix = [], adjList = [];
  var aborted_mousedown = false;
  var move1 = true;
  var screenHeight = window.innerHeight-100;
  var screenWidth = window.innerWidth-80;
  var firstNode = -1;
  var isCheckingPointInside = false;
  var cutPolygonState = 0;
  var isPreviousPointInsde = false;
  var isPolygon = false;
  var coord_idx = new Array();
  var coord_data = new Array();
  var suffix_table = new Array();
  var SA = new Array();
  var LCP = new Array();
  var c, r = 0;
  var tempSA = new Array(), SA = new Array(), RA = new Array(), tempRA = new Array();
  var previous_option = null;
  var left_start = 50;

  mainSvg.style("class", "unselectable");

  mainSvg.attr("height", screenHeight);
  mainSvg.attr("width", screenWidth);
  //graphWidget.addRectVertex(100, 100, "ABC", 1, true);

  function resetEverything() {
    coord = new Array();
    A = new Array();
    amountVertex = 0;
    amountEdge = 0;
    //graphWidget = new GraphWidget();
    stateList = [];
    edgeGenerator = d3.svg.line()
    .x(function(d){return d.x;})
    .y(function(d){return d.y;})
    .interpolate("linear");
    mousedown_node = null;
    mousemove_coor = null;
    edgeList = [];
    mousedown_in_progress = false, mousemove_in_progress = false, mouseup_in_progress = false;
    mousedown_event = null, mousemove_event = null, mouseup_event = null;
    deleted_vertex_list = [];
    used_alt = -1;
    adjMatrix = [];
    adjList = [];
    aborted_mousedown = false;
    firstNode = -1;
    isCheckingPointInside = false;
    cutPolygonState = 0;
    isPreviousPointInsde = false;
    isPolygon = false;
    coord_idx = new Array();
    coord_data = new Array();
    suffix_table = new Array();
    SA = new Array();
    LCP = new Array();
    tempSA = new Array(), SA = new Array(), RA = new Array(), tempRA = new Array();
    previous_option = null;
  }

  function createState(lower_bound) {
    var state = {
      "vl":{},
      "el":{},
      "status":{}
    };

    var y0 = 50;
    for (var i = 0; i < Object.size(coord_idx); ++i) {
      for (var j = 0; j < Object.size(coord_idx[0]); ++j) {
        var key = i.toString() + "_" + j.toString();
        state["vl"][key] = {};
        state["vl"][key]["state"] = VERTEX_RECT;
        if (i == 0 && j == 0) {
          state["vl"][key]["cx"] = left_start;
          state["vl"][key]["cy"] = 40 + i*30;
          state["vl"][key]["text"] = "i";
          continue;
        }
        if (j == 0) {
          state["vl"][key]["cx"] = left_start;
          state["vl"][key]["cy"] = 40 + i*30;
          state["vl"][key]["text"] = i-1;
          continue;
        }
        state["vl"][key]["cx"] = coord_idx[i][j];
        state["vl"][key]["cy"] = 40 + i*30;
        state["vl"][key]["text"] = coord_data[i][j];
      }
    }

    return state;
  }

  this.getGraphWidget = function() { return graphWidget; }

  this.getAmountVertex = function() { return amountVertex; }

  this.getAmountEdge = function() { return amountEdge; }

  function dist2P(x1, y1, x2, y2) {
    return Math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
  }

  // return the circle class id if is inside the circle
  // return -1 if free
  function isUsed(x,y) {
    var i, j;
    for (i = 0; i < amountVertex; i++) {
      if (dist2P(x, y, coord[i][0], coord[i][1]) <= 35)
       return i;
   }
   return -1;
  }

  function colorNode(cs, row_id, column_id) {
    cs["vl"][row_id.toString() + "_" + column_id.toString()]["state"] = VERTEX_HIGHLIGHTED_RECT;
  }

  function colorColumn(cs, column_id) {
    for (var i = 0; i < Object.size(coord_idx); i++)
      cs["vl"][i.toString() + "_" + column_id.toString()]["state"] = VERTEX_HIGHLIGHTED_RECT;
  }

  function colorRow(cs, row_id) {
    for (var i = 0; i < Object.size(coord_idx[0]); i++)
      cs["vl"][row_id.toString() + "_" + i.toString()]["state"] = VERTEX_HIGHLIGHTED_RECT;
  }

  function colorResultRow(cs, row_id) {
    for (var i = 0; i < Object.size(coord_idx[0]); i++)
      cs["vl"][row_id.toString() + "_" + i.toString()]["state"] = VERTEX_RESULT_RECT;
  }

  // Note: data.size must = no of rows
  function addColumn(data) {
    for (var i = 0; i < Object.size(data); ++i) {
      var tmp = new Array();
      tmp.push(data[i]);
      appendRow(i, tmp);
    }
  }

  function appendRow(row_id, data) {
    var cur_y = 50 + 30*row_id;
    var sz = Object.size(coord_idx[row_id]);
    for (var i = 1; i <= Object.size(data); ++i) {
      coord_idx[row_id][sz] = coord_idx[row_id][sz-1] + 150;
      coord_data[row_id][sz] = data[i-1];
      graphWidget.addRectVertex(coord_idx[row_id][sz], cur_y, data[i-1], row_id.toString() + "_" + sz.toString(), true, "rect_long");
      sz++;
    }
  }

  function addRow(data) {
    var sz = Object.size(coord_idx);
    coord_idx[sz] = new Array();
    coord_idx[sz][0] = left_start;
    coord_data[sz] = new Array();
    var cur_y = 40 + 30*sz;
    if (sz == 0)
      graphWidget.addRectVertex(left_start, cur_y, "i",  sz.toString() + "_0", true, "rect");
    else
      graphWidget.addRectVertex(left_start, cur_y, (sz-1).toString(),  sz.toString() + "_0", true, "rect");
    for (var i = 1; i <= Object.size(data); ++i) {
      coord_idx[sz][i] = coord_idx[sz][i-1] + 140; // approximation of column width below...
      coord_data[sz][i] = data[i-1];
      if (i <= 3 || i == 5 || i == 6) coord_idx[sz][i] = coord_idx[sz][i-1] + 70; // i == 1 (i), i == 2 (SA[i]), i == 3 (LCP[i]), i == 5 (owner/RA1/Phi[i]), i == 6 (RA2/PLCP[i])
      // i == 4 (Suffix T[SA[i]:])
      // i == 7 (Positional Suffix)
      graphWidget.addRectVertex(coord_idx[sz][i], cur_y, data[i-1], sz.toString() + "_" + i.toString(), true, "rect_long");
    }
  }

  this.clrscr = function() {
    clearScreen();
  }

  function clearScreen() {
    var i, j;

    for (i = 0; i <= 500; ++i) {
      try {
        graphWidget.removeEdge(i);
      } catch(err) {}
    }

    for (i = 0; i <= 500; ++i) {
      try {
        graphWidget.removeVertex(i);
      } catch(err) {}
    }

    for (i = 0; i <= 30; ++i)
      for (j = 0; j <= 6; ++j)
        mainSvg.selectAll(".v" + i.toString() + "_" + j.toString()).remove();

    try {
      graphWidget.removeVertex(0);
    } catch (err) {}

    mainSvg.selectAll(".edgelabel").remove();
    mainSvg.selectAll("text").remove();
    amountVertex = 0;
    resetEverything();
  }

  function stringCmp(a, b) {
    for (var i = 0; i < Math.min(a.length, b.length); i++) {
      if (a[i] < b[i]) return -1;
      else if (a[i] > b[i]) return 1;
    }
    if (a.length == b.length) return 0;
    else if (a.length > b.length) return 1;
    return -1;
  }

  function countingSort(T, k) {
    var SAText = T;
    var n = SAText.length;
    var i, sum, maxi = Math.max(300, n); // up to 255 ASCII chars or length of n
    c = new Array();
    for (var i = 0; i < 300; i++) c.push(0);
    for (i = 0; i < n; i++) // count the frequency of each rank
      c[i+k < n ? RA[i+k] : 0]++;
    sum = 0;
    for (i = 0; i < maxi; i++) {
      var t = c[i]; c[i] = sum; sum += t;
    }
    for (i = 0; i < n; i++) // shuffle the suffix array if necessary
      tempSA[c[SA[i]+k < n ? RA[SA[i]+k] : 0]++] = SA[i];
    for (i = 0; i < n; i++) // update the suffix array SA
      SA[i] = tempSA[i];
  }

  this.constructSA = function(T) { // this version can go up to 100000 characters
    clearScreen();
    populatePseudocode(0);
    var i, k, r;
    var cs = createState();
    var stateList = new Array();
    var n = T.length;

    var data = ["SA[i]", "LCP[i]", "Suffix", "RA[SA[i]]", "RA[SA[i]+k]", "tempRA[SA[i]]"];
    addRow(data);
    for (i = 0; i < n; ++i) {
      RA.push(T.charCodeAt(i));
      SA.push(i);
      var tmp = new Array();
      tmp.push('-');
      tmp.push('-');
      tmp.push(T.substring(i));
      tmp.push('-'); // T.charCodeAt(i));
      tmp.push('-'); // i+1 < n ? T.charCodeAt(i+1) : 0);
      tmp.push('-');
      addRow(tmp);
      tempRA.push(0);
    }

/*
// dropped on 28 March 2022, I think it won't happen? I safeguard...
    if (T.charAt(n-1) != '$') {
      cs = createState();
      cs["status"] = 'WARNING... T does not end with a special symbol &#39;$&#39;<br>The result of this algorithm is not guaranteed';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
*/

    cs = createState();
    cs["status"] = 'Initialize the table';
    cs["lineNo"] = 1;
    stateList.push(cs);

    for (i = 0; i < n; ++i)
      coord_data[i+1][1] = i;
    cs = createState();
    cs["status"] = 'Initialize SA[] (2nd column) with [0..n-1]<br>These are the initial positional suffixes'; // Initialize SA[] with [0..n-1]<br>Initialize RA[] with ASCII values of the characters in T (k = 1)';
    cs["lineNo"] = 1;
    colorColumn(cs, 1);
    colorColumn(cs, 3);
    stateList.push(cs);

    k = 1;
    for (i = 0; i < n; ++i) {
      coord_data[i+1][3] = "[" + T.substring(i, i+k) + "] vs [" + T.substring(i+k, i+2*k) + "] " + T.substring(i+2*k);
      coord_data[i+1][4] = T.charCodeAt(i);
      coord_data[i+1][5] = (i+1 < n) ? T.charCodeAt(i+1) : 0;
    }
    cs = createState();
    cs["status"] = 'Initialize RA[] with ASCII values of the characters in T for the first phase of sorting ranking pairs of first two chars'; // Initialize SA[] with [0..n-1]<br>Initialize RA[] with ASCII values of the characters in T (k = 1)';
    cs["lineNo"] = 1;
    colorColumn(cs, 4);
    colorColumn(cs, 5);
    stateList.push(cs);

    for (k = 1; k < n; k <<= 1) { // repeat sorting process log n times
      var SA_old = deepCopy(SA);
      countingSort(T, k); // actually radix sort: sort based on the second item
      countingSort(T, 0); // then (stable) sort based on the first item
      for (i = 0; i < n; ++i) {
        coord_data[i+1][1] = SA[i];
        coord_data[i+1][3] = "[" + T.substring(SA[i], SA[i]+k) + "] vs [" + T.substring(SA[i]+k, SA[i]+2*k) + "] " + T.substring(SA[i]+2*k);
        // coord_data[i+1][3] = T.substring(SA[i]);
        if (k == 1) {
          coord_data[i+1][4] = T.charCodeAt(SA[i]);
          if (SA[i] < n-1) coord_data[i+1][5] = T.charCodeAt([SA[i]+1]);
          else             coord_data[i+1][5] = 0;
        }
        else {
          coord_data[i+1][4] = RA[SA[i]];
          coord_data[i+1][5] = RA[SA[i]+k];
          if (SA[i]+k >=n) coord_data[i+1][5] = 0;
          coord_data[i+1][6] = RA[SA[i]];
        }
      }

      cs = createState();
      cs["lineNo"] = [2, 3];
      cs["status"] = "k = " + k + ", ";
      if (k == 1) {
        cs["status"] += 'Radix sort based on ranking pair of 1st and 2nd chars<br>Changed rows are highlighted';
      } else if (k == 2) {
        cs["status"] += 'Radix sort based on ranking pair of 1st and 2nd&nbsp;pairs<br>Changed rows are highlighted';
      } else if (k == 4) {
        cs["status"] += 'Radix sort based on ranking pair of 1st and 2nd&nbsp;quads<br>Changed rows are highlighted';
      } else {
        cs["status"] += 'Radix sort based on ranking pair (you know the drill)<br>Changed rows are highlighted';
      }

      for (i = 0; i < Object.size(SA_old); ++i)
        if (SA_old[i] != SA[i])
          colorRow(cs, i+1);
      stateList.push(cs);

      cs = createState();
      colorRow(cs, 1);
      cs["status"] = 'k = ' + k + '<br>Now performing re-ranking process starting from rank 0';
      cs["lineNo"] = 4;
      stateList.push(cs);

      tempRA[SA[0]] = r = 0; // re-ranking; start from rank r = 0
      coord_data[0+1][6] = r;
      for (i = 1; i < n; ++i) { // compare adjacent suffices
        cs = createState();
        colorRow(cs, i+1);
        if (RA[SA[i]] == RA[SA[i-1]] && RA[SA[i]+k] == RA[SA[i-1]+k]) { // same rank
          coord_data[i+1][6] = r;
          tempRA[SA[i]] = r
          cs["status"] = "k = " + k + ', same ranking pair as previous suffix<br>Keep rank at r = {r}'.replace("{r}", r);
          cs["lineNo"] = 5;
        }
        else {
          coord_data[i+1][6] = ++r;
          tempRA[SA[i]] = r;
          cs["lineNo"] = [5, 6];
          cs["status"] = "k = " + k + ', different ranking pair as previous suffix<br>Increase rank to r = {r}'.replace("{r}", r);
        }
        stateList.push(cs);
      }

      for (i = 0; i < n; ++i) { // update the rank array RA
        RA[i] = tempRA[i];
        coord_data[i+1][4] = coord_data[i+1][6];
      }
      for (i = 0; i < n; ++i) {
        coord_data[i+1][3] = "[" + T.substring(SA[i], SA[i]+2*k) + "] vs [" + T.substring(SA[i]+2*k, SA[i]+4*k) + "] " + T.substring(SA[i]+4*k);
        coord_data[i+1][4] = RA[SA[i]];
        coord_data[i+1][5] = SA[i]+k*2 < n ? RA[SA[i]+k*2] : 0;
      }

      cs = createState();
      cs["status"] = 'Updating RA[] (5th column) from tempRA[] (7th column)<br>Notice that both RA[SA[i]] and RA[SA[i]+k] values are updated<br>';
      cs["lineNo"] = 7;
      colorColumn(cs, 4);
      colorColumn(cs, 5);
      colorColumn(cs, 6);
      stateList.push(cs);

      if (RA[SA[n-1]] == n-1) {
        for (i = 0; i < n; ++i) // restore
          coord_data[i+1][3] = T.substring(SA[i]);
        cs = createState();
        cs["status"] = 'RA[SA[n-1]] == n-1 so we are done<div>Run Longest Common Prefix to compute the LCP column</div>';
        cs["lineNo"] = 7;
        colorNode(cs, n, 0);
        colorNode(cs, n, 1);
        colorNode(cs, n, 4);
        stateList.push(cs);
        break;
      }
    }

    graphWidget.startAnimation(stateList);
    return true;
  }

  function buildSA(T) {
    suffix_table = new Array();

    SA = new Array();
    for (var i = 0; i < T.length; ++i) {
      suffix_table.push(T.substring(i));
      SA.push(i);
    }

    for (var i = 0; i < T.length-1; ++i)
      for (var j = i+1; j < T.length; ++j) {
        if (suffix_table[i] > suffix_table[j]) {
          var tmp = suffix_table[i];
          suffix_table[i] = suffix_table[j];
          suffix_table[j] = tmp;
          tmp = SA[i];
          SA[i] = SA[j];
          SA[j] = tmp;
        }
      }
  }

  this.constructSA_bad = function(T) { // input size is small anyway
    clearScreen();
    var data = ["SA[i]", "LCP[i]", "Suffix T[SA[i]:]"];
    addRow(data);
    buildSA(T);

    // LCP slow
    LCP = new Array();
    LCP.push(0);
    for (var i = 1; i < Object.size(SA); ++i) {
      var L = 0;
      while (T[SA[i]+L] == T[SA[i-1]+L]) ++L;
      LCP.push(L);
    }

    for (var i = 0; i < Object.size(SA); ++i) {
      var tmp = new Array();
      tmp.push(SA[i]); tmp.push(LCP[i]); tmp.push(suffix_table[i]);
      addRow(tmp);
    }
  }

  function strncmp(str1, str2, n) {
    str1 = str1.substring(0, n);
    str2 = str2.substring(0, n);
    return ((str1 == str2) ? 0 :((str1 > str2) ? 1 : -1));
  }

  this.doSearch = function(callback) {
    var P = document.getElementById("search_inp").value;
    var T = currentT; // document.getElementById("T").value;
    populatePseudocode(1);
    this.constructSA_bad(T);
    var stateList = new Array();

    // find lower bound
    var cs = createState();
    cs["status"] = 'Find the lower bound<br>The first occurrence of P = &#39;{P}&#39; in T'.replace("{P}", P);
    cs["lineNo"] = 1;
    stateList.push(cs);
    var lo = 0, hi = T.length-1, mid = lo;
    while (lo < hi) {
      mid =  Math.floor((lo+hi) / 2);
      cs = createState();
      cs["status"] = 'Low = {lo} and High = {hi}<br>So Mid = ({lo}+{hi}) / 2 = {mid}'
                      .replace("{lo}", lo)
                      .replace("{hi}", hi)
                      .replace("{lo}", lo)
                      .replace("{hi}", hi)
                      .replace("{mid}", mid);
      cs["lineNo"] = 1;
      colorRow(cs, lo+1); colorRow(cs, hi+1); colorRow(cs, mid+1);
      stateList.push(cs);
      cs = createState();
      colorRow(cs, lo+1); colorRow(cs, hi+1); colorRow(cs, mid+1);
      var res = strncmp(T.substring(SA[mid]), P, P.length);
      if (res >= 0) {
        hi = mid;
        cs["status"] = 'P = &#39;{P}&#39; &lt;= middle Suffix-{Smid} = &#39;{substring}&#39;<br>Adjusting High = Mid = {hi}'
                        .replace("{P}", P)
                        .replace("{Smid}", SA[mid])
                        .replace("{substring}", T.substring(SA[mid]))
                        .replace("{hi}", hi);
      }
      else {
        lo = mid+1;
        cs["status"] = 'P = &#39;{P}&#39; &gt; middle Suffix-{Smid} = &#39;{substring}&#39;<br>Adjusting Low = Mid+1 = {lo}'
                        .replace("{P}", P)
                        .replace("{Smid}", SA[mid])
                        .replace("{substring}", T.substring(SA[mid]))
                        .replace("{lo}", lo);
      }
      cs["lineNo"] = 1;
      stateList.push(cs);
    }

    if (strncmp(T.substring(SA[lo]), P, P.length) != 0) {
      cs = createState();
      colorRow(cs, mid+1);
      cs["status"] = 'P = &#39;{P}&#39; is not found in the Suffix-{Smid} = &#39;{substring}&#39;<div>Thus P is not in T = &#39;{T}&#39;. Exiting...</div>'
                     .replace("{Smid}", SA[mid])
                     .replace("{substring}", T.substring(SA[mid]))
                     .replace("{P}", P)
                     .replace("{T}", T);
      cs["lineNo"] = 3;
      stateList.push(cs);
      graphWidget.startAnimation(stateList, callback);
      return true;
    }

    var lower_bound = lo;
    for (j = 0; j < T.length; ++j) // restore first
      coord_data[j+1][3] = T.substring(SA[j]);
    j = lower_bound+1;
    coord_data[j][3] = "[" + T.substring(SA[j-1], SA[j-1]+P.length) + "] " + T.substring(SA[j-1]+P.length);

    cs = createState();
    cs["status"] = 'The lower bound (Suffix-{SA_lo} = &#39;{substring}&#39;) is highlighted'
                    .replace("{SA_lo}", SA[lo])
                    .replace("{substring}", T.substring(SA[lo]));
    cs["lineNo"] = 1;
    colorResultRow(cs, lower_bound+1);
    stateList.push(cs);

    for (j = 0; j < T.length; ++j) // restore first
      coord_data[j+1][3] = T.substring(SA[j]);
    cs = createState();
    cs["status"] = 'Find the upper bound<br>The last occurrence of P = &#39;{P}&#39; in T'.replace("{P}", P);
    cs["lineNo"] = 2;
    stateList.push(cs);

    // find upper bound
    var lo = 0, hi = T.length-1, mid = lo;
    while (lo < hi) {
      mid =  Math.floor((lo+hi) / 2);
      cs = createState();
      cs["status"] = 'Low = {lo} and High = {hi}<br>So Mid = ({lo}+{hi}) / 2 = {mid}'
                      .replace("{lo}", lo)
                      .replace("{hi}", hi)
                      .replace("{lo}", lo)
                      .replace("{hi}", hi)
                      .replace("{mid}", mid);
      cs["lineNo"] = 2;
      colorRow(cs, lo+1); colorRow(cs, hi+1); colorRow(cs, mid+1);
      stateList.push(cs);
      cs = createState();
      colorRow(cs, lo+1); colorRow(cs, hi+1); colorRow(cs, mid+1);
      var res = strncmp(T.substring(SA[mid]), P, P.length);
      if (res > 0) {
        hi = mid;
        cs["status"] = 'P = &#39;{P}&#39; &lt; middle Suffix-{Smid} = &#39;{substring}&#39;<br>Adjusting High = Mid = {hi}'
                        .replace("{P}", P)
                        .replace("{substring}", T.substring(SA[mid]))
                        .replace("{Smid}", SA[mid])
                        .replace("{hi}", hi);
      }
      else {
        lo = mid+1;
        cs["status"] = 'P = &#39;{P}&#39; &gt;= middle Suffix-{Smid} = &#39;{substring}&#39;<br>Adjusting Low = Mid+1 = {lo}'
                        .replace("{P}", P)
                        .replace("{substring}", T.substring(SA[mid]))
                        .replace("{Smid}", SA[mid])
                        .replace("{lo}", lo);
      }
      cs["lineNo"] = 2;
      stateList.push(cs);
    }
    if (strncmp(T.substring(SA[hi]), P, P.length) != 0) {
      var cs = createState();
      colorRow(cs, hi+1);
      cs["status"] = "P = '{P}' >= Suffix-{Shi} = '{substring}'<br>Reducing hi = {hi} by 1 to {himin1}"
                      .replace("{P}", P)
                      .replace("{Shi}", SA[hi])
                      .replace("{substring}", T.substring(SA[hi]))
                      .replace("{hi}", hi)
                      .replace("{himin1}", hi-1);
      cs["lineNo"] = 2;
      stateList.push(cs);
      --hi;
    }
    var h_bound = hi;

    for (j = 0; j < T.length; ++j) // restore first
      coord_data[j+1][3] = T.substring(SA[j]);
    j = h_bound+1;
    coord_data[j][3] = "[" + T.substring(SA[j-1], SA[j-1]+P.length) + "] " + T.substring(SA[j-1]+P.length);
    var cs = createState();
    colorResultRow(cs, h_bound+1);
    cs["status"] = 'The upper bound (Suffix-{SA_hi} = &#39;{substring}&#39;) is highlighted'
                    .replace("{SA_hi}", SA[hi])
                    .replace("{substring}", T.substring(SA[hi]));
    cs["lineNo"] = 2;
    stateList.push(cs);

    for (j = 0; j < T.length; ++j) // restore first
      coord_data[j+1][3] = T.substring(SA[j]);
    for (var j = lower_bound+1; j < h_bound+2; ++j) {
      coord_data[j][3] = "[" + T.substring(SA[j-1], SA[j-1]+P.length) + "] " + T.substring(SA[j-1]+P.length);
    }

    var cs = createState();
    cs["status"] = 'Search P = &#39;{P}&#39; in T = &#39;{T}&#39; is done<br>The results are highlighted from lower bound to upper bound'
                   .replace("{P}", P)
                   .replace("{T}", T);
    cs["lineNo"] = 3;
    for (var i = lower_bound+1; i < h_bound+2; ++i)
      colorResultRow(cs, i);
    stateList.push(cs);

    graphWidget.startAnimation(stateList, callback);
    return true;
  }

  this.doLCP = function(callback) { // it is indeed Kasai's algorithm for computing LCP
    var T = currentT; // document.getElementById("T").value;
    clearScreen();
    populatePseudocode(2);
    var i, k, r;
    var cs = createState();
    var stateList = new Array();
    var n = T.length;

    // var data = ["SA[i]", "Phi[i]", "PLCP[i]", "Suffix", "LCP[i]"];
    var data = ["SA[i]", "LCP[i]", "Sorted Suffix T[SA[i]:]", "Phi[i]", "PLCP[i]", "Positional Suffix T[i]"];
    addRow(data);
    buildSA(T);

    for (i = 0; i < n; ++i) {
      var tmp = new Array();
      tmp.push(SA[i]);
      tmp.push('-');
      tmp.push(T.substring(SA[i]));
      tmp.push('-');
      tmp.push('-');
      tmp.push(T.substring(i));
      addRow(tmp);
    }

    cs = createState();
    cs["status"] = 'Initialize the table';
    cs["lineNo"] = 1;
    stateList.push(cs);

    for (i = 0; i < n; ++i)
      coord_data[i+1][2] = coord_data[i+1][5] = 0;
    cs = createState();
    cs["status"] = 'Initialize LCP[] (3rd column) and PLCP (6th column) to all zeroes';
    cs["lineNo"] = 1;
    colorColumn(cs, 2);
    colorColumn(cs, 5);
    stateList.push(cs);

    var Phi = new Array();
    for (i = 0; i < n; ++i) Phi.push(0);
    Phi[SA[0]] = -1;
    for (i = 1; i < n; ++i) Phi[SA[i]] = SA[i-1];

    for (i = 0; i < n; ++i)
      coord_data[i+1][4] = 0;
    coord_data[SA[0]+1][4] = Phi[SA[0]]; // -1
    cs = createState();
    cs["status"] = 'Initialize Phi[] (5th column) to all zeroes except Phi[SA[0]] (the last row) to -1';
    cs["lineNo"] = 1;
    colorColumn(cs, 2);
    colorColumn(cs, 4);
    colorColumn(cs, 5);
    stateList.push(cs);

    for (i = 1; i < n; ++i) {
      coord_data[SA[i]+1][4] = Phi[SA[i]];
      cs = createState();
      cs["status"] = 'Updating Phi[{SA_i}] = {SA_i-1}'
                      .replace("{SA_i}", SA[i])
                      .replace("{SA_i-1}", SA[i-1]);
      cs["lineNo"] = 2;
      colorNode(cs, i, 1);
      colorNode(cs, i+1, 1);
      colorNode(cs, SA[i]+1, 4);
      stateList.push(cs);
    }

    var L = 0, PLCP = new Array();
    for (i = 0; i < n; ++i) {
      if (Phi[i] == -1) {
        PLCP[i] = 0;
        continue;
      }
      while (T[i+L] == T[Phi[i]+L]) ++L;
      PLCP[i] = L;
      L = L > 1 ? L-1 : 0;
    }
    for (i = 0; i < n; ++i) {
      coord_data[i+1][5] = PLCP[i];
      for (j = 0; j < n; ++j) { // restore first
        coord_data[j+1][6] = T.substring(j);
      }
      if (Phi[i] != -1) {
        coord_data[i+1][6] = "[" + T.substring(i, i+PLCP[i]) + "] " + T.substring(i+PLCP[i]);
        coord_data[Phi[i]+1][6] = "[" + T.substring(Phi[i], Phi[i]+PLCP[i]) + "] " + T.substring(Phi[i]+PLCP[i]);
      }
      cs = createState();
      colorNode(cs, i+1, 5); // Phi[i]
      if (Phi[i] != -1) {
        colorNode(cs, i+1, 6); // T[i]
        colorNode(cs, Phi[i]+1, 6); // T[Phi[i]]
      }
      cs["status"] = 'Updating PLCP[{i}]. L={PLCP_i} because Suffix-{i} = &#39;{Si}&#39; and Suffix-{phi_i} = &#39;{Sphii}&#39; has {PLCP_i} character(s) in common'
                      .replace("{i}", i)
                      .replace("{PLCP_i}", PLCP[i])
                      .replace("{i}", i)
                      .replace("{Si}", T.substring(i))
                      .replace("{phi_i}", Phi[i])
                      .replace("{Sphii}", T.substring(Phi[i]))
                      .replace("{PLCP_i}", PLCP[i]);
      cs["lineNo"] = [4,5,6];
      stateList.push(cs);
    }

    for (i = 0; i < n; ++i) {
      for (j = 0; j < n; ++j) { // restore first
        coord_data[j+1][3] = T.substring(SA[j]);
      }
      coord_data[i+1][3] = "[" + T.substring(SA[i], SA[i]+PLCP[SA[i]]) + "] " + T.substring(SA[i]+PLCP[SA[i]]);
      if (i > 0)
        coord_data[i][3] = "[" + T.substring(SA[i-1], SA[i-1]+PLCP[SA[i]]) + "] " + T.substring(SA[i-1]+PLCP[SA[i]]);
      coord_data[i+1][2] = PLCP[SA[i]];
      cs = createState();
      colorNode(cs, i+1, 3);
      if (i > 0)
        colorNode(cs, i, 3);
      colorNode(cs, i+1, 2);
      colorNode(cs, SA[i]+1, 5);
      cs["status"] = 'Updating LCP[{i}] = {PLCP_SA_i}'
                      .replace("{i}", i)
                      .replace("{PLCP_SA_i}", PLCP[SA[i]]);
      cs["lineNo"] = 7;
      stateList.push(cs);
    }

    for (j = 0; j < n; ++j) { // restore first
      coord_data[j+1][3] = T.substring(SA[j]);
    }
    cs = createState();
    cs["status"] = 'Finish, LCP[] (column 3) is computed in O(n) time'
    colorColumn(cs, 2);
    stateList.push(cs);

    graphWidget.startAnimation(stateList, callback);
    return true;
  }

  this.doLRS = function(callback) {
    populatePseudocode(3);
    var T = currentT; // always go back to this currentT
    this.constructSA_bad(T);

    var cs = createState();
    var stateList = new Array();
    cs["status"] = 'Simple O(<b>n</b>) check over the LCP column (from row 1)<br>ans = 0, current best suffix(es) will be colored green';
    cs["lineNo"] = 1;
    stateList.push(cs);

    var max = 0, save = new Array();
    for (var i = 1; i < Object.size(LCP); ++i) {
      if (LCP[i] > max) {
        save = new Array();
        save.push(i);
      }
      else if (LCP[i] == max)
        save.push(i);

      for (j = 0; j < Object.size(LCP); ++j) // restore first
        coord_data[j+1][3] = T.substring(SA[j]);
      for (var j = 0; j < Object.size(save); ++j) {
        coord_data[save[j]+1][3] = "[" + T.substring(SA[save[j]], SA[save[j]]+LCP[save[j]]) + "] " + T.substring(SA[save[j]]+LCP[save[j]]);
      }

      var cs = createState();
      colorRow(cs, i+1);
      cs["status"] = "LCP[{i}] = {LCP_i}, Suffix-{i} = '{Si}', Suffix-{i-1} = '{Si-1}'<br>starts with the same {LCP_i} character(s)"
                     .replace('{i}', i)
                     .replace('{LCP_i}', LCP[i])
                     .replace('{i}', i)
                     .replace('{Si}', T.substring(SA[i]))
                     .replace('{i-1}', i-1)
                     .replace('{Si-1}', T.substring(SA[i-1]))
                     .replace('{LCP_i}', LCP[i]);
      cs["lineNo"] = 2;
      for (var j = 0; j < Object.size(save); j++)
        colorResultRow(cs, save[j]+1);
      stateList.push(cs);

      cs = createState();
      colorRow(cs, i+1);
      if (LCP[i] == 0) {
        //cs["status"] = "LCP[" + i + "] = 0 (nothing in common; max = {max} will not change)<br>Just continue";
        cs["status"] = 'LCP[{i}] = 0 (nothing in common; max = {max} will not change)<br>Just continue'
                        .replace('{i}', i)
                        .replace('{max}', max);
        cs["lineNo"] = 3;

      }
      else if (LCP[i] > max) {
        //cs["status"] = "LCP[" + i + "] = " + LCP[i] + " is bigger than max = " + max + "<br>Update max = " + LCP[i] + " and set result array to only has this Suffix-i";
        cs["status"] = 'LCP[{i}] = {LCP_i} is bigger than max = {max}, so update max to {LCP_i}<div>and set the result array to only has this Suffix-{i}</div>'
                        .replace('{i}', i)
                        .replace('{LCP_i}', LCP[i])
                        .replace('{max}', max)
                        .replace('{LCP_i}', LCP[i])
                        .replace('{i}', i);
        max = LCP[i];
        //save = new Array();
        //save.push(i);
        cs["lineNo"] = [3, 4];
      }
      else if (LCP[i] == max) {
        //cs["status"] = "LCP[" + i + "] = " + LCP[i] + " is equal to max = " + max + "<br>Keep max but add this Suffix-i to result array";
        cs["status"] = 'LCP[{i}] = {LCP_i} is equal to max = {max}<br>Keep max but add this Suffix-{i} to the result array'
                        .replace('{i}', i)
                        .replace('{LCP_i}', LCP[i])
                        .replace('{max}', max)
                        .replace('{i}', i);
        //save.push(i);
        cs["lineNo"] = [3, 4];

      }
      else {
        cs["status"] = 'LCP[{i}] = {LCP_i} is smaller than max = {max}<br>Just continue'
                        .replace('{i}', i)
                        .replace('{LCP_i}', LCP[i])
                        .replace('{max}', max);
        cs["lineNo"] = 3;
        colorRow(cs, i+1);
      }
      for (var j = 0; j < Object.size(save); ++j) {
        colorResultRow(cs, save[j]+1);
        coord_data[save[j]+1][3] = "[" + T.substring(SA[save[j]], SA[save[j]]+LCP[save[j]]) + "] " + T.substring(SA[save[j]]+LCP[save[j]]);
      }
      stateList.push(cs);
    }

    cs = createState();
    cs["lineNo"] = 5;
    if (max > 0) {
      var ans = ""; // T.substring(SA[save[0]], SA[save[0]]+LCP[save[0]]);
      //cs["status"] = "The Longest Repeated Substring of '{T}'<br>is '{ans}' (length {LCP[save[0]]}), the prefix of the green-colored rows";
      for (var j = 0; j < Object.size(save); ++j) {
        colorResultRow(cs, save[j]+1);
        ans += "\'" + T.substring(SA[save[j]], SA[save[j]]+LCP[save[j]]) + "\', ";
      }
      cs["status"] = 'The LRS of &#39;{T}&#39; has length {length}, the prefix of the green-colored rows, e.g., {ans}.'
                      .replace('{T}', T)
                      .replace('{length}', LCP[save[0]])
                      .replace('{ans}', ans.slice(0, -2)); // remove the last ', '
    }
    else
      cs["status"] = 'The LRS of &#39;{T}&#39; is a &#39;<i>null string&#39;</i>&nbsp;(of length 0) as there is no repeated character at all'.replace('{T}', T);
    stateList.push(cs);

    graphWidget.startAnimation(stateList, callback);
    return true;
  }

  this.doLCS = function(callback) {
    var owner = new Array();
    populatePseudocode(4);
    var s1 = document.getElementById("s1").value, s2 = document.getElementById("s2").value;
    var T = s1+s2;
    this.constructSA_bad(T);
    owner.push("Owner");
    for (var i = 0; i < Object.size(SA); i++) {
      var tmp = T.substring(SA[i]);
      if (tmp.indexOf("$") == -1)
        owner.push(2);
      else
        owner.push(1);
    }
    addColumn(owner);
    owner = owner.splice(1);

    var cs = createState();
    var stateList = new Array();
    var max = 0;
    var save = new Array();
    cs["status"] = 'Simple O(<b>n</b>) check over the LCP+owner columns (from row 1)<br>ans = 0, current best suffix(es) will be colored green';
    cs["lineNo"] = 1;
    stateList.push(cs);

    cs = createState();
    cs["status"] = 'Start at index 1';
    cs["lineNo"] = 2; 
    colorRow(cs, 2);
    stateList.push(cs);

    for (var i = 1; i < Object.size(SA); i++) {
      if (owner[i] != owner[i-1]) {
        if (LCP[i] > max) {
          save = new Array();
          save.push(i);
        }
        else if (LCP[i] == max)
          save.push(i);
      }

      for (j = 0; j < Object.size(LCP); ++j) // restore first
        coord_data[j+1][3] = T.substring(SA[j]);
      for (var j = 0; j < Object.size(save); ++j) {
        coord_data[save[j]+1][3] = "[" + T.substring(SA[save[j]], SA[save[j]]+LCP[save[j]]) + "] " + T.substring(SA[save[j]]+LCP[save[j]]);
      }

      cs = createState();
      colorRow(cs, i+1);
      if (owner[i] == owner[i-1]) {
        cs["status"] = 'Same owner as previous index<br>Continue';
        cs["lineNo"] = 3;
      }
      else {
        cs["status"] = 'Different owner as previous index ';
        cs["lineNo"] = 4;
        if (LCP[i] > max) {
          max = LCP[i];
          //cs["status"] += "LCP[i]=" + LCP[i] + " max=" + max + "<br>Update max";
          cs["status"] += 'LCP[i]={LCP_i} max={max}<br>Update max'
                            .replace('{LCP_i}', LCP[i])
                            .replace('{max}', max);
          //save = new Array();
          //save.push(i);
        }
        else if (LCP[i] == max) {
          //save.push(i);
          cs["status"] += 'LCP[i]={LCP_i} max={max}<br>Update result'
                            .replace('{LCP_i}', LCP[i])
                            .replace('{max}', max);
        }
        else
          cs["status"] += 'LCP[i]={LCP_i} max={max}<br>Continue'
                            .replace('{LCP_i}', LCP[i])
                            .replace('{max}', max);
      }
      for (var j = 0; j < Object.size(save); j++)
        colorResultRow(cs, save[j]+1);
      stateList.push(cs);
    }

    cs = createState();
    cs["status"] = 'Finish';
    cs["lineNo"] = 5;
    for (var j = 0; j < Object.size(save); j++)
      colorResultRow(cs, save[j]+1);
    stateList.push(cs);

    graphWidget.startAnimation(stateList, callback);
    return true;
  }

  // Javascript addon: get size of an object
  Object.size = function(obj) {
    var size = 0, key;
    for (key in obj)
      if (obj.hasOwnProperty(key))
        size++;
    return size;
  };

  function populatePseudocode(act) {
    switch (act) {
      case 0: // constructSA
        $("#code1").html('Initialization Phase'); // finish');
        $("#code2").html('for (k = 1; k &lt; n; k &lt;&lt;= 1) // O(log <b>n</b>)');
        $("#code3").html('&nbsp;&nbsp;Radix sort based on ranking pair // O(<b>n</b>)');
        $("#code4").html('&nbsp;&nbsp;for (i = 1; i &lt; n; ++i)');
        $("#code5").html('&nbsp;&nbsp;&nbsp;&nbsp;if ranking pair is different');
        $("#code6").html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;increase rank');
        $("#code7").html('&nbsp;&nbsp;updating RA[] from tempRA[]');
        //$("#code7").html('finish');
        break;
      case 1: // Search
        $("#code1").html('find the lower bound // O(<b>m</b> log <b>n</b>)');
        $("#code2").html('find the upper bound // O(<b>m</b> log <b>n</b>)');
        $("#code3").html('report results');
        $("#code4").html('');
        $("#code5").html('');
        $("#code6").html('');
        $("#code7").html('');
        break;
      case 2: // LCP
        $("#code1").html('Initialization Phase'); // // Overall O(<b>n</b>) via PLCP theorem');
        $("#code2").html('for (i = 1; i &lt; n; ++i) Phi[SA[i]] = SA[i-1]');
        $("#code3").html('for (i = L = 0; i &lt; n; ++i)');
        $("#code4").html('&nbsp;&nbsp;if (Phi[i] == -1) PLCP[i] = 0, continue');
        $("#code5").html('&nbsp;&nbsp;while (T[i+L] == T[Phi[i]+L]) ++L');
        $("#code6").html('&nbsp;&nbsp;L = max(L-1, 0)');
        $("#code7").html('for (i = 0; i &lt; n; ++i) LCP[i] = PLCP[SA[i]]');
        //$("#code7").html('// Overall O(<b>n</b>) via PLCP theorem');
        break;
      case 3: // LRS
        $("#code1").html('max = 0, result = null');
        $("#code2").html('for i = 1 to n-1');
        $("#code3").html('&nbsp;&nbsp;if (LCP[i] >= max)');
        $("#code4").html('&nbsp;&nbsp;&nbsp;&nbsp;update max and result');
        $("#code5").html('return result');
        $("#code6").html('// LRS length is unique');
        $("#code7").html('// But LRS substring(s) may not be unique');
        break;
      case 4: // LCS
        $("#code1").html('max = 0, result = null');
        $("#code2").html('for i = 1 to n-1');
        $("#code3").html('&nbsp;&nbsp;if (owner[i] == owner[i-1] continue');
        $("#code4").html('&nbsp;&nbsp;if (LCP[i] >= max) update max, result');
        $("#code5").html('return result');
        $("#code6").html('// LCS length is unique');
        $("#code7").html('// But LCS substring may not be unique');
        break;
    } 
  }
}

// Suffix Array action
var actionsWidth = 180;
var statusCodetraceWidth = 370;

var saWidget, gw, currentT;

// local
//start by showing actions panel
$(function() {
  $('#play').hide();
  saWidget = new SuffixArrayWidget();
  gw = saWidget.getGraphWidget();
  gw.setAnimationDuration(700 / speedVal);
  var option = ["GATAGACA$", "BANANABAN$", "MISSISSIPPI$", "ABRACADABRA$", "RATATAT$", "AAAAAAA$", "ABCDE$", "AABBCC$"];
  currentT = option[Math.floor(Math.random()*7)];
  $("#T").val(currentT);
  // saWidget.constructSA_bad(currentT);
  // to do: accept T from query string?
  constructSuffixArrayInstant();
});


function constructSuffixArray() {
  if (isPlaying) stop();
  currentT = $("#T").val();
  if (currentT == "" || currentT == "$") currentT = "GATAGACA$"; // if empty or $ only, go to default test case
  currentT = currentT.replace(/\$/g, "") + "$"; // ensure that $ is only used once, and at the back
  $("#T").val(currentT);
  commonAction(saWidget.constructSA(currentT), "Suffix Array of T = \"" + currentT + "\"");

/*
  try {
    if (isPlaying) { stop(); }
  }
  catch (err) {}
  setTimeout(function() {
    if ((mode == "exploration") && saWidget.constructSA($("#T").val())) {
      $('#current-action').show();
      var T = $("#T").val();
      $('#current-action p').html('Construct Suffix Array of<br>T = "{T}"'.replace('{T}', T));
      $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
      triggerRightPanels();
      isPlaying = true;
    }
  }, 500);
*/
}

function constructSuffixArrayInstant() {
  if (isPlaying) stop();
  currentT = $("#T").val();
  //  if (currentT == "" || currentT == "$") currentT = "GATAGACA$"; // if empty or $ only, go to default test case
  //  currentT = currentT.replace(/\$/g, "") + "$"; // ensure that $ is only used once, and at the back
  $("#T").val(currentT);
  commonAction(saWidget.constructSA_bad(currentT), "Suffix Array of T = \"" + currentT + "\"");
}

function doSearch(callback) {
  if (isPlaying) stop();
  var input = $('#search_inp').val();
  commonAction(saWidget.doSearch(input, callback), "Search P = \'" + input + "\'<br>in T = \'" + currentT + "\'");
/*
  try {
    if (isPlaying) { stop(); }
  }
  catch(err) {}
  setTimeout(function() {
    if ((mode == "exploration") && saWidget.goSearch()) {
      $('#current-action').show();
      var input = $('#search_inp').val();
      var T = $("#T").val();
      $('#current-action p').html('Search P = "{input}"<br>in T = "{T}"'.replace('{input}', input).replace('{T}', T));
      $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
      triggerRightPanels();
      isPlaying = true;
    }
  }, 500);
*/
}

function doLCP(callback) {
  if (isPlaying) stop();
  commonAction(saWidget.doLCP(callback), "Compute the LCP of SA of P = \"" + currentT + "\"");
/*
  try {
    if (isPlaying) { stop(); }
  } catch(err) {}
  setTimeout(function() {
    if ((mode == "exploration") && saWidget.goLCP()) {
      $('#current-action').show();
      $('#current-action p').html('Longest Common Prefix');
      $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
      triggerRightPanels();
      isPlaying = true;
    }
  }, 500);
*/
}

function doLRS(callback) {
  if (isPlaying) stop();
  commonAction(saWidget.doLRS(callback), "Find Longest Repeated Substring of \"" + currentT + "\"");
/*
  try {
    if (isPlaying) { stop(); }
  } catch(err) {}
  setTimeout( function() {
    if ((mode == "exploration") && saWidget.goLRS()) {
      $('#current-action').show();
      var T = $("#T").val()
      $('#current-action p').html('Longest Repeated Substring of T = "{T}"'.replace('{T}', T));
      $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
      triggerRightPanels();
      isPlaying = true;
    }
  }, 500);
*/
}

function doLCS(callback) {
  if (isPlaying) stop();
  var input1 = $('#s1').val();
  var input2 = $('#s2').val();
  commonAction(saWidget.doLCS(callback), "Find Longest Common Substring of \"" + input1 + "\" and \"" + input2 + "\"");
/*
  try {
    if (isPlaying) { stop(); }
  } catch(err) {}
  setTimeout(function() {
    if ((mode == "exploration") && saWidget.goLCS()) {
      $('#current-action').show();
      var s1 = $("#s1").val();
      var s2 = $("#s2").val();
      $('#current-action p').html('Longest Common Substring of T1 = "{s1}" and T2 = "{s2}"'.replace('{s1}', s1).replace('{s2}', s2));
      $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
      triggerRightPanels();
      isPlaying = true;
    }
  }, 500);
*/
}
</script>
</body>

<!-- Mirrored from visualgo.net/en/suffixarray by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Dec 2023 15:18:15 GMT -->
</html>
